--- Chunk #1 ---
Java
®
7th Edition
by Barry Burd, PhD
Java® For Dummies®, 7th Edition
Published by: John Wiley & Sons, Inc., 111 River Street, Hoboken, NJ 07030-5774, www.wiley.com
Copyright © 2017 by John Wiley & Sons, Inc., Hoboken, New Jersey
Published simultaneously in Canada
No part of this publication may be reproduced, stored in a retrieval system or transmitted in any form or by any 
means, electronic, mechanical, photocopying, recording, scanning or otherwise, except as permitted under Sections 
107 or 108 of the 1976 United States Copyright Act, without the prior written permission of the Publisher. Requests 
to the Publisher for permission should be addressed to the Permissions Department, John Wiley & Sons, Inc., 
111 River Street, Hoboken, NJ 07030, (201) 748-6011, fax (201) 748-6008, or online at http://www.wiley.com/go/
permissions. Trademarks: Wiley, For Dummies, the Dummies Man logo, Dummies.com, Making Everything Easier, and related 
trade dress are trademarks or registered trademarks of John Wiley & Sons, Inc. and may not be used without written 
permission. Java is a registered trademark of Oracle America, Inc. Android is a registered trademark of Google, Inc. All other trademarks are the property of their respective owners. John Wiley & Sons, Inc. is not associated with any 
product or vendor mentioned in this book. LIMIT OF LIABILITY/DISCLAIMER OF WARRANTY: THE PUBLISHER AND THE AUTHOR MAKE NO 
REPRESENTATIONS OR WARRANTIES WITH RESPECT TO THE ACCURACY OR COMPLETENESS OF THE CONTENTS 
OF THIS WORK AND SPECIFICALLY DISCLAIM ALL WARRANTIES, INCLUDING WITHOUT LIMITATION WARRANTIES 
OF FITNESS FOR A PARTICULAR PURPOSE. NO WARRANTY MAY BE CREATED OR EXTENDED BY SALES OR 
PROMOTIONAL MATERIALS. THE ADVICE AND STRATEGIES CONTAINED HEREIN MAY NOT BE SUITABLE FOR 
EVERY SITUATION. THIS WORK IS SOLD WITH THE UNDERSTANDING THAT THE PUBLISHER IS NOT ENGAGED 
IN RENDERING LEGAL, ACCOUNTING, OR OTHER PROFESSIONAL SERVICES. IF PROFESSIONAL ASSISTANCE IS 
REQUIRED, THE SERVICES OF A COMPETENT PROFESSIONAL PERSON SHOULD BE SOUGHT. NEITHER THE 
PUBLISHER NOR THE AUTHOR SHALL BE LIABLE FOR DAMAGES ARISING HEREFROM. THE FACT THAT AN 
ORGANIZATION OR WEBSITE IS REFERRED TO IN THIS WORK AS A CITATION AND/OR A POTENTIAL SOURCE OF 
FURTHER INFORMATION DOES NOT MEAN THAT THE AUTHOR OR THE PUBLISHER ENDORSES THE INFORMATION 
THE ORGANIZATION OR WEBSITE MAY PROVIDE OR RECOMMENDATIONS IT MAY MAKE. FURTHER, READERS 
SHOULD BE AWARE THAT INTERNET WEBSITES LISTED IN THIS WORK MAY HAVE CHANGED OR DISAPPEARED 
BETWEEN WHEN THIS WORK WAS WRITTEN AND WHEN IT IS READ. For general information on our other products and services, please contact our Customer Care Department within 
the U.S. at 877-762-2974, outside the U.S. at 317-572-3993, or fax 317-572-4002. For technical support, please visit 
https://hub.wiley.com/community/support/dummies. Wiley publishes in a variety of print and electronic formats and by print-on-demand. Some material included with 
standard print versions of this book may not be included in e-books or in print-on-demand. If this book refers to 
media such as a CD or DVD that is not included in the version you purchased, you may download this material at 
http://booksupport.wiley.com. For more information about Wiley products, visit www.wiley.com. Library of Congress Control Number: 2017932837
ISBN: 978-1-119-23555-2; 978-1-119-23558-3 (ebk); 978-1-119-23557-6 (ebk)
Manufactured in the United States of America
10   9   8   7   6   5   4   3   2   1
Contents at a Glance
Introduction  . .

--- Chunk #2 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #3 ---
. 1
Part 1: Getting Started with Java  . .

--- Chunk #4 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #5 ---
. 9
CHAPTER 1:  All about Java  . .

--- Chunk #6 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #7 ---
. 11
CHAPTER 2:  All about Software . .

--- Chunk #8 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #9 ---
. 25
CHAPTER 3:  Using the Basic Building Blocks  . .

--- Chunk #10 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #11 ---
. 43
Part 2: Writing Your Own Java Programs  . .

--- Chunk #12 ---
. . . . . . . . . . . . . . . . . .

--- Chunk #13 ---
. 65
CHAPTER 4:  Making the Most of Variables and Their Values  . .

--- Chunk #14 ---
. . . . . . . . . . . . . . . . .

--- Chunk #15 ---
. 67
CHAPTER 5:  Controlling Program Flow with Decision-Making Statements  . .

--- Chunk #16 ---
. . . . .

--- Chunk #17 ---
. 105
CHAPTER 6:  Controlling Program Flow with Loops  . .

--- Chunk #18 ---
. . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #19 ---
. 139
Part 3: Working with the Big Picture:  
Object-Oriented Programming  . .

--- Chunk #20 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #21 ---
. 159
CHAPTER 7:  Thinking in Terms of Classes and Objects  . .

--- Chunk #22 ---
. . . . . . . . . . . . . . . . . . . . .

--- Chunk #23 ---
. 161
CHAPTER 8:  Saving Time and Money: Reusing Existing Code  . .

--- Chunk #24 ---
. . . . . . . . . . . . . . . .

--- Chunk #25 ---
. 197
CHAPTER 9:  Constructing New Objects  . .

--- Chunk #26 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #27 ---
. 231
Part 4: Smart Java Techniques  . .

--- Chunk #28 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #29 ---
. 257
CHAPTER 10:  Putting Variables and Methods Where They Belong  . .

--- Chunk #30 ---
. . . . . . . . . . . .

--- Chunk #31 ---
. 259
CHAPTER 11:  Using Arrays to Juggle Values  . .

--- Chunk #32 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #33 ---
. 293
CHAPTER 12:  Using Collections and Streams (When Arrays Aren’t  
Good Enough)  . .

--- Chunk #34 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #35 ---
. 321
CHAPTER 13:  Looking Good When Things Take Unexpected Turns  . .

--- Chunk #36 ---
. . . . . . . . . . .

--- Chunk #37 ---
. 351
CHAPTER 14:  Sharing Names among the Parts of a Java Program  . .

--- Chunk #38 ---
. . . . . . . . . . . .

--- Chunk #39 ---
. 383
CHAPTER 15:  Fancy Reference Types . .

--- Chunk #40 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #41 ---
. .409
CHAPTER 16: 	Responding	to	Keystrokes	and	Mouse Clicks . .

--- Chunk #42 ---
. . . . . . . . . . . . . . . . . .

--- Chunk #43 ---
. .427
CHAPTER 17:  Using Java Database Connectivity  . .

--- Chunk #44 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #45 ---
. 445
Part 5: The Part of Tens  . .

--- Chunk #46 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #47 ---
. 455
CHAPTER 18:  Ten Ways to Avoid Mistakes  . .

--- Chunk #48 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #49 ---
. 457
CHAPTER 19:  Ten Websites for Java  . .

--- Chunk #50 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #51 ---
. 463
Index  . .

--- Chunk #52 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #53 ---
. 465
Table of Contents      v
Table of Contents
INTRODUCTION   . .

--- Chunk #54 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #55 ---
. 1
How to Use This Book  . .

--- Chunk #56 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #57 ---
. 1
Conventions Used in This Book  . .

--- Chunk #58 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #59 ---
. 2
What You Don’t Have to Read  . .

--- Chunk #60 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #61 ---
. 2
Foolish Assumptions  . .

--- Chunk #62 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #63 ---
. 3
How This Book Is Organized   . .

--- Chunk #64 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #65 ---
. 4
Part 1: Getting Started with Java  . .

--- Chunk #66 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #67 ---
. 4
Part 2: Writing Your Own Java Program  . .

--- Chunk #68 ---
. . . . . . . . . . . . . . . . . . . . .

--- Chunk #69 ---
. 4
Part 3: Working with the Big Picture: Object-Oriented 
Programming  . .

--- Chunk #70 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #71 ---
. 5
Part 4: Smart Java Techniques  . .

--- Chunk #72 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #73 ---
. 5
Part 5: The Part of Tens   . .

--- Chunk #74 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #75 ---
. 5
Icons Used in This Book  . .

--- Chunk #76 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #77 ---
. 5
Beyond the Book  . .

--- Chunk #78 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #79 ---
. 6
Where to Go from Here  . .

--- Chunk #80 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #81 ---
. 7
PART 1: GETTING STARTED WITH JAVA  . .

--- Chunk #82 ---
. . . . . . . . . . . . . . . . . . . . .

--- Chunk #83 ---
. 9
CHAPTER 1:  All about Java  . .

--- Chunk #84 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #85 ---
. 11
What You Can Do with Java  . .

--- Chunk #86 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #87 ---
. 12
Why You Should Use Java  . .

--- Chunk #88 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #89 ---
. 13
Getting Perspective: Where Java Fits In  . .

--- Chunk #90 ---
. . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #91 ---
. 14
Object-Oriented Programming (OOP)   . .

--- Chunk #92 ---
. . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #93 ---
. 16
Object-oriented languages  . .

--- Chunk #94 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #95 ---
. 16
Objects and their classes  . .

--- Chunk #96 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #97 ---
. 18
What’s so good about an object-oriented language? .

--- Chunk #98 ---
. . . . . . . . . .

--- Chunk #99 ---
. 19
Refining	your	understanding	of	classes	and	objects  . .

--- Chunk #100 ---
. . . . . . . . .

--- Chunk #101 ---
. 21
What’s Next? .

--- Chunk #102 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #103 ---
. 23
CHAPTER 2:  All about Software  . .

--- Chunk #104 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #105 ---
. 25
Quick-Start Instructions  . .

--- Chunk #106 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #107 ---
. 25
What You Install on Your Computer  . .

--- Chunk #108 ---
. . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #109 ---
. 28
What is a compiler? .

--- Chunk #110 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #111 ---
. 29
What is a Java Virtual Machine? .

--- Chunk #112 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #113 ---
. 32
Developing software  . .

--- Chunk #114 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #115 ---
. 39
What is an integrated development environment? .

--- Chunk #116 ---
. . . . . . . . . . .

--- Chunk #117 ---
. 40
CHAPTER 3:  Using the Basic Building Blocks  . .

--- Chunk #118 ---
. . . . . . . . . . . . . . . . . . . .

--- Chunk #119 ---
. 43
Speaking the Java Language   . .

--- Chunk #120 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #121 ---
. 43
The grammar and the common names  . .

--- Chunk #122 ---
. . . . . . . . . . . . . . . . . . . .

--- Chunk #123 ---
. 44
The words in a Java program  . .

--- Chunk #124 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #125 ---
. 45
vi      Java For Dummies
Checking Out Java Code for the First Time   . .

--- Chunk #126 ---
. . . . . . . . . . . . . . . . . . . .

--- Chunk #127 ---
. 47
Understanding a Simple Java Program   . .

--- Chunk #128 ---
. . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #129 ---
. 48
The Java class  . .

--- Chunk #130 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #131 ---
. 49
The Java method  . .

--- Chunk #132 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #133 ---
. 50
The main method in a program   . .

--- Chunk #134 ---
. . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #135 ---
. 52
How	you	finally	tell	the	computer	to	do	something  . .

--- Chunk #136 ---
. . . . . . . . . .

--- Chunk #137 ---
. 53
Curly braces  . .

--- Chunk #138 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #139 ---
. 55
And Now, a Few Comments  . .

--- Chunk #140 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #141 ---
. 59
Adding comments to your code   . .

--- Chunk #142 ---
. . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #143 ---
. 60
What’s Barry’s excuse? .

--- Chunk #144 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #145 ---
. 63
Using comments to experiment with your code  . .

--- Chunk #146 ---
. . . . . . . . . . . . .

--- Chunk #147 ---
. 63
PART 2: WRITING YOUR OWN JAVA PROGRAMS  . .

--- Chunk #148 ---
. . . . . . . .

--- Chunk #149 ---
. 65
CHAPTER 4:  Making the Most of Variables and Their Values  . . . 67
Varying a Variable  . .

--- Chunk #150 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #151 ---
. 68
Assignment statements  . .

--- Chunk #152 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #153 ---
. 70
The types of values that variables may have  . .

--- Chunk #154 ---
. . . . . . . . . . . . . . . .

--- Chunk #155 ---
. 71
Displaying text  . .

--- Chunk #156 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #157 ---
. 74
Numbers without decimal points  . .

--- Chunk #158 ---
. . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #159 ---
. 75
Combining declarations and initializing variables   . .

--- Chunk #160 ---
. . . . . . . . . . .

--- Chunk #161 ---
. 77
Experimenting with JShell  . .

--- Chunk #162 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #163 ---
. 78
What	Happened	to	All	the	Cool	Visual	Effects? .

--- Chunk #164 ---
. . . . . . . . . . . . . . . . . .

--- Chunk #165 ---
. 82
The Atoms: Java’s Primitive Types  . .

--- Chunk #166 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #167 ---
. 82
The char type  . .

--- Chunk #168 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #169 ---
. 83
The boolean type  . .

--- Chunk #170 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #171 ---
. 85
The Molecules and Compounds: Reference Types   . .

--- Chunk #172 ---
. . . . . . . . . . . . .

--- Chunk #173 ---
. 87
An Import Declaration   . .

--- Chunk #174 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #175 ---
. 91
Creating New Values by Applying Operators   . .

--- Chunk #176 ---
. . . . . . . . . . . . . . . . . .

--- Chunk #177 ---
. 93
Initialize once, assign often  . .

--- Chunk #178 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #179 ---
. 97
The increment and decrement operators  . .

--- Chunk #180 ---
. . . . . . . . . . . . . . . . . .

--- Chunk #181 ---
. 98
Assignment operators   . .

--- Chunk #182 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #183 ---
. 102
CHAPTER 5:  Controlling Program Flow with Decision-Making 
Statements  . .

--- Chunk #184 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #185 ---
. 105
Making Decisions (Java if Statements)  . .

--- Chunk #186 ---
. . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #187 ---
. 106
Guess the number  . .

--- Chunk #188 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #189 ---
. 106
She controlled keystrokes from the keyboard  . .

--- Chunk #190 ---
. . . . . . . . . . . . .

--- Chunk #191 ---
. 107
Creating randomness  . .

--- Chunk #192 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #193 ---
. 110
The if statement  . .

--- Chunk #194 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #195 ---
. 111
The double equal sign  . .

--- Chunk #196 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #197 ---
. 112
Brace yourself   . .

--- Chunk #198 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #199 ---
. 112
Indenting if statements in your code  . .

--- Chunk #200 ---
. . . . . . . . . . . . . . . . . . . . .

--- Chunk #201 ---
. 113
Elseless in Ifrica  . .

--- Chunk #202 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #203 ---
. 114
Table of Contents      vii
Using Blocks in JShell   . .

--- Chunk #204 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #205 ---
. 116
Forming Conditions with Comparisons and Logical Operators  . .

--- Chunk #206 ---
. .

--- Chunk #207 ---
. 117
Comparing numbers; comparing characters   . .

--- Chunk #208 ---
. . . . . . . . . . . . . .

--- Chunk #209 ---
. 117
Comparing objects   . .

--- Chunk #210 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #211 ---
. 118
Importing everything in one fell swoop  . .

--- Chunk #212 ---
. . . . . . . . . . . . . . . . . . .

--- Chunk #213 ---
. 121
Java’s logical operators  . .

--- Chunk #214 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #215 ---
. 121
Vive les nuls! .

--- Chunk #216 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #217 ---
. 124
(Conditions in parentheses)  . .

--- Chunk #218 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #219 ---
. 125
Building a Nest  . .

--- Chunk #220 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #221 ---
. 127
Choosing among Many Alternatives (Java switch Statements)  . .

--- Chunk #222 ---
. . .

--- Chunk #223 ---
. 130
Your basic switch statement  . .

--- Chunk #224 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #225 ---
. 130
To break or not to break  . .

--- Chunk #226 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #227 ---
. 134
Strings in a switch statement  . .

--- Chunk #228 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #229 ---
. 136
CHAPTER 6:  Controlling Program Flow with Loops  . .

--- Chunk #230 ---
. . . . . . . . . . .

--- Chunk #231 ---
. 139
Repeating Instructions Over and Over Again  
(Java while Statements)  . .

--- Chunk #232 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #233 ---
. 140
Repeating a Certain Number of Times (Java for Statements)  . .

--- Chunk #234 ---
. . . .

--- Chunk #235 ---
. 143
The anatomy of a for statement  . .

--- Chunk #236 ---
. . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #237 ---
. 145
The world premiere of “Al’s All Wet”  . .

--- Chunk #238 ---
. . . . . . . . . . . . . . . . . . . . . .

--- Chunk #239 ---
. 147
Repeating	until	You	Get	What	You	Want (Java	do	Statements)  . .

--- Chunk #240 ---
. .

--- Chunk #241 ---
. 150
Reading a single character  . .

--- Chunk #242 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #243 ---
. 154
File handling in Java  . .

--- Chunk #244 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #245 ---
. 154
Variable declarations and blocks   . .

--- Chunk #246 ---
. . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #247 ---
. 156
PART 3: WORKING WITH THE BIG PICTURE:  
OBJECT-ORIENTED PROGRAMMING  . .

--- Chunk #248 ---
. . . . . . . . . . . . . . . . . . . . . .

--- Chunk #249 ---
. 159
CHAPTER 7:  Thinking in Terms of Classes and Objects  . .

--- Chunk #250 ---
. . . . . . .

--- Chunk #251 ---
. 161
Defining	a	Class	(What	It	Means	to	Be	an	Account)  . .

--- Chunk #252 ---
. . . . . . . . . . . .

--- Chunk #253 ---
. 162
Declaring variables and creating objects  . .

--- Chunk #254 ---
. . . . . . . . . . . . . . . . . .

--- Chunk #255 ---
. 164
Initializing a variable  . .

--- Chunk #256 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #257 ---
. 167
Using	an	object’s	fields  . .

--- Chunk #258 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #259 ---
. 167
One program; several classes  . .

--- Chunk #260 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #261 ---
. 168
Public classes  . .

--- Chunk #262 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #263 ---
. 168
Defining	a	Method	within	a	Class	(Displaying	an	Account)  . .

--- Chunk #264 ---
. . . . . .

--- Chunk #265 ---
. 169
An account that displays itself  . .

--- Chunk #266 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #267 ---
. 171
The display method’s header  . .

--- Chunk #268 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #269 ---
. 172
Sending Values to and from Methods (Calculating Interest)  . .

--- Chunk #270 ---
. . . . .

--- Chunk #271 ---
. 173
Passing a value to a method  . .

--- Chunk #272 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #273 ---
. 176
Returning a value from the getInterest method  . .

--- Chunk #274 ---
. . . . . . . . . . . .

--- Chunk #275 ---
. 178
Making Numbers Look Good  . .

--- Chunk #276 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #277 ---
. 180
viii      Java For Dummies
Hiding Details with Accessor Methods  . .

--- Chunk #278 ---
. . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #279 ---
. 185
Good programming . .

--- Chunk #280 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #281 ---
. .185
Public	lives	and	private	dreams:	Making	a	field	inaccessible  . .

--- Chunk #282 ---
.

--- Chunk #283 ---
. 188
Enforcing rules with accessor methods  . .

--- Chunk #284 ---
. . . . . . . . . . . . . . . . . . .

--- Chunk #285 ---
. 190
Barry’s Own GUI Class . .

--- Chunk #286 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #287 ---
. .190
CHAPTER 8:  Saving Time and Money: Reusing  
Existing Code  . .

--- Chunk #288 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #289 ---
. 197
Defining	a	Class	(What	It	Means	to	Be	an	Employee)  . .

--- Chunk #290 ---
. . . . . . . . . . .

--- Chunk #291 ---
. 198
The last word on employees  . .

--- Chunk #292 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #293 ---
. 198
Putting your class to good use   . .

--- Chunk #294 ---
. . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #295 ---
. 200
Cutting a check  . .

--- Chunk #296 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #297 ---
. 204
Working with Disk Files (a Brief Detour)  . .

--- Chunk #298 ---
. . . . . . . . . . . . . . . . . . . . . .

--- Chunk #299 ---
. 205
Storing	data	in	a	file  . .

--- Chunk #300 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #301 ---
. 205
Copying and pasting code  . .

--- Chunk #302 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #303 ---
. 206
Reading	from	a	file  . .

--- Chunk #304 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #305 ---
. 208
Who	moved	my	file? .

--- Chunk #306 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #307 ---
. 210
Adding	directory	names	to	your	filenames  . .

--- Chunk #308 ---
. . . . . . . . . . . . . . . .

--- Chunk #309 ---
. 211
Reading a line at a time   . .

--- Chunk #310 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #311 ---
. 212
Closing	the	connection	to	a	disk	file  . .

--- Chunk #312 ---
. . . . . . . . . . . . . . . . . . . . . .

--- Chunk #313 ---
. 213
Defining	Subclasses	(What	It	Means	to	Be	a	Full-Time	 
or Part-Time Employee)  . .

--- Chunk #314 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #315 ---
. 214
Creating a subclass  . .

--- Chunk #316 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #317 ---
. 216
Creating subclasses is habit-forming  . .

--- Chunk #318 ---
. . . . . . . . . . . . . . . . . . . . .

--- Chunk #319 ---
. 219
Using Subclasses  . .

--- Chunk #320 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #321 ---
. 219
Making types match   . .

--- Chunk #322 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #323 ---
. 221
The second half of the story   . .

--- Chunk #324 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #325 ---
. 222
Overriding Existing Methods (Changing the Payments  
for Some Employees)  . .

--- Chunk #326 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #327 ---
. 224
A Java annotation  . .

--- Chunk #328 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #329 ---
. 226
Using methods from classes and subclasses   . .

--- Chunk #330 ---
. . . . . . . . . . . . . .

--- Chunk #331 ---
. 226
CHAPTER 9:  Constructing New Objects  . .

--- Chunk #332 ---
. . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #333 ---
. 231
Defining	Constructors	(What	It	Means	to	Be	a	Temperature)  . .

--- Chunk #334 ---
. . .

--- Chunk #335 ---
. 232
What is a temperature? .

--- Chunk #336 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #337 ---
. 233
What is a temperature scale? (Java’s enum type)  . .

--- Chunk #338 ---
. . . . . . . . . . .

--- Chunk #339 ---
. 233
Okay, so then what is a temperature? .

--- Chunk #340 ---
. . . . . . . . . . . . . . . . . . . . .

--- Chunk #341 ---
. 234
What you can do with a temperature  . .

--- Chunk #342 ---
. . . . . . . . . . . . . . . . . . . . .

--- Chunk #343 ---
. 236
Calling new Temperature(32 .0): A case study  . .

--- Chunk #344 ---
. . . . . . . . . . . . . .

--- Chunk #345 ---
. 239
Some things never change  . .

--- Chunk #346 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #347 ---
. 241
More Subclasses (Doing Something about the Weather)  . .

--- Chunk #348 ---
. . . . . . .

--- Chunk #349 ---
. 243
Building better temperatures   . .

--- Chunk #350 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #351 ---
. 243
Constructors for subclasses  . .

--- Chunk #352 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #353 ---
. 245
Using	all	this	stuff  . .

--- Chunk #354 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #355 ---
. 246
The default constructor   . .

--- Chunk #356 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #357 ---
. 247
Table of Contents      ix
A Constructor That Does More  . .

--- Chunk #358 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #359 ---
. 250
Classes and methods from the Java API  . .

--- Chunk #360 ---
. . . . . . . . . . . . . . . . . . .

--- Chunk #361 ---
. 253
The SuppressWarnings annotation   . .

--- Chunk #362 ---
. . . . . . . . . . . . . . . . . . . . . .

--- Chunk #363 ---
. 254
PART 4: SMART JAVA TECHNIQUES  . .

--- Chunk #364 ---
. . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #365 ---
. 257
CHAPTER 10:  Putting Variables and Methods  
Where They Belong  . .

--- Chunk #366 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #367 ---
. 259
Defining	a	Class	(What	It	Means	to	Be	a	Baseball	Player)  . .

--- Chunk #368 ---
. . . . . . .

--- Chunk #369 ---
. 260
Another way to beautify your numbers  . .

--- Chunk #370 ---
. . . . . . . . . . . . . . . . . . .

--- Chunk #371 ---
. 261
Using the Player class  . .

--- Chunk #372 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #373 ---
. 261
One class; nine objects  . .

--- Chunk #374 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #375 ---
. 264
Don’t get all GUI on me  . .

--- Chunk #376 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #377 ---
. 265
Tossing an exception from method to method   . .

--- Chunk #378 ---
. . . . . . . . . . . .

--- Chunk #379 ---
. 266
Making Static (Finding the Team Average)  . .

--- Chunk #380 ---
. . . . . . . . . . . . . . . . . . . .

--- Chunk #381 ---
. 267
Why is there so much static? .

--- Chunk #382 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #383 ---
. 269
Meet the static initializer   . .

--- Chunk #384 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #385 ---
. 270
Displaying the overall team average   . .

--- Chunk #386 ---
. . . . . . . . . . . . . . . . . . . . .

--- Chunk #387 ---
. 271
The static keyword is yesterday’s news  . .

--- Chunk #388 ---
. . . . . . . . . . . . . . . . . . .

--- Chunk #389 ---
. 273
Could cause static; handle with care   . .

--- Chunk #390 ---
. . . . . . . . . . . . . . . . . . . . .

--- Chunk #391 ---
. 274
Experiments with Variables  . .

--- Chunk #392 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #393 ---
. 277
Putting a variable in its place  . .

--- Chunk #394 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #395 ---
. 277
Telling a variable where to go  . .

--- Chunk #396 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #397 ---
. 280
Passing Parameters . .

--- Chunk #398 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #399 ---
. .285
Pass by value  . .

--- Chunk #400 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #401 ---
. 285
Returning a result  . .

--- Chunk #402 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #403 ---
. 287
Pass by reference   . .

--- Chunk #404 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #405 ---
. 287
Returning an object from a method  . .

--- Chunk #406 ---
. . . . . . . . . . . . . . . . . . . . . .

--- Chunk #407 ---
. 289
Epilogue   . .

--- Chunk #408 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #409 ---
. 292
CHAPTER 11:  Using Arrays to Juggle Values  . .

--- Chunk #410 ---
. . . . . . . . . . . . . . . . . . . . .

--- Chunk #411 ---
. 293
Getting Your Ducks All in a Row   . .

--- Chunk #412 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #413 ---
. 293
Creating an array in two easy steps  . .

--- Chunk #414 ---
. . . . . . . . . . . . . . . . . . . . . .

--- Chunk #415 ---
. 296
Storing values  . .

--- Chunk #416 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #417 ---
. 297
Tab stops and other special things  . .

--- Chunk #418 ---
. . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #419 ---
. 299
Using an array initializer  . .

--- Chunk #420 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #421 ---
. 299
Stepping through an array with the enhanced for loop   . .

--- Chunk #422 ---
. . . . .

--- Chunk #423 ---
. 300
Searching   . .

--- Chunk #424 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #425 ---
. 302
Writing	to	a	file  . .

--- Chunk #426 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #427 ---
. 305
When	to	close	a	file  . .

--- Chunk #428 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #429 ---
. 306
Arrays of Objects  . .

--- Chunk #430 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #431 ---
. 307
Using the Room class  . .

--- Chunk #432 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #433 ---
. 309
Yet another way to beautify your numbers  . .

--- Chunk #434 ---
. . . . . . . . . . . . . . . .

--- Chunk #435 ---
. 312
The conditional operator  . .

--- Chunk #436 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #437 ---
. 313
x      Java For Dummies
Command Line Arguments   . .

--- Chunk #438 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #439 ---
. 315
Using	command	line	arguments	in	a	Java program  . .

--- Chunk #440 ---
. . . . . . . . .

--- Chunk #441 ---
. 317
Checking for the right number of command line arguments  . .

--- Chunk #442 ---
.

--- Chunk #443 ---
. 319
CHAPTER 12:  Using Collections and Streams (When  
Arrays Aren’t Good Enough)  . .

--- Chunk #444 ---
. . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #445 ---
. 321
Understanding the Limitations of Arrays  . .

--- Chunk #446 ---
. . . . . . . . . . . . . . . . . . . . .

--- Chunk #447 ---
. 321
Collection Classes to the Rescue  . .

--- Chunk #448 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #449 ---
. 323
Using an ArrayList  . .

--- Chunk #450 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #451 ---
. 323
Using generics  . .

--- Chunk #452 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #453 ---
. 325
Wrapper classes  . .

--- Chunk #454 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #455 ---
. 328
Testing for the presence of more data  . .

--- Chunk #456 ---
. . . . . . . . . . . . . . . . . . . .

--- Chunk #457 ---
. 330
Using an iterator  . .

--- Chunk #458 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #459 ---
. 330
Java’s many collection classes  . .

--- Chunk #460 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #461 ---
. 331
Functional Programming  . .

--- Chunk #462 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #463 ---
. 333
Solving a problem the old-fashioned way  . .

--- Chunk #464 ---
. . . . . . . . . . . . . . . . .

--- Chunk #465 ---
. 336
Streams  . .

--- Chunk #466 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #467 ---
. 338
Lambda expressions  . .

--- Chunk #468 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #469 ---
. 339
A taxonomy of lambda expressions  . .

--- Chunk #470 ---
. . . . . . . . . . . . . . . . . . . . . .

--- Chunk #471 ---
. 342
Using streams and lambda expressions   . .

--- Chunk #472 ---
. . . . . . . . . . . . . . . . . .

--- Chunk #473 ---
. 342
Why bother? .

--- Chunk #474 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #475 ---
. 348
Method references  . .

--- Chunk #476 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #477 ---
. 350
CHAPTER 13:  Looking Good When Things Take  
Unexpected Turns  . .

--- Chunk #478 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #479 ---
. 351
Handling Exceptions  . .

--- Chunk #480 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #481 ---
. 352
The parameter in a catch clause  . .

--- Chunk #482 ---
. . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #483 ---
. 356
Exception types  . .

--- Chunk #484 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #485 ---
. 357
Who’s going to catch the exception? .

--- Chunk #486 ---
. . . . . . . . . . . . . . . . . . . . . .

--- Chunk #487 ---
. 359
Catching two or more exceptions at a time  . .

--- Chunk #488 ---
. . . . . . . . . . . . . . . .

--- Chunk #489 ---
. 365
Throwing caution to the wind  . .

--- Chunk #490 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #491 ---
. 366
Doing useful things  . .

--- Chunk #492 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #493 ---
. 367
Our friends, the good exceptions  . .

--- Chunk #494 ---
. . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #495 ---
. 368
Handle an Exception or Pass the Buck  . .

--- Chunk #496 ---
. . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #497 ---
. 369
Finishing	the	Job	with	a	finally	Clause  . .

--- Chunk #498 ---
. . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #499 ---
. 376
A try Statement with Resources   . .

--- Chunk #500 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #501 ---
. 379
CHAPTER 14:  Sharing Names among the Parts of a  
Java Program  . .

--- Chunk #502 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #503 ---
. 383
Access	Modifiers  . .

--- Chunk #504 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #505 ---
. 384
Classes, Access, and Multipart Programs   . .

--- Chunk #506 ---
. . . . . . . . . . . . . . . . . . . .

--- Chunk #507 ---
. 385
Members versus classes  . .

--- Chunk #508 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #509 ---
. 385
Access	modifiers	for	members  . .

--- Chunk #510 ---
. . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #511 ---
. 386
Table of Contents      xi
Putting a drawing on a frame   . .

--- Chunk #512 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #513 ---
. 389
Directory structure   . .

--- Chunk #514 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #515 ---
. 391
Making a frame  . .

--- Chunk #516 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #517 ---
. 392
Sneaking Away from the Original Code  . .

--- Chunk #518 ---
. . . . . . . . . . . . . . . . . . . . . .

--- Chunk #519 ---
. 394
Default access   . .

--- Chunk #520 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #521 ---
. 396
Crawling back into the package  . .

--- Chunk #522 ---
. . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #523 ---
. 399
Protected Access  . .

--- Chunk #524 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #525 ---
. 400
Subclasses that aren’t in the same package  . .

--- Chunk #526 ---
. . . . . . . . . . . . . . .

--- Chunk #527 ---
. 400
Classes that aren’t subclasses (but are in the same package)  . .

--- Chunk #528 ---
.

--- Chunk #529 ---
. 402
Access	Modifiers	for	Java	Classes  . .

--- Chunk #530 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #531 ---
. 406
Public classes  . .

--- Chunk #532 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #533 ---
. 406
Nonpublic classes  . .

--- Chunk #534 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #535 ---
. 406
CHAPTER 15:  Fancy Reference Types  . .

--- Chunk #536 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #537 ---
. 409
Java’s Types  . .

--- Chunk #538 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #539 ---
. 409
The Java Interface   . .

--- Chunk #540 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #541 ---
. 410
Two interfaces  . .

--- Chunk #542 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #543 ---
. 411
Implementing interfaces   . .

--- Chunk #544 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #545 ---
. 412
Putting the pieces together  . .

--- Chunk #546 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #547 ---
. 415
Abstract Classes  . .

--- Chunk #548 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #549 ---
. 417
Caring for your pet   . .

--- Chunk #550 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #551 ---
. 420
Using all your classes   . .

--- Chunk #552 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #553 ---
. 422
Relax! You’re Not Seeing Double! .

--- Chunk #554 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #555 ---
. 424
CHAPTER 16: 	Responding	to	Keystrokes	and	Mouse Clicks  . .

--- Chunk #556 ---
. . .

--- Chunk #557 ---
. 427
Go	On . .

--- Chunk #558 ---
. Click	That	Button  . .

--- Chunk #559 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #560 ---
. 428
Events and event handling  . .

--- Chunk #561 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #562 ---
. 430
Threads of execution   . .

--- Chunk #563 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #564 ---
. 431
The keyword this  . .

--- Chunk #565 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #566 ---
. 432
Inside the actionPerformed method   . .

--- Chunk #567 ---
. . . . . . . . . . . . . . . . . . . . .

--- Chunk #568 ---
. 434
The serialVersionUID  . .

--- Chunk #569 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #570 ---
. 435
Responding to Things Other Than Button Clicks   . .

--- Chunk #571 ---
. . . . . . . . . . . . . .

--- Chunk #572 ---
. 436
Creating Inner Classes   . .

--- Chunk #573 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #574 ---
. 441
CHAPTER 17:  Using Java Database Connectivity  . .

--- Chunk #575 ---
. . . . . . . . . . . . . . . .

--- Chunk #576 ---
. 445
Creating a Database and a Table   . .

--- Chunk #577 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #578 ---
. 446
What happens when you run the code   . .

--- Chunk #579 ---
. . . . . . . . . . . . . . . . . . .

--- Chunk #580 ---
. 447
Using SQL commands  . .

--- Chunk #581 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #582 ---
. 447
Connecting and disconnecting   . .

--- Chunk #583 ---
. . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #584 ---
. 449
Putting Data in the Table  . .

--- Chunk #585 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #586 ---
. 450
Retrieving Data   . .

--- Chunk #587 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #588 ---
. 451
Destroying Data  . .

--- Chunk #589 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #590 ---
. 453
xii      Java For Dummies
PART 5: THE PART OF TENS  . .

--- Chunk #591 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #592 ---
. 455
CHAPTER 18:  Ten Ways to Avoid Mistakes  . .

--- Chunk #593 ---
. . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #594 ---
. 457
Putting Capital Letters Where They Belong  . .

--- Chunk #595 ---
. . . . . . . . . . . . . . . . . . .

--- Chunk #596 ---
. 457
Breaking Out of a switch Statement  . .

--- Chunk #597 ---
. . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #598 ---
. 458
Comparing Values with a Double Equal Sign   . .

--- Chunk #599 ---
. . . . . . . . . . . . . . . . .

--- Chunk #600 ---
. 458
Adding Components to a GUI  . .

--- Chunk #601 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #602 ---
. 459
Adding Listeners to Handle Events  . .

--- Chunk #603 ---
. . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #604 ---
. 459
Defining	the	Required	Constructors  . .

--- Chunk #605 ---
. . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #606 ---
. 459
Fixing Non-Static References  . .

--- Chunk #607 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #608 ---
. 460
Staying within Bounds in an Array  . .

--- Chunk #609 ---
. . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #610 ---
. 460
Anticipating Null Pointers  . .

--- Chunk #611 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #612 ---
. 461
Helping Java Find Its Files  . .

--- Chunk #613 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #614 ---
. 462
CHAPTER 19:  Ten Websites for Java  . .

--- Chunk #615 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #616 ---
. 463
This Book’s Website  . .

--- Chunk #617 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #618 ---
. 463
The Horse’s Mouth   . .

--- Chunk #619 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #620 ---
. 463
Finding News, Reviews, and Sample Code  . .

--- Chunk #621 ---
. . . . . . . . . . . . . . . . . . . .

--- Chunk #622 ---
. 464
Got a Technical Question? .

--- Chunk #623 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #624 ---
. 464
INDEX   . .

--- Chunk #625 ---
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #626 ---
. 465
Introduction      1
Introduction
J
ava is good stuff. I’ve been using it for years. I like Java because it’s orderly. Almost everything follows simple rules. The rules can seem intimidating at 
times, but this book is here to help you figure them out. So, if you want to use 
Java and you want an alternative to the traditional techie, soft-cover book, sit 
down, relax, and start reading Java For Dummies, 7th Edition. How to Use This Book
I wish I could say, “Open to a random page of this book and start writing Java 
code. Just fill in the blanks and don’t look back.” In a sense, this is true. You can’t 
break anything by writing Java code, so you’re always free to experiment. But let me be honest. If you don’t understand the bigger picture, writing a  program 
is difficult. That’s true with any computer programming language — not just Java. If you’re typing code without knowing what it’s about and the code doesn’t do 
exactly what you want it to do, you’re just plain stuck. In this book, I divide Java programming into manageable chunks. Each chunk is 
(more or less) a chapter. You can jump in anywhere you want  — Chapter  5, 
 Chapter 10, or wherever. You can even start by poking around in the middle of a 
chapter. I’ve tried to make the examples interesting without making one chapter 
depend on another. When I use an important idea from another chapter, I include 
a note to help you find your way around. In general, my advice is as follows:
 » If you already know something, don’t bother reading about it. » If you’re curious, don’t be afraid to skip ahead. You can always sneak a peek at 
an earlier chapter, if you really need to do so. 2      Java For Dummies
Conventions Used in This Book
Almost every technical book starts with a little typeface legend, and Java For  
Dummies, 7th Edition, is no exception. What follows is a brief explanation of the 
typefaces used in this book:
 » New terms are set in italics. » If you need to type something that’s mixed in with the regular text, the 
characters you type appear in bold. For example: “Type MyNewProject in the 
text field.”
 » You also see this computerese font. I use computerese for Java code, 
filenames, web page addresses (URLs), onscreen messages, and other such 
things. Also, if something you need to type is really long, it appears in comput-
erese font on its own line (or lines). » You need to change certain things when you type them on your own com-
puter keyboard. For instance, I may ask you to type
public class Anyname
which means that you type public class and then some name that you make 
up on your own. Words that you need to replace with your own words are set 
in italicized computerese. What You Don’t Have to Read
Pick the first chapter or section that has material you don’t already know and start 
reading there.

--- Chunk #627 ---
Of course, you may hate making decisions as much as I do. If so, 
here are some guidelines that you can follow:
 » If you already know what kind of an animal Java is and know that you want to 
use Java, skip Chapter 1 and go straight to Chapter 2. Believe me, I won’t mind. » If you already know how to get a Java program running, and you don’t care 
what happens behind the scenes when a Java program runs, skip Chapter 2 
and start with Chapter 3. » If you write programs for a living but use any language other than C or C++, 
start with Chapter 2 or 3. When you reach Chapters 5 and 6, you’ll probably 
find them to be easy reading. When you get to Chapter 7, it’ll be time to dive in. Introduction      3
 » If you write C (not C++) programs for a living, start with Chapters 2, 3, and 4 
and just skim Chapters 5 and 6. » If you write C++ programs for a living, glance at Chapters 2 and 3, skim 
Chapters 4 through 6, and start reading seriously in Chapter 7. (Java is a bit 
different from C++ in the way it handles classes and objects.)
 » If you write Java programs for a living, come to my house and help me write 
Java For Dummies, 8th Edition. If you want to skip the sidebars and the Technical Stuff icons, please do. In fact, if 
you want to skip anything at all, feel free. Foolish Assumptions
In this book, I make a few assumptions about you, the reader. If one of these 
assumptions is incorrect, you’re probably okay. If all these assumptions are 
 incorrect . .

--- Chunk #628 ---
. well, buy the book anyway:
 » I assume that you have access to a computer. Here’s the good news: You 
can run most of the code in this book on almost any computer. The only 
computers that you can’t use to run this code are ancient things that are more 
than ten years old (give or take a few years). » I assume that you can navigate through your computer’s common 
menus and dialog boxes. You don’t have to be a Windows, Linux, or 
Macintosh power user, but you should be able to start a program, find a file, 
put a file into a certain directory . .

--- Chunk #629 ---
.

--- Chunk #630 ---
that sort of thing. Most of the time, when 
you practice the stuff in this book, you’re typing code on the keyboard, not 
pointing and clicking the mouse. On those rare occasions when you need to drag and drop, cut and paste, or 
plug and play, I guide you carefully through the steps. But your computer may 
be configured in any of several billion ways, and my instructions may not quite 
fit your special situation. When you reach one of these platform-specific tasks, 
try following the steps in this book. If the steps don’t quite fit, consult a book 
with instructions tailored to your system. » I assume that you can think logically. That’s all there is to programming in 
Java — thinking logically. If you can think logically, you’ve got it made. If you 
don’t believe that you can think logically, read on. You may be pleasantly 
surprised. 4      Java For Dummies
 » I make few assumptions about your computer programming experience 
(or your lack of such experience). In writing this book, I’ve tried to do the 
impossible: I’ve tried to make the book interesting for experienced program-
mers yet accessible to people with little or no programming experience. This means that I don’t assume any particular programming background on 
your part. If you’ve never created a loop or indexed an array, that’s okay. On the other hand, if you’ve done these things (maybe in Visual Basic, Python, 
or C++), you’ll discover some interesting plot twists in Java. The developers of 
Java took the best ideas in object-oriented programming, streamlined them, 
reworked them, and reorganized them into a sleek, powerful way of thinking 
about problems. You’ll find many new, thought-provoking features in Java. As 
you find out about these features, many of them will seem quite natural to 
you. One way or another, you’ll feel good about using Java. How This Book Is Organized
This book is divided into subsections, which are grouped into sections, which 
come together to make chapters, which are lumped finally into five parts. (When 
you write a book, you get to know your book’s structure pretty well. After months 
of writing, you find yourself dreaming in sections and chapters when you go to 
bed at night.) The parts of the book are listed here. Part 1: Getting Started with Java
This part is your complete, executive briefing on Java. It includes some “What is 
Java?” material and a jump-start chapter — Chapter 3. In Chapter 3, you visit the 
major technical ideas and dissect a simple program. Part 2: Writing Your Own Java Program
Chapters 4 through 6 cover the fundamentals. These chapters describe the things 
that you need to know so that you can get your computer humming along. If you’ve written programs in Visual Basic, C++, or any another language, some of 
the material in Part 2 may be familiar to you. If so, you can skip some sections or 
read this stuff quickly. But don’t read too quickly. Java is a little different from some 
other programming languages, especially in the things that I describe in Chapter 4. Introduction      5
Part 3: Working with the Big Picture:  
Object-Oriented Programming
Part 3 has some of my favorite chapters. This part covers the all-important topic 
of object-oriented programming. In these chapters, you find out how to map 
solutions to big problems. (Sure, the examples in these chapters aren’t big, but the 
examples involve big ideas.) In bite-worthy increments, you discover how to 
design classes, reuse existing classes, and construct objects. Have you read any of those books that explain object-oriented programming in 
vague, general terms? I’m proud to say that Java For Dummies,  7th Edition, isn’t 
like that. In this book, I illustrate each concept with a simple-yet-concrete pro-
gram example. Part 4: Smart Java Techniques
If you’ve tasted some Java and you want more, you can find what you need in this 
part of the book. This part’s chapters are devoted to details — the things that you 
don’t see when you first glance at the material. After you read the earlier parts and 
write some programs on your own, you can dive in a little deeper by reading Part 4. Part 5: The Part of Tens
The Part of Tens is a little Java candy store. In the Part of Tens, you can find 
lists — lists of tips for avoiding mistakes, for finding resources, and for all kinds 
of interesting goodies. Icons Used in This Book
If you could watch me write this book, you’d see me sitting at my computer, talk-
ing to myself. I say each sentence in my head. Most of the sentences, I mutter 
several times. When I have an extra thought, a side comment, or something that 
doesn’t belong in the regular stream, I twist my head a little bit. That way, who-
ever’s listening to me (usually nobody) knows that I’m off on a momentary 
tangent. Of course, in print, you can’t see me twisting my head. I need some other way of 
setting a side thought in a corner by itself. I do it with icons. When you see a Tip 
icon or a Remember icon, you know that I’m taking a quick detour. 6      Java For Dummies
Here’s a list of icons that I use in this book:
A tip is an extra piece of information — something helpful that the other books 
may forget to tell you. Everyone makes mistakes.

--- Chunk #631 ---
Heaven knows that I’ve made a few in my time. Any-
way, when I think people are especially prone to make a mistake, I mark it with a 
Warning icon. Question: What’s stronger than a Tip, but not as strong as a Warning? Answer: A Remember icon. “If you don’t remember what such-and-such means, see blah-blah-blah,” or 
“For more information, read blahbity-blah-blah.”
Writing computer code is an activity, and the best way to learn an activity is to 
practice it. That’s why I’ve created things for you to try in order to reinforce your 
knowledge. Many of these are confidence-builders, but some are a bit more chal-
lenging. When you first start putting things into practice, you’ll discover all kinds 
of issues, quandaries, and roadblocks that didn’t occur to you when you started 
reading about the material. But that’s a good thing.

--- Chunk #632 ---
Keep at it! Don’t become frus-
trated. Or, if you do become frustrated, visit this book’s website (www.allmycode. com/JavaForDummies) for hints and solutions. This icon calls attention to useful material that you can find online. Check it out! Occasionally, I run across a technical tidbit. The tidbit may help you understand 
what the people behind the scenes (the people who developed Java) were thinking. You don’t have to read it, but you may find it useful. You may also find the tidbit 
helpful if you plan to read other (more geeky) books about Java. Beyond the Book
In addition to what you’re reading right now, this book comes with a free access-
anywhere Cheat Sheet containing code that you can copy and paste into your own 
Android program. To get this Cheat Sheet, simply go to www.dummies.com and type 
Java For Dummies Cheat Sheet in the Search box. Introduction      7
Where to Go from Here
If you’ve gotten this far, you’re ready to start reading about Java application 
development. Think of me (the author) as your guide, your host, your personal 
assistant. I do everything I can to keep things interesting and, most importantly, 
to help you understand. If you like what you read, send me a note. My email address, which I created just 
for comments and questions about this book, is JavaForDummies@allmycode. com. If email and chat aren’t your favorites, you can reach me instead on Twitter 
(@allmycode) and on Facebook ( www.facebook.com/allmycode). And don’t  
forget — for the latest updates, visit this book’s website. The site’s address is 
www.allmycode.com/JavaForDummies. 1
Getting Started 
with Java
IN THIS PART . . . Find out about the tools you need for developing Java 
programs. Find out how Java fits into today’s technology scene. See your first complete Java program. CHAPTER 1  All about Java      11
IN THIS CHAPTER
 » What Java is
 » Where Java came from
 » Why Java is so cool
 » How to orient yourself to object-
oriented programming
All about Java
S
 
ay what you want about computers. As far as I’m concerned, computers are 
good for just two simple reasons:
 » When computers do work, they feel no resistance, no stress, no bore-
dom, and no fatigue. Computers are our electronic slaves. I have my 
computer working 24/7 doing calculations for Cosmology@Home — a distrib-
uted computing project to investigate models describing the universe. Do I 
feel sorry for my computer because it’s working so hard? Does the computer 
complain? Will the computer report me to the National Labor Relations 
Board? No. I can make demands, give the computer its orders, and crack the whip. Do I (or should I) feel the least bit guilty? Not at all. » Computers move ideas, not paper. Not long ago, when you wanted to send  
a message to someone, you hired a messenger. The messenger got on his or 
her horse and delivered your message personally. The message was on paper, 
parchment, a clay tablet, or whatever physical medium was available at the 
time. This whole process seems wasteful now, but that’s only because you and I are 
sitting comfortably in the electronic age. Messages are ideas, and physical 
things like ink, paper, and horses have little or nothing to do with real ideas; 
they’re just temporary carriers for ideas (even though people used them to 
carry ideas for several centuries). Nevertheless, the ideas themselves are 
paperless, horseless, and messengerless. Chapter 1
12      PART 1  Getting Started with Java
The neat thing about computers is that they carry ideas efficiently. They carry 
nothing but the ideas, a couple of photons, and a little electrical power. They 
do this with no muss, no fuss, and no extra physical baggage.

--- Chunk #633 ---
When you start dealing efficiently with ideas, something very nice happens. Sud-
denly, all the overhead is gone. Instead of pushing paper and trees, you’re pushing 
numbers and concepts. Without the overhead, you can do things much faster and 
do things that are far more complex than ever before. What You Can Do with Java
It would be so nice if all this complexity were free, but unfortunately, it isn’t. Someone has to think hard and decide exactly what to ask the computer to do. After that thinking takes place, someone has to write a set of instructions for the 
computer to follow. Given the current state of affairs, you can’t write these instructions in English or 
any other language that people speak. Science fiction is filled with stories about 
people who say simple things to robots and get back disastrous, unexpected 
results. English and other such languages are unsuitable for communication with 
computers, for several reasons:
 » An English sentence can be misinterpreted. “Chew one tablet three times a 
day until finished.”
 » It’s difficult to weave a very complicated command in English. “Join flange 
A to protuberance B, making sure to connect only the outermost lip of flange 
A to the larger end of the protuberance B, while joining the middle and inner 
lips of flange A to grommet C.”
 » An English sentence has lots of extra baggage. “Sentence has unneeded 
words.”
 » English is difficult to interpret.

--- Chunk #634 ---
“As part of this Publishing Agreement 
between John Wiley & Sons, Inc. (‘Wiley’) and the Author (‘Barry Burd’), Wiley 
shall pay the sum of one-thousand-two-hundred-fifty-seven dollars and 
sixty-three cents ($1,257.63) to the Author for partial submittal of Java For 
Dummies, 7th Edition (‘the Work’).”
To tell a computer what to do, you have to use a special language to write terse, 
unambiguous instructions. A special language of this kind is called a computer 
programming language. A set of instructions written in such a language is called a 
program. When looked at as a big blob, these instructions are called software or 
code. Here’s what code looks like when it’s written in Java:
CHAPTER 1  All about Java      13
public class PayBarry {
    public static void main(String args[]) {
        double checkAmount = 1257.63;
        System.out.print("Pay to the order of ");
        System.out.print("Dr. Barry Burd ");
        System.out.print("$");
        System.out.println(checkAmount);
    }
}
Why You Should Use Java
It’s time to celebrate! You’ve just picked up a copy of Java For Dummies, 7th  Edition, 
and you’re reading Chapter 1. At this rate, you’ll be an expert Java programmer* in 
no time at all, so rejoice in your eventual success by throwing a big party. To prepare for the party, I’ll bake a cake. I’m lazy, so I’ll use a ready-to-bake cake 
mix. Let me see .

--- Chunk #635 ---
.

--- Chunk #636 ---
. add water to the mix and then add butter and eggs — hey, 
wait! I just looked at the list of ingredients. What’s MSG? And what about propyl-
ene glycol? That’s used in antifreeze, isn’t it? I’ll change plans and make the cake from scratch. Sure, it’s a little harder, but that 
way I get exactly what I want. Computer programs work the same way. You can use somebody else’s program or 
write your own. If you use somebody else’s program, you use whatever you get. When 
you write your own program, you can tailor the program especially for your needs. Writing computer code is a big, worldwide industry. Companies do it, freelance 
professionals do it, hobbyists do it — all kinds of people do it. A typical big com-
pany has teams, departments, and divisions that write programs for the company. But you can write programs for yourself or someone else, for a living or for fun. In 
a recent estimate, the number of lines of code written each day by programmers 
in the United States alone exceeds the number of methane molecules on the planet 
Jupiter.** Take almost anything that can be done with a computer. With the right 
amount of time, you can write your own program to do it. (Of course, the “right 
amount of time” may be very long, but that’s not the point. Many interesting and 
useful programs can be written in hours or even minutes.)
*In professional circles, a developer’s responsibilities are usually broader than 
those of a programmer. But, in this book, I use the terms programmer and devel-
oper almost interchangeably. **I made up this fact all by myself. 14      PART 1  Getting Started with Java
Getting Perspective: Where Java Fits In
Here’s a brief history of modern computer programming:
 » 1954–1957: FORTRAN is developed. FORTRAN was the first modern computer programming language. For 
scientific programming, FORTRAN is a real racehorse. Year after year, 
FORTRAN is a leading language among computer programmers throughout 
the world. » 1959: Grace Hopper at Remington Rand develops the COBOL program-
ming language. The letter B in COBOL stands for Business, and business is just what COBOL is 
all about. The language’s primary feature is the processing of one record after 
another, one customer after another, or one employee after another. Within a few years after its initial development, COBOL became the most 
widely used language for business data processing. » 1972: Dennis Ritchie at AT&T Bell Labs develops the C programming 
language. The “look and feel” that you see in this book’s examples comes from the C 
programming language. Code written in C uses curly braces, if statements, 
for statements, and so on. In terms of power, you can use C to solve the same problems that you can 
solve by using FORTRAN, Java, or any other modern programming language. (You can write a scientific calculator program in COBOL, but doing that sort of 
thing would feel really strange.) The difference between one programming 
language and another isn’t power. The difference is ease and appropriateness 
of use. That’s where the Java language excels. » 1986: Bjarne Stroustrup (again at AT&T Bell Labs) develops C++. Unlike its C language ancestor, the language C++ supports object-oriented 
programming. This support represents a huge step forward. (See the next 
section in this chapter.)
 » May 23, 1995: Sun Microsystems releases its first official version of the 
Java programming language. Java improves upon the concepts in C++. Java’s “Write Once, Run Anywhere” 
philosophy makes the language ideal for distributing code across the Internet. Additionally, Java is a great general-purpose programming language. With 
Java, you can write windowed applications, build and explore databases, 
CHAPTER 1  All about Java      15
control handheld devices, and more. Within five short years, the Java pro-
gramming language had 2.5 million developers worldwide. (I know. I have a 
commemorative T-shirt to prove it.)
 » November 2000: The College Board announces that, starting in the year 
2003, the Computer Science Advanced Placement exams will be based  
on Java. Wanna know what that snot-nosed kid living down the street is learning in 
high school? You guessed it — Java. » 2002: Microsoft introduces a new language, named C#. Many of the C# language features come directly from features in Java. » June 2004: Sys-Con Media reports that the demand for Java programmers 
tops the demand for C++ programmers by 50 percent (http://java. sys-con.com/node/48507). And there’s more! The demand for Java programmers beats the combined 
demand for C++ and C# programmers by 8 percent. Java programmers are 
more employable than Visual Basic (VB) programmers by a whopping 190 
percent. » 2007: Google adopts Java as the primary language for creating apps on 
Android mobile devices. » January 2010: Oracle Corporation purchases Sun Microsystems, bringing 
Java technology into the Oracle family of products. » June 2010: eWeek ranks Java first among its “Top 10 Programming 
Languages to Keep You Employed” (www.eweek.com/c/a/Application- 
Development/Top-10-Programming-Languages-to-Keep-You-Employed- 
719257). » 2016: Java runs on 15 billion devices (http://java.com/en/about), with 
Android Java running on 87.6 percent of all mobile phones worldwide 
(www.idc.com/prodserv/smartphone-os-market-share.jsp). Additionally, Java technology provides interactive capabilities to all Blu-ray 
devices and is the most popular programming language in the TIOBE 
Programming Community Index (www.tiobe.com/index.php/content/
paperinfo/tpci), on PYPL: the PopularitY of Programming Language Index 
(http://sites.google.com/site/pydatalog/pypl/PyPL-PopularitY- 
of-Programming-Language), and on other indexes. Well, I’m impressed. 16      PART 1  Getting Started with Java
Object-Oriented Programming (OOP)
It’s three in the morning. I’m dreaming about the history course that I failed in 
high school. The teacher is yelling at me, “You have two days to study for the final 
exam, but you won’t remember to study. You’ll forget and feel guilty, guilty, 
guilty.”
Suddenly, the phone rings. I’m awakened abruptly from my deep sleep. (Sure,  
I disliked dreaming about the history course, but I like being awakened even less.) 
At first, I drop the telephone on the floor. After fumbling to pick it up, I issue a 
grumpy, “Hello, who’s this?” A voice answers, “I’m a reporter from the New York 
Times. I’m writing an article about Java, and I need to know all about the program-
ming language in five words or less. Can you explain it?”
My mind is too hazy.

--- Chunk #637 ---
I can’t think. So I say the first thing that comes to my mind 
and then go back to sleep. Come morning, I hardly remember the conversation with the reporter. In fact,  
I don’t remember how I answered the question. Did I tell the reporter where he 
could put his article about Java? I put on my robe and rush out to my driveway. As I pick up the morning paper,  
I glance at the front page and see this 2-inch headline:
Burd Calls Java “A Great Object-Oriented Language”
Object-oriented languages
Java is object-oriented. What does that mean? Unlike languages, such as FOR-
TRAN, that focus on giving the computer imperative “Do this/Do that” com-
mands, object-oriented languages focus on data. Of course, object-oriented 
programs still tell the computer what to do. They start, however, by organizing 
the data, and the commands come later. Object-oriented languages are better than “Do this/Do that” languages because 
they organize data in a way that helps people do all kinds of things with it. To 
modify the data, you can build on what you already have rather than scrap every-
thing you’ve done and start over each time you need to do something new. Although computer programmers are generally smart people, they took a while to 
figure this out. For the full history lesson, see the sidebar “The winding road from 
FORTRAN to Java” (but I won’t make you feel guilty if you don’t read it). CHAPTER 1  All about Java      17
(continued)
THE WINDING ROAD FROM  
FORTRAN TO JAVA
In the mid-1950s, a team of people created a programming language named 
FORTRAN. It was a good language, but it was based on the idea that you should issue 
direct, imperative commands to the computer. “Do this, computer. Then do that, com-
puter.” (Of course, the commands in a real FORTRAN program were much more precise 
than “Do this” or “Do that.”)
In the years that followed, teams developed many new computer languages, and many 
of the languages copied the FORTRAN “Do this/Do that” model. One of the more popu-
lar “Do this/Do that” languages went by the 1-letter name C. Of course, the “Do this/Do 
that” camp had some renegades. In languages named SIMULA and Smalltalk, program-
mers moved the imperative “Do this” commands into the background and concentrated 
on descriptions of data. In these languages, you didn’t come right out and say, “Print a 
list of delinquent accounts.” Instead, you began by saying, “This is what it means to be 
an account. An account has a name and a balance.” Then you said, “This is how you ask 
an account whether it’s delinquent.” Suddenly, the data became king. An account was a 
thing that had a name, a balance, and a way of telling you whether it was delinquent. Languages that focus first on the data are called object-oriented programming lan-
guages. These object-oriented languages make excellent programming tools. Here’s why:
• Thinking first about the data makes you a good computer programmer. • You can extend and reuse the descriptions of data over and over again. When you 
try to teach old FORTRAN programs new tricks, however, the old programs show 
how brittle they are. They break. In the 1970s, object-oriented languages, such as SIMULA and Smalltalk, were buried in 
the computer hobbyist magazine articles. In the meantime, languages based on the old 
FORTRAN model were multiplying like rabbits. So in 1986, a fellow named Bjarne Stroustrup created a language named C++. The C++ 
language became very popular because it mixed the old C language terminology with 
the improved object-oriented structure. Many companies turned their backs on the old 
FORTRAN/C programming style and adopted C++ as their standard. 18      PART 1  Getting Started with Java
Objects and their classes
In an object-oriented language, you use objects and classes to organize your data. Imagine that you’re writing a computer program to keep track of the houses in a 
new condominium development (still under construction).

--- Chunk #638 ---
The houses differ only 
slightly from one another. Each house has a distinctive siding color, an indoor 
paint color, a kitchen cabinet style, and so on. In your object-oriented computer 
program, each house is an object. But objects aren’t the whole story. Although the houses differ slightly from one 
another, all the houses share the same list of characteristics. For instance, each 
house has a characteristic known as siding color. Each house has another charac-
teristic known as kitchen cabinet style. In your object-oriented program, you need a 
master list containing all the characteristics that a house object can possess. This 
master list of characteristics is called a class. So there you have it. Object-oriented programming is misnamed. It should be 
called “programming with classes and objects.”
(continued)
But C++ had a flaw. Using C++, you could bypass all the object-oriented features and 
write a program by using the old FORTRAN/C programming style. When you started 
writing a C++ accounting program, you could take either fork in the road:
• Start by issuing direct “Do this” commands to the computer, saying the mathemati-
cal equivalent of “Print a list of delinquent accounts, and make it snappy.”
• Choose the object-oriented approach and begin by describing what it means to be 
an account. Some people said that C++ offered the best of both worlds, but others argued that the 
first world (the world of FORTRAN and C) shouldn’t be part of modern programming. If 
you gave a programmer an opportunity to write code either way, the programmer 
would too often choose to write code the wrong way. So in 1995, James Gosling of Sun Microsystems created the language named Java. In cre-
ating Java, Gosling borrowed the look and feel of C++. But Gosling took most of the old 
“Do this/Do that” features of C++ and threw them in the trash. Then he added features 
that made the development of objects smoother and easier. All in all, Gosling created a 
language whose object-oriented philosophy is pure and clean. When you program in 
Java, you have no choice but to work with objects. That’s the way it should be. CHAPTER 1  All about Java      19
Now notice that I put the word classes first. How dare I do this!

--- Chunk #639 ---
Well, maybe I’m 
not so crazy. Think again about a housing development that’s under construction. Somewhere on the lot, in a rickety trailer parked on bare dirt, is a master list of 
characteristics known as a blueprint. An architect’s blueprint is like an object-
oriented programmer’s class. A blueprint is a list of characteristics that each 
house will have. The blueprint says, “siding.” The actual house object has gray 
siding. The blueprint says, “kitchen cabinet.” The actual house object has Louis 
XIV kitchen cabinets. The analogy doesn’t end with lists of characteristics. Another important parallel 
exists between blueprints and classes. A year after you create the blueprint, you 
use it to build ten houses. It’s the same with classes and objects. First, the pro-
grammer writes code to describe a class. Then when the program runs, the com-
puter creates objects from the (blueprint) class. So that’s the real relationship between classes and objects. The programmer 
defines a class, and from the class definition, the computer makes individual 
objects. What’s so good about an object-oriented 
language? Based on the preceding section’s story about home building, imagine that you’ve 
already written a computer program to keep track of the building instructions for 
houses in a new development. Then, the big boss decides on a modified plan — a 
plan in which half the houses have three bedrooms and the other half have four. If you use the old FORTRAN/C style of computer programming, your instructions 
look like this:
Dig a ditch for the basement. Lay concrete around the sides of the ditch. Put two-by-fours along the sides for the basement’s frame. ... This would be like an architect creating a long list of instructions instead of a 
blueprint. To modify the plan, you have to sort through the list to find the instruc-
tions for building bedrooms. To make things worse, the instructions could be 
scattered among pages 234, 394–410, 739, 10, and 2. If the builder had to decipher 
other peoples’ complicated instructions, the task would be ten times harder. 20      PART 1  Getting Started with Java
Starting with a class, however, is like starting with a blueprint. If you decide to 
have both three- and four-bedroom houses, you can start with a blueprint called 
the house blueprint that has a ground floor and a second floor, but has no indoor 
walls drawn on the second floor. Then you make two more second-floor 
 blueprints — one for the three-bedroom house and another for the four-bedroom 
house. (You name these new blueprints the three-bedroom house blueprint and the 
four-bedroom house blueprint.)
Your builder colleagues are amazed with your sense of logic and organization, but 
they have concerns. They pose a question. “You called one of the blueprints the 
‘three-bedroom house’ blueprint. How can you do this if it’s a blueprint for a 
second floor and not for a whole house?”
You smile knowingly and answer, “The three-bedroom house blueprint can say, 
‘For info about the lower floors, see the original house blueprint.’ That way, the 
three-bedroom house blueprint describes a whole house. The four-bedroom 
house blueprint can say the same thing. With this setup, we can take advantage of 
all the work we already did to create the original house blueprint and save lots of 
money.”
In the language of object-oriented programming, the three- and four-bedroom 
house classes are inheriting  the features of the original house class. You can also 
say that the three- and four-bedroom house classes are extending the original 
house class. (See Figure 1-1.)
The original house class is called the superclass of the three- and four-bedroom 
house classes. In that vein, the three- and four-bedroom house classes are sub-
classes of the original house class. Put another way, the original house class is 
called the parent class of three- and four-bedroom house classes. The three- and 
four-bedroom house classes are child classes of the original house class. (Refer to 
Figure 1-1.)
Needless to say, your homebuilder colleagues are jealous. A crowd of homebuild-
ers is mobbing around you to hear about your great ideas. So, at that moment, you 
drop one more bombshell: “By creating a class with subclasses, we can reuse the 
blueprint in the future. If someone comes along and wants a five-bedroom house, 
we can extend our original house blueprint by making a five-bedroom house 
blueprint. We’ll never have to spend money for an original house blueprint again.”
“But,” says a colleague in the back row, “what happens if someone wants a dif -
ferent first-floor design? Do we trash the original house blueprint or start scrib -
bling all over the original blueprint? That’ll cost big bucks, won’t it?”
CHAPTER 1  All about Java      21
In a confident tone, you reply, “We don’t have to mess with the original house 
blueprint. If someone wants a Jacuzzi in his living room, we can make a new, 
small blueprint describing only the new living room and call this the Jacuzzi-in- 
living-room house blueprint. Then, this new blueprint can refer to the original 
house blueprint for info on the rest of the house (the part that’s not in the living 
room).” In the language of object-oriented programming, the Jacuzzi-in-living-
room house blueprint still extends the original house blueprint. The Jacuzzi blue-
print is still a subclass of the original house blueprint. In fact, all the terminology 
about superclass, parent class, and child class still applies. The only thing that’s 
new is that the Jacuzzi blueprint overrides the living room features in the original 
house blueprint. In the days before object-oriented languages, the programming world experi-
enced a crisis in software development. Programmers wrote code, and then dis -
covered new needs, and then had to trash their code and start from scratch. This 
problem happened over and over again because the code that the programmers 
were writing couldn’t be reused. Object-oriented programming changed all this 
for the better (and, as Burd said, Java is “A Great Object-Oriented Language”). Refining your understanding  
of classes and objects
When you program in Java, you work constantly with classes and objects. These 
two ideas are really important. That’s why, in this chapter, I hit you over the head 
with one analogy after another about classes and objects. FIGURE 1-1: 
Terminology in 
object-oriented 
programming. 22      PART 1  Getting Started with Java
Close your eyes for a minute and think about what it means for something to be a 
chair . .

--- Chunk #640 ---
.

--- Chunk #641 ---
. A chair has a seat, a back, and legs. Each seat has a shape, a color, a degree of soft-
ness, and so on. These are the properties that a chair possesses. What I describe is 
chairness — the notion of something being a chair. In object-oriented terminol -
ogy, I’m describing the Chair class. Now peek over the edge of this book’s margin and take a minute to look around 
your room. (If you’re not sitting in a room right now, fake it.)
Several chairs are in the room, and each chair is an object. Each of these objects is 
an example of that ethereal thing called the Chair class. So that’s how it works — 
the class is the idea of chairness, and each individual chair is an object. A class isn’t quite a collection of things. Instead, a class is the idea behind a cer -
tain kind of thing. When I talk about the class of chairs in your room, I’m talking 
about the fact that each chair has legs, a seat, a color, and so on. The colors may 
be different for different chairs in the room, but that doesn’t matter. When you 
talk about a class of things, you’re focusing on the properties that each of the 
things possesses. It makes sense to think of an object as being a concrete instance of a class. In fact, 
the official terminology is consistent with this thinking. If you write a Java pro-
gram in which you define a Chair class, each actual chair (the chair that you’re 
sitting on, the empty chair right next to you, and so on) is called an instance of the 
Chair class. Here’s another way to think about a class. Imagine a table displaying all three of 
your bank accounts. (See Table 1-1.)
TABLE 1-1	 A Table of Accounts
Account Number Type Balance
16-13154-22864-7 Checking 174.87
1011 1234 2122 0000 Credit –471.03
16-17238-13344-7 Savings 247.38
CHAPTER 1  All about Java      23
Think of the table’s column headings as a class, and think of each row of the table 
as an object. The table’s column headings describe the Account class. According to the table’s column headings, each account has an account number, a 
type, and a balance. Rephrased in the terminology of object-oriented program-
ming, each object in the Account class (that is, each instance of the Account class) 
has an account number, a type, and a balance. So, the bottom row of the table is 
an object with account number 16-17238-13344-7. This same object has type Sav-
ings and a balance of 247.38. If you opened a new account, you would have another 
object, and the table would grow an additional row. The new object would be an 
instance of the same Account class. What’s Next? This chapter is filled with general descriptions of things. A general description is 
good when you’re just getting started, but you don’t really understand things 
until you get to know some specifics. That’s why the next several chapters deal 
with specifics. So please, turn the page.

--- Chunk #642 ---
The next chapter can’t wait for you to read it. CHAPTER 2  All about Software      25
IN THIS CHAPTER
 » Understanding the roles of the 
software development tools
 » Selecting the version of Java that’s 
right for you
 » Preparing to write and run Java 
programs
All about Software
T
he best way to get to know Java is to do Java. When you’re doing Java, you’re 
writing, testing, and running your own Java programs. This chapter gets 
you ready to do Java by describing the general software setup — the soft -
ware that you must have on your computer whether you run Windows, Mac, 
Linux, or Joe’s Private Operating System. This chapter doesn’t describe the specific 
setup instructions for Windows, for a Mac, or for any other system. For setup instructions that are specific to your system, visit this book’s website 
(www.allmycode.com/JavaForDummies). Quick-Start Instructions
If you’re a seasoned veteran of computers and computing (whatever that means), 
and if you’re too jumpy to get detailed instructions from this book’s website, you 
can try installing the required software by following this section’s general instruc-
tions. The instructions work for many computers, but not all. And this section 
provides no detailed steps, no if-this-then-do-that alternatives, and no this- 
works-but-you’re-better-off-doing-something-else tips. Chapter 2
26      PART 1  Getting Started with Java
To prepare your computer for writing Java programs, follow these steps:
1. Install the Java Development Kit. To do so, visit www.oracle.com/technetwork/java/javase/downloads. Follow the instructions at that website to download and install the newest Java 
SE JDK. Look for the Standard Edition (SE). Don’t bother with the Enterprise Edition (EE) 
or any other such edition. Also, go for the JDK, not the JRE. If you see a code 
number, such as 9u3, this stands for "the 3rd update of Java 9." Generally, 
anything marked Java 9 or later is good for running the examples in this book. 2.

--- Chunk #643 ---
Install an integrated development environment. An integrated development environment (IDE) is a program to help you compose 
and test new software. For this book’s examples, you can use almost any IDE 
that supports Java. Here’s a list of the most popular Java IDEs:
• Eclipse
According to www.baeldung.com/java-ides-2016, 48.2 percent of the 
world’s Java programmers used the Eclipse IDE in mid-2016. To download and use Eclipse, follow the instructions at http://eclipse. org/downloads. Eclipse’s download page may offer you several different 
packages, including Eclipse for Java EE, Eclipse for JavaScript, Eclipse for 
Java and DSL, and others. To run this book’s examples, you need a 
relatively small Eclipse package — the Eclipse IDE for Java Developers. Eclipse is free for commercial and noncommercial use. • IntelliJ IDEA
In Baeldung’s survey of Java IDEs (http://www.baeldung.com/java- 
ides-2016), IntelliJ IDEA comes in a close second, with 43.6 percent of all 
programmers onboard. When you visit www.jetbrains.com/idea, you can download the 
Community Edition (which is free) or the Ultimate Edition (which isn’t free). To run this book’s examples, you can use the Community Edition. You can 
even use the Community Edition to create commercial software! CHAPTER 2  All about Software      27
• NetBeans
Baeldung’s survey of Java IDEs (http://www.baeldung.com/java-ides- 
2016) gives NetBeans a mere 5.9 percent. But NetBeans is Oracle’s official 
Java IDE. If the site offers you a choice of download bundles, choose the 
Java SE bundle. To get your own copy of NetBeans, visit https://netbeans.org/
downloads. NetBeans is free for commercial and noncommercial use. 3.

--- Chunk #644 ---
Test your installed software. What you do in this step depends on which IDE you choose in Step 2. Anyway, 
here are some general instructions:
a. Launch your IDE (Eclipse, IntelliJ IDEA, NetBeans, or whatever). b. In the IDE, create a new Java project. c. Within the Java project, create a new Java class named Displayer. (Selecting File ➪   New ➪   Class works in most IDEs.)
d. Edit the new Displayer.java file by typing the code from Listing 3-1 (the 
first code listing in Chapter 3). For most IDEs, you add the code into a big (mostly blank) editor pane. Try to 
type the code exactly as you see it in Listing 3-1. If you see an uppercase 
letter, type an uppercase letter.

--- Chunk #645 ---
Do the same with all lowercase letters. What? You say you don’t want to type a bunch of code from the book? Well, all right then! Visit this book’s website (www.allmycode.com/
JavaForDummies) to find out how to download all the code examples and 
load them into the IDE of your choice. e. Run Displayer.java and check to make sure that the run’s output reads 
You'll love Java!. That’s it!

--- Chunk #646 ---
But remember: Not everyone (computer geek or not) can follow these 
skeletal instructions flawlessly. So you have several alternatives:
 » Visit this book’s website. Do not pass Go. Do not try this section’s quick-start instructions. Follow  
the more detailed instructions that you find at www.allmycode.com/
JavaForDummies. 28      PART 1  Getting Started with Java
 » Try this section’s quick-start instructions. You can’t hurt anything by trying. If you accidentally install the wrong software, 
you can probably leave the wrong software on your computer. (You don’t 
have to uninstall it.) If you’re not sure whether you’ve installed the software 
correctly, you can always fall back on my website’s detailed instructions. » E-mail your questions to me at JavaForDummies@allmycode.com. » Tweet me at @allmycode. » Visit my /allmycode Facebook page. I like hearing from readers. What You Install on Your Computer
I once met a tool-and-die maker. He used tools to make tools (and dies). I was 
happy to meet him because I knew that, one day, I’d make an analogy between 
computer programmers and tool-and-die makers. A computer programmer uses existing programs as tools to create new programs. The existing programs and new programs might perform very different kinds of 
tasks. For example, a Java program (a program that you create) might keep track 
of a business’s customers. To create that customer-tracking program, you might 
use an existing program that looks for errors in your Java code. This general-
purpose error-finding program can find errors in any kind of Java code  —  
customer-tracking code, weather-predicting code, gaming code, or the code for 
an app on your mobile phone. So how many tools do you need for creating Java programs? As a novice, you need 
three tools:
 » You need a compiler. A compiler takes the Java code that you write and turns that code into a bunch 
of instructions called bytecode. Humans can’t readily compose or decipher bytecode instructions. But certain 
software that you run on your computer can interpret and carry out bytecode 
instructions. CHAPTER 2  All about Software      29
 » You need a Java Virtual Machine (JVM). A Java Virtual Machine is a piece of software. A Java Virtual Machine interprets 
and carries out bytecode instructions. » You need an integrated development environment (IDE). An integrated development environment helps you manage your Java code and 
provides convenient ways for you to write, compile, and run your code. To be honest, you don’t actually need an integrated development environ-
ment. In fact, some programmers take pride in using plain, old text editors 
such as Windows Notepad, Macintosh TextEdit, or the vim editor in Linux. But, 
as a novice programmer, a full-featured IDE makes your life much, much 
easier. The World Wide Web has free, downloadable versions of each of these tools:
 » When you download the Java SE JDK from Oracle’s website (www.oracle.com/
technetwork/java/javase/downloads/index.html), you get the compiler 
and the JVM. » When you visit the Eclipse (www.eclipse.org/downloads), IntelliJ IDEA  
(www.jetbrains.com/idea, or NetBeans (https://netbeans.org/
downloads) site, you get an IDE. You may find variations on the picture that I paint in the preceding two bullets. Many IDEs come with their own JVMs, and Oracle’s website may offer a combined 
JDK+NetBeans bundle. Nevertheless, the picture that I paint with these bullets is 
useful and reliable. When you follow my instructions, you might end up with two 
copies of the JVM, or two IDEs, but that’s okay. You never know when you’ll need 
a spare. This chapter provides background information about software you need on your 
computer. But the chapter contains absolutely no detailed instructions to help  
you install the software. For detailed instructions, visit this book’s website  
(www.allmycode.com/JavaForDummies). The rest of this chapter describes compilers, JVMs, and IDEs. What is a compiler? A compiler takes the Java code that you write and turns that code into a bunch 
of instructions called bytecode. —BARRY BURD, JAVA FOR DUMMIES, 7TH EDITION
30      PART 1  Getting Started with Java
You’re a human being. (Sure, every rule has exceptions. But if you’re reading this 
book, you’re probably human.) Anyway, humans can write and comprehend the 
code in Listing 2-1. LISTING 2-1: Looking for a Vacant Room
// This is part of a Java program. // It's not a complete Java program. roomNum = 1;
while (roomNum < 100) {
    if (guests[roomNum] == 0) {
        out.println("Room " + roomNum + " is available.");
        exit(0);
    } else {
        roomNum++;
    }
}
out.println("No vacancy");
The Java code in Listing 2-1 checks for vacancies in a small hotel (a hotel with 
room numbers 1 to 99). You can’t run the code in Listing 2-1 without adding sev-
eral additional lines. But here in Chapter 2, those additional lines aren’t impor-
tant. What’s important is that, by staring at the code, squinting a bit, and looking 
past all the code’s strange punctuation, you can see what the code is trying to do:
Set the room number to 1. As long as the room number is less than 100,
    Check the number of guests in the room. If the number of guests in the room is 0, then
        report that the room is available,
        and stop. Otherwise,
        prepare to check the next room by
        adding 1 to the room number. If you get to the nonexistent room number 100, then
    report that there are no vacancies. If you don’t see the similarities between Listing 2-1 and its English equivalent, 
don’t worry. You’re reading Java For Dummies, 7th Edition, and like most human 
beings, you can learn to read and write the code in Listing  2-1. The code in 
 Listing 2-1 is called Java source code. CHAPTER 2  All about Software      31
So here’s the catch: Computers aren’t human beings. Computers don’t normally 
follow instructions like the instructions in Listing 2-1. That is, computers don’t 
follow Java source code instructions. Instead, computers follow cryptic instruc -
tions like the ones in Listing 2-2. LISTING 2-2: Listing 2-1 Translated into Java Bytecode
aload_0
iconst_1
putfield Hotel/roomNum I
goto 32
aload_0
getfield Hotel/guests [I
aload_0
getfield Hotel/roomNum I
iaload
ifne 26
getstatic java/lang/System/out Ljava/io/PrintStream;
new java/lang/StringBuilder
dup
ldc "Room "
invokespecial java/lang/StringBuilder/<init>(Ljava/lang/String;)V
aload_0
getfield Hotel/roomNum I
invokevirtual java/lang/StringBuilder/append(I)Ljava/lang/StringBuilder;
ldc " is available."
invokevirtual
  java/lang/StringBuilder/append(Ljava/lang/String;)Ljava/lang/StringBuilder;
invokevirtual java/lang/StringBuilder/toString()Ljava/lang/String;
invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V
iconst_0
invokestatic java/lang/System/exit(I)V
goto 32
aload_0
dup
getfield Hotel/roomNum I
iconst_1
iadd
putfield Hotel/roomNum I
aload_0
getfield Hotel/roomNum I
(continued)
32      PART 1  Getting Started with Java
bipush 100
if_icmplt 5
getstatic java/lang/System/out Ljava/io/PrintStream;
ldc "No vacancy"
invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V
return
The instructions in Listing 2-2 aren’t Java source code instructions. They’re Java 
bytecode instructions.

--- Chunk #647 ---
When you write a Java program, you write source code 
instructions (like the instructions in Listing 2-1). After writing the source code, 
you run a program (that is, you apply a tool) to your source code. The program is 
a compiler. The compiler translates your source code instructions into Java byte-
code instructions. In other words, the compiler takes code that you can write and 
understand (like the code in Listing 2-1) and translates it into code that a com-
puter has a fighting chance of carrying out (like the code in Listing 2-2). You might put your source code in a file named Hotel.java. If so, the compiler 
probably puts the Java bytecode in another file named Hotel.class. Normally, 
you don’t bother looking at the bytecode in the Hotel.class file. In fact, the com-
piler doesn’t encode the Hotel.class file as ordinary text, so you can’t examine 
the bytecode with an ordinary editor. If you try to open Hotel.class with Note-
pad, TextEdit, KWrite, or even Microsoft Word, you’ll see nothing but dots, squig-
gles, and other gobbledygook. To create Listing 2-2, I had to apply yet another 
tool to my Hotel.class file. That tool displays a text-like version of a Java byte-
code file. I used Ando Saabas’s Java Bytecode Editor (www.cs.ioc.ee/~ando/jbe). No one (except for a few crazy programmers in some isolated labs in faraway 
places) writes Java bytecode. You run software (a compiler) to create Java byte-
code. The only reason to look at Listing 2-2 is to understand what a hard worker 
your computer is. What is a Java Virtual Machine? A Java Virtual Machine is a piece of software. A Java Virtual Machine interprets 
and carries out bytecode instructions. —BARRY BURD, JAVA FOR DUMMIES, 7TH EDITION
In the preceding “What is a compiler?” section, I make a big fuss about computers 
following instructions like the ones in Listing 2-2. As fusses go, it’s a very nice 
fuss. But if you don’t read every fussy word, you may be misguided. The exact 
LISTING 2-2: (continued)
CHAPTER 2  All about Software      33
wording is “ . . . computers follow cryptic instructions like the ones in Listing 2-2.” 
The instructions in Listing  2-2 are a lot like instructions that a computer can 
 execute, but generally, computers don’t execute Java bytecode instructions. Instead, each kind of computer processor has its own set of executable instruc-
tions, and each computer operating system uses the processor’s instructions in a 
slightly different way. Here’s a hypothetical situation: The year is 1992 (a few years before Java was 
made public) and you run the Linux operating system on a computer that has an 
old Pentium processor. Your friend runs Linux on a computer with a different kind 
of processor — a PowerPC processor. (In the 1990s, Intel Corporation made Pen-
tium processors, and IBM made PowerPC processors.)
Listing 2-3 contains a set of instructions to display Hello world! on the com-
puter screen.* The instructions work on a Pentium processor running the Linux 
operating system. LISTING 2-3: A Simple Program for a Pentium Processor
.data
msg:
        .ascii  "Hello, world!\n"
        len = . - msg
.text
    .global _start
_start:
        movl    $len,%edx
        movl    $msg,%ecx
        movl    $1,%ebx
        movl    $4,%eax
        int     $0x80
        movl    $0,%ebx
        movl    $1,%eax
        int     $0x80
*I paraphrase these Intel instructions from Konstantin Boldyshev’s Linux 
 Assembly HOWTO (http://tldp.org/HOWTO/Assembly-HOWTO/hello.html). 34      PART 1  Getting Started with Java
Listing 2-4 contains another set of instructions to display Hello world! on the 
screen.** The instructions in Listing 2-4 work on a PowerPC processor running 
Linux. LISTING 2-4: A Simple Program for a PowerPC Processor
.data
msg:
        .string "Hello, world!\n"
        len = . - msg
.text
        .global _start
_start:
        li      0,4
        li      3,1
        lis     4,msg@ha
        addi    4,4,msg@l
        li      5,len
        sc
        li      0,1
        li      3,1
        sc
The instructions in Listing 2-3 run smoothly on a Pentium processor. But these 
instructions mean nothing to a PowerPC processor. Likewise, the instructions in 
Listing 2-4 run nicely on a PowerPC, but these same instructions are complete 
gibberish to a computer with a Pentium processor. So your friend’s PowerPC 
 software might not be available on your computer. And your Intel computer’s 
software might not run at all on your friend’s computer. Now go to your cousin’s house. Your cousin’s computer has a Pentium processor 
(just like yours), but your cousin’s computer runs Windows instead of Linux. What 
does your cousin’s computer do when you feed it the Pentium code in Listing 2-3? It screams, “Not a valid Win32 application” or “Windows can’t open this file.” 
What a mess! **I paraphrase the PowerPC code from Hollis Blanchard’s PowerPC Assembly 
page (www.ibm.com/developerworks/library/l-ppc). Hollis also reviewed and 
critiqued this “What is a Java Virtual Machine?” section for me. Thank you, 
Hollis. CHAPTER 2  All about Software      35
Java bytecode creates order from all this chaos. Unlike the code in Listings 2-3 
and 2-4, Java bytecode isn’t specific to one kind of processor or to one operating 
system. Instead, any kind of computer can have a Java Virtual Machine, and Java 
bytecode instructions run on any computer’s Java Virtual Machine. The JVM that 
runs on a Pentium with Linux translates Java bytecode instructions into the 
kind of code you see in Listing 2-3. And the JVM that runs on a PowerPC with 
Linux translates Java bytecode instructions into the kind of code you see in 
Listing 2-4. If you write a Java program and compile that Java program into bytecode, then the 
JVM on your computer can run the bytecode, the JVM on your friend’s computer can 
run the bytecode, the JVM on your grandmother’s supercomputer can run the byte-
code, and with any luck, the JVM on your cellphone or tablet can run the bytecode. For a look at some Java bytecode, see Listing 2-2. But remember: You never have 
to write or decipher Java bytecode. Writing bytecode is the compiler’s job. Deci -
phering bytecode is the Java Virtual Machine’s job. With Java, you can take a bytecode file that you created with a Windows computer, 
copy the bytecode to who-knows-what kind of computer, and then run the byte-
code with no trouble at all. That’s one of the many reasons why Java has become 
popular so quickly. This outstanding feature, which gives you the ability to run 
code on many different kinds of computers, is called portability. What makes Java bytecode so versatile? This fantastic universality enjoyed by Java 
bytecode programs comes from the Java Virtual Machine. The Java Virtual Machine 
is one of those three tools that you must have on your computer. Imagine that you’re the Windows representative to the United Nations Security 
Council. (See Figure 2-1.) The Macintosh representative is seated to your right, 
and the Linux representative is on your left. (Naturally, you don’t get along with 
either of these people.

--- Chunk #648 ---
You’re always cordial to one another, but you’re never sin-
cere. What do you expect? It’s politics!) The distinguished representative from 
Java is at the podium. The Java representative is speaking in bytecode, and neither 
you nor your fellow ambassadors (Mac and Linux) understand a word of Java 
bytecode. But each of you has an interpreter. Your interpreter translates from bytecode to 
Windows while the Java representative speaks. Another interpreter translates 
from bytecode to Macintosh-ese. And a third interpreter translates bytecode into 
Linux-speak. 36      PART 1  Getting Started with Java
Think of your interpreter as a virtual ambassador. The interpreter doesn’t really 
represent your country, but the interpreter performs one of the important tasks 
that a real ambassador performs. The interpreter listens to bytecode on your 
behalf. The interpreter does what you would do if your native language were 
Java bytecode. The interpreter pretends to be the Windows ambassador and sits 
through the boring bytecode speech, taking in every word and processing each 
word in some way or another. You have an interpreter — a virtual ambassador. In the same way, a Windows 
computer runs its own bytecode-interpreting software. That software is the Java 
Virtual Machine. A Java Virtual Machine is a proxy, an errand boy, a go-between. The JVM serves as 
an interpreter between Java’s run-anywhere bytecode and your computer’s own 
system. While it runs, the JVM walks your computer through the execution of 
bytecode instructions. The JVM examines your bytecode, bit by bit, and carries out 
the instructions described in the bytecode. The JVM interprets bytecode for your 
Windows system, your Mac, or your Linux box, or for whatever kind of computer 
you’re using. That’s a good thing. It’s what makes Java programs more portable 
than programs in any other language. FIGURE 2-1: 
An imaginary 
meeting of the 
UN Security 
Council. CHAPTER 2  All about Software      37
WHAT ON EARTH IS JAVA 2  
STANDARD EDITION 1.2? If you poke around the web looking for Java tools, you find things with all kinds of 
strange names. You find the Java Development Kit, the Software Development Kit, the 
Java Runtime Environment, and other confusing names. • The names Java Development Kit (JDK) and Software Development Kit (SDK) stand for 
different versions of the same toolset — a toolset whose key component is a Java 
compiler. • The name Java Runtime Environment (JRE) stands for a toolset whose key component 
is a Java Virtual Machine. If you install the JDK on your computer, the JRE comes along with it. You can also 
get the JRE on its own. In fact, you can have many combinations of the JDK and JRE 
on your computer. For example, my Windows computer currently has JDK 1.6, JDK 
1.8, and JRE 8 in its c:\program files\Java directory and has JDK 9 in its  
c:\program files (x86)\Java directory. Only occasionally do I run into 
any version conflicts. If you suspect that you’re experiencing a version conflict, 
it’s best to uninstall all JDK and JRE versions except the latest (for example, JDK 9 
and JRE 9). The numbering of Java versions can be confusing. Instead of “Java 1,” “Java 2,” and 
“Java 3,” the numbering of Java versions winds through an obstacle course. This side-
bar’s figure describes the development of new Java versions over time. Each Java ver-
sion has several names. The product version is an official name that’s used for the world 
in general, and the developer version is a number that identifies versions so that pro-
grammers can keep track of them. (In casual conversation, programmers use all kinds 
of names for the various Java versions.) The code name is a more playful name that 
 identifies a version while it’s being created. The asterisks in the figure mark changes in the formulation of Java product-version 
names. Back in 1996, the product versions were Java Development Kit 1.0 and Java 
Development Kit 1.1. In 1998, someone decided to christen the product Java 2 Standard 
Edition 1.2, which confuses everyone to this day. At the time, anyone using the term Java 
Development Kit was asked to use Software Development Kit (SDK) instead. (continued)
38      PART 1  Getting Started with Java
In 2004 the 1. business went away from the platform version name, and in 2006 Java 
platform names lost the 2 and the .0. By far the most significant changes for Java programmers came about in 2004. With the 
release of J2SE 5.0, the overseers of Java made changes to the language by adding new 
features — features such as generic types, annotations, and the enhanced for state-
ment. (To see Java annotations in action, go to Chapters 8, 9, and 16. For examples of 
the use of the enhanced for statement and generic types, see Chapters 11 and 12.)
Most of the programs in this book run only with Java 5.0 or later. They don’t run with 
any version earlier than Java 5.0. Particularly, they don’t run with Java 1.4 or Java 1.4.2. Some of this book’s examples don’t run with Java 9 or lower. But don’t worry too much 
about Java version numbers. Java 6 or 7 is better than no Java at all. You can learn a lot 
about Java without having the latest Java version. (continued)
CHAPTER 2  All about Software      39
Developing software
All this has happened before, and it will all happen again. —PETER PAN (J.M. BARRIE) AND BATTLESTAR GALACTICA  
(2003–2009, NBC UNIVERSAL)
When you create a Java program, you repeat the same steps over and over again. Figure 2-2 illustrates the cycle. First, you write a program. After writing the first draft, you repeatedly compile, 
run, and modify the program. With a little experience, the compile and run  
steps become very easy. In many cases, one mouse click starts the compilation or 
the run. However, writing the first draft and modifying the code are not 1-click tasks. Developing code requires time and concentration. Never be discouraged when the first draft of your code doesn’t work. For that 
matter, never be discouraged when the 25th draft of your code doesn’t work. Rewriting code is one of the most important things you can do (aside from ensur-
ing world peace). For detailed instructions on compiling and running Java programs, visit this 
book’s website (www.allmycode.com/JavaForDummies). When people talk about writing programs, they use the wording in Figure 2-2. They say, “You compile the code” and “You run the code.” But the “you” isn’t 
always accurate, and the “code” differs slightly from one part of the cycle to the 
next. Figure 2-3 describes the cycle from Figure 2-2 in a bit more detail. FIGURE 2-2: 
Developing a Java 
program. 40      PART 1  Getting Started with Java
For most people’s needs, Figure 2-3 contains too much information. If I click a Run 
icon, I don’t have to remember that the computer runs code on my behalf. And for 
all I care, the computer can run my original Java code or some bytecode knockoff  
of my original Java code. In fact, many times in this book, I casually write "when 
you run your Java code," or "when the computer runs your Java program." You can 
live a very happy life without looking at Figure 2-3. The only use for Figure 2-3 is 
to help you if the loose wording in Figure 2-2 confuses you. If Figure 2-2 doesn’t 
confuse you, ignore Figure 2-3. What is an integrated development  
environment? “An integrated development environment helps you manage your Java code 
and provides convenient ways for you to write, compile, and run your code.”
—BARRY BURD, JAVA FOR DUMMIES, 7TH EDITION
In the olden days, writing and running a Java program involved opening several 
windows — a window for typing the program, another window for running the 
program, and maybe a third window to keep track of all the code you’ve written. (See Figure 2-4.)
An integrated development environment seamlessly combines all this functional-
ity into one well-organized application. (See Figure 2-5.)
FIGURE 2-3: 
Who does what 
with which code? CHAPTER 2  All about Software      41
Java has its share of integrated development environments such as Eclipse, IntelliJ 
IDEA, and NetBeans. Many environments have drag-and-drop components so 
that you can design your graphical interface visually. (See Figure 2-6.)
To run a program, you might click a toolbar button or choose Run from a menu. To compile a program, you might not have to do anything at all. (You might not 
even have to issue a command. Some IDEs compile your code automatically while 
you type it.)
For help with installing and using an integrated development environment, see 
this book’s website (www.allmycode.com/JavaForDummies). FIGURE 2-4: 
Developing code 
without an 
integrated 
development 
environment. FIGURE 2-5: 
Developing code 
with the Eclipse 
integrated 
development 
environment. 42      PART 1  Getting Started with Java
FIGURE 2-6: 
Using the 
drag-and-drop 
Swing GUI  
Builder in the 
NetBeans IDE. CHAPTER 3  Using the Basic Building Blocks      43
IN THIS CHAPTER
 » Speaking the Java language: The API 
and the language specification
 » Taking a first glance at Java code
 » Understanding the parts of a simple 
program
 » Documenting your code
Using the Basic Building 
Blocks
“Bce мыcли, кoтopыe имeют oгpoмныe пocлeдcтвия вceгдa пpocты. (All great ideas are simple.)”
—LEO TOLSTOY
T
he quotation applies to all kinds of things — things like life, love, and com-
puter programming. That’s why this chapter takes a multilayered approach. In this chapter, you get your first details about Java programming. And in 
discovering details, you’ll see the simplicities. Speaking the Java Language
If you try to picture in your mind the entire English language, what do you see? Maybe you see words, words, words. (That’s what Hamlet saw.) Looking at the 
language under a microscope, you see one word after another. The bunch-of-words 
image is fine, but if you step back a bit, you may see two other things:
 » The language’s grammar
 » Thousands of expressions, sayings, idioms, and historical names
Chapter 3
44      PART 1  Getting Started with Java
The first category (the grammar) includes rules like, “The verb agrees with the 
noun in number and person.” The second category (expressions, sayings, and 
stuff) includes knowledge like, “Julius Caesar was a famous Roman emperor, so 
don’t name your son Julius Caesar, unless you want him to get beaten up every day 
after school.”
The Java programming language has all the aspects of a spoken language like 
English. Java has words, grammar, commonly used names, stylistic idioms, and 
other such elements. The grammar and the common names
The people at Sun Microsystems who created Java thought of Java as having two 
parts. Just as English has its grammar and commonly used names, the Java 
 programming language has its specification (its grammar) and its application 
programming interface (its commonly used names). Whenever I write Java pro-
grams, I keep two important pieces of documentation — one for each part of the 
language — on my desk:
 » The Java Language Specification: This documentation includes rules like 
this: “Always put an open parenthesis after the word for” and “Use an asterisk 
to multiply two numbers.”
 » The application programming interface: Java’s application programming 
interface (API) contains thousands of names that were added to Java after the 
language’s grammar was defined. These names range from the commonplace 
to the exotic. For example, one name — the name JFrame — represents a 
window on your computer’s screen. A more razzle-dazzle name — pow — 
helps you raise 5 to the tenth power, or raise whatever to the whatever else 
power. Other names help you listen for the user’s button clicks, query 
databases, and do all kinds of useful things. You can download the language specification, the API documents, and all the 
other Java documentation (or view the documents online) by poking around at 
http://docs.oracle.com/javase/specs. The first part of Java, the language specification, is relatively small. That doesn’t 
mean you won’t take plenty of time finding out how to use the rules in the lan-
guage specification. Other programming languages, however, have double, triple, 
or ten times the number of rules. The second part of Java — the API — can be intimidating because it’s so large. The 
API contains thousands and thousands of names and keeps growing with each 
new Java language release. Pretty scary, eh? Well, the good news is that you don’t 
CHAPTER 3  Using the Basic Building Blocks      45
have to memorize anything in the API. Nothing.

--- Chunk #649 ---
None of it. You can look up the 
stuff you need to use in the documentation and ignore the stuff you don’t need. What you use often, you’ll remember. What you don’t use often, you’ll forget (like 
any other programmer). No one knows all there is to know about the Java API. If you’re a Java programmer 
who frequently writes programs that open new windows, you know how to use the 
API JFrame class. If you seldom write programs that open windows, the first few 
times you need to create a window, you can look up the JFrame class in the API 
documentation. My guess is that if you prevented a typical Java programmer from 
looking up anything in the API documentation, the programmer would be able to 
use less than 2 percent of all the names in the Java API. You may love the For Dummies  style, but unfortunately, Java’s official API 
 documentation isn’t written that way. The API documentation is both concise and 
precise. For some help deciphering the API documentation’s language and style, 
see this book’s website (www.allmycode.com/JavaForDummies). In a way, nothing about the Java API is special. Whenever you write a Java 
 program — even the smallest, simplest Java program — you create a class that’s 
on par with any of the classes defined in the official Java API. The API is just a set 
of classes and other names that were created by ordinary programmers who hap-
pen to participate in the official Java Community Process (JCP) and in the OpenJDK 
Project. Unlike the names you create, the names in the API are distributed with 
every version of Java. (I’m assuming that you, the reader, are not a participant in 
the Java Community Process or the OpenJDK Project. But, with a fine book like Java 
For Dummies, 7th Edition, one never knows.)
If you’re interested in the JCP’s activities, visit www.jcp.org. If you’re interested 
in the OpenJDK Project, visit http://openjdk.java.net. The folks at the JCP don’t keep the Java programs in the official Java API a secret. If you want, you can look at all these programs. When you install Java on your 
computer, the installation puts a file named src.zip on your hard drive. You can 
open src.zip with your favorite unzipping program. There, before your eyes, is 
all the Java API code. The words in a Java program
A hard-core Javateer will say that the Java programming language has two kinds 
of words: keywords and identifiers. This is true. But the bare truth, without any 
other explanation, is sometimes misleading. So I recommend dressing up the 
truth a bit and thinking in terms of three kinds of words: keywords, identifiers 
that ordinary programmers like you and I create, and identifiers from the API. 46      PART 1  Getting Started with Java
The differences among these three kinds of words are similar to the differences 
among words in the English language. In the sentence “Sam is a person,” the 
word person is like a Java keyword. No matter who uses the word person, the word 
always means roughly the same thing. (Sure, you can think of bizarre exceptions 
in English usage, but please don’t.)
The word Sam is like a Java identifier because Sam is a name for a particular per-
son. Words like Sam, Dinswald, and McGillimaroo aren’t prepacked with meaning in 
the English language. These words apply to different people depending on the 
context and become names when parents pick one for their newborn kid. Now consider the sentence “Julius Caesar is a person.” If you utter this sentence, 
you’re probably talking about the fellow who ruled Rome until the Ides of March. Although the name Julius Caesar  isn’t hard-wired into the English language, 
almost everyone uses the name to refer to the same person. If English were a pro-
gramming language, the name Julius Caesar would be an API identifier. So here’s how I, in my mind, divide the words in a Java program into categories:
 » Keywords: A keyword is a word that has its own special meaning in the Java 
programming language, and that meaning doesn’t change from one program 
to another. Examples of keywords in Java are if, else, and do. The JCP committee members, who have the final say on what constitutes a 
Java program, have chosen all the Java keywords. If you think about the two 
parts of Java, which I discuss earlier, in the section “The grammar and the 
common names,” the Java keywords belong solidly to the language 
specification. » Identifiers: An identifier is a name for something. The identifier’s meaning can 
change from one program to another, but some identifiers’ meanings tend to 
change more:
• Identifiers created by you and me: As a Java programmer (yes, even as a 
novice Java programmer), you create new names for classes and other 
items you describe in your programs. Of course, you may name something 
Prime, and the guy writing code two cubicles down the hall can name 
something else Prime. That’s okay because Java doesn’t have a predeter-
mined meaning for Prime. In your program, you can make Prime stand for 
the Federal Reserve’s prime rate. And the guy down the hall can make 
Prime stand for the “bread, roll, preserves, and prime rib.” A conflict 
doesn’t arise, because you and your coworker are writing two different 
Java programs. » Identifiers from the API: The JCP members have created names for many things 
and thrown tens of thousands of these names into the Java API. The API 
CHAPTER 3  Using the Basic Building Blocks      47
comes with each version of Java, so these names are available to anyone 
who writes a Java program. Examples of such names are String, Integer, 
JWindow, JButton, JTextField, and File. Strictly speaking, the meanings of the identifiers in the Java API aren’t cast in 
stone. Although you can make up your own meanings for JButton or JWindow, this 
isn’t a good idea. If you did, you would confuse the dickens out of other program-
mers, who are used to the standard API meanings for these familiar identifier 
names. But even worse, when your code assigns a new meaning to an identifier 
like JButton, you lose any computational power that was created for the identifier 
in the API code. The programmers at Sun Microsystems, Oracle, the Java Com -
munity Process, and the OpenJDK Project did all the work of writing Java code to 
handle buttons. If you assign your own meaning to JButton, you’re turning your 
back on all the progress made in creating the API. To see the list of Java keywords, visit this book’s website: www.allmycode.com/
JavaForDummies. Checking Out Java Code for the First Time
The first time you look at somebody else’s Java program, you may tend to feel a bit 
queasy. The realization that you don’t understand something (or many things) in 
the code can make you nervous. I’ve written hundreds (maybe thousands) of Java 
programs, but I still feel insecure when I start reading someone else’s code. The truth is that finding out about a Java program is a bootstrapping experience. First, you gawk in awe of the program. Then you run the program to see what it 
does. Then you stare at the program for a while or read someone’s explanation of 
the program and its parts. Then you gawk a little more and run the program again. Eventually, you come to terms with the program. (Don’t believe the wise guys who 
say they never go through these steps. Even the experienced programmers 
approach a new project slowly and carefully.)
In Listing 3-1, you get a blast of Java code. (Like all novice programmers, you’re 
expected to gawk humbly at the code.) Hidden in the code, I’ve placed some 
important ideas, which I explain in detail in the next section. These ideas include 
the use of classes, methods, and Java statements. 48      PART 1  Getting Started with Java
LISTING 3-1: The Simplest Java Program
public class Displayer {
    public static void main(String args[]) {
        System.out.println("You'll love Java!");
    }
}
You don’t have to type the code in Listing 3-1 (or in any of this book’s listings). To 
download all the code in this book, visit the book’s website (www.allmycode.com/
JavaForDummies). When you run the program from Listing 3-1, the computer displays You'll love 
Java! (Figure 3-1 shows the output of the Displayer program when you use the 
Eclipse IDE.) Now, I admit that writing and running a Java program is a lot of work 
just to get You'll love Java! to appear on somebody’s computer screen, but 
every endeavor has to start somewhere. To see how to run the code in Listing  3-1, visit this book’s website ( www. allmycode.com/JavaForDummies). In the following section, you do more than just admire the program’s output. After you read the following section, you actually understand what makes the 
program in Listing 3-1 work. Understanding a Simple Java Program
This section presents, explains, analyzes, dissects, and otherwise demystifies the 
Java program shown previously in Listing 3-1. FIGURE 3-1: 
I use Eclipse to 
run the program 
in Listing 3-1. CHAPTER 3  Using the Basic Building Blocks      49
The Java class
Because Java is an object-oriented programming language, your primary goal is to 
describe classes and objects. (If you’re not convinced about this, read the sections 
on object-oriented programming in Chapter 1.)
On those special days when I’m feeling sentimental, I tell people that Java is more 
pure in its object-orientation than many other so-called object-oriented lan-
guages. I say this because, in Java, you can’t do anything until you create a class 
of some kind. It’s like being on Jeopardy! and hearing Alex Trebek say, “Let’s go to 
a commercial” and then interrupting him by saying, “I’m sorry, Alex. You can’t 
issue an instruction without putting your instruction inside a class.”
The code in Listing 3-1 is a Java program, and that program describes a class. I 
wrote the program, so I get to make up a name for my new class. I chose the name 
Displayer because the program displays a line of text on the computer screen. That’s why the first line in Listing 3-1 contains the words class Displayer. (See 
Figure 3-2.)
The first two words in Listing 3-1, public and class, are Java keywords. (See the 
section “The words in a Java program,” earlier in this chapter.) No matter who 
writes a Java program, the words public and class are always used in the same 
way. On the other hand, Displayer in Listing 3-1 is an identifier. I made up the 
word Displayer while I was writing this chapter. Displayer is the name of a par-
ticular class — the class that I’m creating by writing this program. FIGURE 3-2: 
A Java program is 
a class. 50      PART 1  Getting Started with Java
This book is filled with talk about classes, but for the best description of a Java 
class (the reason for using the word class in Listing 3-1), visit Chapter 7. The 
word public means that other Java classes (classes other than the Displayer 
class in Listing 3-1) can use the features declared in Listing 3-1. For more details 
about the meaning of public and the use of the word public in a Java program, 
see Chapters 7 and 14. tHE jAVA PROGRAMMING LANGUAGE IS cASe-sEnsITiVE. If you change a lower-
case letter in a word to an UpperCase letter, you can change the word’s meaning. cHANGING case can make the entire word go from being meaningful to being 
meaningless. In the first line of Listing 3-1, you can’t replace class with Class. iF 
YOU DO, THE WHOLE PROGRAM STOPS WORKING. The same holds true, to some 
extent, for the name of a file containing a particular class. For example, the name 
of the class in Listing 3-1 is Displayer, starting with an uppercase letter D. So it’s 
a good idea to save the code of Listing 3-1 in a file named Displayer.java, start-
ing with an uppercase letter D. Normally, if you define a class named DogAndPony, the class’s Java code is in a file 
named DogAndPony.java, spelled and capitalized exactly the same way that the 
class name is spelled and capitalized. In fact, this file-naming convention is man-
datory for most examples in this book. The Java method
You’re working as an auto mechanic in an upscale garage. Your boss, who’s always 
in a hurry and has a habit of running words together, says, “fixTheAlternator on 
that junkyOldFord.” Mentally, you run through a list of tasks. “Drive the car into 
the bay, lift the hood, get a wrench, loosen the alternator belt,” and so on. Three 
things are going on here:
 » You have a name for what you’re supposed to do. The name is 
fixTheAlternator. » In your mind, you have a list of tasks associated with the name  
fixTheAlternator. The list includes “Drive the car into the bay, lift the hood,  
get a wrench, loosen the alternator belt,” and so on. » You have a grumpy boss who’s telling you to do all this work. Your boss 
gets you working by saying, “fixTheAlternator.” In other words, your boss gets 
you working by saying the name of what you’re supposed to do. In this scenario, using the word method wouldn’t be a big stretch. You have a 
method for doing something with an alternator. Your boss calls that method into 
action, and you respond by doing all the things in the list of instructions that you 
associate with the method. CHAPTER 3  Using the Basic Building Blocks      51
If you believe all that (and I hope you do), you’re ready to read about Java meth-
ods. In Java, a method is a list of things to do. Every method has a name, and you 
tell the computer to do the things in the list by using the method’s name in your 
program. I’ve never written a program to get a robot to fix an alternator. But, if I did, the 
program might include a fixTheAlternator method. The list of instructions in 
my fixTheAlternator method would look something like the text in Listing 3-2. Don’t scrutinize Listings 3-2 and 3-3 too carefully. All the code in Listings 3-2 
and 3-3 is fake! I made up this code so that it looks a lot like real Java code, but it’s 
not real. What’s more important, the code in Listings 3-2 and 3-3 isn’t meant to 
illustrate all the rules about Java. So, if you have a grain of salt handy, take it with 
Listings 3-2 and 3-3. LISTING 3-2: A Method Declaration
void fixTheAlternator(onACertainCar) {
   driveInto(car, bay);
   lift(hood);
   get(wrench);
   loosen(alternatorBelt);
   ... }
Somewhere else in my Java code (somewhere outside of Listing 3-2), I need an 
instruction to call my fixTheAlternator method into action. The instruction to 
call the fixTheAlternator method into action may look like the line in 
Listing 3-3. LISTING 3-3: A Method Call
fixTheAlternator(junkyOldFord);
Now that you have a basic understanding of what a method is and how it works, 
you can dig a little deeper into some useful terminology:
 » If I’m being lazy, I refer to the code in Listing 3-2 as a method. If I’m not being 
lazy, I refer to this code as a method declaration. » The method declaration in Listing 3-2 has two parts. The first line (the part 
with fixTheAlternator in it, up to but not including the open curly brace) is 
52      PART 1  Getting Started with Java
a method header. The rest of Listing 3-2 (the part surrounded by curly braces) 
is a method body. » The term method declaration distinguishes the list of instructions in Listing 3-2 
from the instruction in Listing 3-3, which is known as a method call. A method’s declaration tells the computer what happens if you call the method into 
action. A method call (a separate piece of code) tells the computer to actually call 
the method into action. A method’s declaration and the method’s call tend to be in 
different parts of the Java program. The main method in a program
Figure 3-3 has a copy of the code from Listing 3-1. The bulk of the code contains 
the declaration of a method named main. (Just look for the word main in the code’s 
method header.) For now, don’t worry about the other words in the method 
header: public, static, void, String, and args. I explain these words in the next 
several chapters. Like any Java method, the main method is a recipe:
How to make biscuits:
    Heat the oven. Roll the dough. Bake the rolled dough. FIGURE 3-3: 
The main 
method. CHAPTER 3  Using the Basic Building Blocks      53
or
How to follow the main instructions for a Displayer:
    Print "You'll love Java!" on the screen. The word main plays a special role in Java. In particular, you never write code that 
explicitly calls a main method into action. The word main is the name of the method 
that is called into action automatically when the program begins running. Look back at Figure 3-1. When the Displayer program runs, the computer auto-
matically finds the program’s main method and executes any instructions inside 
the method’s body. In the Displayer program, the main method’s body has only 
one instruction. That instruction tells the computer to print You'll love Java! on 
the screen. So in Figure 3-1, You'll love Java! appears on the computer screen. The instructions in a method aren’t executed until the method is called into action. But, if you give a method the name main, that method is called into action 
automatically. Almost every computer programming language has something akin to Java’s 
methods. If you’ve worked with other languages, you may remember terms like 
subprograms, procedures, functions, subroutines, subprocedures, and PERFORM 
statements. Whatever you call it in your favorite programming language, a method 
is a bunch of instructions collected and given a new name. How you finally tell the computer  
to do something
Buried deep in the heart of Listing 3-1 is the single line that actually issues a direct 
instruction to the computer. The line, which is highlighted in Figure 3-4, tells the 
computer to display You'll love Java! This line is a statement. In Java, a state-
ment is a direct instruction that tells the computer to do something (for example, 
display this text, put 7 in that memory location, make a window appear). FIGURE 3-4: 
A Java statement. 54      PART 1  Getting Started with Java
In System.out.println, the next-to-last character is a lowercase letter l, not a 
digit 1. Of course, Java has different kinds of statements. A method call, which I introduce 
in the earlier “The Java method” section, is one of the many kinds of Java state-
ments. Listing 3-3 shows you what a method call looks like, and Figure 3-4 also 
contains a method call that looks like this:
System.out.println("You'll love Java!");
When the computer executes this statement, the computer calls a method named 
System.out.println into action. (Yes, in Java, a name can have dots in it. The 
dots mean something.)
I said it already, but it’s worth repeating: In System.out.println, the next-to-last 
character is a lowercase letter l (as in the word line), not a digit 1 (as in the  number 
one). If you use a digit 1, your code won’t work. Just think of println as a way of 
saying “print line” and you won’t have any problem. To learn the meaning behind the dots in Java names, see Chapter 7. Figure 3-5 illustrates the System.out.println situation. Actually, two methods 
play active roles in the running of the Displayer program. Here’s how they work:
 » There’s a declaration for a main method. I wrote the main method myself. This main method is called automatically whenever I run the Displayer  
program. » There’s a call to the System.out.println method. The method call for the 
System.out.println method is the only statement in the body of the main 
method. In other words, calling the System.out.println method is the only 
item on the main method’s to-do list. The declaration for the System.out.println method is buried inside the 
official Java API. For a refresher on the Java API, see the sections “The gram-
mar and the common names” and “The words in a Java program,” earlier in 
this chapter. When I say things like, “ System.out.println is buried inside the API,” I’m not 
doing justice to the API. True, you can ignore all the nitty-gritty Java code inside 
the API. All you need to remember is that System.out.println is defined some-
where inside that code. But I’m not being fair when I make the API code sound like 
something magical. The API is just another bunch of Java code. The statements in 
the API that tell the computer what it means to carry out a call to System.out. println look a lot like the Java code in Listing 3-1. CHAPTER 3  Using the Basic Building Blocks      55
In Java, each statement (like the boxed line in Figure 3-4) ends with a semicolon. Other lines in Figure 3-4 don’t end with semicolons, because the other lines in 
Figure 3-4 aren’t statements. For instance, the method header (the line with the 
word main in it) doesn’t directly tell the computer to do anything. The method 
header announces, “Just in case you ever want to do main, the next few lines of 
code tell you how to do it.”
Every complete Java statement ends with a semicolon. Curly braces
Long ago, or maybe not so long ago, your schoolteachers told you how useful out-
lines are. With an outline, you can organize thoughts and ideas, help people see 
forests instead of trees, and generally show that you’re a member of the Tidy 
Persons Club. Well, a Java program is like an outline. The program in Listing 3-1 
starts with a header line that says, “Here comes a class named Displayer.” After 
that header, a subheader announces, “Here comes a method named main.”
FIGURE 3-5: 
Calling the 
System.out. println  
method. 56      PART 1  Getting Started with Java
Now, if a Java program is like an outline, why doesn’t a program look like an out-
line? What takes the place of the Roman numerals, capital letters, and other items? The answer is twofold:
 » In a Java program, curly braces enclose meaningful units of code. » You, the programmer, can (and should) indent lines so that other program-
mers can see at a glance the outline form of your code. In an outline, everything is subordinate to the item in Roman numeral I. In a Java 
program, everything is subordinate to the top line — the line with class in it. To 
indicate that everything else in the code is subordinate to this class line, you use 
curly braces. Everything else in the code goes inside these curly braces. (See 
Listing 3-4.)
LISTING 3-4: Curly Braces for a Java Class
public class Displayer {
    public static void main(String args[]) {
        System.out.println("You'll love Java!");
    }
}
In an outline, some stuff is subordinate to a capital letter A item. In a Java pro-
gram, some lines are subordinate to the method header. To indicate that some-
thing is subordinate to a method header, you use curly braces. (See Listing 3-5.)
LISTING 3-5: Curly Braces for a Java Method
public class Displayer {
    public static void main(String args[]) {
        System.out.println("You'll love Java!");
    }
}
In an outline, some items are at the bottom of the food chain. In the Displayer 
class, the corresponding line is the line that begins with System.out.println. Accordingly, this System.out.println line goes inside all the other curly braces 
and is indented more than any other line. CHAPTER 3  Using the Basic Building Blocks      57
Never lose sight of the fact that a Java program is, first and foremost, an outline. If you put curly braces in the wrong places or omit curly braces where the braces 
should be, your program probably won’t work at all. If your program works, it’ll 
probably work incorrectly. If you don’t indent lines of code in an informative manner, your program will still 
work correctly, but neither you nor any other programmer will be able to figure 
out what you were thinking when you wrote the code. If you’re a visual thinker, you can picture outlines of Java programs in your head. One friend of mine visualizes an actual numbered outline morphing into a Java 
program. (See Figure  3-6.) Another person, who shall remain nameless, uses 
more bizarre imagery. (See Figure 3-7.)
I appreciate a good excuse as much as the next guy, but failing to indent your Java 
code is inexcusable. In fact, many Java IDEs have tools to indent your code auto-
matically. Visit this book’s website ( www.allmycode.com/JavaForDummies) for 
more information. FIGURE 3-6: 
An outline turns 
into a Java 
program. 58      PART 1  Getting Started with Java
Here are some things for you to try to help you understand the material in this 
section. If trying these things builds your confidence, that’s good.

--- Chunk #650 ---
If trying these 
things makes you question what you’ve read, that’s good too. If trying these 
things makes you nervous, don’t be discouraged. You can find answers and other 
help at this book’s website ( www.allmycode.com/JavaForDummies). You can also 
email me with your questions (JavaForDummies@allmycode.com). » If you’ve downloaded the code from this book’s website, import Listing 3-1 
(from the downloaded 03-01 folder) into your IDE. If you don’t plan to 
download the code, create a new project in your IDE. In the new project, 
create a class named Displayer with the code from Listing 3-1. With the 
downloaded project, or with your own, newly created project, run the 
program and look for the words You'll love Java! in the output. » Try running the code in Listing 3-1 with the text "You'll love Java!" 
changed to "No more baked beans!". What happens? » Try to run the code in Listing 3-1 with the word public (all lowercase) 
changed to Public (starting with an uppercase letter). What happens? » Try to run the code in Listing 3-1 with the word main (all lowercase) changed 
to Main (starting with an uppercase letter). What happens? » Try to run the code in Listing 3-1 with the word System (starting with an 
uppercase letter) changed to system (all lowercase). What happens? » Try to run the code in Listing 3-1 with the indentation changed. For example, 
don’t indent any lines. Also, for good measure, remove the line breaks 
between the first curly brace and the word public (so that the code reads 
public class Displayer { public ...). What happens? » Try to run the code in Listing 3-1 with the word println changed to print1n 
(with the digit 1 near the end). What happens? » Try to run the code in Listing 3-1 with the semicolon missing. What happens? FIGURE 3-7: 
A class is bigger 
than a method; a 
method is bigger 
than a statement. CHAPTER 3  Using the Basic Building Blocks      59
 » Try to run the code in Listing 3-1 with additional semicolons added at the ends 
of some of the lines. What happens? » Try to run the code in Listing 3-1 with the text "You'll love Java!" 
changed to " Use a straight quote \", not a curly quote \u201D". What happens?

--- Chunk #651 ---
And Now, a Few Comments
People gather around campfires to hear the old legend about a programmer whose 
laziness got her into trouble. To maintain this programmer’s anonymity, I call her 
Jane Pro. Jane worked many months to create the holy grail of computing: a pro-
gram that thinks on its own. If completed, this program could work indepen -
dently, learning new things without human intervention. Day after day, night 
after night, Jane Pro labored to give the program that spark of creative, indepen-
dent thought. One day, when she was almost finished with the project, she received a disturbing 
piece of paper mail from her health insurance company. No, the mail wasn’t about 
a serious illness. It was about a routine office visit. The insurance company’s 
claim form had a place for Jane’s date of birth, as if her date of birth had changed 
since the last time she sent in a claim. She had absentmindedly scribbled 2016 as 
her year of birth, so the insurance company refused to pay the bill. Jane dialed the insurance company’s phone number. Within 20 minutes, she was 
talking to a live person. “I’m sorry,” said the live person. “To resolve this issue, 
you must dial a different number.” Well, you can guess what happened next. “I’m 
sorry. The other operator gave you the wrong number.” And then, “I’m sorry. You 
must call back the original phone number.”
Five months later, Jane’s ear ached, but after 800 hours on the phone, she had 
finally gotten a tentative promise that the insurance company would eventually 
reprocess the claim. Elated as she was, she was anxious to get back to her pro-
gramming project. Could she remember what all those lines of code were sup-
posed to be doing? No, she couldn’t. Jane stared and stared at her own work and, like a dream that 
doesn’t make sense the next morning, the code was completely meaningless to 
her. She had written a million lines of code, and not one line was accompanied by 
an informative explanatory comment. She had left no clues to help her understand 
what she’d been thinking, so in frustration, she abandoned the whole project. 60      PART 1  Getting Started with Java
Adding comments to your code
Listing 3-6 has an enhanced version of this chapter’s sample program. In addition 
to all the keywords, identifiers, and punctuation, Listing 3-6 has text that’s meant 
for human beings to read. LISTING 3-6: Three Kinds of Comments
/*
 * Listing 3-6 in "Java For Dummies, 7th Edition"
 *
 * Copyright 2017 Wiley Publishing, Inc. * All rights reserved. */
/**
 * The Displayer class displays text
 * on the computer screen. *
 * @author  Barry Burd
 * @version 1.0 1/24/17
 * @see     java.lang.System
 */
public class Displayer {
    /**
     * The main method is where
     * execution of the code begins. *
     * @param  args   (See Chapter 11.)
     */
    public static void main(String args[]) {
        System.out.println("I love Java!");  //I? You? }
}
A comment is a special section of text, inside a program, whose purpose is to help 
people understand the program. A comment is part of a good program’s 
documentation. CHAPTER 3  Using the Basic Building Blocks      61
The Java programming language has three kinds of comments:
 » Traditional comments: The first five lines of Listing 3-6 form one traditional 
comment. The comment begins with /* and ends with */. Everything 
between the opening /* and the closing */ is for human eyes only. No 
information about "Java For Dummies, 7th Edition" or Wiley 
Publishing, Inc. is translated by the compiler. To read about compilers, see Chapter 2. The second, third, fourth, and fifth lines in Listing 3-6 have extra asterisks (*). I call them extra because these asterisks aren’t required when you create 
a comment. They just make the comment look pretty. I include them in 
Listing 3-6 because, for some reason that I don’t entirely understand, most 
Java programmers add these extra asterisks. » End-of-line comments: The text //I? You? in Listing 3-6 is an end-of-line 
comment. An end-of-line comment starts with two slashes and goes to the end 
of a line of type. Once again, the compiler doesn’t translate the text inside the 
end-of-line comment. » Javadoc comments: A javadoc comment begins with a slash and two 
asterisks (/**). Listing 3-6 has two javadoc comments: one with the text The 
Displayer class ... and another with the text The main method is 
where .... A javadoc comment, which is a special kind of traditional comment, is meant 
to be read by people who never even look at the Java code. But that doesn’t 
make sense. How can you see the javadoc comments in Listing 3-6 if you 
never look at Listing 3-6? » Well, a certain program called javadoc (what else?) can find all the javadoc 
comments in Listing 3-6 and turn these comments into a nice-looking web 
page. Figure 3-8 shows the page. Javadoc comments are great. Here are several great things about them:
 » The only person who has to look at a piece of Java code is the programmer 
who writes the code. Other people who use the code can find out what the 
code does by viewing the automatically generated web page. » Because other people don’t look at the Java code, other people don’t make 
changes to the Java code. (In other words, other people don’t introduce errors 
into the existing Java code.)
 » Because other people don’t look at the Java code, other people don’t have to 
decipher the inner workings of the Java code. All these people need to know 
about the code is what they read on the code’s web page. 62      PART 1  Getting Started with Java
 » The programmer doesn’t create two separate files — some Java code over 
here and some documentation about the code over there. Instead, the 
programmer creates one piece of Java code and embeds the documentation 
(in the form of javadoc comments) right inside the code. » Best of all, the generation of web pages from javadoc comments is automatic. So everyone’s documentation has the same format. No matter whose Java 
code you use, you find out about that code by reading a page like the one in 
Figure 3-8. That’s good because the format in Figure 3-8 is familiar to anyone 
who uses Java. You can generate your own web pages from the javadoc comments that you put in 
your code. To discover how, visit this book’s website ( www.allmycode.com/
JavaForDummies). FIGURE 3-8: 
The javadoc page 
generated from 
the code in 
Listing 3-6. CHAPTER 3  Using the Basic Building Blocks      63
What’s Barry’s excuse? For years I’ve been telling my students to put comments in their code, and for 
years I’ve been creating sample code (like the code in Listing 3-1) with no com-
ments in it. Why? Three little words: Know your audience. When you write complicated, real-life code, 
your audience is other programmers, information technology managers, and 
 people who need help deciphering what you’ve done. When I write simple samples 
of code for this book, my audience is you — the novice Java programmer. Instead 
of reading my comments, your best strategy is to stare at my Java statements — 
the statements that Java’s compiler deciphers. That’s why I put so few comments 
in this book’s listings. Besides, I’m a little lazy. Using comments to experiment  
with your code
You may hear programmers talk about commenting out certain parts of their code. When you’re writing a program and something’s not working correctly, it often 
helps to try removing some of the code. If nothing else, you find out what happens 
when that suspicious code is removed. Of course, you may not like what happens 
when the code is removed, so you don’t want to delete the code completely. Instead, you turn your ordinary Java statements into comments. For instance, you 
turn the statement
System.out.println("I love Java!");
into the comment
// System.out.println("I love Java!");
This change keeps the Java compiler from seeing the code while you try to figure 
out what’s wrong with your program. Traditional comments aren’t very useful for commenting out code. The big prob-
lem is that you can’t put one traditional comment inside of another. Suppose that 
you want to comment out the following statements:
System.out.println("Parents,");
System.out.println("pick your");
/*
64      PART 1  Getting Started with Java
 * Intentionally displays on four separate lines
 */
System.out.println("battles");
System.out.println("carefully!");
If you try to turn this code into one traditional comment, you get the following 
mess:
/*
  System.out.println("Parents,");
  System.out.println("pick your");
  /*
   * Intentionally displays on four separate lines
   */
  System.out.println("battles");
  System.out.println("carefully!");
*/
The first */ (after Intentionally displays) ends the traditional comment pre-
maturely. Then the battles and carefully statements aren’t commented out, 
and the last */ chokes the compiler. You can’t nest traditional comments inside 
one another. Because of this, I recommend end-of-line comments as tools for 
experimenting with your code. Most IDEs can comment out sections of your code for you automatically. For 
details, visit this book’s website (www.allmycode.com/JavaForDummies). 2
Writing Your 
Own Java 
Programs
IN THIS PART . .

--- Chunk #652 ---
. Create new values and modify existing values. Put decision-making into your application’s logic. Repeat things as needed when your program runs. CHAPTER 4  Making the Most of Variables and Their Values      67
IN THIS CHAPTER
 » Assigning values to things
 » Making things store certain types of 
values
 » Applying operators to get new values
Making the Most of 
Variables and Their 
Values
T
 
he following conversation between Mr. Van Doren and Mr. Barasch never 
took place:
Charles: A sea squirt eats its brain, turning itself from an animal into a plant. Jack: Is that your final answer, Charles?

--- Chunk #653 ---
Charles: Yes, it is. Jack: How much money do you have in your account today, Charles? Charles: I have fifty dollars and twenty-two cents in my checking account. Jack: Well, you better call the IRS, because your sea squirt answer is correct. You 
just won a million dollars to add to your checking account. What do you think of 
that, Charles? Charles: I owe it all to honesty, diligence, and hard work, Jack. Some aspects of this dialogue can be represented in Java by a few lines of code. Chapter 4
68      PART 2  Writing Your Own Java Programs
Varying a Variable
No matter how you acquire your million dollars, you can use a variable to tally 
your wealth. Listing 4-1 shows the code. LISTING 4-1: Using a Variable
amountInAccount = 50.22;
amountInAccount = amountInAccount + 1000000.00;
You don’t have to type the code in Listing 4-1 (or in any of this book’s listings). To 
download all the code in this book, visit the book’s website (www.allmycode.com/
JavaForDummies). The code in Listing 4-1 makes use of the amountInAccount variable. A variable is 
a placeholder. You can stick a number like 50.22 into a variable. After you place a 
number in the variable, you can change your mind and put a different number into 
the variable. (That’s what varies in a variable.) Of course, when you put a new 
number in a variable, the old number is no longer there. If you didn’t save the old 
number somewhere else, the old number is gone. Figure 4-1 gives a before-and-after picture of the code in Listing 4-1. After the 
first statement in Listing  4-1 is executed, the variable amountInAccount has 
the number 50.22 in it. Then, after the second statement of Listing 4-1 is executed, 
the amountInAccount variable suddenly has 1000050.22  in it. When you think 
about a variable, picture a place in the computer’s memory where wires and tran-
sistors store 50.22, 1000050.22, or whatever. On the left side of Figure 4-1, imag-
ine that the box with 50.22 in it is surrounded by millions of other such boxes. FIGURE 4-1: 
A variable (before 
and after). CHAPTER 4  Making the Most of Variables and Their Values      69
Now you need some terminology. The thing stored in a variable is a value. A vari-
able’s value can change during the run of a program (when Jack gives you a mil-
lion bucks, for instance). The value that’s stored in a variable isn’t necessarily a 
number. (For instance, you can create a variable that always stores a letter.) The 
kind of value that’s stored in a variable is a variable’s type. You can read more about types in the section “The types of values that variables 
may have,” later in this chapter. A subtle, almost unnoticeable difference exists between a variable and a variable’s 
name. Even in formal writing, I often use the word variable  when I mean variable 
name. Strictly speaking, amountInAccount is a variable name, and all the memory 
storage associated with amountInAccount (including the type that amount 
InAccount has and whatever value amountInAccount currently represents) is the 
variable itself. If you think this distinction between variable and variable name is 
too subtle for you to worry about, join the club. Every variable name is an identifier — a name that you can make up in your own 
code. In preparing Listing 4-1, I made up the name amountInAccount. For more information on the kinds of names in a Java program, see Chapter 3. Before the sun sets on Listing 4-1, you need to notice one more part of the listing. The listing has 50.22 and 1000000.00 in it. Anybody in his or her right mind 
would call these things numbers, but in a Java program it helps to call these things 
literals. And what’s so literal about 50.22 and 1000000.00? Well, think about the variable 
amountInAccount in Listing  4-1. The variable amountInAccount stands for 50.22 
some of the time, but it stands for 1000050.22 the rest of the time. You could use the 
word number to talk about amountInAccount. But really, what amountInAccount 
stands for depends on the fashion of the moment. On the other hand, 50.22 literally 
stands for the value 50 22/100. A variable’s value changes; a literal’s value doesn’t. Starting with Java 7, you can add underscores to numeric literals. Instead of using 
the plain old 1000000.00 in Listing  4-1, you can write amountInAccount = 
amountInAccount + 1_000_000.00 . Unfortunately, you can’t easily do what 
you’re most tempted to do. You can’t write 1,000,000.00 (as you would in the 
United States), nor can you write 1.000.000,00 (as you would in Germany). If you 
want to display a number such as 1,000,000.00 in the program’s output, you 
have to use some fancy formatting tricks. For more information about formatting, 
check Chapters 10 and 11. 70      PART 2  Writing Your Own Java Programs
Assignment statements
Statements like the ones in Listing  4-1 are called assignment statements. In an 
assignment statement, you assign a value to something. In many cases, this 
something is a variable. I recommend getting into the habit of reading assignment statements from right 
to left. Figure 4-2 illustrates the action of the first line in Listing 4-1. The second line in Listing 4-1 is just a bit more complicated. Figure 4-3 illustrates 
the action of the second line in Listing 4-1. In an assignment statement, the thing being assigned a value is always on the left 
side of the equal sign. FIGURE 4-2: 
The action of the 
first line in 
Listing 4-1. FIGURE 4-3: 
The action of the 
second line in 
Listing 4-1. CHAPTER 4  Making the Most of Variables and Their Values      71
The types of values that variables  
may have
Have you seen the TV commercials that make you think you’re flying among the 
circuits inside a computer? Pretty cool, eh? These commercials show 0s (zeros) 
and 1s (ones) sailing by because 0s and 1s are the only things that computers can 
deal with. When you think a computer is storing the letter J, the computer is really 
storing 01001010. Everything inside the computer is a sequence of 0s and 1s. As 
every computer geek knows, a 0 or 1 is called a bit. As it turns out, the sequence 01001010, which stands for the letter J, can also stand 
for the number 74. The same sequence can also stand for 1.0369608636003646 × 
10–43. In fact, if the bits are interpreted as screen pixels, the same sequence can be 
used to represent the dots shown in Figure 4-4. The meaning of 01001010 depends 
on the way the software interprets this sequence of 0s and 1s. How do you tell the computer what 01001010 stands for? The answer is in the 
concept of type. The type of a variable is the range of values that the variable is 
permitted to store. I copied the lines from Listing 4-1 and put them into a complete Java program. The program is in Listing 4-2. When I run the program in Listing 4-2, I get the 
output shown in Figure 4-5. LISTING 4-2: A Program Uses amountInAccount
public class Millionaire {
    public static void main(String args[]) {
        double amountInAccount;
        amountInAccount = 50.22;
        amountInAccount = amountInAccount + 1000000.00;
FIGURE 4-4: 
An extreme 
close-up of eight 
black and white 
screen pixels. (continued)
72      PART 2  Writing Your Own Java Programs
        System.out.print("You have $");
        System.out.print(amountInAccount);
        System.out.println(" in your account.");
    }
}
In Listing 4-2, look at the first line in the body of the main method:
double amountInAccount;
This line is called a variable declaration. Putting this line in your program is like 
saying, “I’m declaring my intention to have a variable named amountInAccount in 
my program.” This line reserves the name amountInAccount for your use in the 
program. In this variable declaration, the word double is a Java keyword. This word double 
tells the computer what kinds of values you intend to store in amountInAccount. In particular, the word double stands for numbers between –1.8 × 10 308 and 
1.8 × 10308. (These are enormous numbers with 308 zeros before the decimal point. Only the world’s richest people write checks with 308 zeros in them. The second 
of these numbers is one-point-eight gazazzo-zillion-kaskillion. The number 1.8 
× 10308, a constant defined by the International Bureau of Weights and Measures, 
is the number of eccentric computer programmers between Sunnyvale, California, 
and the M31 Andromeda Galaxy.)
More important than the humongous range of the double keyword’s numbers is 
the fact that a double value can have digits beyond the decimal point. After you 
declare amountInAccount to be of type double, you can store all sorts of numbers 
in amountInAccount. You can store 50.22, 0.02398479, or –3.0. In Listing 4-2, if 
I hadn’t declared amountInAccount to be of type double, I may not have been able 
to store 50.22. Instead, I would have had to store plain old 50, without any digits 
beyond the decimal point. Another type — type float — also allows you to have digits beyond the decimal 
point. But float values aren’t as accurate as double values. FIGURE 4-5: 
Running the 
program in 
Listing 4-2. LISTING 4-2: (continued)
CHAPTER 4  Making the Most of Variables and Their Values      73
DIGITS BEYOND THE DECIMAL POINT
Java has two different types that have digits beyond the decimal point: type double 
and type float. So what’s the difference? When you declare a variable to be of type 
double, you’re telling the computer to keep track of 64 bits when it stores the variable’s 
values. When you declare a variable to be of type float, the computer keeps track of 
only 32 bits. You could change Listing 4-2 and declare amountInAccount to be of type float. float amountInAccount;
Surely, 32 bits are enough to store a small number like 50.22, right? Well, they are and 
they aren’t. You could easily store 50.00 with only 32 bits. Heck, you could store 50.00 
with only 6 bits. The size of the number doesn’t matter. The accuracy matters. In a 64-bit 
double variable, you’re using most of the bits to store stuff beyond the decimal point. To 
store the .22 part of 50.22, you need more than the measly 32 bits that you get with 
type float. Do you really believe what you just read — that it takes more than 32 bits to store .22? To help convince you, I made a few changes to the code in Listing 4-2. I made amount 
InAccount be of type float. Then I changed the first three statements inside the main 
method as follows:
float amountInAccount;
amountInAccount = 50.22F;
amountInAccount = amountInAccount + 1000000.00F;
(To understand why I used the letter F in 50.22F and 1000000.00F, see Table 4-1, later 
in this chapter.) The output I got was
You have $1000050.25 in your account. Compare this with the output in Figure 4-5. When I switch from type double to type 
float, Charles has an extra three cents in his account. By changing to the 32-bit float 
type, I’ve clobbered the accuracy in the amountInAccount variable’s hundredths place. That’s bad. Another difficulty with float values is purely cosmetic. Look again at the literals, 50.22 
and 1000000.00, in Listing 4-2. The Laws of Java say that literals like these take up 64 
bits each. So, if you declare amountInAccount to be of type float, you’ll run into 
 trouble. You’ll have trouble stuffing those 64-bit literals into your little 32-bit  
(continued)
74      PART 2  Writing Your Own Java Programs
In many situations, you have a choice. You can declare certain values to be either 
float values or double values. But don’t sweat the choice between float and 
double. For most programs, just use double. With today’s fancy processors, the 
space you save using the float type is almost never worth the loss of accuracy. (For more details, see the nearby sidebar, “Digits beyond the decimal point.”)
The big million-dollar jackpot in Listing 4-2 is impressive. But Listing 4-2 doesn’t 
illustrate the best way to deal with dollar amounts. In a Java program, the best 
way to represent currency is to shun the double and float types and opt instead 
for a type named BigDecimal. For more information, see this book’s website (www.

--- Chunk #654 ---
allmycode.com/JavaForDummies). Displaying text
The last three statements in Listing 4-2 use a neat formatting trick. You want to 
display several different items on a single line on the screen. You put these items 
in separate statements. All but the last of the statements are calls to System.out. print. (The last statement is a call to System.out.println.) Calls to System.out. print display text on part of a line and then leave the cursor at the end of the cur-
rent line. After executing System.out.print, the cursor is still at the end of the 
same line, so the next System.out.whatever can continue printing on that same 
line. With several calls to print capped off by a single call to println, the result is 
just one nice-looking line of output. (Refer to Figure 4-5.)
A call to System.out.print writes some things and leaves the cursor sitting at the 
end of the line of output. A call to System.out.println writes things and then 
finishes the job by moving the cursor to the start of a brand-new line of output. amountInAccount variable. To compensate, you can switch from double literals to 
float literals by adding an F to each double literal, but a number with an extra F at the 
end looks funny. float amountInAccount;
amountInAccount = 50.22F;
amountInAccount = amountInAccount + 1000000.00F;
To experiment with numbers, visit http://babbage.cs.qc.cuny.edu/IEEE-754. old/Decimal.html. The page takes any number you enter and shows you how the 
number would be represented as 32 bits and as 64 bits. (continued)
CHAPTER 4  Making the Most of Variables and Their Values      75
Run the code in Listing 4-2 to make sure that it runs correctly on your computer. Then see what happens when you make the following changes:
 » Add thousands-separators to the number 1000000.00 in the code. For 
example, if you live in the United States, where the thousands-separator is a 
comma, change the number to 1,000,000.00 and see what happens. (Hint: 
Nothing good happens.)
 » Try using underscores as thousands-separators in the code. That is, change 
1000000.00 to 1_000_000.00 and see what happens. » Add a currency symbol to the number 50.22 in the code. For example, if you 
live in the United States, where the currency symbol is $, see what happens 
when you change the first assignment statement to amountInAccount = 
$50.22. » Listing 4-2 has two System.out.print statements and one System.out. println statement. Change all three to System.out.println statements 
and then run the program. » The code in Listing 4-2 displays one line of text in its output. Using the 
amountInAccount variable, add statements to the program so that it displays 
a second line of text. Have the second line of text be "Now you have even 
more! You have 2000000.00 in your account."
Numbers without decimal points
“In 1995, the average family had 2.3 children.”
At this point, a wise guy always remarks that no real family has exactly 2.3 chil -
dren. Clearly, whole numbers have a role in this world. Therefore, in Java, you can 
declare a variable to store nothing but whole numbers. Listing 4-3 shows a pro-
gram that uses whole number variables. LISTING 4-3: Using the int Type
public class ElevatorFitter {
    public static void main(String args[]) {
        int weightOfAPerson;
        int elevatorWeightLimit;
        int numberOfPeople;
(continued)
76      PART 2  Writing Your Own Java Programs
        weightOfAPerson = 150;
        elevatorWeightLimit = 1400;
        numberOfPeople = elevatorWeightLimit / weightOfAPerson;
        System.out.print("You can fit ");
        System.out.print(numberOfPeople);
        System.out.println(" people on the elevator.");
    }
}
The story behind the program in Listing 4-3 takes some heavy-duty explaining. Here goes:
You have a hotel elevator whose weight capacity is 1,400 pounds. One weekend 
the  hotel hosts the Brickenchicker family reunion. A certain branch of the 
 Brickenchicker family has been blessed with identical dectuplets (ten siblings, all 
with the same physical characteristics). Normally, each of the Brickenchicker 
 dectuplets weighs exactly 145 pounds. But on Saturday the family has a big 
catered  lunch, and, because lunch included strawberry shortcake, each of the 
Brickenchicker dectuplets now weighs 150 pounds. Immediately after lunch, all 
ten of the Brickenchicker dectuplets arrive at the elevator at exactly the same 
time. (Why not? All ten of them think alike.) So, the question is, how many of the 
dectuplets can fit on the elevator? Now remember, if you put one ounce more than 1,400 pounds of weight on the 
elevator, the elevator cable breaks, plunging all dectuplets on the elevator to their 
sudden (and costly) deaths. The answer to the Brickenchicker riddle (the output of the program of Listing 4-3) 
is shown in Figure 4-6. At the core of the Brickenchicker elevator problem, you have whole numbers — 
numbers with no digits beyond the decimal point. When you divide 1,400 by 150, 
you get 91⁄3, but you shouldn’t take the 1⁄3 seriously. No matter how hard you try, 
FIGURE 4-6: 
Save the 
Brickenchickers. LISTING 4-3: (continued)
CHAPTER 4  Making the Most of Variables and Their Values      77
you can’t squeeze an extra 50 pounds’ worth of Brickenchicker dectuplet onto the 
elevator. This fact is reflected nicely in Java. In Listing 4-3, all three variables 
(weightOfAPerson, elevatorWeightLimit, and numberOfPeople) are of type int. An int value is a whole number. When you divide one int value by another (as you 
do with the slash in Listing 4-3), you get another int. When you divide 1,400 by 
150, you get 9 — not 91⁄3. You see this in Figure 4-6. Taken together, the following 
statements display 9 onscreen:
numberOfPeople = elevatorWeightLimit / weightOfAPerson;
System.out.print(numberOfPeople);
My wife and I were married on February 29, so we have one anniversary every four 
years. Write a program with a variable named years. Based on the value of the 
years variable, the program displays the number of anniversaries we’ve had. For 
example, if the value of years is 4, the program displays the sentence Number of 
anniversaries: 1. If the value of years is 7, the program still displays Number 
of anniversaries: 1. But if the value of years is 8, the program displays Number 
of anniversaries: 2. Combining declarations and  
initializing variables
Look back at Listing 4-3. In that listing, you see three variable declarations — one 
for each of the program’s three int variables. I could have done the same thing 
with just one declaration:
int weightOfAPerson, elevatorWeightLimit, numberOfPeople;
FOUR WAYS TO STORE WHOLE NUMBERS
Java has four types of whole numbers. The types are byte, short, int, and long. Unlike the complicated story about the accuracy of types float and double, the only 
thing that matters when you choose among the whole number types is the size of the 
number you’re trying to store. If you want to use numbers larger than 127, don’t use 
byte. To store numbers larger than 32767, don’t use short. Most of the time, you’ll use int. But if you need to store numbers larger than 
2147483647, forsake int in favor of long. (A long number can be as big as 
9223372036854775807.) For the whole story, see Table 4-1, a little later in this chapter. 78      PART 2  Writing Your Own Java Programs
If two variables have completely different types, you can’t create both variables in 
the same declaration. For instance, to create an int variable named weightOfFred 
and a double variable named amountInFredsAccount, you need two separate vari-
able declarations. You can give variables their starting values in a declaration. In Listing 4-3, for 
instance, one declaration can replace several lines in the main method (all but the 
calls to print and println):
int weightOfAPerson = 150, elevatorWeightLimit = 1400,
  numberOfPeople = elevatorWeightLimit/weightOfAPerson;
When you do this, you don’t say that you’re assigning values to variables. The 
pieces of the declarations with equal signs in them aren’t really called assignment 
statements. Instead, you say that you’re initializing the variables. Believe it or not, 
keeping this distinction in mind is helpful. Like everything else in life, initializing a variable has advantages and 
disadvantages:
 » When you combine six lines of Listing 4-3 into just one declaration, the 
code becomes more concise. Sometimes concise code is easier to read. Sometimes it’s not. As a programmer, it’s your judgment call. » By initializing a variable, you might automatically avoid certain pro-
gramming errors. For an example, see Chapter 7. » In some situations, you have no choice. The nature of your code forces 
you either to initialize or not to initialize. For an example that doesn’t lend 
itself to variable initialization, see the deleting-evidence program in Chapter 6. Experimenting with JShell
The programs in Listings 4-2 and 4-3 both begin with the same old, tiresome 
refrain:
public class SomethingOrOther {
    public static void main(String args[]) {
CHAPTER 4  Making the Most of Variables and Their Values      79
A Java program requires this verbose introduction because
 » In Java the entire program is a class. » The main method is called into action automatically when the program begins 
running. I explain all of this in Chapter 3. Anyway, retyping this boilerplate code into an editor window can be annoying, 
especially when your goal is to test the effect of executing a few simple state-
ments. To fix this problem, the stewards of Java came up with a new tool in Java 
9. They call it JShell. Instructions for launching JShell differ from one computer to the next. For instruc-
tions that work on your computer, visit this book’s website (www.allmycode.com/
JavaForDummies). When you use JShell, you hardly ever type an entire program. Instead, you type a 
Java statement, and then JShell responds to your statement, and then you type a 
second statement, and then JShell responds to your second statement, and then 
you type a third statement, and so on. A single statement is enough to get a 
response from JShell. JShell is only one example of a language’s Read Evaluate Print Loop (REPL). Many 
programming languages have REPLs and, with Java 9, the Java language finally 
has a REPL of its own. In Figure 4-7, I use JShell to find out how Java responds to the assignment state-
ments in Listings 4-2 and 4-3. When you run JShell, the dialogue goes something like this:
jshell> You type a statement
JShell responds
jshell> You type another statement
JShell responds
For example, in Figure 4-7, I type double amountInAccount and then press Enter. JShell responds by displaying
amountInAccount ==> 0.0
80      PART 2  Writing Your Own Java Programs
Here are a few things to notice about JShell:
 » You don’t have to type an entire Java program. Typing a few statements such as
double amountInAccount
amountInAccount = 50.22
amountInAccount = amountInAccount + 1000000.00
does the trick. It’s like running the code snippet in Listing 4-1 (except that 
Listing 4-1 doesn’t declare amountInAccount to be a double). » In JShell, semicolons are (to a large extent) optional. In Figure 4-7, I type a semicolon at the end of only one of my nine lines. For some advice about using semicolons in JShell, see Chapter 5. » JShell responds immediately after you type each line. After I declare amountInAccount to be double, JShell responds by telling 
me that the amountInAccount variable has the value 0.0. After I type  
amountInAccount = amountInAccount + 1000000.00, JShell tells me that 
the new value of amountInAccount is 1000050.22. FIGURE 4-7: 
An intimate 
conversation 
between me  
and JShell. CHAPTER 4  Making the Most of Variables and Their Values      81
 » You can mix statements from many different Java programs. In Figure 4-7, I mix statements from the programs in Listings 4-2 and 4-3. JShell doesn’t care. » You can ask JShell for the value of an expression. You don’t have to assign the expression’s value to a variable. For example, in 
Figure 4-7, I type
elevatorWeightLimit / weightOfAPerson
JShell responds by telling me that the value of elevatorWeightLimit / 
weightOfAPerson is 9. JShell makes up a temporary name for that value. In 
Figure 4-7, the name happens to be $8. So, on the next line in Figure 4-7, I ask 
for the value of $8 +1, and JShell gives me the answer 10. » You can even get answers from JShell without using variables. On the last line in Figure 4-7, I ask for the value of 42 + 7, and JShell generously 
answers with the value 49. While you’re running JShell, you don’t have to retype commands that you’ve 
already typed. If you press the up-arrow key once, JShell shows you the command 
that you typed most recently. If you press the up-arrow key twice, JShell shows 
you the next-to-last command that you typed. And so on. When JShell shows you 
a command, you can use your left- and right-arrow keys to move to any character 
in the middle of the command. You can modify characters in the command. Finally, when you press Enter, JShell executes your newly modified command. To end your run of JShell, you type /exit (starting with a slash). But /exit is only 
one of many commands you can give to JShell. To ask JShell what other kinds of 
commands you can use, type /help. With JShell, you can test your statements before you put them into a full-blown 
Java program. That makes JShell a truly useful tool. Visit this book’s website ( www.allmycode.com/JavaForDummies) for instruc-
tions on launching JShell on your computer. After launching JShell, type a few 
lines of code from Figure 4-7. See what happens when you type some slightly 
different lines. 82      PART 2  Writing Your Own Java Programs
What Happened to All the  
Cool Visual Effects? The programs in Listings 4-2 and 4-3 are text-based. A text-based program has 
no windows, no dialog boxes — nothing of that kind. All you see is line after line 
of plain, unformatted text. The user types something, and the computer displays 
a response beneath each line of input. The opposite of a text-based program is a graphical user interface (GUI) program. A GUI program has windows, text fields, buttons, and other visual goodies. As visually unexciting as text-based programs are, they contain the basic concepts 
for all computer programming. Also, text-based programs are easier for the 
 novice programmer to read, write, and understand than the corresponding GUI 
programs. So, in this book I take a three-pronged approach:
 » Text-based examples: I introduce most of the new concepts with 
these examples. » The DummiesFrame class: Alongside the text-based examples, I present GUI 
versions using the DummiesFrame class, which I created especially for this 
book. (I introduce the DummiesFrame class in Chapter 7.)
 » GUI programming techniques: I describe some of the well-known tech-
niques in Chapters 9, 10, 14, and 16. I even have a tiny GUI example in this 
chapter. (See the later section "The Molecules and Compounds: Reference 
Types.")
With this careful balance of drab programs and sparkly programs, you’re sure to 
learn Java. The Atoms: Java’s Primitive Types
The words int and double that I describe in the previous sections are examples of 
primitive types (also known as simple types) in Java. The Java language has exactly 
eight primitive types. As a newcomer to Java, you can pretty much ignore all but 
four of these types. (As programming languages go, Java is nice and compact that 
way.) Table 4-1 shows the complete list of primitive types. CHAPTER 4  Making the Most of Variables and Their Values      83
The types that you shouldn’t ignore are int, double, char, and boolean. Previous 
sections in this chapter cover the int and double types. So the next two sections 
cover char and boolean types. The char type
Several decades ago, people thought computers existed only for doing big 
 number-crunching calculations. Nowadays, nobody thinks that way. So, if you 
haven’t been in a cryogenic freezing chamber for the past 20 years, you know that 
computers store letters, punctuation symbols, and other characters. The Java type that’s used to store characters is called char. Listing 4-4 has a sim-
ple program that uses the char type. Figure 4-8 shows the output of the program 
in Listing 4-4. TABLE 4-1: Java’s Primitive Types
Type Name What a Literal Looks Like Range of Values
Whole number types
byte (byte)42 –128 to 127
short (short)42 –32768 to 32767
int 42 –2147483648 to 2147483647
long 42L –9223372036854775808 to 
9223372036854775807
Decimal number types
float 42.0F –3.4 × 1038 to 3.4 × 1038
double 42.0 –1.8 × 10308 to 1.8 × 10308
Character type
char 'A' Thousands of characters, glyphs, 
and symbols
Logical type
boolean true true, false
84      PART 2  Writing Your Own Java Programs
LISTING 4-4: Using the char Type
public class CharDemo {
  public static void main(String args[]) {
     char myLittleChar = 'b';
     char myBigChar = Character.toUpperCase(myLittleChar);
     System.out.println(myBigChar);
  }
}
In Listing  4-4, the first initialization stores the letter b in the variable  
myLittleChar. In the initialization, notice how b is surrounded by single quote 
marks. In Java, every char literal starts and ends with a single quote mark. In a Java program, single quote marks surround the letter in a char literal. If you need help sorting out the terms assignment, declaration, and initialization, see 
the “Combining declarations and initializing variables” section, earlier in this 
chapter. In the second initialization of Listing 4-4, the program calls an API method whose 
name is Character.toUpperCase. The Character.toUpperCase method does just 
what its name suggests — the method produces the uppercase equivalent of the 
letter b. This uppercase equivalent (the letter B) is assigned to the myBigChar vari-
able, and the B that’s in myBigChar prints onscreen. For an introduction to the Java application programming interface (API), see 
Chapter 3. If you’re tempted to write the following statement,
char myLittleChars = 'barry';  //Don't do this
FIGURE 4-8: 
An exciting run 
of the program 
of Listing 4-4 as 
it appears in 
the Eclipse 
Console view. CHAPTER 4  Making the Most of Variables and Their Values      85
please resist the temptation. You can’t store more than one letter at a time in a 
char variable, and you can’t put more than one letter between a pair of single 
quotes. If you’re trying to store words or sentences (not just single letters), you 
need to use something called a String. For a look at Java’s String type, see the section “The Molecules and Compounds: 
Reference Types,” later in this chapter. If you’re used to writing programs in other languages, you may be aware of some-
thing called ASCII character encoding. Most languages use ASCII; Java uses Uni -
code. In the old ASCII representation, each character takes up only 8 bits, but in 
Unicode, each character takes up 8, 16, or 32 bits. Whereas ASCII stores the letters 
of the Roman (English) alphabet, Unicode has room for characters from most of 
the world’s commonly spoken languages. The only problem is that some of the 
Java API methods are geared specially toward 16-bit Unicode. Occasionally, this 
bites you in the back (or it bytes you in the back, as the case may be). If you’re 
using a method to write Hello on the screen and H e l l o  shows up instead, 
check the method’s documentation for mention of Unicode characters. It’s worth noticing that the two methods, Character.toUpperCase and System. out.println, are used quite differently in Listing 4-4. The method Character. toUpperCase is called as part of an initialization or an assignment statement, but 
the method System.out.println is called on its own. To find out more about this 
topic, see the explanation of return values in Chapter 7. The boolean type
A variable of type boolean stores one of two values: true or false. Listing 4-5 
demonstrates the use of a boolean variable. Figure 4-9 shows the output of the 
program in Listing 4-5. LISTING 4-5: Using the boolean Type
public class ElevatorFitter2 {
    public static void main(String args[]) {
        System.out.println("True or False?");
        System.out.println("You can fit all ten of the");
        System.out.println("Brickenchicker dectuplets");
        System.out.println("on the elevator:");
        System.out.println();
        int weightOfAPerson = 150;
(continued)
86      PART 2  Writing Your Own Java Programs
        int elevatorWeightLimit = 1400;
        int numberOfPeople = elevatorWeightLimit / weightOfAPerson;
        boolean allTenOkay = numberOfPeople >= 10;
        System.out.println(allTenOkay);
    }
}
In Listing 4-5, the allTenOkay variable is of type boolean. To find a value for the 
allTenOkay variable, the program checks to see whether numberOfPeople is 
greater than or equal to ten. (The symbols >= stand for greater than or equal to.)
At this point, it pays to be fussy about terminology. Any part of a Java program 
that has a value is an expression. If you write
weightOfAPerson = 150;
then 150 is an expression (an expression whose value is the quantity 150). If you 
write
numberOfEggs = 2 + 2;
then 2 + 2 is an expression (because 2 + 2 has the value 4). If you write
int numberOfPeople = elevatorWeightLimit / weightOfAPerson;
then elevatorWeightLimit / weightOfAPerson is an expression. (The value of 
the expression elevatorWeightLimit / weightOfAPerson depends on whatever 
values the variables elevatorWeightLimit and weightOfAPerson have when the 
code containing the expression is executed.)
Any part of a Java program that has a value is an expression. FIGURE 4-9: 
The Brickenchicker 
dectuplets strike 
again. LISTING 4-5: (continued)
CHAPTER 4  Making the Most of Variables and Their Values      87
In Listing 4-5, the code numberOfPeople >= 10 is an expression. The expression’s 
value depends on the value stored in the numberOfPeople variable. But, as you 
know from seeing the strawberry shortcake at the Brickenchicker family’s catered 
lunch, the value of numberOfPeople isn’t greater than or equal to ten. As a result, 
the value of numberOfPeople >= 10 is false. So, in the statement in Listing 4-5, 
in which allTenOkay is assigned a value, the allTenOkay variable is assigned a 
false value. In Listing 4-5, I call System.out.println() with nothing inside the parentheses. When I do this, Java adds a line break to the program’s output. In Listing 4-5, 
System.out.println() tells the program to display a blank line. The Molecules and Compounds:  
Reference Types
By combining simple things, you get more complicated things. That’s the way 
things always go. Take some of Java’s primitive types, whip them together to 
make a primitive type stew, and what do you get? A more complicated type called 
a reference type. The program in Listing 4-6 uses reference types. Figure 4-10 shows you what 
happens when you run the program in Listing 4-6. LISTING 4-6: Using Reference Types
import javax.swing.JFrame;
public class ShowAFrame {
    public static void main(String args[]) {
        JFrame myFrame = new JFrame();
        String myTitle = "Blank Frame";
        myFrame.setTitle(myTitle);
        myFrame.setSize(300, 200);
        myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        myFrame.setVisible(true);
    }
}
88      PART 2  Writing Your Own Java Programs
The program in Listing  4-6 uses two references types. Both types are defined 
in the Java API. One of the types (the one that you’ll use all the time) is called 
String. The other type (the one that you can use to create GUIs) is called JFrame. A String is a bunch of characters. It’s like having several char values in a row. So, 
with the myTitle variable declared to be of type String, assigning "Blank Frame" 
to the myTitle variable makes sense in Listing 4-6. The String class is declared 
in the Java API. In a Java program, double quote marks surround the letters in a String literal. A Java JFrame is a lot like a window. (The only difference is that you call it a JFrame 
instead of a window.) To keep Listing 4-6 short and sweet, I decided not to put 
anything in my frame — no buttons, no fields, nothing. Even with a completely empty frame, Listing 4-6 uses tricks that I don’t describe 
until later in this book. So don’t try reading and interpreting every word of 
 Listing 4-6. The big thing to get from Listing 4-6 is that the program has two 
variable declarations. In writing the program, I made up two variable names: 
myTitle and myFrame. According to the declarations, myTitle is of type String, 
and myFrame is of type JFrame. You can look up String and JFrame in Java’s API documentation. But, even before 
you do, I can tell you what you’ll find. You’ll find that String and JFrame are the 
names of Java classes. So that’s the big news.

--- Chunk #655 ---
Every class is the name of a refer -
ence type. You can reserve amountInAccount for double values by writing
double amountInAccount;
or by writing
double amountInAccount = 50.22;
FIGURE 4-10: 
An empty frame. CHAPTER 4  Making the Most of Variables and Their Values      89
You can also reserve myFrame for a JFrame value by writing
JFrame myFrame;
or by writing
JFrame myFrame = new JFrame();
To review the notion of a Java class, see the sections on object-oriented program-
ming (OOP) in Chapter 1. Every Java class is a reference type. If you declare a variable to have some type 
that’s not a primitive type, the variable’s type is (most of the time) the name of a 
Java class. Now, when you declare a variable to have type int, you can visualize what that 
declaration means in a fairly straightforward way. It means that, somewhere 
inside the computer’s memory, a storage location is reserved for that variable’s 
value. In the storage location is a bunch of bits. The arrangement of the bits 
ensures that a certain whole number is represented. That explanation is fine for primitive types like int or double, but what does it 
mean when you declare a variable to have a reference type? What does it mean to 
declare variable myFrame to be of type JFrame? Well, what does it mean to declare i thank You God to be an E. E. Cummings poem? What would it mean to write the following declaration? EECummingsPoem ithankYouGod;
It means that a class of things is EECummingsPoem, and ithankYouGod refers to an 
instance of that class. In other words, ithankYouGod is an object belonging to the 
EECummingsPoem class. Because JFrame is a class, you can create objects from that class. (If you don’t 
believe me, read some of my paragraphs about classes and objects in Chapter 1.) 
Each object (each instance of the JFrame class) is an actual frame — a window 
that appears on the screen when you run the code in Listing 4-6. By declaring the 
variable myFrame to be of type JFrame, you’re reserving the use of the name 
myFrame. This reservation tells the computer that myFrame can refer to an actual 
JFrame-type object. In other words, myFrame can become a nickname for one of 
the windows that appears on the computer screen. Figure  4-11 illustrates the 
situation. 90      PART 2  Writing Your Own Java Programs
When you declare ClassName variableName;, you’re saying that a certain vari-
able can refer to an instance of a particular class. In Listing 4-6, the phrase JFrame myFrame reserves the use of the name myFrame. On that same line of code, the phrase new JFrame() creates a new object (an 
instance of the JFrame class). Finally, that line’s equal sign makes myFrame refer 
to the new object. Knowing that the two words new JFrame() create an object can 
be very important. For a more thorough explanation of objects, see Chapter 7. Try these things:
 » Run the code in Listing 4-6 on your computer. » Before running the code in Listing 4-6, comment out the myFrame.set 
Visible(true) statement by putting two forward slashes (//) immediately 
to the left of the statement. Does anything happen when you run the 
modified code? » Experiment with the code in Listing 4-6 by changing the order of the state-
ments inside the body of the main method. What rearrangements of these 
statements are okay, and which aren’t? FIGURE 4-11: 
The variable 
myFrame  
refers to an 
instance of the 
JFrame class. CHAPTER 4  Making the Most of Variables and Their Values      91
An Import Declaration
It’s always good to announce your intentions up front. Consider the following 
classroom lecture:
Today, in our History of Film course, we’ll be discussing the career of actor Lionel 
Herbert Blythe Barrymore. Born in Philadelphia, Barrymore appeared in more than 200 films, including It’s a 
Wonderful Life, Key Largo, and Dr. Kildare’s Wedding Day. In addition, Barrymore 
was a writer, composer, and director. Barrymore did the voice of Ebenezer Scrooge 
every year on radio . .

--- Chunk #656 ---
.

--- Chunk #657 ---
. PRIMITIVE TYPE STEW
While I’m on the subject of frames, what’s a frame, anyway? A frame is a window that 
has a certain height and width and a certain location on your computer’s screen. Therefore, deep inside the declaration of the Frame class, you can find variable declara-
tions that look something like this:
int width;
int height;
int x;
int y;
Here’s another example — Time. An instance of the Time class may have an hour 
(a number from 1 to 12), a number of minutes (from 0 to 59), and a letter (a for a.m.;  
p for p.m.). int hour;
int minutes;
char amOrPm;
Notice that this high-and-mighty thing called a Java API class is neither high nor mighty. A class is just a collection of declarations. Some of those declarations are the declara-
tions of variables. Some of those variable declarations use primitive types, and other 
variable declarations use reference types. These reference types, however, come from 
other classes, and the declarations of those classes have variables. The chain goes on 
and on. Ultimately, everything comes, in one way or another, from the primitive types. 92      PART 2  Writing Your Own Java Programs
Interesting stuff, heh? Now compare these paragraphs with a lecture in which the 
instructor doesn’t begin by introducing the subject:
Welcome once again to the History of Film. Born in Philadelphia, Lionel Barrymore appeared in more than 200 films, including It’s 
a Wonderful Life, Key Largo, and Dr. Kildare’s Wedding Day. In addition, Barrymore 
(not Ethel, John, or Drew) was a writer, composer, and director. Lionel Barrymore did 
the voice of Ebenezer Scrooge every year on radio . .

--- Chunk #658 ---
.

--- Chunk #659 ---
. Without a proper introduction, a speaker may have to remind you constantly that 
the discussion is about Lionel Barrymore and not about any other Barrymore. The 
same is true in a Java program. Look again at Listing 4-6:
import javax.swing.JFrame;
public class ShowAFrame {
    public static void main(String args[]) {
        JFrame myFrame = new JFrame();
In Listing 4-6, you announce in the introduction (in the import declaration) that 
you’re using JFrame in your Java class. You clarify what you mean by JFrame with 
the full name javax.swing.JFrame. (Hey! Didn’t the first lecturer clarify with the 
full name “Lionel Herbert Blythe Barrymore”?) After announcing your intentions 
in the import declaration, you can use the abbreviated name JFrame in your Java 
class code. If you don’t use an import declaration, you have to repeat the full javax.swing. JFrame name wherever you use the name JFrame in your code. For example, with-
out an import declaration, the code of Listing 4-6 would look like this:
public class ShowAFrame {
    public static void main(String args[]) {
        javax.swing.JFrame myFrame = new javax.swing.JFrame();
        String myTitle = "Blank Frame";
        myFrame.setTitle(myTitle);
        myFrame.setSize(3200, 200);
        myFrame.setDefaultCloseOperation(javax.swing.JFrame.EXIT_ON_CLOSE);
        myFrame.setVisible(true);
    }
}
CHAPTER 4  Making the Most of Variables and Their Values      93
The details of this import stuff can be pretty nasty. But fortunately, many IDEs 
have convenient helper features for import declarations. For details, see this 
book’s website (www.allmycode.com/JavaForDummies). No single section in this book can present the entire story about import declara-
tions. To begin untangling some of the import declaration’s subtleties, see Chap-
ters 5, 9, and 10. Creating New Values by  
Applying Operators
What could be more comforting than your old friend the plus sign? It was the first 
topic you learned about in elementary school math. Almost everybody knows how 
to add 2 and 2. In fact, in English usage, adding 2 and 2 is a metaphor for some-
thing that’s easy to do. Whenever you see a plus sign, a cell in your brain says, 
“Thank goodness — it could be something much more complicated.”
Java has a plus sign. You can use it for several purposes. You can use the plus sign 
to add two numbers, like this:
int apples, oranges, fruit;
apples = 5;
oranges = 16;
fruit = apples + oranges;
You can also use the plus sign to paste String values together:
String startOfChapter =
    "It's three in the morning. I'm dreaming about the"+
    "history course that I failed in high school.";
System.out.println(startOfChapter);
This can be handy because in Java, you’re not allowed to make a String straddle 
from one line to another. In other words, the following code wouldn’t work:
String thisIsBadCode =
    "It's three in the morning. I'm dreaming about the
     history course that I failed in high school.";
System.out.println(thisIsBadCode);
94      PART 2  Writing Your Own Java Programs
The correct way to say that you’re pasting String values together is to say that 
you’re concatenating String values. You can even use the plus sign to paste numbers next to String values:
int apples, oranges, fruit;
apples = 5;
oranges = 16;
fruit = apples + oranges;
System.out.println("You have" + fruit + "pieces of fruit.");
Of course, the old minus sign is available, too (but not for String values):
apples = fruit - oranges;
Use an asterisk (*) for multiplication and a slash (/) for division:
double rate, pay;
int hours;
rate = 6.25;
hours = 35;
pay = rate * hours;
System.out.println(pay);
For an example using division, refer to Listing 4-3. When you divide an int value by another int value, you get an int value. The 
computer doesn’t round. Instead, the computer chops off any remainder. If you 
put System.out.println(11 / 4) in your program, the computer prints 2, not 
2.75. To get past this, make either (or both) of the numbers you’re dividing 
double values. If you put System.out.println(11.0 / 4) in your program, the 
computer prints 2.75. Another useful arithmetic operator is called the remainder operator. The symbol 
for the remainder operator is the percent sign ( %). When you put System.out. println(11 % 4) in your program, the computer prints 3. It does this because 4 
goes into 11 who-cares-how-many times with a remainder of 3. The remainder 
operator turns out to be fairly useful.

--- Chunk #660 ---
Listing 4-7 has an example. CHAPTER 4  Making the Most of Variables and Their Values      95
LISTING 4-7: Making Change
import static java.lang.System.out;
public class MakeChange {
    public static void main(String args[]) {
        int total = 248;
        int quarters = total / 25;
        int whatsLeft = total % 25;
        int dimes = whatsLeft / 10;
        whatsLeft = whatsLeft % 10;
        int nickels = whatsLeft / 5;
        whatsLeft = whatsLeft % 5;
        int cents = whatsLeft;
        out.println("From " + total + " cents you get");
        out.println(quarters + " quarters");
        out.println(dimes + " dimes");
        out.println(nickels + " nickels");
        out.println(cents + " cents");
    }
}
Figure 4-12 shows a run of the code in Listing 4-7. You start with a total of 248 
cents. Then
quarters = total / 25
divides 248 by 25, giving 9. That means you can make 9 quarters from 248 cents. Next,
whatsLeft = total % 25
divides 248 by 25 again and puts only the remainder, 23, into whatsLeft. Now 
you’re ready for the next step, which is to take as many dimes as you can out 
of  cents. FIGURE 4-12: 
Change for $2.48. 96      PART 2  Writing Your Own Java Programs
The code in Listing  4-7 makes change in U.S. currency with the following coin 
denominations: 1 cent, 5 cents (one nickel), 10 cents (one dime), and 25 cents (one 
quarter). With these denominations, the MakeChange class gives you more than 
simply a set of coins adding up to 248 cents. The MakeChange class gives you the 
smallest number of coins that add up to 248 cents. With some minor tweaking, you can 
make the code work in any country’s coinage. You can always get a set of coins add-
ing up to a total. But, for the denominations of coins in some countries, you won’t 
always get the smallest number of coins that add up to a total. In fact, I’m looking for 
examples.

--- Chunk #661 ---
If your country’s coinage prevents MakeChange from always giving the 
best answer, please, send me an email (JavaForDummies@allmycode.com). IMPORT DECLARATIONS: THE UGLY TRUTH
Notice the import declaration at the top of Listing 4-7:
import static java.lang.System.out;
Compare this with the import declaration at the top of Listing 4-6:
import javax.swing.JFrame;
By adding the import static java.lang.System.out; line to Listing 4-7, I can 
make the rest of the code a bit easier to read, and I can avoid having long Java state-
ments that start on one line and continue on another. But you never have to do that. If 
you remove the import static java.lang.System.out; line and pepper the code 
liberally with System.out.println, the code works just fine. Here’s a question: Why does one declaration include the word static and the other dec-
laration doesn’t? Well, to be honest, I wish I hadn’t asked! For the real story about static, you have to read part of Chapter 10. And frankly, I don’t 
recommend skipping ahead to that chapter’s static section if you take medicine for a 
heart condition, if you’re pregnant or nursing, or if you have no previous experience 
with object-oriented programming. For now, rest assured that Chapter 10 is easy to 
read after you’ve made the journey through Part 3 of this book. And when you have to 
decide whether to use the word static in an import declaration, remember these hints:
• The vast majority of import declarations in Java program do not use the word static. • In this book, I never use import static to import anything except System.out. (Well, 
almost never .

--- Chunk #662 ---
.

--- Chunk #663 ---
. .)
• Most import declarations don’t use the word static because most declarations 
import classes. Unfortunately, System.out is not the name of a class. CHAPTER 4  Making the Most of Variables and Their Values      97
Find the values of the following expressions by typing each expression in JShell (if 
you have trouble launching JShell, create a Java program that displays the value of 
each of these expressions):
 » 5 / 4
 » 5 / 4.0
 » 5.0 / 4
 » 5.0 / 4.0
 » "5" + "4"
 » 5 + 4
 » " " + 5 + 4
Initialize once, assign often
Listing 4-7 has three lines that put values into the variable whatsLeft:
int whatsLeft = total % 25;
whatsLeft = whatsLeft % 10;
whatsLeft = whatsLeft % 5;
Only one of these lines is a declaration. The other two lines are assignment state-
ments. That’s good because you can’t declare the same variable more than once 
(not without creating something called a block). If you goof and write
int whatsLeft = total % 25;
int whatsLeft = whatsLeft % 10;
in Listing 4-7, you see an error message (such as Duplicate variable  whats 
Left or Variable 'whatsLeft' is already defined ) when you try to compile 
your code. To find out what a block is, see Chapter 5. Then, for some honest talk about rede-
claring variables, see Chapter 10. 98      PART 2  Writing Your Own Java Programs
The increment and decrement operators
Java has some neat little operators that make life easier (for the computer’s pro-
cessor, for your brain, and for your fingers). Altogether, four such operators 
exist — two increment operators and two decrement operators. The increment 
operators add 1, and the decrement operators subtract 1. The increment operators 
use double plus signs ( ++), and the decrement operators use double minus 
signs (--). To see how they work, you need some examples. The first example is 
shown in Figure 4-13.

--- Chunk #664 ---
Figure 4-14 shows a run of the program in Figure 4-13. In this horribly uneventful 
run, the count of bunnies prints three times. The double plus signs go by two names, depending on where you put them. When 
you put the ++ before a variable, the ++ is called the preincrement operator. (The pre 
stands for before.)
The word before has two meanings:
 » You put ++ before the variable. » The computer adds 1 to the variable’s value before the variable is used in any 
other part of the statement. FIGURE 4-14: 
A run of the code 
in Figure 4-13. FIGURE 4-13: 
Using  
preincrement. CHAPTER 4  Making the Most of Variables and Their Values      99
To understand this, look at the bold line in Figure 4-13. The computer adds 1 to 
numberOfBunnies (raising the value of numberOfBunnies to 29) and then prints 
29 onscreen. With out.println(++numberOfBunnies), the computer adds 1 to numberOf 
Bunnies before printing the new value of numberOfBunnies onscreen. An alternative to preincrement is postincrement. (The post stands for after. ) The 
word after has two different meanings:
 » You put ++ after the variable. » The computer adds 1 to the variable’s value after the variable is used in any 
other part of the statement. To see more clearly how postincrement works, look at the bold line in Figure 4-15. The computer prints the old value of numberOfBunnies (which is 28) on the screen, 
and then the computer adds 1 to numberOfBunnies, which raises the value of 
 numberOfBunnies to 29. With out.println(numberOfBunnies++), the computer adds 1 to numberOfBunnies 
after printing the old value that numberOfBunnies already had. Figure 4-16 shows a run of the code in Figure 4-15. Compare Figure 4-16 with the 
run in Figure 4-14:
 » With preincrement in Figure 4-14, the second number is 29. » With postincrement in Figure 4-16, the second number is 28. In Figure 4-16, 29 doesn’t show onscreen until the end of the run, when the 
computer executes one last out.println(numberOfBunnies). FIGURE 4-15: 
Using 
 postincrement. 100      PART 2  Writing Your Own Java Programs
Are you trying to decide between using preincrement or postincrement? Try no 
longer. Most programmers use postincrement. In a typical Java program, you 
often see things like numberOfBunnies++. You seldom see things like 
++numberOfBunnies. In addition to preincrement and postincrement, Java has two operators that  
use --. These operators are called predecrement and postdecrement:
 » With predecrement (--numberOfBunnies), the computer subtracts 1 from the 
variable’s value before the variable is used in the rest of the statement. » With postdecrement (numberOfBunnies--), the computer subtracts 1 from 
the variable’s value after the variable is used in the rest of the statement. Instead of writing ++numberOfBunnies, you could achieve the same effect by 
writing numberOfBunnies = numberOfBunnies + 1 . So some people conclude 
that Java’s ++ and -- operators are for saving keystrokes — to keep those poor 
fingers from overworking themselves. This is entirely incorrect. The best reason 
for using ++ is to avoid the inefficient and error-prone practice of writing the 
same variable name, such as numberOfBunnies, twice in the same statement. If  you write numberOfBunnies only once (as you do when you use ++ or --), 
the  computer has to figure out  what numberOfBunnies means only once. On 
top  of that, when you write numberOfBunnies only once, you have only one 
chance (instead of two chances) to type the variable name incorrectly. With sim-
ple expressions like numberOfBunnies++, these advantages hardly make a  
difference. But with more complicated expressions, such as inventoryItems 
[(quantityReceived--*itemsPerBox+17)]++ , the efficiency and accuracy that 
you gain by using ++ and -- are significant. FIGURE 4-16: 
A run of the code 
in Figure 4-15. CHAPTER 4  Making the Most of Variables and Their Values      101
STATEMENTS AND EXPRESSIONS
You can describe the pre- and postincrement and pre- and postdecrement operators in 
two ways: the way everyone understands them and the right way. The way that I explain 
the concept in most of this section (in terms of time, with before and after) is the way 
that everyone understands it. Unfortunately, the way everyone understands the con-
cept isn’t really the right way. When you see ++ or --, you can think in terms of time 
sequence. But occasionally a programmer uses ++ or -- in a convoluted way, and the 
notions of before and after break down. So if you’re ever in a tight spot, think about 
these operators in terms of statements and expressions. First, remember that a statement tells the computer to do something, and an expres-
sion has a value. (I discuss statements in Chapter 3, and I describe expressions else-
where in this chapter.) Which category does numberOfBunnies++ belong to? The 
surprising answer is both. The Java code numberOfBunnies++ is both a statement and 
an expression. Assume that, before the computer executes the code out. println(numberOfBunnies++), the value of numberOfBunnies is 28. • As a statement, numberOfBunnies++ tells the computer to add 1 to 
numberOfBunnies. • As an expression, the value of numberOfBunnies++ is 28, not 29. So even though the computer adds 1 to numberOfBunnies, the code out. println(numberOfBunnies++) really means out.println(28). Now, almost everything you just read about numberOfBunnies++ is true about  
++numberOfBunnies. The only difference is that as an expression, ++numberOf 
Bunnies behaves in a more intuitive way. • As a statement, ++numberOfBunnies tells the computer to add 1 to 
numberOfBunnies. • As an expression, the value of ++numberOfBunnies is 29. So, with out.println(++numberOfBunnies), the computer adds 1 to the variable 
numberOfBunnies, and the code out.println(++numberOfBunnies) really means 
out.println(29). 102      PART 2  Writing Your Own Java Programs
Before you run the following code, try to predict what the code’s output will be. Then run the code to find out whether your prediction is correct:
public class Main {
  public static void main(String[] args) {
    int i = 10;
    System.out.println(i++);
    System.out.println(--i);
    --i;
    i--;
    System.out.println(i);
    System.out.println(++i);
    System.out.println(i--);
    System.out.println(i);
    i++;
    i = i++ + ++i;
    System.out.println(i);
    i = i++ + i++;
    System.out.println(i);
  }
}
Type the boldface text, one line after another, into JShell, and see how JShell 
responds. jshell> int i = 8
jshell> i++
jshell> i
jshell> i
jshell> i++
jshell> i
jshell> ++i
jshell> i
Assignment operators
If you read the preceding section, which is about operators that add 1, you may be 
wondering whether you can manipulate these operators to add 2 or add 5 or add 
1000000. Can you write numberOfBunnies++++ and still call yourself a Java pro-
grammer? Well, you can’t.

--- Chunk #665 ---
If you try it, an error message appears when you try to 
compile your code. What can you do? As luck would have it, Java has plenty of assignment operators 
you can use. With an assignment operator, you can add, subtract, multiply, or divide 
CHAPTER 4  Making the Most of Variables and Their Values      103
by anything you want. You can do other cool operations, too. Listing 4-8 has a 
smorgasbord of assignment operators (the things with equal signs). Figure 4-17 
shows the output from running Listing 4-8. LISTING 4-8: Assignment Operators
public class UseAssignmentOperators {
    public static void main(String args[]) {
        int numberOfBunnies = 27;
        int numberExtra = 53;
        numberOfBunnies += 1;
        System.out.println(numberOfBunnies);
        numberOfBunnies += 5;
        System.out.println(numberOfBunnies);
        numberOfBunnies += numberExtra;
        System.out.println(numberOfBunnies);
        numberOfBunnies *= 2;
        System.out.println(numberOfBunnies);
        System.out.println(numberOfBunnies -= 7);
        System.out.println(numberOfBunnies = 100);
    }
}
Listing  4-8 shows how versatile Java’s assignment operators are. With the 
 assignment operators, you can add, subtract, multiply, or divide a variable by any 
number. Notice how += 5 adds 5 to numberOfBunnies, and how *= 2 multiplies 
numberOfBunnies by 2. You can even use another expression’s value (in Listing 4-8, 
numberExtra) as the number to be applied. FIGURE 4-17: 
A run of the code 
in Listing 4-8. 104      PART 2  Writing Your Own Java Programs
The last two lines in Listing 4-8 demonstrate a special feature of Java’s assign -
ment operators. You can use an assignment operator as part of a larger Java state-
ment. In the next-to-last line of Listing  4-8, the operator subtracts 7 from 
numberOfBunnies, decreasing the value of numberOfBunnies from 172 to 165. Then the whole assignment business is stuffed into a call to System.out.println, 
so 165 prints onscreen. Lo and behold, the last line of Listing 4-8 shows how you can do the same thing 
with Java’s plain old equal sign. The thing that I call an assignment statement 
near the start of this chapter is really one of the assignment operators that I 
describe in this section. Therefore, whenever you assign a value to something, you 
can make that assignment be part of a larger statement. Each use of an assignment operator does double duty as a statement and an 
expression. In all cases, the expression’s value equals whatever value you 
assign. For example, before executing the code System.out.println(number  
OfBunnies -= 7), the value of numberOfBunnies is 172. As a statement, number 
OfBunnies -= 7  tells the computer to subtract 7 from numberOfBunnies 
(so  the  value of  numberOfBunnies goes from 172 to 165). As an expression, 
the value of numberOfBunnies -= 7  is 165. So the code System.out.println 
(numberOfBunnies -= 7)  really means System.out.println(165) . The num-
ber 165 displays on the computer screen. For a richer explanation of this kind of thing, see the sidebar “Statements and 
expressions,” earlier in this chapter.

--- Chunk #666 ---
Before you run the following code, try to predict what the code’s output will be. Then run the code to find out whether your prediction is correct:
public class Main {
  public static void main(String[] args) {
    int i = 10;
    i += 2;
    i -= 5;
    i *= 6;
    System.out.println(i);
    System.out.println(i += 3);
    System.out.println(i /= 2);
  }
}
CHAPTER 5  Controlling Program Flow with Decision-Making Statements      105
IN THIS CHAPTER
 » Writing statements that choose 
between alternatives
 » Forming logical conditions
 » Putting statements inside one 
another
 » Choosing among many alternatives
Controlling Program 
Flow with Decision-
Making Statements
T
he TV show Dennis the Menace aired on CBS from 1959 to 1963. I remember 
one episode in which Mr. Wilson was having trouble making an important 
decision. I think it was something about changing jobs or moving to a new 
town. Anyway, I can still see that shot of Mr. Wilson sitting in his yard, sipping 
lemonade, and staring into nowhere for the whole afternoon. Of course, the 
annoying character Dennis was constantly interrupting Mr. Wilson’s peace and 
quiet. That’s what made this situation funny. What impressed me about this episode (the reason I remember it clearly even 
now) was Mr. Wilson’s dogged intent in making the decision. This guy wasn’t 
going about his everyday business, roaming around the neighborhood while 
thoughts about the decision wandered in and out of his mind. He was sitting qui-
etly in his yard, making marks carefully and logically on his mental balance sheet. How many people actually make decisions this way? At that time, I was still pretty young. I’d never faced the responsibility of making 
a big decision that affected my family and me. But I wondered what such a 
 decision-making process would be like. Would it help to sit there like a stump for 
Chapter 5
106      PART 2  Writing Your Own Java Programs
hours on end? Would I make my decisions by the careful weighing and tallying of 
options? Or would I shoot in the dark, take risks, and act on impulse? Only time 
would tell.

--- Chunk #667 ---
Making Decisions ( Java if Statements)
When you’re writing computer programs, you’re constantly hitting forks in roads. Did the user correctly type the password? If yes, let the user work; if no, kick the 
bum out. So the Java programming language needs a way of making a program 
branch in one of two directions. Fortunately, the language has a way: It’s called an 
if statement. Guess the number
Listing 5-1 illustrates the use of an if statement. Two runs of the program in 
Listing 5-1 are shown in Figure 5-1. LISTING 5-1: A Guessing Game
import static java.lang.System.out;
import java.util.Scanner;
import java.util.Random;
public class GuessingGame {
    public static void main(String args[]) {
        Scanner keyboard = new Scanner(System.in);
        out.print("Enter an int from 1 to 10: ");
        int inputNumber = keyboard.nextInt();
        int randomNumber = new Random().nextInt(10) + 1;
        if (inputNumber == randomNumber) {
            out.println("**********");
            out.println("*You win.*");
            out.println("**********");
        } else {
            out.println("You lose.");
            out.print("The random number was ");
            out.println(randomNumber + ".");
        }
CHAPTER 5  Controlling Program Flow with Decision-Making Statements      107
        out.println("Thank you for playing.");
        keyboard.close();
    }
}
The program in Listing 5-1 plays a guessing game with the user. The program gets 
a number (a guess) from the user and then generates a random number between 
1 and 10. If the number that the user entered is the same as the random number, 
the user wins. Otherwise, the user loses and the program tells the user what the 
random number was. She controlled keystrokes  
from the keyboard
Taken together, the lines
import java.util.Scanner;
        Scanner keyboard = new Scanner(System.in);
        int inputNumber = keyboard.nextInt();
in Listing 5-1 get whatever number the user types on the computer’s keyboard. The last of the three lines puts this number into a variable named inputNumber. If 
these lines look complicated, don’t worry: You can copy these lines almost word 
for word whenever you want to read from the keyboard. Include the first two lines 
(the import and Scanner lines) just once in your program. Later in your program, 
wherever the user types an int value, include a line with a call to nextInt (as in 
the last of the preceding three lines of code). FIGURE 5-1: 
Two runs of the 
guessing game. 108      PART 2  Writing Your Own Java Programs
Of all the names in these three lines of code, the only two names that I coined 
myself are inputNumber and keyboard. All the other names are part of Java. So, if I 
want to be creative, I can write the lines this way:
import java.util.Scanner;
        Scanner readingThingie = new Scanner(System.in);
        int valueTypedIn = readingThingie.nextInt();
I can also beef up my program’s import declarations, as I do later on in 
Listings 5-2 and 5-3. Other than that, I have very little leeway. As you read on in this book, you’ll start recognizing the patterns behind these 
three lines of code, so I don’t clutter up this section with all the details. For now, 
you can just copy these three lines and keep the following in mind:
 » When you import java.util.Scanner, you don’t use the word static. But importing Scanner is different from importing System.out. When 
you import java.lang.System.out, you use the word static. (Refer to 
Listing 5-1.) The difference creeps into the code because Scanner is the 
name of a class, and System.out isn’t the name of a class. For a quick look at the use of the word static in import declarations, see the 
sidebar in Chapter 4 about import declarations: the ugly truth. For a more 
complete story about the word, see Chapter 10. » Typically (on a desktop or laptop computer), the name System.in stands 
for the keyboard. To get characters from some place other than the keyboard, you can type 
something other than System.in inside the parentheses. What else can you put inside the new Scanner(...) parentheses? For some 
ideas, see Chapter 8. In Listing 5-1, I make the arbitrary decision to give one of my variables the 
name keyboard. The name keyboard reminds you, the reader, that this 
variable refers to a bunch of plastic buttons in front of your computer. Naming something keyboard doesn’t tell Java anything about plastic buttons 
or about user input. On the other hand, the name System.in always tells 
Java about those plastic buttons. The code Scanner keyboard = new 
Scanner(System.in) in Listing 5-1 connects the name keyboard with the 
plastic buttons that we all know and love. CHAPTER 5  Controlling Program Flow with Decision-Making Statements      109
 » When you expect the user to type an int value (a whole number of some 
kind), use nextInt(). If you expect the user to type a double value (a number containing a decimal 
point), use nextDouble(). If you expect the user to type true or false, use 
nextBoolean(). If you expect the user to type a word like Barry, Java, or Hello, 
use next(). Decimal points vary from one country to another. In the United States, 10.5 
(with a period) represents ten-and-a-half, but in France, 10,5 (with a comma) 
represents ten-and-a-half. In the Persian language, a decimal point looks like 
a slash (but it sits a bit lower than the digit characters). Your computer’s 
operating system stores information about the country you live in, and Java 
reads that information to decide what ten-and-a-half looks like. If you run a 
program containing a nextDouble() method call, and Java responds with 
an InputMismatchException, check your input. You might have input 10.5 
when your country’s conventions require 10,5 (or another way of representing 
ten-and-a-half). For more information, see the “Where on Earth do you live?” 
sidebar in Chapter 8. For an example in which the user types a word, see Listing 5-3, later in this 
chapter. For an example in which the user types a single character, see 
Listing 6-4, in Chapter 6. For an example in which a program reads an entire 
line of text (all in one big gulp), see Chapter 8. » You can get several values from the keyboard, one after another. To do this, use the keyboard.nextInt() code several times. To see a program that reads more than one value from the keyboard, go to 
Listing 5-4, later in this chapter. » Whenever you use Java’s Scanner, you should call the close method after your 
last nextInt call (or your last nextDouble call, or your last nextWhatever call). In Listing 5-1, the main method’s last statement is
keyboard.close();
This statement does some housekeeping to disconnect the Java program from 
the computer keyboard. (The amount of required housekeeping is more than 
you might think!) If I omit this statement from Listing 5-1, nothing terrible 
happens. Java’s Virtual Machine usually cleans up after itself very nicely. But 
using close() to explicitly detach from the keyboard is good practice, and 
some IDEs display warnings if you omit the keyboard.close() statement. In this book’s example, I always remember to close my Scanner variables. 110      PART 2  Writing Your Own Java Programs
In Chapter 13, I show you a more reliable way to incorporate the keyboard. close() statement in your Java program. When your program calls System.out.println, your program uses the 
computer’s screen. So why don’t you call a close method after all your 
System.out.println calls? The answer is subtle. In Listing 5-1, your own 
code connects to the keyboard by calling new Scanner(System.in). So, later 
in the program, your code cleans up after itself by calling the close method. But with System.out.println, your own code doesn’t create a connection to 
the screen. (The out variable refers to a PrintStream, but you don’t call new 
PrintStream() to prepare for calling System.out.println.) Instead, the 
Java Virtual Machine connects to the screen on your behalf. The Java Virtual 
Machine’s code (which you never have to see) contains a call to new 
PrintStream() in preparation for your calling System.out.println. So, 
because it’s a well-behaved piece of code, the Java Virtual Machine eventually 
calls out.close() without any effort on your part. Creating randomness
Achieving real randomness is surprisingly difficult. Mathematician Persi Diaconis 
says that if you flip a coin several times, always starting with the head side up, 
you’re likely to toss heads more often than tails. If you toss several more times, 
always starting with the tail side up, you’ll likely toss tails more often than heads. In other words, coin tossing isn’t really fair.*
Computers aren’t much better than coins and human thumbs. A computer mimics 
the generation of random sequences, but in the end the computer just does what 
it’s told and does all of this in a purely deterministic fashion. So in Listing 5-1, 
when the computer executes
import java.util.Random;
        int randomNumber = new Random().nextInt(10) + 1;
the computer appears to give a randomly generated number — a whole number 
between 1 and 10. But it’s all a fake. The computer only follows instructions. It’s 
not really random, but without bending a computer over backward, it’s the best 
that anyone can do. *Diaconis, Persi. “The Search for Randomness.” American Association for the 
Advancement of Science annual meeting. Seattle.

--- Chunk #668 ---
14 Feb.

--- Chunk #669 ---
2004. CHAPTER 5  Controlling Program Flow with Decision-Making Statements      111
Once again, I ask you to take this code on blind faith. Don’t worry about what new 
Random().nextInt means until you have more experience with Java. Just copy 
this code into your own programs and have fun with it. And if the numbers from 1 
to 10 aren’t in your flight plans, don’t fret. To roll an imaginary die, write the 
statement
int rollEmBaby = new Random().nextInt(6) + 1;
With the execution of this statement, the variable rollEmBaby gets a value from  
1 to 6. The if statement
At the core of Listing 5-1 is a Java if statement. This if statement represents a 
fork in the road. (See Figure 5-2.) The computer follows one of two prongs — the 
prong that prints You win or the prong that prints You lose. The computer decides 
which prong to take by testing the truth or falsehood of a condition. In Listing 5-1, 
the condition being tested is
inputNumber == randomNumber
Does the value of inputNumber equal the value of randomNumber? When the condi-
tion is true, the computer does the stuff between the condition and the word else. When the condition turns out to be false, the computer does the stuff after the 
FIGURE 5-2: 
An if statement 
is like a fork in 
the road. 112      PART 2  Writing Your Own Java Programs
word else. Either way, the computer goes on to execute the last println call, which 
displays Thank you for playing. The condition in an if statement must be enclosed in parentheses. However, 
a  line like if (inputNumber == randomNumber)  is not a complete statement 
(just as “If I had a hammer” isn’t a complete sentence). So this line if (input 
Number == randomNumber) shouldn’t end with a semicolon. Sometimes, when I’m writing about a condition that’s being tested, I slip into 
using the word expression instead of condition. That’s okay because every condition 
is an expression. An expression is something that has a value and, sure enough, 
every condition has a value. The condition’s value is either true or false. (For 
revealing information about expressions and values like true and false, see 
Chapter 4.)
The double equal sign
In Listing 5-1, in the if statement’s condition, notice the use of the double equal 
sign. Comparing two numbers to see whether they’re the same isn’t the same as 
setting something equal to something else. That’s why the symbol to compare for 
equality isn’t the same as the symbol that’s used in an assignment or an initial -
ization. In an if statement’s condition, you can’t replace the double equal sign 
with a single equal sign. If you do, your program just won’t work. (You almost 
always get an error message when you try to compile your code.)
On the other hand, if you never make the mistake of using a single equal sign in a 
condition, you’re not normal. Not long ago, while I was teaching an introductory 
Java course, I promised that I’d swallow my laser pointer if no one made the single 
equal sign mistake during any of the lab sessions. This wasn’t an idle promise. I knew I’d never have to keep it. As it turned out, even if I had ignored the first ten 
times anybody made the single equal sign mistake during those lab sessions, 
I would still be laser-pointer-free. Everybody mistakenly uses the single equal 
sign several times in a programming career. The trick is not to avoid making the single-equal-sign mistake; the trick is to 
catch the mistake whenever you make it. Brace yourself
The if statement in Listing 5-1 has two halves: a top half and a bottom half. I have 
names for these two parts of an if statement. I call them the if part (the top half) 
and the else part (the bottom half). CHAPTER 5  Controlling Program Flow with Decision-Making Statements      113
The if part in Listing 5-1 seems to have more than one statement in it. I make this 
happen by enclosing the three statements of the if part in a pair of curly braces. When I do this, I form a block. A block is a bunch of statements scrunched together 
by a pair of curly braces. With this block, three calls to println are tucked away safely inside the if part. With the curly braces, the rows of asterisks and the words You win display only 
when the user’s guess is correct. This business with blocks and curly braces applies to the else part as well. In List-
ing 5-1, whenever inputNumber doesn’t equal randomNumber, the computer exe-
cutes three print/println calls. To convince the computer that all three of these 
calls are inside the else clause, I put these calls into a block. That is, I enclose 
these three calls in a pair of curly braces. Strictly speaking, Listing 5-1 has only one statement between the if and the else 
statements and only one statement after the else statement. The trick is that 
when you place a bunch of statements inside curly braces, you get a block; and a 
block behaves, in all respects, like a single statement. In fact, the official Java 
documentation lists blocks as one of the many kinds of statements. So, in List -
ing 5-1, the block that prints You win and asterisks is a single statement that has, 
within it, three smaller statements. Indenting if statements in your code
Notice how, in Listing 5-1, the print and println calls inside the if statement 
are indented. (This includes both the You win  and You lose  statements. The 
print and println calls that come after the word else are still part of the if 
statement.) Strictly speaking, you don’t have to indent the statements that are 
inside an if statement. For all the compiler cares, you can write your whole pro-
gram on a single line or place all your statements in an artful, misshapen zigzag. The problem is that neither you nor anyone else can make sense of your code if 
you don’t indent your statements in some logical fashion. In Listing  5-1, the 
indenting of the print and println statements helps your eye (and brain) see 
quickly that these statements are subordinate to the overall if/else flow. In a small program, unindented or poorly indented code is barely tolerable. But in 
a complicated program, indentation that doesn’t follow a neat, logical pattern is a 
big, ugly nightmare. Many Java IDEs have tools to indent your code automatically. In fact, code inden-
tation is one of my favorite IDE features. So don’t walk — run — to a computer, 
and visit this book’s website ( www.allmycode.com/JavaForDummies) for more 
information on what Java IDEs can offer. 114      PART 2  Writing Your Own Java Programs
When you write if statements, you may be tempted to chuck out the window all 
the rules about curly braces and simply rely on indentation. This works in other 
programming languages, such as Python and Haskell, but it doesn’t work in Java. If you indent three statements after the word else and forget to enclose those 
statements in curly braces, the computer thinks that the else part includes only 
the first of the three statements. What’s worse, the indentation misleads you into 
believing that the else part includes all three statements. This makes it more dif-
ficult for you to figure out why your code isn’t behaving the way you think it 
should. Watch those braces! Elseless in Ifrica
Okay, so the title of this section is contrived. Big deal! The idea is that you can 
create an if statement without the else part. Take, for instance, the code in 
 Listing 5-1, shown earlier. Maybe you’d rather not rub it in whenever the user 
loses the game. The modified code in Listing 5-2 shows you how to do this (and 
Figure 5-3 shows you the result). LISTING 5-2: A Kinder, Gentler Guessing Game
import static java.lang.System.in;
import static java.lang.System.out;
import java.util.Scanner;
import java.util.Random;
public class DontTellThemTheyLost {
    public static void main(String args[]) {
        Scanner keyboard = new Scanner(in);
        out.print("Enter an int from 1 to 10: ");
        int inputNumber = keyboard.nextInt();
        int randomNumber = new Random().nextInt(10) + 1;
        if (inputNumber == randomNumber) {
            out.println("*You win.*");
        }
        out.println("That was a very good guess :-)");
        out.print("The random number was ");
        out.println(randomNumber + ".");
        out.println("Thank you for playing.");
        keyboard.close();
    }
}
CHAPTER 5  Controlling Program Flow with Decision-Making Statements      115
The if statement in Listing 5-2 has no else part. When inputNumber is the same 
as randomNumber, the computer prints You win. When inputNumber is different 
from randomNumber, the computer doesn’t print You win. Listing 5-2 illustrates another new idea.

--- Chunk #670 ---
With an import declaration for System. in, I can reduce new Scanner(System.in) to the shorter new Scanner(in). Add-
ing this import declaration is hardly worth the effort. In fact, I do more typing 
with the import declaration than without it. Nevertheless, the code in Listing 5-2 
demonstrates that it’s possible to import System.in. In Chapter 4, Listing 4-5 tells you whether you can or cannot fit ten people on an 
elevator. A run of the listing’s code looks something like this:
True or False? You can fit all ten of the
Brickenchicker dectuplets
on the elevator:
false
Use what you know about Java’s if statements to make the program’s output 
more natural. Depending on the value of the program’s elevatorWeightLimit 
variable, the output should be either
You can fit all ten of the
Brickenchicker dectuplets
on the elevator. or
You can't fit all ten of the
Brickenchicker dectuplets
on the elevator. FIGURE 5-3: 
Two runs of the 
game in 
Listing 5-2. 116      PART 2  Writing Your Own Java Programs
Using Blocks in JShell
Chapter 4 introduces Java 9’s interactive JShell environment. You type a state-
ment, and JShell responds immediately by executing the statement. That’s fine 
for simple statements, but what happens when you have a statement inside of a 
block? In JShell, you can start typing a statement with one or more blocks. JShell doesn’t 
respond until you finish typing the entire statement — blocks and all. To see how 
it works, look over this conversation that I had recently with JShell:
jshell> import static java.lang.System.out
jshell> import java.util.Random
jshell> int randomNumber = new Random().nextInt(10) + 1
randomNumber ==> 4
jshell> int inputNumber = 4
inputNumber ==> 4
jshell> if (inputNumber == randomNumber) {
   ...>     out.println("*You win.*");
   ...> }
*You win.*
jshell>
In this dialogue, I’ve set the text that I type in bold. JShell’s responses aren’t set 
in bold. When I type if (inputNumber == randomNumber) {  and press Enter, JShell 
doesn’t do much. JShell only displays a ...> prompt, which indicates that what-
ever lines I’ve typed don’t form a complete statement. I have to respond by typing 
the rest of the if statement. When I finish the if statement with a close curly brace, JShell finally acknowl -
edges that I’ve typed an entire statement. JShell executes the statement and (in 
this example) displays *You win.*. Notice the semicolon at the end of the out.println line:
 » When you type a statement that’s not inside of a block, JShell lets you omit the 
semicolon at the end of the statement. CHAPTER 5  Controlling Program Flow with Decision-Making Statements      117
 » When you type a statement that’s inside of a block, JShell (like the plain old 
Java in Listing 5-2) doesn’t let you omit the semicolon. When you type a block in JShell, you always have the option of typing the entire 
block on one line, with no line breaks, like so:
if (inputNumber == randomNumber) { out.println("*You win.*"); }
Forming Conditions with Comparisons  
and Logical Operators
The Java programming language has plenty of little squiggles and doodads for 
your various condition-forming needs. This section tells you all about them. Comparing numbers; comparing characters
Table 5-1 shows you the operators that you can use to compare one value with 
another. You can use all of Java’s comparison operators to compare numbers and charac-
ters. When you compare numbers, things go pretty much the way you think they 
should go. But when you compare characters, things are a little strange. Compar-
ing uppercase letters with one another is no problem. Because the letter B comes 
alphabetically before H, the condition 'B' < 'H'  is true. Comparing lowercase 
TABLE 5-1 Comparison Operators
Operator Symbol Meaning Example
== is equal to numberOfCows == 5
!= is not equal to buttonClicked != panicButton
< is less than numberOfCows < 5
> is greater than myInitial > 'B'
<= is less than or equal to numberOfCows <= 5
>= is greater than or equal to myInitial >= 'B'
118      PART 2  Writing Your Own Java Programs
letters with one another is also okay. What’s strange is that when you compare an 
uppercase letter with a lowercase letter, the uppercase letter is always smaller. So, 
even though 'Z' < 'A' is false, 'Z' < 'a' is true. Under the hood, the letters A through Z are stored with numeric codes 65 through 
90. The letters a through z are stored with codes 97 through 122. That’s why each 
uppercase letter is smaller than each lowercase letter. Be careful when you compare two numbers for equality (with ==) or inequality 
(with !=). After you do some calculations and obtain two double values or two 
float values, the values that you have are seldom dead-on equal to one another. (The problem comes from those pesky digits beyond the decimal point.) For 
instance, the Fahrenheit equivalent of 21 degrees Celsius is 69.8, and when you 
calculate 9.0 / 5 * 21 + 32 by hand, you get 69.8. But the condition 9.0 / 5 * 
21 + 32 == 69.8 turns out to be false. That’s because, when the computer calcu-
lates 9.0 / 5 * 21 + 32, it gets 69.80000000000001, not 69.8. Comparing objects
When you start working with objects, you find that you can use == and != to com-
pare objects with one another.

--- Chunk #671 ---
For instance, a button you see on the computer 
screen is an object. You can ask whether the thing that was just mouse-clicked is 
a particular button on your screen. You do this with Java’s equality operator:
if (e.getSource() == bCopy) {
    clipboard.setText(which.getText());
To find out more about responding to button clicks, read Chapter 16. The big gotcha with Java’s comparison scheme comes when you compare two 
strings. (For a word or two about Java’s String type, see the section about refer-
ence types in Chapter 4.) When you compare two strings with one another, you 
don’t want to use the double equal sign. Using the double equal sign would ask, 
“Is this string stored in exactly the same place in memory as that other string?” 
Usually, that’s not what you want to ask. Instead, you usually want to ask, “Does 
this string have the same characters in it as that other string?” To ask the second 
question (the more appropriate question), Java’s String type has a method named 
equals. (Like everything else in the known universe, this equals method is 
defined in the Java API, short for application programming interface.) The equals 
method compares two strings to see whether they have the same characters in 
them. For an example using Java’s equals method, see Listing 5-3. (Figure 5-4 
shows a run of the program in Listing 5-3.)
CHAPTER 5  Controlling Program Flow with Decision-Making Statements      119
LISTING 5-3: Checking a Password
import static java.lang.System.*;
import java.util.Scanner;
public class CheckPassword {
    public static void main(String args[]) {
        out.print("What's the password?");
        Scanner keyboard = new Scanner(in);
        String password = keyboard.next();
        out.println("You typed >>" + password + "<<");
        out.println();
        if (password == "swordfish") {
            out.println("The word you typed is stored");
            out.println("in the same place as the real");
            out.println("password. You must be a");
            out.println("hacker.");
        } else {
            out.println("The word you typed is not");
            out.println("stored in the same place as");
            out.println("the real password, but that's");
            out.println("no big deal.");
        }
        out.println();
        if (password.equals("swordfish")) {
            out.println("The word you typed has the");
            out.println("same characters as the real");
FIGURE 5-4: 
The results of 
using == and 
using Java’s 
equals method. (continued)
120      PART 2  Writing Your Own Java Programs
            out.println("password. You can use our");
            out.println("precious system.");
        } else {
            out.println("The word you typed doesn't");
            out.println("have the same characters as");
            out.println("the real password. You can't");
            out.println("use our precious system.");
        }
        keyboard.close();
    }
}
In Listing 5-3, the call keyboard.next() grabs whatever word the user types on 
the computer keyboard. The code shoves this word into the variable named 
password. Then the program’s if statements use two different techniques to 
 compare password with "swordfish". The more appropriate of the two techniques uses Java’s equals method. The 
equals method looks funny because when you call it, you put a dot after one string 
and put the other string in parentheses. But that’s the way you have to do it. In calling Java’s equals method, it doesn’t matter which string gets the dot and 
which gets the parentheses. For instance, in Listing 5-3, you could have written
if ("swordfish".equals(password))
The method would work just as well. A call to Java’s equals method looks imbalanced, but it’s not. There’s a reason 
behind the apparent imbalance between the dot and the parentheses. The idea is 
that you have two objects: the password object and the "swordfish" object. Each 
of these two objects is of type String. (However, password is a variable of type 
String, and "swordfish" is a String literal.) When you write password. equals("swordfish"), you’re calling an equals method that belongs to the  
password object. When you call that method, you’re feeding "swordfish" to the 
method as the method’s parameter (pun intended). You can read more about methods belonging to objects in Chapter 7. LISTING 5-3: (continued)
CHAPTER 5  Controlling Program Flow with Decision-Making Statements      121
When comparing strings with one another, use the equals method  — not the 
double equal sign. Importing everything in one fell swoop
The first line of Listing 5-3 illustrates a lazy way of importing both System.out 
and System.in. To import everything that System has to offer, you use the aster-
isk wildcard character (*). In fact, importing java.lang.System.* is like having 
about 30 separate import declarations, including System.in, System.out,  
System.err, System.nanoTime, and many other System things. The use of an asterisk in an import declaration is generally considered bad pro-
gramming practice, so I don’t do it often in this book’s examples. But for larger 
programs — programs that use dozens of names from the Java API — the lazy 
asterisk trick is handy. You can’t toss an asterisk anywhere you want inside an import declaration. For 
example, you can’t import everything starting with java by writing import 
java.*. You can substitute an asterisk only for the name of a class or for the name 
of something static that’s tucked away inside a class. For more information about 
asterisks in import declarations, see Chapter  9. For information about static 
things, see Chapter 10. Java’s logical operators
Mr. Spock would be pleased: Java has all the operators that you need for mixing 
and matching logical tests. The operators are shown in Table 5-2. You can use these operators to form all kinds of elaborate conditions. Listing 5-4 
has an example.

--- Chunk #672 ---
TABLE 5-2 Logical Operators
Operator Symbol What It Means Example
&& and 5 < x && x < 10
|| or x < 5 || 10 < x
! not !password.equals("swordfish")
122      PART 2  Writing Your Own Java Programs
LISTING 5-4: Checking Username and Password
import javax.swing.JOptionPane;
public class Authenticator {
    public static void main(String args[]) {
        String username = JOptionPane.showInputDialog("Username:");
        String password = JOptionPane.showInputDialog("Password:");
        if (
              username != null && password != null &&
              (
                (username.equals("bburd") && password.equals("swordfish")) ||
                (username.equals("hritter") && password.equals("preakston"))
              )
           )
        {
            JOptionPane.showMessageDialog(null, "You're in.");
        } else {
            JOptionPane.showMessageDialog(null, "You're suspicious.");
        }
    }
}
Several runs of the program of Listing 5-4 are shown in Figure 5-5. When the 
username is bburd and the password is swordfish or when the username is hritter  
and the password is preakston, the user gets a nice message. Otherwise, the user is 
a bum who gets the nasty message that he or she deserves. Confession: Figure 5-5 is a fake! To help you read the usernames and passwords, I 
added an extra statement to Listing  5-4. The extra statement ( UIManager. put("TextField.font", new Font("Dialog", Font.BOLD, 14))) enlarges each 
text field’s font size. Yes, I modified the code before creating the figure.

--- Chunk #673 ---
Shame 
on me! Listing 5-4 illustrates a new way to get user input; namely, to show the user an 
input dialog box. The statement
String password = JOptionPane.showInputDialog("Password:");
in Listing 5-4 performs more or less the same task as the statement
String password = keyboard.next();
CHAPTER 5  Controlling Program Flow with Decision-Making Statements      123
from Listing  5-3. The big difference is, while keyboard.next() displays dull-
looking text in a console, JOptionPane.showInputDialog("Username:") displays 
a fancy dialog box containing a text field and buttons. (Compare Figures  5-4 
and 5-5.) When the user clicks OK, the computer takes whatever text is in the text 
field and hands that text over to a variable. In fact, Listing 5-4 uses JOptionPane. showInputDialog twice — once to get a value for the username variable and a 
second time to get a value for the password variable. Near the end of Listing  5-4, I use a slight variation on the JOptionPane 
business,
JOptionPane.showMessageDialog(null, "You're in.");
With showMessageDialog, I show a very simple dialog box — a box with no text 
field. (Again, see Figure 5-5.)
Like thousands of other names, the name JOptionPane is defined in Java’s API. (To be more specific, JOptionPane is defined inside something called javax. swing, which in turn is defined inside Java’s API.) So, to use the name JOption 
Pane throughout Listing 5-4, I import javax.swing.JOptionPane at the top of 
the listing. FIGURE 5-5: 
Several runs of 
the code from 
Listing 5-4. 124      PART 2  Writing Your Own Java Programs
In Listing 5-4, JOptionPane.showInputDialog works nicely because the user’s 
input (username and password) are mere strings of characters. If you want the 
user to input a number (an int or a double, for example), you have to do some 
extra work. For example, to get an int value from the user, type something like 
int numberOfCows = Integer.parseInt(JOptionPane.showInputDialog("How 
many cows?")). The extra Integer.parseInt stuff forces your text field’s input 
to be an int value. To get a double value from the user, type something like 
double fractionOfHolsteins = Double.parseDouble(JOptionPane.showInpu
tDialog("Holsteins:")). The extra Double.parseDouble business forces your 
text field’s input to be a double value. Vive les nuls! The French translations of For Dummies  books are books Pour les Nuls. So a 
“dummy” in English is a “nul” in French. * But in Java, the word null means 
“nothing.” When you see
if (
      username != null
in Listing 5-4, you can imagine that you see
if (
      username isn't nothing
or
if (
      username has any value at all
To find out how username can have no value, see the last row in Figure  5-5. When you click Cancel in the first dialog box, the computer hands null to your 
program. So, in Listing 5-4, the variable username becomes null. The compari-
sons username != null checks to make sure that you haven’t clicked Cancel in 
the program’s first dialog box. The comparison password != null performs the 
same kind of check for the program’s second dialog box. When you see the if 
statement in Listing 5-4, you can imagine that you see the following:
*In Russian, a “dummy” is a “чaйник” which, when interpreted literally, means a 
“teapot.” So in Russian, this book is “Java For Teapots.” I’ve never been called a 
“teapot,” and I’m not sure how I’d react if I were. CHAPTER 5  Controlling Program Flow with Decision-Making Statements      125
if (
      you didn't press Cancel in the username dialog and
      you didn't press Cancel in the password dialog and
      (
        (you typed bburd in the username dialog and
         you typed swordfish in the password dialog) or
        (you typed hritter in the username dialog and
         you typed preakston in the password dialog)
      )
   )
In Listing 5-4, the comparisons username != null and password != null are not 
optional. If you forget to include these and click Cancel when the program runs, 
you get a nasty NullPointerException message, and the program comes crash-
ing down before your eyes. The word null represents nothing, and in Java, you 
can’t compare nothing to a string like "bburd" or "swordfish". In Listing 5-4, 
the purpose of the comparison username != null is to prevent Java from moving 
on to check username.equals("bburd") whenever you happen to click Cancel. Without this preliminary username != null test, you’re courting trouble. The last couple of nulls in Listing 5-4 are different from the others. In the code 
JOptionPane.showMessageDialog (null, "You're in."), the word null stands 
for “no other dialog box.” In particular, the call showMessageDialog tells Java to 
pop up a new dialog box, and the word null indicates that the new dialog box 
doesn’t grow out of any existing dialog box. One way or another, Java insists that 
you say something about the origin of the newly popped dialog box. (For some 
reason, Java doesn’t insist that you specify the origin of the showInputDialog 
box. Go figure!) Anyway, in Listing 5-4, having a showMessageDialog box pop up 
from nowhere is quite useful. (Conditions in parentheses)
Keep an eye on those parentheses! When you’re combining conditions with logical 
operators, it’s better to waste typing effort and add unneeded parentheses than to 
goof up your result by using too few parentheses. Take, for example, the 
expression
2 < 5 || 100 < 6 && 27 < 1
By misreading this expression, you might conclude that the expression is false. That is, you could wrongly read the expression as meaning (something-or- 
other) && 27 < 1 . Because 27 < 1 is false, you would conclude that the whole 
expression is false. The fact is that, in Java, any && operator is evaluated before 
126      PART 2  Writing Your Own Java Programs
any || operator. So the expression really asks whether 2 < 5 || (something-or- 
other). Because 2 < 5 is true, the whole expression is true. To change the expression’s value from true to false, you can put the expres-
sion’s first two comparisons in parentheses, like this:
(2 < 5 || 100 < 6) && 27 < 1
Java’s || operator is inclusive. This means that you get a true value whenever the 
thing on the left side is true, the thing on the right side is true, or both things are 
true. For instance, the expression 2 < 10 || 20 < 30 is true. In Java, you can’t combine comparisons the way you do in ordinary English. In 
English, you may say, “We’ll have between three and ten people at the dinner 
table.” But in Java, you get an error message if you write 3 <= people <= 10. To 
do this comparison, you need something like 3 <= people && people <= 10. In Listing 5-4, the if statement’s condition has more than a dozen parentheses. What happens if you omit two of them? if (
      username != null && password != null &&
      // open parenthesis omitted
          (username.equals("bburd") && password.equals("swordfish")) ||
          (username.equals("hritter") && password.equals("preakston"))
      // close parenthesis omitted
   )
Java tries to interpret your wishes by grouping everything before the “or” (the || 
operator):
if (
      username != null && password != null &&
      (username.equals("bburd") && password.equals("swordfish"))
      ||
      (username.equals("hritter") && password.equals("preakston"))
   )
When the user clicks Cancel and username is null, Java says, “Okay! The stuff  
before the || operator is false, but maybe the stuff after the || operator is true. I’ll 
check the stuff after the || operator to find out whether it’s true.” (Java often 
talks to itself. The psychiatrists are monitoring this situation.)
CHAPTER 5  Controlling Program Flow with Decision-Making Statements      127
Anyway, when Java finally checks username.equals("hritter"), your program 
aborts with an ugly NullPointerException message. You’ve made Java angry by 
trying to apply .equals to a null username. (Psychiatrists have recommended 
anger management sessions for Java, but Java’s insurance plan refuses to pay for 
the sessions.)
Make some changes to the code in Listing 5-4:
 » Add a third username/password combination to the list of acceptable logins. » Modify the if statement’s condition so that an all-uppercase entry for either 
username is acceptable. In other words, the input BBURD yields the same 
result as bburd and the input HRITTER yields the same result as hritter. » In Listing 5-4, change
username != null && password != null
to
!(username == null || password == null)
Does the program still work? Why, or why not? » In Listing 5-4, change
username != null && password != null
to
!(username == null && password == null)
This is almost the same as the previous experiment. The only difference is the 
use of && instead of || between the two == null tests. Does the program still work?

--- Chunk #674 ---
Why, or why not? Building a Nest
Have you seen those cute Russian matryoshka nesting dolls? Open one, and 
another one is inside.

--- Chunk #675 ---
Open the second, and a third one is inside it. You can do 
the same thing with Java’s if statements. (Talk about fun!) Listing 5-5 shows 
you how. 128      PART 2  Writing Your Own Java Programs
LISTING 5-5: Nested if Statements
import static java.lang.System.out;
import java.util.Scanner;
public class Authenticator2 {
    public static void main(String args[]) {
        Scanner keyboard = new Scanner(System.in);
        out.print("Username: ");
        String username = keyboard.next();
        if (username.equals("bburd")) {
            out.print("Password: ");
            String password = keyboard.next();
            if (password.equals("swordfish")) {
                out.println("You're in.");
            } else {
                out.println("Incorrect password");
            }
        } else {
            out.println("Unknown user");
        }
        keyboard.close();
    }
}
Figure 5-6 shows several runs of the code in Listing 5-5. The main idea is that to 
log on, you have to pass two tests. (In other words, two conditions must be true.) 
The first condition tests for a valid username; the second condition tests for the 
correct password. If you pass the first test (the username test), you march right 
into another if statement that performs a second test (the password test). If you 
fail the first test, you never make it to the second test. Figure  5-7 shows the 
 overall plan. The code in Listing 5-5 does a good job with nested if statements, but it does a 
terrible job with real-world user authentication. First, never show a password in 
plain view (without asterisks to masquerade the password). Second, don’t handle 
passwords without encrypting them. Third, don’t tell the malicious user which of 
the two words (the username or the password) was entered incorrectly. Fourth .

--- Chunk #676 ---
.

--- Chunk #677 ---
.

--- Chunk #678 ---
well, I could go on and on. The code in Listing 5-5 just isn’t meant to 
illustrate good username/password practices. CHAPTER 5  Controlling Program Flow with Decision-Making Statements      129
Modify the program in Listing 5-4 so that, if the user clicks Cancel for either the 
username or the password, the program replies with a Not enough information 
message. FIGURE 5-6: 
Three runs of 
the code in 
Listing 5-5. FIGURE 5-7: 
Don’t try eating 
with this fork. 130      PART 2  Writing Your Own Java Programs
Choosing among Many Alternatives  
(Java switch Statements)
I’m the first to admit that I hate making decisions. If things go wrong, I would 
rather have the problem be someone else’s fault. Writing the previous sections (on 
making decisions with Java’s if statement) knocked the stuffing right out of me. That’s why my mind boggles as I begin this section on choosing among many 
alternatives. What a relief it is to have that confession out of the way! Your basic switch statement
Now, it’s time to explore situations in which you have a decision with many 
branches. Take, for instance, the popular campfire song “Al’s All Wet.” (For a 
review of the lyrics, see the “Al’s All Wet” sidebar.) You’re eager to write code that 
prints this song’s lyrics. Fortunately, you don’t have to type all the words over and 
over again. Instead, you can take advantage of the repetition in the lyrics. “AL’S ALL WET”
Sung to the tune of “Gentille Alouette”:
Al’s all wet. Oh, why is Al all wet? Oh,
Al’s all wet ’cause he’s standing in the rain. Why is Al out in the rain? That’s because he has no brain. Has no brain, has no brain,
In the rain, in the rain. Ohhhhhhhh ... Al’s all wet. Oh, why is Al all wet? Oh,
CHAPTER 5  Controlling Program Flow with Decision-Making Statements      131
Al’s all wet ’cause he’s standing in the rain. Why is Al out in the rain? That’s because he is a pain. He’s a pain, he’s a pain,
Has no brain, has no brain,
In the rain, in the rain. Ohhhhhhhh ... Al’s all wet. Oh, why is Al all wet? Oh,
Al’s all wet ’cause he’s standing in the rain. Why is Al out in the rain? ’Cause this is the last refrain. Last refrain, last refrain,
He’s a pain, he’s a pain,
Has no brain, has no brain,
In the rain, in the rain. Ohhhhhhhh ... Al’s all wet. Oh, why is Al all wet? Oh,
Al’s all wet ’cause he’s standing in the rain. —Harriet Ritter and Barry Burd
132      PART 2  Writing Your Own Java Programs
A complete program to display the “Al’s All Wet” lyrics won’t come until 
 Chapter 6. In the meantime, assume that you have a variable named verse. The 
value of verse is 1, 2, 3, or 4, depending on which verse of “Al’s All Wet” you’re 
trying to print. You could have a big, clumsy bunch of if statements that checks 
each possible verse number:
if (verse == 1) {
    out.println("That's because he has no brain.");
}
if (verse == 2) {
    out.println("That's because he is a pain.");
}
if (verse == 3) {
    out.println("'Cause this is the last refrain.");
}
But that approach seems wasteful. Why not create a statement that checks the 
value of verse just once and then takes an action based on the value it finds? For-
tunately, just such a statement exists. It’s called a switch statement. Listing 5-6 
has an example of a switch statement. LISTING 5-6: A switch Statement
import static java.lang.System.out;
import java.util.Scanner;
public class JustSwitchIt {
    public static void main(String args[]) {
       Scanner keyboard = new Scanner(System.in);
       out.print("Which verse? ");
       int verse = keyboard.nextInt();
       switch (verse) {
       case 1:
          out.println("That's because he has no brain.");
          break;
       case 2:
          out.println("That's because he is a pain.");
          break;
       case 3:
          out.println("'Cause this is the last refrain.");
          break;
CHAPTER 5  Controlling Program Flow with Decision-Making Statements      133
       default:
          out.println("No such verse. Please try again.");
          break;
       }
       out.println("Ohhhhhhhh ... .");
       keyboard.close();
    }
}
Figure 5-8 shows two runs of the program in Listing 5-6. (Figure 5-9 illustrates 
the program’s overall idea.) First, the user types a number, like the number 2. Then execution of the program reaches the top of the switch statement. The com-
puter checks the value of the verse variable. When the computer determines that 
the verse variable’s value is 2, the computer checks each case of the switch state-
ment. The value 2 doesn’t match the topmost case, so the computer proceeds to 
the middle of the three cases. The value posted for the middle case (the number 2) 
matches the value of the verse variable, so the computer executes the statements 
that come immediately after case 2. These two statements are
out.println("That's because he is a pain.");
break;
The first of the two statements displays the line That’s because he is a pain. on the screen. The second statement is called a break statement. (What a sur -
prise!) When the computer encounters a break statement, the computer jumps 
out of whatever switch statement it’s in. So, in Listing 5-6, the computer skips 
right past the case that would display ’Cause this is the last refrain. In fact, 
the computer jumps out of the entire switch statement and goes straight to the 
statement just after the end of the switch statement. The computer displays 
Ohhhhhhhh ... because that’s what the statement after the switch statement 
tells the computer to do. FIGURE 5-8: 
Running the 
code of 
Listing 5-6 
two times. 134      PART 2  Writing Your Own Java Programs
FIGURE 5-9: 
The big fork in 
the code of 
Listing 5-6. If the pesky user asks for verse 6, the computer bypasses cases 1, 2, and 3. The 
computer goes straight to the default. In the default, the computer displays 
No such verse. Please try again , and then breaks out of the switch state-
ment. After the computer is out of the switch statement, the computer displays 
Ohhhhhhhh ... You don’t really need to put a break at the very end of a switch statement. In 
 Listing 5-6, the last break (the break that’s part of the default) is just for the sake 
of overall tidiness. To break or not to break
In every Java programmer’s life, a time comes when he or she forgets to use break 
statements. At first, the resulting output is confusing, but then the programmer 
remembers fall-through. The term fall-through describes what happens when you 
end a case without a break statement. What happens is that execution of the code 
falls right through to the next case in line. Execution keeps falling through until 
you eventually reach a break statement or the end of the entire switch 
statement. Usually, when you’re using a switch statement, you don’t want fall-through, so 
you pepper break statements throughout the switch statements. But, occasion -
ally, fall-through is just the thing you need. Take, for instance, the “Al’s All Wet” 
song. (The classy lyrics are shown in the sidebar bearing the song’s name.) Each 
CHAPTER 5  Controlling Program Flow with Decision-Making Statements      135
verse of “Al’s All Wet” adds new lines in addition to the lines from previous verses. This situation (accumulating lines from one verse to another) cries out for a 
switch statement with fall-through. Listing 5-7 demonstrates the idea. LISTING 5-7: A switch Statement with Fall-Through
import static java.lang.System.out;
import java.util.Scanner;
public class FallingForYou {
    public static void main(String args[]) {
        Scanner keyboard = new Scanner(System.in);
        out.print("Which verse? ");
        int verse = keyboard.nextInt();
        switch (verse) {
        case 3:
            out.print("Last refrain, ");
            out.println("last refrain,");
        case 2:
            out.print("He's a pain, ");
            out.println("he's a pain,");
        case 1:
            out.print("Has no brain, ");
            out.println("has no brain,");
        }
        out.println("In the rain, in the rain.");
        out.println("Ohhhhhhhh...");
        out.println();
        keyboard.close();
    }
}
Figure 5-10 shows several runs of the program in Listing 5-7. Because the switch 
has no break statements in it, fall-through happens all over the place. For 
instance, when the user selects verse 2, the computer executes the two statements 
in case 2:
out.print("He's a pain, ");
out.println("he's a pain,");
136      PART 2  Writing Your Own Java Programs
Then the computer marches right on to execute the two statements in case 1:
out.print("Has no brain, ");
out.println("has no brain,");
That’s good because the song’s second verse has all these lines in it. Notice what happens when the user asks for verse 6. The switch statement in 
Listing 5-7 has no case 6 and no default, so none of the actions inside the switch 
statement is executed. Even so, with statements that print In the rain, in the 
rain and Ohhhhhhhh ... right after the switch statement, the computer displays 
something when the user asks for verse 6. Strings in a switch statement
In Listings 5-6 and 5-7, shown earlier, the variable verse (an int value) steers 
the switch statement to one case or another. An int value inside a switch state-
ment works in any version of Java, old or new. (For that matter, char values and a 
few other kinds of values have worked in Java’s switch statements ever since Java 
was a brand-new language.)
FIGURE 5-10: 
Running 
the code of 
Listing 5-7 
four times. CHAPTER 5  Controlling Program Flow with Decision-Making Statements      137
Starting with Java 7, you can set it up so that the case to be executed in a switch 
statement depends on the value of a particular string. Listing 5-8 illustrates the 
use of strings in switch statements. Figure  5-11 shows a run of the code in 
Listing 5-8. LISTING 5-8: A switch Statement with a String
import static java.lang.System.out;
import java.util.Scanner;
public class SwitchIt7 {
    public static void main(String args[]) {
       Scanner keyboard = new Scanner(System.in);
       out.print("Which verse (one, two or three)? ");
       String verse = keyboard.next();
       switch (verse) {
       case "one":
          out.println("That's because he has no brain.");
          break;
       case "two":
          out.println("That's because he is a pain.");
          break;
       case "three":
          out.println("'Cause this is the last refrain.");
          break;
       default:
          out.println("No such verse. Please try again.");
          break;
       }
       out.println("Ohhhhhhhh... .");
       keyboard.close();
    }
}
FIGURE 5-11: 
Running the code 
of Listing 5-8. 138      PART 2  Writing Your Own Java Programs
Get some practice with if statements and switch statements! » Write a program that inputs the name of a month and outputs the number of 
days in that month. In this first version of the program, assume that February 
always has 28 days. » Make your code even better! Have the user input a month name, but also 
have the user input yes or no in response to the question Is it a leap 
year? CHAPTER 6  Controlling Program Flow with Loops      139
IN THIS CHAPTER
 » Using basic looping
 » Counting as you loop
 » Repeating relentlessly (until the user 
gives you a clear answer)
Controlling Program 
Flow with Loops
I
n 1966, the company that brings you Head & Shoulders shampoo made history. On the back of the bottle, the directions for using the shampoo read, “LATHER- 
RINSE-REPEAT.” Never before had a complete set of directions (for doing any-
thing, let alone shampooing your hair) been summarized so succinctly. People in 
the direction-writing business hailed this as a monumental achievement. Directions like these stood in stark contrast to others of the time. (For instance, 
the first sentence on a can of bug spray read, “Turn this can so that it points away 
from your face.” Duh!)
Aside from their brevity, the thing that made the Head & Shoulders directions so 
cool was that, with three simple words, it managed to capture a notion that’s at 
the heart of all instruction-giving  — the notion of repetition. That last word, 
REPEAT, took an otherwise bland instructional drone and turned it into a sophis -
ticated recipe for action. The fundamental idea is that when you’re following directions, you don’t just fol-
low one instruction after another.

--- Chunk #679 ---
Instead, you take turns in the road. You make 
decisions (“If HAIR IS DRY, then USE CONDITIONER”) and you go into loops 
(“LATHER-RINSE, and then LATHER-RINSE again.”). In computer program-
ming, you use decision-making and looping all the time. This chapter explores 
looping in Java. Chapter 6
140      PART 2  Writing Your Own Java Programs
Repeating Instructions Over and Over 
Again (Java while Statements)
Here’s a guessing game for you. The computer generates a random number from 
1 to 10. The computer asks you to guess the number. If you guess incorrectly, the 
game continues. As soon as you guess correctly, the game is over. Listing  6-1 
shows the program to play the game, and Figure 6-1 shows a round of play. LISTING 6-1: A Repeating Guessing Game
import static java.lang.System.out;
import java.util.Scanner;
import java.util.Random;
public class GuessAgain {
    public static void main(String args[]) {
        Scanner keyboard = new Scanner(System.in);
        int numGuesses = 0;
        int randomNumber = new Random().nextInt(10) + 1;
        out.println("       ************         ");
        out.println("Welcome to the Guessing Game");
        out.println("       ************         ");
        out.println();
        out.print("Enter an int from 1 to 10: ");
        int inputNumber = keyboard.nextInt();
        numGuesses++;
        while (inputNumber != randomNumber) {
            out.println();
            out.println("Try again...");
            out.print("Enter an int from 1 to 10: ");
            inputNumber = keyboard.nextInt();
            numGuesses++;
        }
CHAPTER 6  Controlling Program Flow with Loops      141
        out.print("You win after ");
        out.println(numGuesses + " guesses.");
        keyboard.close();
    }
}
In Figure  6-1, the user makes four guesses. Each time around, the computer 
checks to see whether the guess is correct. An incorrect guess generates a request 
to try again. For a correct guess, the user gets a rousing You win, along with a tally 
of the number of guesses he or she made. The computer repeats several state-
ments, checking each time through to see whether the user’s guess is the same as 
a certain randomly generated number. Each time the user makes a guess, the 
computer adds 1 to its tally of guesses. When the user makes the correct guess, the 
computer displays that tally. Figure 6-2 illustrates the flow of action. When you look over Listing 6-1, you see the code that does all this work. At the 
core of the code is a thing called a while statement (also known as a while loop). Rephrased in English, the while statement says:
while the inputNumber is not equal to the randomNumber
keep doing all the stuff in curly braces: {
}
The stuff in curly braces (the stuff that repeats) is the code that prints Try again 
and Enter an int ..., gets a value from the keyboard, and adds 1 to the count of 
the user’s guesses. FIGURE 6-1: 
Play until  
you drop. 142      PART 2  Writing Your Own Java Programs
When you’re dealing with counters, like numGuesses in Listing 6-1, you may  easily 
become confused and be off by 1 in either direction. You can avoid this headache 
by making sure that the ++ statements stay close to the statements whose events 
you’re counting. For example, in Listing 6-1, the variable numGuesses starts with 
a value of 0. That’s because, when the program starts running, the user hasn’t 
made any guesses. Later in the program, right after each call to keyboard. nextInt, is a numGuesses++ statement. That’s how you do it — you increment the 
counter as soon as the user enters another guess. The statements in curly braces are repeated as long as inputNumber != random 
Number is true. Each repetition of the statements in the loop is called an iteration 
of the loop. In Figure 6-1, the loop undergoes three iterations. (If you don’t believe 
that Figure 6-1 has exactly three iterations, count the number of Try again print-
ings in the program’s output. A Try again appears for each incorrect guess.)
When, at long last, the user enters the correct guess, the computer goes back to 
the top of the while statement, checks the condition in parentheses, and finds 
itself in double double-negative land. The not equal (!=) relationship between 
inputNumber and randomNumber no longer holds. In other words, the while 
 statement’s condition, inputNumber != randomNumber , is false. Because the 
while statement’s condition is false, the computer jumps past the while loop and 
goes on to the statements just below the while loop. In these two statements, the 
computer prints You win after four guesses. FIGURE 6-2: 
Around and 
around you go. CHAPTER 6  Controlling Program Flow with Loops      143
With code of the kind shown in Listing 6-1, the computer never jumps out in mid-
loop. When the computer finds that inputNumber isn’t equal to randomNumber, the 
computer marches on and executes all five statements inside the loop’s curly braces. The computer performs the test again (to see whether inputNumber is still not 
equal to randomNumber) only after it fully executes all five statements in the loop. I have two things for you to try:
 » Modify the program in Listing 6-1 so that the randomly generated number is a 
number from 1 and 100. To make life bearable for the game player, have the 
program give a hint whenever the player guesses incorrectly. Hints such as 
Try a higher number or Try a lower number are very helpful. » Write a program in which the user types int values, one after another. The 
program stops looping when the user types a number that isn’t positive (for 
example, the number 0 or the number –17). After all the looping, the program 
displays the largest number that the user typed. For example, if the user types 
the numbers
7
25
3
9
0
the program displays the number 25. Repeating a Certain Number of Times 
(Java for Statements)
“Write I will not talk in class on the blackboard 100 times.”
What your teacher really meant was this:
Set the count to 0. As long as the count is less than 100,
    Write 'I will not talk in class' on the blackboard,
    Add 1 to the count. Fortunately, you didn’t know about loops and counters at the time. If you pointed 
out all this stuff to your teacher, you’d have gotten into a lot more trouble than 
you were already in. 144      PART 2  Writing Your Own Java Programs
One way or another, life is filled with examples of counting loops. And computer 
programming mirrors life — or is it the other way around? When you tell a com-
puter what to do, you’re often telling the computer to print three lines, process 
ten accounts, dial a million phone numbers, or whatever. Because counting loops 
is so common in programming, the people who create programming languages 
have developed statements just for loops of this kind. In Java, the statement that 
repeats something a certain number of times is called a for statement. Listings 6-2 
and 6-3 illustrate the use of the for statement. Listing 6-2 has a rock-bottom 
simple example, and Listing 6-3 has a more exotic example. Take your pick. LISTING 6-2: The World’s Most Boring for Loop
import static java.lang.System.out;
public class Yawn {
    public static void main(String args[]) {
        for (int count = 1; count <= 10; count++) {
            out.print("The value of count is ");
            out.print(count);
            out.println(".");
        }
        out.println("Done!");
    }
}
Figure 6-3 shows you what you get when you run the program of Listing 6-2. (You 
get exactly what you deserve.) The for statement in Listing 6-2 starts by setting 
the count variable to 1. Then the statement tests to make sure that count is less 
than or equal to 10 (which it certainly is). Then the for statement dives ahead and 
executes the printing statements between the curly braces. (At this early stage of 
the game, the computer prints The value of count is 1.) Finally, the for state-
ment does that last thing inside its parentheses — it adds 1 to the value of count. With count now equal to 2, the for statement checks again to make sure that 
count is less than or equal to 10. (Yes, 2 is smaller than 10.) Because the test turns 
out okay, the for statement marches back into the curly braced statements and 
prints The value of count is 2 on the screen. Finally, the for statement does 
that last thing inside its parentheses — it adds 1 to the value of count, increasing 
the value of count to 3. CHAPTER 6  Controlling Program Flow with Loops      145
And so on. This whole thing repeats until, after ten iterations, the value of count 
finally reaches 11. When this happens, the check for count being less than or equal 
to ten fails, and the loop’s execution ends. The computer jumps to whatever state-
ment comes immediately after the for statement. In Listing 6-2, the computer 
prints Done! as its output. Figure 6-4 illustrates the whole process. The anatomy of a for statement
After the word for, you always put three things in parentheses. The first of these 
three is called an initialization, the second is an expression, and the third is an 
update:
for ( initialization ; expression ; update )
FIGURE 6-3: 
Counting to ten. FIGURE 6-4: 
The action of the 
for loop in 
Listing 6-2. 146      PART 2  Writing Your Own Java Programs
Each of the three items in parentheses plays its own distinct role:
 » The initialization is executed once, when the run of your program first 
reaches the for statement. » The expression is evaluated several times (before each iteration). » The update is also evaluated several times (at the end of each iteration). If it helps, think of the loop as though its text is shifted all around:
int count = 1
for count <= 10 {
    out.print("The value of count is ");
    out.print(count);
    out.println(".");
    count++;
}
You can’t write a real for statement this way. Even so, this is the order in which 
the parts of the statement are executed. If you declare a variable in the initialization of a for loop, you can’t use that vari-
able outside the loop. For instance, in Listing 6-2, you get an error message if you 
try putting out.println(count) after the end of the loop. Anything that can be done with a for loop can also be done with a while loop. Choosing to use a for loop is a matter of style and convenience, not necessity. Would you like some practice? Try these experiments and challenges:
 » A for statement’s initialization may have several parts. A for statement’s 
update may also have several parts. To find out how, enter the following lines 
in Java’s JShell, or add the lines to a small Java program:
import static java.lang.System.out
for (int i = 0, j = 10; i < j; i++, j--) {out.println(i + " " + j);}
 » What’s the output of the following code? int total = 0;
for (int i = 0; i < 10; i++) {
  total += i;
}
System.out.println(total);
CHAPTER 6  Controlling Program Flow with Loops      147
In this code, the variable total is called an accumulator because it accumu-
lates (adds up) a bunch of values inside the loop. » In mathematics, the exclamation point (!) means factorial — the number you get 
when you multiply all the positive int values up to and including a certain number. For example, 3! is 1 × 2 × 3, which is 6. And 5! is 1 × 2 × 3 × 4 × 5, which is 120. Write a program in which the user types a positive int value (call it n), and 
Java displays the value of n! as its output. » Without running the following code, try to predict what the code’s output will be:
for (int row = 0; row < 5; row++) {
  for (int column = 0; column < 5; column++) {
    System.out.print("*");
  }
  System.out.println();
}
After making your prediction, run the code to find out whether your predic-
tion is correct. » The code in this experiment is a slight variation on the code in the previous 
experiment. First, try to predict what the code will output. Then run the code 
to find out whether your prediction is correct:
for (int row = 0; row < 5; row++) {
  for (int column = 0; column <= row; column++) {
    System.out.print("*");
  }
  System.out.println();
}
 » Write a program that uses loops to display three copies of the following 
pattern, one after another:
*
**
***
****
*****
The world premiere of “Al’s All Wet”
Listing 6-2 is very nice, but the program in that listing doesn’t do anything inter-
esting. For a more eye-catching example, see Listing 6-3. In Listing 6-3, I make 
148      PART 2  Writing Your Own Java Programs
good on a promise I make in Chapter 5. The program in Listing 6-3 prints all the 
lyrics of the hit single “Al’s All Wet.” (You can find the lyrics in Chapter 5.)
LISTING 6-3: The Unabridged “Al’s All Wet” Song
import static java.lang.System.out;
public class AlsAllWet {
   public static void main(String args[]) {
      for (int verse = 1; verse <= 3; verse++) {
        out.print("Al's all wet. ");
        out.println("Oh, why is Al all wet? Oh,");
        out.print("Al's all wet 'cause ");
        out.println("he's standing in the rain.");
        out.println("Why is Al out in the rain?");
        switch (verse) {
        case 1:
          out.println("That's because he has no brain.");
          break;
        case 2:
          out.println("That's because he is a pain.");
          break;
        case 3:
          out.println("'Cause this is the last refrain.");
          break;
        }
        switch (verse) {
        case 3:
          out.println("Last refrain, last refrain,");
        case 2:
          out.println("He's a pain, he's a pain,");
        case 1:
          out.println("Has no brain, has no brain,");
        }
        out.println("In the rain, in the rain.");
        out.println("Ohhhhhhhh...");
        out.println();
      }
CHAPTER 6  Controlling Program Flow with Loops      149
      out.print("Al's all wet. ");
      out.println("Oh, why is Al all wet? Oh,");
      out.print("Al's all wet 'cause ");
      out.println("he's standing in the rain.");
   }
}
Listing 6-3 is nice because it combines many of the ideas from Chapters 5 and 6. In Listing 6-3, two switch statements are nested inside a for loop. One of the 
switch statements uses break statements; the other switch statement uses fall-
through. As the value of the for loop’s counter variable ( verse) goes from 1 to 2 
and then to 3, all the cases in the switch statements are executed. When the pro-
gram is near the end of its run and execution has dropped out of the for loop, the 
program’s last four statements print the song’s final verse. When I boldly declare that a for statement is for counting, I’m stretching the 
truth just a bit. Java’s for statement is very versatile. You can use a for statement 
in situations that have nothing to do with counting. For instance, a statement 
with no update part, such as for (i = 0; i < 10; ) , just keeps on going. The 
looping ends when some action inside the loop assigns a big number to the vari-
able i. You can even create a for statement with nothing inside the parentheses. The loop for ( ; ; )  runs forever, which is good if the loop controls a serious 
piece of machinery. Usually, when you write a for statement, you’re counting how 
many times to repeat something. But, in truth, you can do just about any kind of 
repetition with a for statement. Look!

--- Chunk #680 ---
I have some experiments for you to try! » Listing 6-3 uses break statements to jump out of a switch. But a break 
statement can also play a role inside a loop. To find out how it works, run a 
program containing the following code:
Scanner keyboard = new Scanner(System.in);
while (true) {
  System.out.print("Enter an int value: ");
  int i = keyboard.nextInt();
  if (i == 0) {
    break;
  }
  System.out.println(i);
}
System.out.println("Done!");
keyboard.close();
150      PART 2  Writing Your Own Java Programs
The loop’s condition is always true. It’s like starting a loop with the line
while (1 + 1 == 2)
If it weren’t for the break statement, the loop would run forever. Fortunately, 
when you execute the break statement, Java jumps to the code immediately 
after the loop. » In addition to its break statement, Java has a continue statement. When you 
execute a continue statement, Java skips to the end of its loop and begins the 
next iteration of that loop. To see it in action, run a program containing the 
following code:
Scanner keyboard = new Scanner(System.in);
while (true) {
  System.out.print("Enter an int value: ");
  int i = keyboard.nextInt();
  if (i > 10) {
    continue;
  }
  if (i == 0) {
    break;
  }
  System.out.println(i);
}
System.out.println("Done!");
keyboard.close();
Repeating until You Get What You 
Want (Java do Statements)
Fools rush in where angels fear to tread. —ALEXANDER POPE
Today, I want to be young and foolish (or, at the very least, foolish). Look back at 
Figure  6-2 and notice how Java’s while loop works. When execution enters a 
while loop, the computer checks to make sure that the loop’s condition is true. If 
the condition isn’t true, the statements inside the loop are never executed — not 
CHAPTER 6  Controlling Program Flow with Loops      151
even once. In fact, you can easily cook up a while loop whose statements are never 
executed (although I can’t think of a reason why you would ever want to do it):
int twoPlusTwo = 2 + 2;
while (twoPlusTwo == 5) {
    out.println("Are you kidding?");
    out.println("2 + 2 doesn't equal 5");
    out.print("Everyone knows that");
    out.println(" 2 + 2 equals 3");
}
In spite of this silly twoPlusTwo example, the while statement turns out to be the 
most versatile of Java’s looping constructs. In particular, the while loop is good 
for situations in which you must look before you leap. For example, “While money 
is in my account, write a mortgage check every month.” When you first encounter 
this statement, if your account has a zero balance, you don’t want to write a mort-
gage check — not even one check. But at times (not many), you want to leap before you look. Take, for instance, the 
situation in which you’re asking the user for a response. Maybe the user’s response 
makes sense, but maybe it doesn’t. If it doesn’t, you want to ask again. Maybe the 
user’s finger slipped, or perhaps the user didn’t understand the question. Figure 6-5 shows some runs of a program to delete a file. Before deleting the file, 
the program asks the user whether making the deletion is okay. If the user answers 
y or n, the program proceeds according to the user’s wishes. But if the user enters 
any other character (any digit, uppercase letter, punctuation symbol, or whatever), 
the program asks the user for another response. To write this program, you need a loop — a loop that repeatedly asks the user 
whether the file should be deleted. The loop keeps asking until the user gives a 
meaningful response.

--- Chunk #681 ---
Now, the thing to notice is that the loop doesn’t need to 
check anything before asking the user the first time. Indeed, before the user gives 
FIGURE 6-5: 
Two runs of  
the code in 
Listing 6-4. 152      PART 2  Writing Your Own Java Programs
the first response, the loop has nothing to check. The loop doesn’t start with “as 
long as such-and-such is true, then get a response from the user.” Instead, the 
loop just leaps ahead, gets a response from the user, and then checks the response 
to see whether it makes sense. That’s why the program in Listing 6-4 has a do loop (also known as a do . .

--- Chunk #682 ---
. while 
loop). With a do loop, the program jumps right in, takes action, and then checks a 
condition to see whether the result of the action makes sense. If the result makes 
sense, execution of the loop is done. If not, the program goes back to the top of the 
loop for another go-round. LISTING 6-4: To Delete or Not to Delete
import java.io.File;
import static java.lang.System.out;
import java.util.Scanner;
public class DeleteEvidence {
   public static void main(String args[]) {
      File evidence = new File("cookedBooks.txt");
      Scanner keyboard = new Scanner(System.in);
      char reply;
      do {
         out.print("Delete evidence? (y/n) ");
         reply = keyboard.findWithinHorizon(".",0).charAt(0);
      } while (reply != 'y' && reply != 'n');
      if (reply == 'y') {
         out.println("Okay, here goes...");
         evidence.delete();
         out.println("The evidence has been deleted.");
      } else {
         out.println("Sorry, buddy. Just asking.");
      }
      keyboard.close();
   }
}
Figure 6-5 shows two runs of the code in Listing 6-4. The program accepts low-
ercase letters y and n, but not the uppercase letters Y and N. To make the program 
accept uppercase letters, change the conditions in the code as follows:
CHAPTER 6  Controlling Program Flow with Loops      153
do {
    out.print("Delete evidence? (y/n) ");
    reply = keyboard.findWithinHorizon(".", 0).charAt(0);
} while (reply != 'y' && reply != 'Y' && reply != 'n' && reply!='N');
if (reply == 'y' || reply == 'Y') {
Figure 6-6 shows the flow of control in the loop of Listing 6-4. With a do loop, the 
situation in the twoPlusTwo program (shown at the beginning of this section) can 
never happen. Because the do loop carries out its first action without testing a 
condition, every do loop is guaranteed to perform at least one iteration. The location of Listing 6-4’s cookedBooks.txt file on your computer’s hard drive 
depends on several factors. If you create a cookedBooks.txt file in the wrong 
directory, the code in Listing  6-4 cannot delete your file. (More precisely, if 
cookedBooks.txt is in the wrong directory on your hard drive, the code in  
Listing 6-4 can’t find the cookedBooks.txt file in preparation for deleting the 
file.) In most settings, you start testing Listing 6-4 by creating a project within 
your IDE. The new project lives in a folder on your hard drive, and the cooked 
Books.txt file belongs directly inside that folder. For example, I have a project 
named 06-04. That project lives on my hard drive in a folder named 06-04. Inside 
that folder, I have a file named cookedBooks.txt. If you have trouble with this, 
add the following code to Listing 6-4 immediately after the new File statement:
try {
  out.println("Looking for " + evidence.getCanonicalPath());
} catch (java.io.IOException e) {
  e.printStackTrace();
}
FIGURE 6-6: 
Here we go loop, 
do loop. 154      PART 2  Writing Your Own Java Programs
When you run the code, Java tells you where, on your hard drive, the cooked-
Books.txt file should be. For more information about files and their folders, see Chapter 8. Reading a single character
Over in Listing 5-3 from Chapter  5, the user types a word on the keyboard. The keyboard.next method grabs the word and places the word into a String 
variable named password. Everything works nicely because a String variable 
can store many characters at once, and the next method can read many charac-
ters at once. But in Listing 6-4, you’re not interested in reading several characters. You expect 
the user to type one letter — either y or n. So you don’t create a String variable 
to store the user’s response. Instead, you create a char variable — a variable that 
stores just one symbol at a time. The Java API doesn’t have a nextChar method. To read something suitable for 
storage in a char variable, you have to improvise. In Listing 6-4, the improvisa-
tion looks like this:
keyboard.findWithinHorizon(".", 0).charAt(0)
You can use this code exactly as it appears in Listing 6-4 whenever you want to 
read a single character. A String variable can contain many characters or just one.

--- Chunk #683 ---
But a String variable 
that contains only one character isn’t the same as a char variable. No matter what 
you put in a String variable, String variables and char variables have to be 
treated differently. File handling in Java
In Listing 6-4, the actual file-handling statements deserve some attention. These 
statements involve the use of classes, objects, and methods. Many of the meaty 
details about these things are in other chapters, like Chapters 7 and 9. Even so, I 
can’t do any harm by touching on some highlights right here. So, you can find a class in the Java language API named java.io.File. The 
statement
File evidence = new File("cookedBooks.txt");
CHAPTER 6  Controlling Program Flow with Loops      155
creates a new object in the computer’s memory. This object, formed from the 
java.io.File class, describes everything that the program needs to know about 
the disk file cookedBooks.txt. From this point on in Listing  6-4, the variable 
evidence refers to the disk file cookedBooks.txt. The evidence object, as an instance of the java.io.File class, has a delete 
method. (What can I say? It’s in the API documentation.) When you call evidence. delete, the computer gets rid of the file for you. Of course, you can’t get rid of something that doesn’t already exist. When the 
computer executes
File evidence = new File("cookedBooks.txt");
Java doesn’t check to make sure that you have a file named cookedBooks.txt. To 
force Java to do the checking, you have a few options. The simplest is to call the 
exists method. When you call evidence.exists(), the method looks in the 
folder where Java expects to find cookedBooks.txt. The call evidence.exists() 
returns true if Java finds cookedBooks.txt inside that folder. Otherwise, the call 
evidence.exists() returns false. Here’s a souped-up version of Listing  6-4, 
with a call to exists included in the code:
import java.io.File;
import static java.lang.System.out;
import java.util.Scanner;
public class DeleteEvidence {
  public static void main(String args[]) {
    File evidence = new File("cookedBooks.txt");
    if (evidence.exists()) {
      Scanner keyboard = new Scanner(System.in);
      char reply;
      do {
        out.print("Delete evidence? (y/n) ");
        reply =
           keyboard.findWithinHorizon(".", 0).charAt(0);
      } while (reply != 'y' && reply != 'n');
      if (reply == 'y') {
        out.println("Okay, here goes...");
        evidence.delete();
        out.println("The evidence has been deleted.");
156      PART 2  Writing Your Own Java Programs
      } else {
        out.println("Sorry, buddy. Just asking.");
      }
      keyboard.close();
    }
  }
}
Variable declarations and blocks
A bunch of statements surrounded by curly braces forms a block. If you declare a 
variable inside a block, you generally can’t use that variable outside the block. For 
instance, in Listing  6-4, you get an error message if you make the following 
change:
do {
   out.print("Delete evidence? (y/n) ");
   char reply = keyboard.findWithinHorizon(".", 0).charAt(0);
} while (reply != 'y' && reply != 'n');
if (reply == 'y')
With the declaration char reply inside the loop’s curly braces, no use of the name 
reply makes sense anywhere outside the braces. When you try to compile this 
code, you get three error messages — two for the reply words in while (reply != 
'y' && reply != 'n') and a third for the if statement’s reply. So in Listing 6-4, your hands are tied. The program’s first real use of the reply 
variable is inside the loop. But to make that variable available after the loop, you 
have to declare reply before the loop. In this situation, you’re best off declaring 
the reply variable without initializing the variable. Very interesting!

--- Chunk #684 ---
To read more about variable initializations, see Chapter 4. To find out more about 
blocks, see Chapter 5. All versions of Java have the three kinds of loops described in this chapter (while 
loops, for loops, and do ... while  loops). But newer Java versions (namely, 
Java 5 and beyond) have yet another kind of loop, called an enhanced for loop. For 
a look at Java’s enhanced for loop, see Chapter 11. CHAPTER 6  Controlling Program Flow with Loops      157
Copy the code from Listing 6-1, but with the following change:
        out.print("Enter an int from 1 to 10: ");
        int inputNumber = keyboard.nextInt();
        numGuesses++;
        do {
            out.println();
            out.println("Try again...");
            out.print("Enter an int from 1 to 10: ");
            inputNumber = keyboard.nextInt();
            numGuesses++;
        } while (inputNumber != randomNumber);
        out.print("You win after ");
        out.println(numGuesses + " guesses.");
The code in Listing 6-1 has a while loop, but this modified code has a do loop. Does this modified code work correctly?

--- Chunk #685 ---
Why, or why not? 3
Working with 
the Big Picture: 
Object-Oriented 
Programming
IN THIS PART . .

--- Chunk #686 ---
. Find out what classes and objects are (without bending 
your brain out of shape). Find out how object-oriented programming helps you 
reuse existing code (saving you time and money). Be the emperor of your own virtual world by constructing 
brand-new objects. CHAPTER 7  Thinking in Terms of Classes and Objects      161
IN THIS CHAPTER
 » Thinking like a real object-oriented 
programmer
 » Passing values to and from methods
 » Hiding details in your object-oriented 
code
Thinking in Terms of 
Classes and Objects
A
s a computer book author, I’ve been told this over and over again: I 
shouldn’t expect people to read sections and chapters in their logical order. People jump around, picking what they need and skipping what they don’t 
feel like reading. With that in mind, I realize that you may have skipped Chapter 1. If that’s the case, please don’t feel guilty. You can compensate in just 60 seconds 
by reading the following information, culled from Chapter 1:
Because Java is an object-oriented programming language, your primary goal is to 
describe classes and objects. A class is the idea behind a certain kind of thing. An object 
is a concrete instance of a class. The programmer defines a class, and from the class 
definition, Java makes individual objects. Of course, you can certainly choose to skip over the 60-second summary para -
graph. If that’s the case, you may want to recoup some of your losses.

--- Chunk #687 ---
You can do 
that by reading the following two-word summary of Chapter 1:
Classes; objects. Chapter 7
162      PART 3  Working with the Big Picture: Object-Oriented Programming
Defining a Class (What It Means  
to Be an Account)
What distinguishes one bank account from another? If you ask a banker this 
 question, you hear a long sales pitch. The banker describes interest rates, fees, 
penalties — the whole routine. Fortunately for you, I’m not interested in all that. Instead, I want to know how my account is different from your account. After all, 
my account is named Barry Burd, trading as Burd Brain Consulting, and your account 
is named Jane Q. Reader, trading as Budding Java Expert. My account has $24.02 in it. How about yours? When you come right down to it, the differences between one account and another 
can be summarized as values of variables. Maybe there’s a variable named 
 balance. For me, the value of balance is 24.02. For you, the value of balance is 
55.63. The question is, when writing a computer program to deal with accounts, 
how do I separate my balance variable from your balance variable? The answer is to create two separate objects. Let one balance variable live inside 
one of the objects and let the other balance variable live inside the other object. While you’re at it, put a name variable and an address variable in each of the 
objects. And there you have it: two objects, and each object represents an account. More precisely, each object is an instance of the Account class. (See Figure 7-1.)
So far, so good.

--- Chunk #688 ---
However, you still haven’t solved the original problem. In your 
computer program, how do you refer to my balance variable, as opposed to your 
balance variable? Well, you have two objects sitting around, so maybe you have 
variables to refer to these two objects. Create one variable named myAccount and 
another variable named yourAccount. The myAccount variable refers to my object 
(my instance of the Account class) with all the stuff that’s inside it. To refer to my 
balance, write
myAccount.balance
FIGURE 7-1: 
Two objects. CHAPTER 7  Thinking in Terms of Classes and Objects      163
To refer to my name, write
myAccount.name
Then yourAccount.balance refers to the value in your object’s balance variable, 
and yourAccount.name refers to the value of your object’s name variable. To tell 
Java how much I have in my account, you can write
myAccount.balance = 24.02;
To display your name on the screen, you can write
out.println(yourAccount.name);
These ideas come together in Listings 7-1 and 7-2. Here’s Listing 7-1:
LISTING 7-1: What It Means to Be an Account
public class Account {
    String name;
    String address;
    double balance;
}
The Account class in Listing 7-1 defines what it means to be an Account. In par-
ticular, Listing 7-1 tells you that each of the Account class’s instances has three 
variables: name, address, and balance. This is consistent with the information in 
Figure  7-1. Java programmers have a special name for variables of this kind 
 (variables that belong to instances of classes). Each of these variables — name, 
address, and balance — is called a field. A variable declared inside a class but not inside any particular method is a field. In 
Listing 7-1, the variables name, address, and balance are fields. Another name for 
a field is an instance variable. If you’ve been grappling with the material in Chapters 4 through 6, the code for 
class Account (refer to Listing 7-1) may come as a big shock to you. Can you really 
define a complete Java class with only four lines of code (give or take a curly brace)? You certainly can. A class is a grouping of existing things. In the Account class of 
Listing 7-1, those existing things are two String values and a double value. 164      PART 3  Working with the Big Picture: Object-Oriented Programming
The field declarations in Listing 7-1 have default access, which means that I didn’t 
add a word before the type name String. The alternatives to default access are 
public, protected, and private access:
public String name;
protected String address;
private double balance;
Professional programmers shun the use of default access because default access 
doesn’t shield a field from accidental misuse. But in my experience, you learn best 
when you learn about the simplest stuff first, and in Java, default access is the 
simplest stuff. In this book, I delay the discussion of private access until this 
chapter’s section “Hiding Details with Accessor Methods.” And I delay the discus-
sion of protected access until Chapter 14. As you read this chapter’s examples, 
please keep in mind that default access isn’t the best thing to use in a Java pro-
gram. And, if a professional programmer asks you where you learned to use 
default access, please lie and blame someone else’s book. Declaring variables and creating objects
A young fellow approaches me while I’m walking down the street. He tells me to 
print “You’ll love Java!” so I print those words. If you must know, I print them 
with chalk on the sidewalk. But where I print the words doesn’t matter. What 
matters is that some guy issues instructions, and I follow the instructions. Later that day, an elderly woman sits next to me on a park bench. She says, “An 
account has a name, an address, and a balance.” And I say, “That’s fine, but what 
do you want me to do about it?” In response she just stares at me, so I don’t do 
anything about her account pronouncement. I just sit there, she sits there, and we 
both do absolutely nothing. Listing 7-1, shown earlier, is like the elderly woman. This listing defines what it 
means to be an Account, but the listing doesn’t tell me to do anything with my 
account, or with anyone else’s account. In order to do something, I need a second 
piece of code. I need another class — a class that contains a main method. Fortu-
nately, while the woman and I sit quietly on the park bench, a young child comes 
by with Listing 7-2. CHAPTER 7  Thinking in Terms of Classes and Objects      165
LISTING 7-2: Dealing with Account Objects
import static java.lang.System.out;
public class UseAccount {
    public static void main(String args[]) {
        Account myAccount;
        Account yourAccount;
        myAccount = new Account();
        yourAccount = new Account();
        myAccount.name = "Barry Burd";
        myAccount.address = "222 Cyberspace Lane";
        myAccount.balance = 24.02;
        yourAccount.name = "Jane Q. Public";
        yourAccount.address = "111 Consumer Street";
        yourAccount.balance = 55.63;
        out.print(myAccount.name);
        out.print(" (");
        out.print(myAccount.address);
        out.print(") has $");
        out.print(myAccount.balance);
        out.println();
        out.print(yourAccount.name);
        out.print(" (");
        out.print(yourAccount.address);
        out.print(") has $");
        out.print(yourAccount.balance);
    }
}
Taken together, the two classes — Account and UseAccount — form one complete 
program. The code in Listing 7-2 defines the UseAccount class, and the  UseAccount 
class has a main method. This main method has variables of its own —  yourAccount 
and myAccount. In a way, the first two lines inside the main method of Listing 7-2 are misleading. Some people read Account yourAccount as if it’s supposed to mean,  “yourAccount is 
an Account,” or “The variable yourAccount refers to an instance of the Account 
class.” That’s not really what this first line means. Instead, the line Account 
yourAccount means, “If and when I make the variable yourAccount refer to something, 
that something will be an instance of the Account class.” So, what’s the difference? 166      PART 3  Working with the Big Picture: Object-Oriented Programming
The difference is that simply declaring Account yourAccount doesn’t make the 
yourAccount variable refer to an object. All the declaration does is reserve the 
variable name yourAccount so that the name can eventually refer to an instance of 
the Account class. The creation of an actual object doesn’t come until later in the 
code, when Java executes new Account(). Technically, when Java executes new Account(), you’re creating an object by call-
ing the Account class’s constructor. I have more to say about that in Chapter 9. When Java executes the assignment yourAccount = new Account(), Java creates 
a new object (a new instance of the Account class) and makes the variable 
yourAccount refer to that new object. (The equal sign makes the variable refer to 
the new object.) Figure 7-2 illustrates the situation. To test the claim that I made in the last few paragraphs, I added an extra line to 
the code of Listing 7-2. I tried to print yourAccount.name after declaring yourAc-
count but before calling new Account():
Account myAccount;
    Account yourAccount;
    out.println(yourAccount.name);
    myAccount = new Account();
    yourAccount = new Account();
FIGURE 7-2: 
Before and after 
a constructor is 
called. CHAPTER 7  Thinking in Terms of Classes and Objects      167
When I tried to compile the new code, I got this error message: variable 
yourAccount might not have been initialized. That settles it. Before you do 
new Account(), you can’t print the name variable of an object because an object 
doesn’t exist. When a variable has a reference type, simply declaring the variable isn’t enough. You don’t get an object until you call a constructor and use the keyword new. For information about reference types, see Chapter 4. Initializing a variable
In Chapter 4, I announce that you can initialize a primitive type variable as part of 
the variable’s declaration. int weightOfAPerson = 150;
You can do the same thing with reference type variables, such as myAccount and 
yourAccount in Listing 7-2. You can combine the first four lines in the listing’s 
main method into just two lines, like this:
Account myAccount = new Account();
Account yourAccount = new Account();
If you combine lines this way, you automatically avoid the variable might not 
have been initialized error that I describe in the preceding section. Sometimes 
you find a situation in which you can’t initialize a variable. But when you can ini-
tialize, it’s usually a plus. Using an object’s fields
After you’ve bitten off and chewed the main method’s first four lines, the rest of 
the code in the earlier Listing 7-2 is sensible and straightforward. You have three 
lines that put values in the myAccount object’s fields, three lines that put values in 
the yourAccount object’s fields, and four lines that do some printing. Figure 7-3 
shows the program’s output. FIGURE 7-3: 
Running the code 
in Listings 7-1 
and 7-2. 168      PART 3  Working with the Big Picture: Object-Oriented Programming
One program; several classes
Each program in Chapters 3 to 6 consists of a single class. That’s great for a book’s 
introductory chapters. But in real life, a typical program consists of hundreds or 
even thousands of classes. The program that spans Listings 7-1 and 7-2 consists 
of two classes. Sure, having two classes isn’t like having thousands of classes, but 
it’s a step in that direction. In practice, most programmers put each class in a file of its own. When you create 
a program, such as the one in Listings 7-1 and 7-2, you create two files on your 
computer’s hard drive. Therefore, when you download this section’s example 
from the web, you get two separate files — Account.java and UseAccount.java. For information about running a program consisting of more than one .java file 
in Eclipse, NetBeans, and IntelliJ IDEA, visit this book’s website (www.allmycode. com/JavaForDummies). Public classes
The first line of Listing 7-1 is
public class Account {
The Account class is public. A public class is available for use by all other classes. For example, if you write an ATMController program in some remote corner of 
cyberspace, then your ATMController program can contain code, such as 
myAccount.balance = 24.02 , making use of the Account class declared in 
Listing 7-1. (Of course, your code has to know where in cyberspace I’ve stored the 
code in Listing 7-1, but that’s another story.)
Listing  7-2 contains the code myAccount.balance = 24.02 . You might say to 
yourself, “The Account class has to be public because another class (the code in 
Listing 7-2) uses the Account class.” Unfortunately, the real lowdown about pub-
lic classes is a bit more complicated. In fact, when the planets align themselves 
correctly, one class can make use of another class’s code, even though the other 
class isn’t public. (I cover the proper aligning of planets in Chapter 14.)
The dirty secret in this chapter’s code is that declaring certain classes to be public 
simply makes me feel good. Yes, programmers do certain things to feel good. In 
Listing 7-1, my esthetic sense of goodness comes from the fact that an Account 
class is useful to many other programmers. When I create a class that declares 
something useful and nameable  — an Account, an Engine, a Customer, a 
BrainWave, a Headache, or a SevenLayerCake class — I declare the class to be 
public. CHAPTER 7  Thinking in Terms of Classes and Objects      169
The UseAccount class in Listing 7-2 is also public. When a class contains a main 
method, Java programmers tend to make the class public without thinking too 
much about who uses the class. So even if no other class makes use of my main 
method, I declare the UseAccount class to be public. Most of the classes in this 
book contain main methods, so most of the classes in this book are public. When you declare a class to be public, you must declare the class in a file whose 
name is exactly the same as the name of the class (but with the .java extension 
added). For example, if you declare public class MyImportantCode , you must 
put the class’s code in a file named MyImportantCode.java, with uppercase let-
ters M, I, and C and all other letters lowercase. This file-naming rule has an 
important consequence: If your code declares two public classes, your code must 
consist of at least two .java files. In other words, you can’t declare two public 
classes in one .java file. For more news about the word public and other such words, see Chapter 14. In this section, I create an Account class.

--- Chunk #689 ---
You can create classes too. » An Organization has a name (such as XYZ Company), an annual revenue 
(such as $100,000.00), and a boolean value indicating whether the organiza-
tion is or is not a profit-making organization. Companies that manufacture 
and sell products are generally profit-making organizations; groups that 
provide aid to victims of natural disasters are generally not profit-making 
organizations. Declare your own Organization class.

--- Chunk #690 ---
Declare another class that creates 
organizations and displays information about those organizations. » A product for sale in a food store has several characteristics: a type of food 
(peach slices), a weight (500 grams), a cost ($1.83), a number of servings (4), 
and a number of calories per serving (70). Declare a FoodProduct class. Declare another class that creates FoodProduct 
instances and displays information about those instances. Defining a Method within a Class 
(Displaying an Account)
Imagine a table containing the information about two accounts. (If you have trou-
ble imagining such a thing, just look at Table 7-1.)
170      PART 3  Working with the Big Picture: Object-Oriented Programming
In Table 7-1, each account has three things — a name, an address, and a balance. That’s how things were done before object-oriented programming came along. But object-oriented programming involved a big shift in thinking. With object-
oriented programming, each account can have a name, an address, a balance, and 
a way of being displayed. In object-oriented programming, each object has its own built-in functionality. An account knows how to display itself. A string can tell you whether it has the 
same characters inside it as another string has. A PrintStream instance, such as 
System.out, knows how to do println. In object-oriented programming, each 
object has its own methods. These methods are little subprograms that you can 
call to have an object do things to (or for) itself. And why is this a good idea? It’s good because you’re making pieces of data take 
responsibility for themselves. With object-oriented programming, all the func -
tionality that’s associated with an account is collected inside the code for the 
Account class. Everything you have to know about a string is located in the file 
String.java. Anything having to do with year numbers (whether they have two 
or four digits, for instance) is handled right inside the Year class. Therefore, if 
anybody has problems with your Account class or your Year class, he or she knows 
just where to look for all the code. That’s great! Imagine an enhanced account table. In this new table, each object has built-in 
functionality. Each account knows how to display itself on the screen. Each row of 
the table has its own copy of a display method. Of course, you don’t need much 
imagination to picture this table. I just happen to have a table you can look at.

--- Chunk #691 ---
It’s 
Table 7-2. TABLE 7-1 Without Object-Oriented Programming
Name Address Balance
Barry Burd 222 Cyberspace Lane 24.02
Jane Q. Public 111 Consumer Street 55.63
TABLE 7-2 The Object-Oriented Way
Name Address Balance Display
Barry Burd 222 Cyberspace Lane 24.02 out.print ... Jane Q. Public 111 Consumer Street 55.63 out.print ... CHAPTER 7  Thinking in Terms of Classes and Objects      171
An account that displays itself
In Table 7-2, each account object has four things — a name, an address, a balance, 
and a way of displaying itself on the screen. After you make the jump to object-
oriented thinking, you’ll never turn back. Listings 7-3 and 7-4 show programs 
that implement the ideas in Table 7-2. LISTING 7-3: An Account Displays Itself
import static java.lang.System.out;
public class Account {
    String name;
    String address;
    double balance;
    public void display() {
        out.print(name);
        out.print(" (");
        out.print(address);
        out.print(") has $");
        out.print(balance);
    }
}
LISTING 7-4: Using the Improved Account Class
public class UseAccount {
    public static void main(String args[]) {
        Account myAccount = new Account();
        Account yourAccount = new Account();
        myAccount.name = "Barry Burd";
        myAccount.address = "222 Cyberspace Lane";
        myAccount.balance = 24.02;
        yourAccount.name = "Jane Q. Public";
        yourAccount.address = "111 Consumer Street";
        yourAccount.balance = 55.63;
        myAccount.display();
        System.out.println();
        yourAccount.display();
    }
}
172      PART 3  Working with the Big Picture: Object-Oriented Programming
A run of the code in Listings 7-3 and 7-4 looks just like a run for Listings 7-1 
and 7-2. You can see the action earlier, in Figure 7-3. In Listing 7-3, the Account class has four things in it: a name, an address, a bal-
ance, and a display method. These things match up with the four columns in 
Table 7-2. So each instance of the Account class has a name, an address, a bal -
ance, and a way of displaying itself. The way you call these things is nice and 
uniform. To refer to the name stored in myAccount, you write
myAccount.name
To get myAccount to display itself on the screen, you write
myAccount.display()
The only difference is the parentheses. When you call a method, you put parentheses after the method’s name. The display method’s header
Look again at Listings  7-3 and 7-4. A call to the display method is inside the 
 UseAccount class’s main method, but the declaration of the display method is up 
in the Account class. The declaration has a header and a body. (See Chapter 3.) The 
header has three words and some parentheses:
 » The word public serves roughly the same purpose as the word public in 
Listing 7-1. Roughly speaking, any code can contain a call to a public method, 
even if the calling code and the public method belong to two different classes. In this section’s example, the decision to make the display method public is a 
matter of taste. Normally, when I create a method that’s useful in a wide 
variety of applications, I declare the method to be public. » The word void tells Java that when the display method is called, the 
display method doesn’t return anything to the place that called it. To 
see a method that does return something to the place that called it, see the 
next section. » The word display is the method’s name. Every method must have a name. Otherwise, you don’t have a way to call the method. » The parentheses contain all the things you’re going to pass to the 
method when you call it. When you call a method, you can pass information 
to that method on the fly. The display method in Listing 7-3 looks strange 
CHAPTER 7  Thinking in Terms of Classes and Objects      173
because the parentheses in the method’s header have nothing inside them. This nothingness indicates that no information is passed to the display 
method when you call it. For a meatier example, see the next section. Listing 7-3 contains the display method’s declaration, and Listing 7-4 contains 
a call to the display method. Although Listings 7-3 and 7-4 contain different 
classes, both uses of public in Listing 7-3 are optional. To find out why, check out 
Chapter 14. In the previous section, you create Organization and FoodProduct classes. Add 
display methods to both of these classes and create separate classes that make 
use of these display methods. Sending Values to and from Methods 
(Calculating Interest)
Think about sending someone to the supermarket to buy bread. When you do this, 
you say, “Go to the supermarket and buy some bread.” (Try it at home. You’ll 
have a fresh loaf of bread in no time at all!) Of course, some other time, you send 
that same person to the supermarket to buy bananas. You say, “Go to the super-
market and buy some bananas.” And what’s the point of all of this? Well, you 
have a method, and you have some on-the-fly information that you pass to the 
method when you call it. The method is named goToTheSupermarketAndBuySome. The on-the-fly information is either bread or bananas, depending on your culi-
nary needs. In Java, the method calls would look like this:
goToTheSupermarketAndBuySome(bread);
goToTheSupermarketAndBuySome(bananas);
The things in parentheses are called parameters or parameter lists. With parameters, 
your methods become much more versatile. Instead of getting the same thing 
each time, you can send somebody to the supermarket to buy bread one time, 
bananas another time, and birdseed the third time. When you call your 
goToTheSupermarketAndBuySome method, you decide right there what you’re 
going to ask your pal to buy. And what happens when your friend returns from the supermarket? “Here’s the 
bread you asked me to buy,” says your friend. By carrying out your wishes, your 
friend returns something to you. You make a method call, and the method returns 
information (or a loaf of bread). 174      PART 3  Working with the Big Picture: Object-Oriented Programming
The thing returned to you is called the method’s return value. The general type of 
thing that is returned to you is called the method’s return type. These concepts are 
made more concrete in Listings 7-5 and 7-6. LISTING 7-5: An Account That Calculates Its Own Interest
import static java.lang.System.out;
public class Account {
    String name;
    String address;
    double balance;
    public void display() {
        out.print(name);
        out.print(" (");
        out.print(address);
        out.print(") has $");
        out.print(balance);
    }
    public double getInterest(double percentageRate) {
        return balance * percentageRate / 100.00;
    }
}
LISTING 7-6: Calculating Interest
import static java.lang.System.out;
public class UseAccount {
    public static void main(String args[]) {
        Account myAccount = new Account();
        Account yourAccount = new Account();
        myAccount.name = "Barry Burd";
        myAccount.address = "222 Cyberspace Lane";
        myAccount.balance = 24.02;
        yourAccount.name = "Jane Q. Public";
        yourAccount.address = "111 Consumer Street";
        yourAccount.balance = 55.63;
        myAccount.display();
CHAPTER 7  Thinking in Terms of Classes and Objects      175
        out.print(" plus $");
        out.print(myAccount.getInterest(5.00));
        out.println(" interest ");
        yourAccount.display();
        double yourInterestRate = 7.00;
        out.print(" plus $");
        double yourInterestAmount = yourAccount.getInterest(yourInterestRate);
        out.print(yourInterestAmount);
        out.println(" interest ");
    }
}
Figure 7-4 shows the output of the code in Listings 7-5 and 7-6. In Listing 7-5, 
the Account class has a getInterest method. This getInterest method is called 
twice from the main method in Listing 7-6. The actual account balances and inter-
est rates are different each time. » In the first call, the balance is 24.02, and the interest rate is 5.00. The first 
call, myAccount.getInterest(5.00), refers to the myAccount object and to 
the values stored in the myAccount object’s fields. (See Figure 7-5.) When this 
call is made, the expression balance * percentageRate / 100.00 stands 
for 24.02 * 5.00 / 100.00. » In the second call, the balance is 55.63, and the interest rate is 7.00. In the 
main method, just before this second call is made, the variable your 
InterestRate is assigned the value 7.00. The call itself, yourAccount. getInterest(yourInterestRate), refers to the yourAccount object and to 
the values stored in the yourAccount object’s fields. (Again, see Figure 7-5.) 
So, when the call is made, the expression balance * percentageRate / 
100.00 stands for 55.63 * 7.00 / 100.00. By the way, the main method in Listing 7-6 contains two calls to getInterest. One call has the literal 5.00 in its parameter list; the other call has the variable 
yourInterestRate in its parameter list. Why does one call use a literal and the 
other call use a variable? No reason.

--- Chunk #692 ---
I just want to show you that you can do it 
either way. FIGURE 7-4: 
Running the code 
in Listings 7-5  
and 7-6. 176      PART 3  Working with the Big Picture: Object-Oriented Programming
Passing a value to a method
Take a look at the getInterest method’s header. (As you read the explanation in 
the next few bullets, you can follow some of the ideas visually with the diagram in 
Figure 7-6.)
FIGURE 7-5: 
My account and 
your account. FIGURE 7-6: 
Passing a value to 
a method. CHAPTER 7  Thinking in Terms of Classes and Objects      177
 » The word double tells Java that when the getInterest method is called, 
the getInterest method returns a double value back to the place that 
called it. The statement in the getInterest method’s body confirms this. The statement says return balance * percentageRate / 100.00, and 
the expression balance * percentageRate / 100.00 has type double. (That’s because all the things in the expression — balance, percentageRate, 
and 100.00 — have type double.)
When the getInterest method is called, the return statement calculates 
balance * percentageRate / 100.00 and hands the calculation’s result 
back to the code that called the method. » The word getInterest is the method’s name. That’s the name you use to call 
the method when you’re writing the code for the UseAccount class. » The parentheses contain all the things that you pass to the method 
when you call it. When you call a method, you can pass information to that 
method on the fly.

--- Chunk #693 ---
This information is the method’s parameter list. The 
getInterest method’s header says that the getInterest method takes one 
piece of information and that piece of information must be of type double:
public double getInterest(double  percentageRate)
Sure enough, if you look at the first call to getInterest (down in the 
useAccount class’s main method), that call has the number 5.00 in it. And 
5.00 is a double literal. When I call getInterest, I’m giving the method a 
value of type double. If you don’t remember what a literal is, see Chapter 4. The same story holds true for the second call to getInterest. Down 
near the bottom of Listing 7-6, I call getInterest and feed the variable 
yourInterestRate to the method in its parameter list. Luckily for me, 
I declared yourInterestRate to be of type double just a few lines before 
that. When you run the code in Listings 7-5 and 7-6, the flow of action isn’t from top 
to bottom. The action goes from main to getInterest, and then back to main, and 
then back to getInterest, and, finally, back to main again. Figure 7-7 shows the 
whole business. 178      PART 3  Working with the Big Picture: Object-Oriented Programming
Returning a value from the  
getInterest method
When the getInterest method is called, the method executes the one statement 
that’s in the method’s body: a return statement. The return statement computes 
the value of balance * percentageRate / 100.00 . If balance happens to be 
24.02, and percentageRate is 5.00, the value of the expression is 1.201  —  
around $1.20. (Because the computer works exclusively with 0s and 1s, Java gets 
this number wrong by an ever-so-tiny amount. Java gets 1.2009999999999998. That’s just something that humans have to live with.)
FIGURE 7-7: 
The flow of 
control in 
Listings 7-5  
and 7-6. CHAPTER 7  Thinking in Terms of Classes and Objects      179
Anyway, after this value is calculated, Java executes the return, which sends the 
value back to the place in main where getInterest was called. At that point in the 
process, the entire method call  — myAccount.getInterest(5.00)  — takes on 
the value 1.2009999999999998. The call itself is inside a println:
out.println(myAccount.getInterest(5.00));
So the println ends up with the following meaning:
out.println(1.2009999999999998);
The whole process, in which a value is passed back to the method call, is illus -
trated in Figure 7-8. If a method returns anything, a call to the method is an expression with a value. That value can be printed, assigned to a variable, added to something else, or 
whatever. Anything you can do with any other kind of value, you can do with a 
method call. You might use the Account class in Listing 7-5 to solve a real problem. You’d call 
the Account class’s display and getInterest methods in the course of an actual 
banking application. But the UseAccount class in Listing  7-6 is artificial. The 
UseAccount code creates some fake account data and then calls some Account class 
methods to convince you that the Account class’s code works correctly. (You don’t 
FIGURE 7-8: 
A method call is 
an expression 
with a value. 180      PART 3  Working with the Big Picture: Object-Oriented Programming
seriously think that a bank has depositors named “Jane Q. Public” and “Barry 
Burd,” do you?) The UseAccount class in Listing 7-6 is a test case — a short-lived 
class whose sole purpose is to test another class’s code. Like the code in Listing 7-6,  
each test case in this book is an ordinary class — a free-form class containing its 
own main method. Free-form classes are okay, but they’re not optimal. Java 
developers have something better — a more disciplined way of writing test cases. The “better way” is called JUnit, and it’s described on this book’s website ( www. allmycode.com/JavaForDummies). » In previous sections, you create your own Organization class. Add a method 
to the class that computes the amount of tax the organization pays. A 
profit-making organization pays 10 percent of its revenue in tax, but a 
nonprofit organization pays only 2 percent of its revenue in tax. Make a separate class that creates two or three organizations and displays 
information about each organization, including the amount of tax the 
organization pays. » In previous sections, you create your own FoodProduct class. Add methods 
to the class to compute the cost per 100 grams, the cost per serving, and the 
total number of calories in the product. Make a separate class that creates two or three products and displays 
information about each product. Making Numbers Look Good
Looking at Figure 7-4 again, you may be concerned that the interest on my account 
is only $1.2009999999999998. Seemingly, the bank is cheating me out of 
2  hundred-trillionths of a cent. I should go straight to the bank and demand my 
fair interest. Maybe you and I should go together. We’ll kick up some fur at that 
old bank and bust this scam right open. If my guess is correct, this is part of a big 
salami scam. In a salami scam, someone shaves tiny amounts off millions of 
accounts. People don’t notice their tiny little losses, but the person doing the 
shaving collects enough for a quick escape to Barbados (or for a whole truckload 
of salami). Wait a minute!

--- Chunk #694 ---
What about you? In Listing 7-6, you have yourAccount. And in 
Figure 7-4, your name is Jane Q. Public. Nothing is motivating you to come with 
me to the bank. Checking Figure 7-4 again, I see that you’re way ahead of the 
game. According to my calculations, the program overpays you by 3 hundred-
trillionths of a cent. Between the two of us, we’re ahead by a hundred-trillionth of 
a cent. What gives? CHAPTER 7  Thinking in Terms of Classes and Objects      181
Well, because computers use 0s (zeros) and 1s and don’t have an infinite amount 
of space to do calculations, such inaccuracies as the ones shown in Figure 7-4 are 
normal. The quickest solution is to display the inaccurate numbers in a more sen-
sible fashion. You can round the numbers and display only two digits beyond the 
decimal point, and some handy tools from Java’s API (application programming 
interface) can help. Listing 7-7 shows the code, and Figure 7-9 displays the pleas-
ant result. LISTING 7-7: Making Your Numbers Look Right
import static java.lang.System.out;
public class UseAccount {
    public static void main(String args[]) {
        Account myAccount = new Account();
        Account yourAccount = new Account();
        myAccount.balance = 24.02;
        yourAccount.balance = 55.63;
        double myInterest = myAccount.getInterest(5.00);
        double yourInterest = yourAccount.getInterest(7.00);
        out.printf("$%4.2f\n", myInterest);
        out.printf("$%5.2f\n", myInterest);
        out.printf("$%.2f\n",  myInterest);
        out.printf("$%3.2f\n", myInterest);
        out.printf("$%.2f $%.2f", myInterest, yourInterest);
    }
}
The inaccurate numbers in Figure  7-4 come from the computer’s use of 0s 
and 1s. A mythical computer whose circuits were wired to use digits 0, 1, 2, 3, 4, 5, 
6, 7, 8, and 9 wouldn’t suffer from the same inaccuracies. So, to make things better, 
Java provides its own special way around the computer’s inaccurate calculations. Java’s API has a class named BigDecimal — a class that bypasses the computer’s 
strange 0s and 1s and uses ordinary decimal digits to perform arithmetic calcula-
tions. For more information, visit this book’s website ( www.allmycode.com/
JavaForDummies). FIGURE 7-9: 
Numbers that 
look like dollar 
amounts. 182      PART 3  Working with the Big Picture: Object-Oriented Programming
Listing 7-7 uses a handy method named printf. When you call printf, you always 
put at least two parameters inside the call’s parentheses:
 » The first parameter is a format string. The format string uses funny-looking codes to describe exactly how the other 
parameters are displayed. » All the other parameters (after the first) are values to be displayed. Look at the last printf call of Listing 7-7. The first parameter’s format string has 
two placeholders for numbers. The first placeholder (%.2f) describes the display 
of myInterest. The second placeholder (another %.2f) describes the display of 
yourInterest. To find out exactly how these format strings work, see Figures 7-10 
through 7-14. FIGURE 7-11: 
Adding extra 
places to display 
a value. FIGURE 7-10: 
Using a format 
string. CHAPTER 7  Thinking in Terms of Classes and Objects      183
For more examples using the printf method and its format strings, see  Chapters 8 
and 9. For a complete list of options associated with the printf method’s format 
string, see the java.util.Formatter page of Java’s API documentation at 
https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html. The format string in a printf call doesn’t change the way a number is stored 
internally for calculations. All the format string does is create a nice-looking 
bunch of digit characters that can be displayed on your screen. FIGURE 7-12: 
Displaying a value 
without specify-
ing the exact 
number of places. FIGURE 7-13: 
Specifying too 
few places to 
display a value. FIGURE 7-14: 
Displaying more 
than one value 
with a format 
string. 184      PART 3  Working with the Big Picture: Object-Oriented Programming
The printf method is good for formatting values of any kind — ordinary num-
bers, hexadecimal numbers, dates, strings of characters, and some other strange 
values. That’s why I show it to you in this section. But when you work with cur -
rency amounts, this section’s printf tricks are fairly primitive. For some better 
ways to deal with currency amounts (such as the interest amounts in this sec-
tion’s example), see Chapter 11. Here’s a Java “un-program.” It’s not a real Java program, because I’ve masked 
some of the characters in the code. I replaced these characters with underscores 
(_):
import static java.lang.System.out;
public class Main {
    public static void main(String[] args) {
        out.printf("%s%_%s", ">>", 7, "<<\n");
        out.printf("%s%___%s", ">>", 7, "<<\n");
        out.printf("%s%____%s", ">>", 7, "<<\n");
        out.printf("%s%____%s", ">>", 7, "<<\n");
        out.printf("%s%__%s", ">>", 7, "<<\n");
        out.printf("%s%__%s", ">>", -7, "<<\n");
        out.printf("%s%__%s", ">>", -7, "<<\n");
        out.printf("%s%_____%s", ">>", 7.0, "<<\n");
        out.printf("%s%_%s", ">>", "Hello", "<<\n");
        out.printf("%s%_%s", ">>", 'x', "<<\n");
        out.printf("%s%_%s", ">>", 'x', "<<\n");
    }
}
Replace the underscores so that this program produces the following output:
>>7<<
>>         7<<
>>7         <<
>>0000000007<<
>>+7<<
>>-7<<
>>(7)<<
>>   7.00000<<
>>HELLO<<
>>x<<
>>X<<
CHAPTER 7  Thinking in Terms of Classes and Objects      185
To do this, look for clues in the java.util.Formatter page of Java’s API 
 documentation at https://docs.oracle.com/javase/8/docs/api/java/util/
Formatter.html. Hiding Details with Accessor Methods
Put down this book and put on your hat.

--- Chunk #695 ---
You’ve been such a loyal reader that I’m 
taking you out to lunch!

--- Chunk #696 ---
I have just one problem. I’m a bit short on cash. Would you mind if, on the way to 
lunch, we stopped at an automatic teller machine and picked up a few bucks? Also, 
we have to use your account. My account is a little low. Fortunately, the teller machine is easy to use. Just step right up and enter your 
PIN. After you enter your PIN, the machine asks which of several variable names 
you want to use for your current balance. You have a choice of balance324, myBal, 
currentBalance, b$, BALANCE, asj999, or conStanTinople. Having selected a 
variable name, you’re ready to select a memory location for the variable’s value. You can select any number between 022FFF and 0555AA. (Those numbers are in 
hexadecimal format.) After you configure the teller machine’s software, you can 
easily get your cash. You did bring a screwdriver, didn’t you?

--- Chunk #697 ---
Good programming
When it comes to good computer programming practice, one word stands out 
above all others: simplicity. When you’re writing complicated code, the last thing 
you want is to deal with somebody else’s misnamed variables, convoluted solu-
tions to problems, or clever, last-minute kludges. You want a clean interface that 
makes you solve your own problems and no one else’s. In the automatic teller machine scenario that I describe earlier, the big problem is 
that the machine’s design forces you to worry about other people’s concerns. When you should be thinking about getting money for lunch, you’re thinking 
instead about variables and storage locations. Sure, someone has to work out the 
teller machine’s engineering problems, but the banking customer isn’t the 
person. This section is about safety, not security. Safe code keeps you from making acci-
dental programming errors. Secure code (a completely different story) keeps 
malicious hackers from doing intentional damage. 186      PART 3  Working with the Big Picture: Object-Oriented Programming
So, everything connected with every aspect of a computer program has to be sim-
ple, right? Well, no.

--- Chunk #698 ---
That’s not right.

--- Chunk #699 ---
Sometimes, to make things simple in the 
long run, you have to do lots of preparatory work up front. The people who built 
the automated teller machine worked hard to make sure that the machine is 
 consumer-proof. The machine’s interface, with its screen messages and buttons, 
makes the machine a very complicated, but carefully designed, device.

--- Chunk #700 ---
The point is that making things look simple takes some planning. In the case of 
object-oriented programming, one of the ways to make things look simple is to 
prevent code outside a class from directly using fields defined inside the class. Take a peek at the code in Listing 7-1. You’re working at a company that has just 
spent $10 million for the code in the Account class. (That’s more than a million- 
and-a-half per line!) Now your job is to write the UseAccount class. You would 
like to write
myAccount.name = "Barry Burd";
but doing so would be getting you too far inside the guts of the Account class. After all, people who use an automatic teller machine aren’t allowed to program 
the machine’s variables. They can’t use the machine’s keypad to type the 
statement
balanceOnAccount29872865457 = balanceOnAccount29872865457 + 1000000.00;
Instead, they push buttons that do the job in an orderly manner. That’s how a 
programmer achieves safety and simplicity. To keep things nice and orderly, you need to change the Account class from 
 Listing 7-1 by outlawing such statements as the following:
myAccount.name = "Barry Burd";
and
out.print(yourAccount.balance);
Of course, this poses a problem. You’re the person who’s writing the code for the 
UseAccount class. If you can’t write myAccount.name or yourAccount.balance, 
how will you accomplish anything at all? The answer lies in things called accessor 
methods. Listings 7-8 and 7-9 demonstrate these methods. CHAPTER 7  Thinking in Terms of Classes and Objects      187
LISTING 7-8: Hide Those Fields
public class Account {
    private String name;
    private String address;
    private double balance;
    public void setName(String n) {
        name = n;
    }
    public String getName() {
        return name;
    }
    public void setAddress(String a) {
        address = a;
    }
    public String getAddress() {
        return address;
    }
    public void setBalance(double b) {
        balance = b;
    }
    public double getBalance() {
        return balance;
    }
}
LISTING 7-9: Calling Accessor Methods
import static java.lang.System.out;
public class UseAccount {
    public static void main(String args[]) {
        Account myAccount = new Account();
        Account yourAccount = new Account();
        myAccount.setName("Barry Burd");
        myAccount.setAddress("222 Cyberspace Lane");
        myAccount.setBalance(24.02);
(continued)
188      PART 3  Working with the Big Picture: Object-Oriented Programming
        yourAccount.setName("Jane Q. Public");
        yourAccount.setAddress("111 Consumer Street");
        yourAccount.setBalance(55.63);
        out.print(myAccount.getName());
        out.print(" (");
        out.print(myAccount.getAddress());
        out.print(") has $");
        out.print(myAccount.getBalance());
        out.println();
        out.print(yourAccount.getName());
        out.print(" (");
        out.print(yourAccount.getAddress());
        out.print(") has $");
        out.print(yourAccount.getBalance());
    }
}
A run of the code in Listings 7-8 and 7-9 looks no different from a run of List -
ings 7-1 and 7-2. Either program’s run is shown earlier, in Figure 7-3. The big 
difference is that in Listing 7-8, the Account class enforces the carefully con-
trolled use of its name, address, and balance fields. Public lives and private dreams:  
Making a field inaccessible
Notice the addition of the word private in front of each of the Account class’s field 
declarations. The word private is a Java keyword. When a field is declared private, 
no code outside of the class can make direct reference to that field. So if you put 
myAccount.name = "Barry Burd" in the UseAccount class of Listing 7-9, you get 
an error message such as name has private access in Account. Instead of referencing myAccount.name, the UseAccount programmer must call 
method myAccount.setName or method myAccount.getName. These methods, 
setName and getName, are called accessor methods because they provide access to 
the Account class’s name field. (Actually, the term accessor method isn’t formally a 
part of the Java programming language. It’s just the term that people use for 
methods that do this sort of thing.) To zoom in even more, setName is called a 
setter method, and getName is called a getter method. (I bet you won’t forget that 
terminology!)
LISTING 7-9: (continued)
CHAPTER 7  Thinking in Terms of Classes and Objects      189
With many IDEs, you don’t have to type your own accessor methods. First, you 
type a field declaration like private String name. Then, in your IDE’s menu bar, 
you choose Source ➪   Generate Getters and Setters, or choose Code ➪   Insert 
Code ➪   Setter or some mix of those commands. After you make all your choices, 
the IDE creates accessor methods and adds them to your code. Notice that all the setter and getter methods in Listing 7-8 are declared to be pub-
lic. This ensures that anyone from anywhere can call these two methods. The idea 
here is that manipulating the actual fields from outside the Account code is 
impossible, but you can easily reach the approved setter and getter methods for 
using those fields. Think again about the automatic teller machine. Someone using the ATM can’t 
type a command that directly changes the value in his or her account’s balance 
field, but the procedure for depositing a million-dollar check is easy to follow. The 
people who build the teller machines know that if the check-depositing procedure 
is complicated, plenty of customers will mess it up royally. So that’s the story — 
make impossible anything that people shouldn’t do and make sure that the tasks 
people should be doing are easy. Nothing about having setter and getter methods is sacred. You don’t have to write 
any setter and getter methods that you’re not going to use. For instance, in List -
ing 7-8, I can omit the declaration of method getAddress, and everything still 
works. The only problem if I do this is that anyone else who wants to use my 
Account class and retrieve the address of an existing account is up a creek. When you create a method to set the value in a balance field, you don’t have to 
name your method setBalance. You can name it tunaFish or whatever you like. The trouble is that the setFieldname convention (with lowercase letters in set 
and an uppercase letter to start the Fieldname part) is an established stylistic 
convention in the world of Java programming. If you don’t follow the convention, 
you confuse the kumquats out of other Java programmers. If your integrated 
development environment has drag-and-drop GUI design capability, you may 
temporarily lose that capability. (For a word about drag-and-drop GUI design, see 
Chapters 2 and 16.)
When you call a setter method, you feed it a value of the type that’s being set. That’s why, in Listing  7-9, you call yourAccount.setBalance(55.63) with a 
parameter of type double. In contrast, when you call a getter method, you usually 
don’t feed any values to the method. That’s why, in Listing  7-9, you call 
yourAccount.getBalance() with an empty parameter list. Occasionally, you may 
want to get and set a value with a single statement. To add a dollar to your 
account’s existing balance, you write yourAccount.setBalance(yourAccount. getBalance() + 1.00). 190      PART 3  Working with the Big Picture: Object-Oriented Programming
Enforcing rules with accessor methods
Go back to Listing 7-8 and take a quick look at the setName method. Imagine put-
ting the method’s assignment statement inside an if statement. public void setName(String n) {
    if (!n.equals("")) {
        name = n;
    }
}
Now, if the programmer in charge of the UseAccount class writes myAccount. setName(""), the call to setName doesn’t have any effect. Furthermore, because 
the name field is private, the following statement is illegal in the UseAccount 
class:
myAccount.name = "";
Of course, a call such as myAccount.setName("Joe Schmoe") still works because 
"Joe Schmoe" doesn’t equal the empty string "". That’s cool. With a private field and an accessor method, you can prevent someone 
from assigning the empty string to an account’s name field. With more elaborate 
if statements, you can enforce any rules you want. In previous sections, you create your own Organization and FoodProduct classes. In those classes, replace the default access fields with private fields. Create getter 
and setter methods for those fields. In the setter methods, add code to ensure that 
the String values aren’t empty and that numeric values aren’t negative. Barry’s Own GUI Class
You may be getting tired of the bland, text-based programs that litter this book’s 
pages. You may want something a bit flashier — something with text fields and 
buttons. Well, I’ve got some examples for you! I’ve created a class that I call DummiesFrame. When you import my DummiesFrame 
class, you can create a simple graphical user interface (GUI) application with very 
little effort. Listing 7-10 uses my DummiesFrame class, and Figures 7-15 to 7-17 show you the 
results. CHAPTER 7  Thinking in Terms of Classes and Objects      191
LISTING 7-10: Your First DummiesFrame Example
import com.allmycode.dummiesframe.DummiesFrame;
public class GuessingGame {
    public static void main(String[] args) {
        DummiesFrame frame = new DummiesFrame("Greet Me!");
        frame.addRow("Your first name");
        frame.go();
    }
    public static String calculate(String firstName) {
        return "Hello, " + firstName + "!";
    }
}
FIGURE 7-15: 
The code in 
Listing 7-10 starts 
running. FIGURE 7-16: 
The user fills in 
the fields. FIGURE 7-17: 
The user clicks 
the button. 192      PART 3  Working with the Big Picture: Object-Oriented Programming
Here’s a blow-by-blow description of the lines in Listing 7-10:
 » The first line
import com.allmycode.dummiesframe.DummiesFrame;
makes the name DummiesFrame available to the rest of the code in the listing. » Inside the main method, the statement
DummiesFrame frame = new DummiesFrame("Greet Me!");
creates an instance of my DummiesFrame class and makes the variable name 
frame refer to that instance. A DummiesFrame object appears as a window on 
the user’s screen. In this example, the text on the window’s title bar is Greet Me! » The next statement is a call to the frame object’s addRow method:
frame.addRow("Your first name");
This call puts a row on the face of the application’s window. The row consists 
of a label (whose text is Your first name), an empty text field, and a red X mark 
indicating that the user hasn’t yet typed anything useful into the field. (Refer to 
Figure 7-15.)
 » A call to the frame object’s go method
frame.go();
makes the app’s window appear on the screen. » The header of the calculate method
public static String calculate(String firstName) {
tells Java two important things:
• The calculate method returns a value of type String. • Java should expect the user to type a String value in the text field, and 
whatever the user types will become the firstName parameter’s value. To use my DummiesFrame class, your code must have a method named 
calculate, and the calculate method must obey certain rules:
• The calculate method’s header must start with the words public 
static. • The method may return any Java type: String, int, double, or whatever. (That’s actually not a rule; it’s an opportunity!)
• The calculate method must have the same number of parameters as 
there are rows in the application’s window. CHAPTER 7  Thinking in Terms of Classes and Objects      193
Listing 7-10 has only one addRow method call, so the window in Figure 7-10 
has only one row (not including the Submit button), and so the calculate 
method has only one parameter. When the user starts typing text into the window’s text field, the red X mark 
turns into a green check mark. (Refer to Figure 7-16.) The green check mark 
indicates that the user has typed a value of the expected type (in this example, 
a String value) into the text field. » When the user clicks the button, Java executes the calculate method. The 
expression in the method’s return statement
return "Hello, " + firstName + "!";
tells Java what to display at the bottom of the window. (Refer to Figure 7-17.) 
In this example, the user types Barry in the one and only text field, so the 
value of firstName is "Barry", and the calculate method returns the string 
"Hello, Barry!" (Ah! The perks of being a For Dummies author!)
Using my DummiesFrame class, you can build a simple GUI application with only 
ten lines of code. The DummiesFrame class isn’t built into the Java API so, in order to run the 
code in Listing 7-10, my DummiesFrame.java file must be part of your project. When you download the code from this book’s website ( www.allmycode.com/ 
JavaForDummies), you get a folder named 07-10 containing both the Listing 7-10 
code and my DummiesFrame.java code. But if you create your own project con-
taining the  Listing 7-10, you have to add my DummiesFrame.java file manually. The way you do this depends on which IDE you use. One way or another, my  
DummiesFrame class is in a package named com.allmycode.dummiesframe, so the 
DummiesFrame.java file must be in a directory named dummiesframe, which is 
inside another directory named allmycode, which is inside yet another directory 
named com. For more about packages, see  Chapters 9 and 14. To keep things simple, I include the DummiesFrame.java file in the 07-10 folder that 
you download from this book’s website. But, really, is that the best way to add my 
own code to your project? In Chapter 1, I describe files with the .class extension, 
and the role that those files play in the running of a Java program. Instead of hand-
ing you my DummiesFrame.java file, I should be putting only a DummiesFrame.class 
file in the download. And, on some other occasion, if I have to give you hundreds of 
.class files, I should bundle them all into one big archive file. Java has a name for a 
big file that encodes many smaller .class files. It’s called a JAR file and it has the 
.jar extension. In a real-life application, if you’re preparing your code for other 
people to use as part of their own applications, a JAR file is definitely the way to go. My DummiesFrame class isn’t exclusively for greetings and salutations. Listing 7-11 
uses DummiesFrame to do arithmetic. 194      PART 3  Working with the Big Picture: Object-Oriented Programming
LISTING 7-11: A Really Simple Calculator
import com.allmycode.dummiesframe.DummiesFrame;
public class Addition {
    public static void main(String[] args) {
        DummiesFrame frame = new DummiesFrame("Adding Machine");
        frame.addRow("First number");
        frame.addRow("Second number");
        frame.setButtonText("Sum");
        frame.go();
    }
    public static int calculate(int firstNumber, int secondNumber) {
        return firstNumber + secondNumber;
    }
}
The window in Figure 7-18 has two rows because Listing 7-11 has two addRow calls 
and the listing’s calculate method has two parameters. In addition, Listing 7-11 
calls the frame object’s setButtonText method. So, in Figure 7-18, the text on the 
face of the button isn’t the default word Submit. Listing  7-12 contains a GUI version of the Guessing Game application from 
 Chapter 5, and Figure 7-19 shows the game in action. LISTING 7-12: I’m Thinking of a Number
import java.util.Random;
import com.allmycode.dummiesframe.DummiesFrame;
public class GuessingGame {
FIGURE 7-18: 
Look! The code in 
Listing 7-11 
actually works! CHAPTER 7  Thinking in Terms of Classes and Objects      195
  public static void main(String[] args) {
    DummiesFrame frame = new DummiesFrame("Guessing Game");
    frame.addRow("Enter an int from 1 to 10");
    frame.setButtonText("Submit your guess");
    frame.go();
  }
  public static String calculate(int inputNumber) {
    Random random = new Random();
    int randomNumber = random.nextInt(10) + 1;
    if (inputNumber == randomNumber) {
      return "You win.";
    } else {
      return "You lose. The random number was " + randomNumber + ".";
    }
  }
}
In Listing 7-13, I use this chapter’s Account class alongside the DummiesFrame 
class. I could get the same results without creating an Account instance, but I 
want to show you how classes can cooperate to form a complete program. A run of 
the code is in Figure 7-20. LISTING 7-13: Using the Account Class
import com.allmycode.dummiesframe.DummiesFrame;
public class UseAccount {
    public static void main(String args[]) {
        DummiesFrame frame = new DummiesFrame("Display an Account");
        frame.addRow("Full name");
        frame.addRow("Address");
        frame.addRow("Balance");
        frame.setButtonText("Display");
FIGURE 7-19: 
I win! (continued)
196      PART 3  Working with the Big Picture: Object-Oriented Programming
        frame.go();
    }
    public static String calculate(String name, String address,
                                                double balance) {
        Account myAccount = new Account();
        myAccount.setName(name);
        myAccount.setAddress(address);
        myAccount.setBalance(balance);
        return myAccount.getName() + " (" + myAccount.getAddress() +
                ") has $" + myAccount.getBalance();
    }
}
Use the DummiesFrame class to create two GUI programs. » A window has text fields for an organization’s name, annual revenue, and 
status (profit-making or not profit-making). When the user clicks a button, the 
window displays the amount of tax the organization pays. A profit-making organization pays 10 percent of its revenue in tax; a nonprofit 
organization pays 2 percent of its revenue in tax. » A window has text fields for a product’s type of food, weight, cost, number of 
servings, and number of calories per serving. When the user clicks a button, 
the window displays the cost per 100 grams, the cost per serving, and the 
total number of calories in the product. FIGURE 7-20: 
I’m rich. LISTING 7-13: (continued)
CHAPTER 8  Saving Time and Money: Reusing Existing Code      197
IN THIS CHAPTER
 » Adding new life to old code
 » Tweaking your code
 » Making changes without spending a 
fortune
Saving Time and Money: 
Reusing Existing Code
O
nce upon a time, there was a beautiful princess. When the princess turned 
25 (the optimal age for strength, good looks, and fine moral character), 
her kind, old father brought her a gift in a lovely golden box. Anxious to 
know what was in the box, the princess ripped off the golden wrapping paper. When the box was finally opened, the princess was thrilled. To her surprise, her 
father had given her what she had always wanted: a computer program that 
always ran correctly. The program did everything the princess wanted, and did it 
all exactly the way she wanted it to be done. The princess was happy, and so was 
her father. Even as time marched on, the computer program never failed. For years on end, 
the princess changed her needs, expected more out of life, made increasing 
demands, expanded her career, reached for more and more fulfillment, juggled 
the desires of her husband and her kids, stretched the budget, and sought peace 
within her soul. Through all of this, the program remained her steady, faithful 
companion. As the princess grew old, the program became old along with her. One evening, as 
she sat by the fireside, she posed a daunting question to the program: “How do 
you do it?” she asked. “How do you manage to keep giving the right answers, time 
after time, year after year?”
Chapter 8
198      PART 3  Working with the Big Picture: Object-Oriented Programming
“Clean living,” replied the program. “I swim 20 apps each day, I take C++ to Word 
off viruses, I avoid hogarithmic algorithms, I link Java in moderation, I say GNU 
to bugs, I don’t smoke to back up, and I never byte off more than I can queue.”
Needless to say, the princess was stunned. Defining a Class (What It Means to  
Be an Employee)
Wouldn’t it be nice if every piece of software did just what you wanted it to do? In 
an ideal world, you could buy a program, make it work right away, plug it seam-
lessly into new situations, and update it easily whenever your needs change. Unfortunately, software of this kind doesn’t exist. (Nothing  of this kind exists.) 
The truth is that no matter what you want to do, you can find software that does 
some of it, but not all of it. This is one of the reasons why object-oriented programming has been successful. For years, companies were buying prewritten code, only to discover that the code 
didn’t do what they wanted it to do. So, what did the companies do about it? They 
started messing with the code. Their programmers dug deep into the program 
files, changed variable names, moved subprograms around, reworked formulas, 
and generally made the code worse. The reality was that if a program didn’t 
already do what you wanted it to do (even if it did something ever so close to what 
you wanted), you could never improve the situation by mucking around inside the 
code. The best option was always to chuck the whole program (expensive as that 
was) and start all over again. What a sad state of affairs! With object-oriented programming, a big change has come about. At its heart, an 
object-oriented program is made to be modified. With correctly written software, 
you can take advantage of features that are already built-in, add new features of 
your own, and override features that don’t suit your needs. And the best part is 
that the changes you make are clean. No clawing and digging into other people’s 
brittle program code. Instead, you make nice, orderly additions and modifications 
without touching the existing code’s internal logic. It’s the ideal solution. The last word on employees
When you write an object-oriented program, you start by thinking about the data. You’re writing about accounts. So what’s an account? You’re writing code to han-
dle button clicks. So what’s a button? You’re writing a program to send payroll 
checks to employees. What’s an employee? CHAPTER 8  Saving Time and Money: Reusing Existing Code      199
In this chapter’s first example, an employee is someone with a name and a job 
title. Sure, employees have other characteristics, but for now I stick to the basics. The code in Listing 8-1 defines what it means to be an employee. LISTING 8-1: What Is an Employee? import static java.lang.System.out;
public class Employee {
    private String name;
    private String jobTitle;
    public void setName(String nameIn) {
        name = nameIn;
    }
    public String getName() {
        return name;
    }
    public void setJobTitle(String jobTitleIn) {
        jobTitle = jobTitleIn;
    }
    public String getJobTitle() {
        return jobTitle;
    }
    public void cutCheck(double amountPaid) {
        out.printf("Pay to the order of %s ", name);
        out.printf("(%s) ***$", jobTitle);
        out.printf("%,.2f\n", amountPaid);
    }
}
According to Listing 8-1, each employee has seven features. Two of these features 
are fairly simple: Each employee has a name and a job title. (In Listing 8-1, the 
Employee class has a name field and a jobTitle field.)
And what else does an employee have? Each employee has four methods to handle 
the values of the employee’s name and job title. These methods are setName, 
getName, setJobTitle, and getJobTitle. I explain methods like these (accessor  
methods) in Chapter 7. 200      PART 3  Working with the Big Picture: Object-Oriented Programming
On top of all of that, each employee has a cutCheck method. The idea is that the 
method that writes payroll checks has to belong to one class or another. Because 
most of the information in the payroll check is customized for a particular 
employee, you may as well put the cutCheck method inside the Employee class. For details about the printf calls in the cutCheck method, see the section  “Cutting 
a check,” later in this chapter. Putting your class to good use
The Employee class in Listing 8-1 has no main method, so there’s no starting point 
for executing code. To fix this deficiency, the programmer writes a separate pro-
gram with a main method and uses that program to create Employee instances. Listing  8-2 shows a class with a main method  — one that puts the code in 
 Listing 8-1 to the test. LISTING 8-2: Writing Payroll Checks
import java.util.Scanner;
import java.io.File;
import java.io.IOException;
public class DoPayroll {
    public static void main(String args[]) throws IOException {
        Scanner diskScanner = new Scanner(new File("EmployeeInfo.txt"));
        for (int empNum = 1; empNum <= 3; empNum++) {
            payOneEmployee(diskScanner);
        }
        diskScanner.close();
    }
    static void payOneEmployee(Scanner aScanner) {
        Employee anEmployee = new Employee();
        anEmployee.setName(aScanner.nextLine());
        anEmployee.setJobTitle(aScanner.nextLine());
        anEmployee.cutCheck(aScanner.nextDouble());
        aScanner.nextLine();
    }
}
CHAPTER 8  Saving Time and Money: Reusing Existing Code      201
(continued)
WHERE ON EARTH DO YOU LIVE? Grouping separators vary from one country to another. This makes a big difference 
when you try to read double values using Java’s Scanner class. To see what I mean, 
have a serious look at the following JShell session. jshell> import java.util.Scanner
jshell> import java.util.Locale
jshell> Scanner keyboard = new Scanner(System.in)
keyboard ==> java.util.Scanner[delimiters=\p{javaWhitespace}+] ... \E]
[infinity string=\Q8\E]
jshell> keyboard.nextDouble()
1000.00
$4 ==> 1000.0
jshell> Locale.setDefault(Locale.FRANCE)
jshell> keyboard = new Scanner(System.in)
keyboard ==> java.util.Scanner[delimiters=\p{javaWhitespace}+] ... \E]
[infinity string=\Q8\E]
jshell> keyboard.nextDouble()
1000,00
$7 ==> 1000.0
jshell> keyboard.nextDouble()
1000.00
|  java.util.InputMismatchException thrown:
|        at Scanner.throwFor (Scanner.java:860)
|        at Scanner.next (Scanner.java:1497)
|        at Scanner.nextDouble (Scanner.java:2467)
|        at (#8:1)
jshell>
I conducted this session on a computer in the United States. The country of origin is rel-
evant because, in response to the first keyboard.nextDouble() call, I type 1000.00 
(with a period before the last two zeros) and Java accepts this as meaning “one thou-
sand.”
But then, in the JShell session, I call Locale.setDefault(Locale.FRANCE), which tells 
Java to behave as if my computer is in France. When I create another Scanner instance 
202      PART 3  Working with the Big Picture: Object-Oriented Programming
To run the code in Listing  8-2, your hard drive must contain a file named 
EmployeeInfo.txt. Fortunately, the stuff that you download from this book’s 
website ( www.allmycode.com/JavaForDummies) comes with an EmployeeInfo. txt file. You can import the downloaded material into any of the three most 
(continued)
and call keyboard.nextDouble() again, Java accepts 1000,00 (with a comma before 
the last two zeros) as an expression meaning mille (French for “one thousand”). What’s 
more, Java no longer accepts the period in 1000.00. When I type 1000.00 (with a 
period) I get an InputMismatchException. By default, your computer’s Scanner instance wants you to input double numbers the 
way you normally type them in your country. If you type numbers according to another 
country’s convention, you get an InputMismatchException. So, when you run the 
code in Listing 8-2, the numbers in your EmployeeInfo.txt file must use your coun-
try’s format. This brings me to the running of the code in Listing 8-2. The EmployeeInfo.txt file 
that you download from this book’s website starts with the following three lines:
Barry Burd
CEO
5000.00
That last number 5000.00 has a period in it, so if your country prefers a comma in 
place of my United States period, you get an InputMismatchException. In response 
to this, you have two choices:
• In the downloaded EmployeeInfo.txt file, change the periods to commas. • In the code of Listing 8-2, add the statement Locale.setDefault(Locale.US) 
before the diskScanner declaration. And finally, if you want your output to look like your own country’s numbers, you can do 
it with Java’s Formatter class. Add something like this to your code:
out.print( 
new java.util.Formatter().format(java.util.Locale.FRANCE, "%,.2f", 1000.00));
For all the details, see the API (Application Programming Interface) documentation for 
Java’s Formatter class (https://docs.oracle.com/javase/8/docs/api/java/
util/Formatter.html and Locale class (https://docs.oracle.com/javase/8/
docs/api/java/util/Locale.html). CHAPTER 8  Saving Time and Money: Reusing Existing Code      203
popular Java IDEs (Eclipse, NetBeans, or IntelliJ IDEA).

--- Chunk #701 ---
If you import into Eclipse, 
you get a project named 08-01. That project typically lives on your hard drive in a 
folder named /Users/your-user-name/workspace/08-01. Directly inside that 
folder, you have a file named EmployeeInfo.txt. For more words of wisdom about files on your hard drive, see the “Working with 
Disk Files (a Brief Detour)” section in this chapter. The DoPayroll class in Listing 8-2 has two methods. One of the methods, main, 
calls the other method, payOneEmployee, three times. Each time around, the 
payOneEmployee method gets stuff from the EmployeeInfo.txt file and feeds 
this stuff to the Employee class’s methods. Here’s how the variable name anEmployee is reused and recycled:
 » The first time that payOneEmployee is called, the statement anEmployee = 
new Employee() makes anEmployee refer to a new object. » The second time that payOneEmployee is called, the computer executes the 
same statement again. This second execution creates a new incarnation of the 
anEmployee variable that refers to a brand-new object. » The third time around, all the same stuff happens again. A new anEmployee 
variable ends up referring to a third object. The whole story is pictured in Figure 8-1. FIGURE 8-1: 
Three calls to 
the payOne 
Employee 
method. 204      PART 3  Working with the Big Picture: Object-Oriented Programming
There are always interesting things for you to try:
 » A PlaceToLive has an address, a number of bedrooms, and an area (in 
square feet or square meters). Write the PlaceToLive class’s code. Write code 
for a separate class named DisplayThePlaces. Your DisplayThePlaces 
class creates a few PlaceToLive instances by assigning values to their 
address, numberOfBedrooms, and area fields. The DisplayThePlaces class 
also reads (from the keyboard) the cost of living in each place. For each place, 
your code displays the cost per square foot (or square meter) and the cost 
per bedroom. » Use your new PlaceToLive class and my DummiesFrame class (from 
Chapter 7) to create a GUI application. The GUI application takes information 
about a place to live and displays the place’s cost per square foot (or meter) 
and the cost per bedroom. Cutting a check
Listing 8-1 has three printf calls. Each printf call has a format string (like "(%s) 
***$") and a variable (like jobTitle). Each format string has a placeholder (like 
%s) that determines where and how the variable’s value is displayed. For example, in the second printf call, the format string has a %s placeholder. This %s holds a place for the jobTitle variable’s value. According to Java’s rules, 
the notation %s always holds a place for a string and, sure enough, the variable 
jobTitle is declared to be of type String in Listing 8-1. Parentheses and some 
other characters surround the %s placeholder, so parentheses surround each job 
title in the program’s output. (See Figure 8-2.)
Back in Listing 8-1, notice the comma inside the %,.2f placeholder. The comma 
tells the program to use grouping separators. That’s why, in Figure 8-2, you see 
$5,000.00, $7,000.00, and $10,000.00 instead of $5000.00, $7000.00, and 
$10000.00. FIGURE 8-2: 
Everybody 
gets paid. CHAPTER 8  Saving Time and Money: Reusing Existing Code      205
Working with Disk Files (a Brief Detour)
In previous chapters, programs read characters from the computer’s keyboard. But the code in Listing 8-2 reads characters from a specific file. The file (named 
EmployeeInfo.txt) lives on your computer’s hard drive. This EmployeeInfo.txt file is like a word processing document. The file can con-
tain letters, digits, and other characters. But unlike a word processing document, 
the EmployeeInfo.txt file contains no formatting — no italics, no bold, no font 
sizes, nothing of that kind. The EmployeeInfo.txt file contains only ordinary characters — the kinds of key-
strokes that you type while you play a guessing game from Chapters 5 and 6. Of 
course, getting guesses from a user’s keyboard and reading employee data from a 
disk file aren’t exactly the same. In a guessing game, the program displays 
prompts, such as Enter an int from 1 to 10 . The game program conducts a 
back-and-forth dialogue with the person sitting at the keyboard. In contrast, 
Listing  8-2 has no dialogue. This DoPayroll program reads characters from a 
hard drive and doesn’t prompt or interact with anyone. Most of this chapter is about code reuse. But Listing 8-2 stumbles upon an impor-
tant idea — an idea that’s not directly related to code reuse. Unlike the examples 
in previous chapters, Listing 8-2 reads data from a stored disk file. So, in the fol-
lowing sections, I take a short side trip to explore disk files. Storing data in a file
The code in Listing 8-2 doesn’t run unless you have some employee data sitting 
in a file. Listing 8-2 says that this file is EmployeeInfo.txt. So, before running 
the code of Listing 8-2, I created a small EmployeeInfo.txt file. The file is shown 
in Figure 8-3; refer to Figure 8-2 for the resulting output. When you visit this book’s website ( www.allmycode.com/JavaForDummies) and 
you download the book’s code listings, you get a copy of the EmployeeInfo.txt file. FIGURE 8-3: 
An Employee 
Info.txt file. 206      PART 3  Working with the Big Picture: Object-Oriented Programming
To keep Listing 8-2 simple, I insist that, when you type the characters in Figure 8-3, 
you finish up by typing 10000.00 and then pressing Enter. (Look again at Figure 8-3 
and notice how the cursor is at the start of a brand-new line.) If you forget to finish 
by pressing Enter, the code in Listing 8-2 will crash when you try to run it. Grouping separators vary from one country to another. The file shown in Figure 8-3 
works on a computer configured in the United States where 5000.00 means “five 
thousand.” But the file doesn’t work on a computer that’s configured in what I call 
a “comma country” — a country where 5000,00 means “five thousand.” If you live 
in a comma country, be sure to read this chapter’s “Where on Earth do you live?” 
sidebar. This book’s website ( www.allmycode.com/JavaForDummies) has tips for readers 
who need to create data files. This includes instructions for Windows, Linux, and 
Macintosh environments. Copying and pasting code
In almost any computer programming language, reading data from a file can be 
tricky. You add extra lines of code to tell the computer what to do. Sometimes you 
can copy and paste these lines from other peoples’ code. For example, you can 
follow the pattern in Listing 8-2:
/*
 * The pattern in Listing 8-2
 */
import java.util.Scanner;
import java.io.File;
import java.io.IOException;
class SomeClassName {
    public static void main(String args[]) throws IOException {
        Scanner scannerName = new Scanner(new File("SomeFileName"));
        //Some code goes here
        scannerName.nextInt();
        scannerName.nextDouble();
        scannerName.next();
        scannerName.nextLine();
CHAPTER 8  Saving Time and Money: Reusing Existing Code      207
        //Some code goes here
        scannerName.close();
    }
}
You want to read data from a file. You start by imagining that you’re reading from 
the keyboard. Put the usual Scanner and next codes into your program. Then add 
some extra items from the Listing 8-2 pattern:
 » Add two new import declarations — one for java.io.File and another for 
java.io.IOException. » Type throws IOException in your method’s header. » Type new File(" ") in your call to new Scanner. » Take a file that’s already on your hard drive. Type that filename inside the 
quotation marks. » Take the word that you use for the name of your scanner. Reuse that word in 
calls to next, nextInt, nextDouble, and so on. » Take the word that you use for the name of your scanner. Reuse that word in 
a call to close. Occasionally, copying and pasting code can get you into trouble. Maybe you’re 
writing a program that doesn’t fit the simple Listing 8-2 pattern. You need to 
tweak the pattern a bit. But to tweak the pattern, you need to understand some of 
the ideas behind the pattern. That’s how the next section comes to your rescue.

--- Chunk #702 ---
It covers some of these ideas.

--- Chunk #703 ---
This paragraph is actually a confession. In almost every computer programming 
language, input from a disk file is a nasty business. There’s no such thing as a 
simple INPUT command. You normally have to set up a connection between the 
code and the disk device, prepare for possible trouble reading from the device, do 
your reading, convert the characters you read into the type of value that you want 
and, finally, break your connection with the disk device. It’s a big mess. That’s 
why, in this book, I rely on Java’s Scanner class. The Scanner class makes 
input  relatively painless. But, I admit, professional Java programmers hardly 
ever use the Scanner class to do input. Instead, they use something called a 
BufferedReader or classes in the java.nio package. If you’re not content 
with my use of the Scanner class and you want to see Listing 8-2 translated into 
a BufferedReader program, visit this book’s website ( www.allmycode.com/
JavaForDummies). 208      PART 3  Working with the Big Picture: Object-Oriented Programming
Reading from a file
In previous chapters, programs read characters from the computer’s keyboard. These programs use things like Scanner, System.in, and nextDouble — things 
defined in Java’s API. The DoPayroll program in Listing 8-2 puts a new spin on 
this story. Rather than read characters from the keyboard, the program reads 
characters from the EmployeeInfo.txt file. The file lives on your computer’s hard 
drive. To read characters from a file, you use some of the same things that help you read 
characters from the keyboard. You use Scanner, nextDouble, and other goodies. But in addition to these goodies, you have a few extra hurdles to jump. Here’s a list:
 » You need a new File object. To be more precise, you need a new instance of 
the API’s File class. You get this new instance with code like
new File("EmployeeInfo.txt")
The stuff in quotation marks is the name of a file — a file on your computer’s 
hard drive. The file contains characters like those shown previously in 
Figure 8-3. At this point, the terminology makes mountains out of molehills. Sure, I use 
the phrases new File object and new File instance, but all you’re doing is making 
new File("EmployeeInfo.txt") stand for a file on your hard drive. After 
you shove new File("EmployeeInfo.txt") into new Scanner,
Scanner diskScanner = new Scanner(new File("EmployeeInfo.txt"));
you can forget all about the new File business. From that point on in the 
code, diskScanner stands for the EmployeeInfo.txt filename on your 
computer’s hard drive. (The name diskScanner stands for a file on your hard 
drive just as, in previous examples, the name keyboard stands for those 
buttons you press day in and day out.)
Creating a new File object in Listing 8-2 is like creating a new Employee 
object later in the same listing. It’s also like creating a new Account object in 
the examples of Chapter 7. The only difference is that the Employee and 
Account classes are defined in this book’s examples. The File class is defined 
in Java’s API. When you connect to a disk file with new Scanner, don’t forget the new File 
part. If you write new Scanner("EmployeeInfo.txt") without new File, 
the compiler won’t mind. (You don’t get any warnings or error messages 
before you run the code.) But when you run the code, you don’t get anything 
like the results that you expect to get. CHAPTER 8  Saving Time and Money: Reusing Existing Code      209
 » You must refer to the File class by its full name: java.io.File. You can 
do this with an import declaration like the one in Listing 8-2. Alternatively, you 
can clutter your code with a statement like
Scanner diskScanner = new Scanner(new java.io.File("EmployeeInfo.txt"));
 » You need a throws IOException clause. Lots of things can go wrong when 
your program connects to EmployeeInfo.txt. For one thing, your hard drive 
may not have a file named EmployeeInfo.txt. For another, the file 
EmployeeInfo.txt may be in the wrong directory. To brace for this kind of 
calamity, the Java programming language takes certain precautions. The 
language insists that when a disk file is involved, you acknowledge the 
possible dangers of calling new Scanner. You can acknowledge the hazards in several possible ways, but the simplest 
way is to use a throws clause. In Listing 8-2, the main method’s header ends 
with the words throws IOException. By adding these two words, you appease 
the Java compiler. It’s as if you’re saying “I know that calling new Scanner can 
lead to problems. You don’t have to remind me.” And, sure enough, adding 
throws IOException to your main method keeps the compiler from 
complaining. (Without this throws clause, you get an unreported exception 
error message.)
For the full story on Java exceptions, read Chapter 13. In the meantime, add 
throws IOException to the header of any method that calls new 
Scanner(new File( ... . » You must refer to the IOException class by its full name: java. io.IOException. You can do this with an import declaration like the one in Listing 8-2. Alternatively, you can enlarge the main method’s throws clause:
public static void main(String args[])throws java.io.IOException {
 » You must pass the file scanner’s name to the payOneEmployee method. In Listing 7-5 in Chapter 7, the getInterest method has a parameter named 
percentageRate. Whenever you call the getInterest method, you hand an 
extra, up-to-date piece of information to the method. (You hand a number — 
an interest rate — to the method. Figure 7-7 illustrates the idea.)
The same thing happens in Listing 8-2. The payOneEmployee method has a 
parameter named aScanner. Whenever you call the payOneEmployee method, 
you hand an extra, up-to-date piece of information to the method. (You hand 
a scanner — a reference to a disk file — to the method.)
210      PART 3  Working with the Big Picture: Object-Oriented Programming
You may wonder why the payOneEmployee method needs a parameter. After all, in 
Listing 8-2, the payOneEmployee method always reads data from the same file. Why bother informing this method, each time you call it, that the disk file is still 
the EmployeeInfo.txt file? Well, there are plenty of ways to shuffle the code in Listing 8-2. Some ways don’t 
involve a parameter. But the way that this example has arranged things, you have 
two separate methods: a main method and a payOneEmployee method. You create 
a scanner once inside the main method and then use the scanner three times — 
once inside each call to the payOneEmployee method. Anything you define inside a method is like a private joke that’s known only to the 
code inside that method. So the diskScanner that you define inside the main 
method isn’t automatically known inside the payOneEmployee method. To make 
the payOneEmployee method aware of the disk file, you pass diskScanner from 
the main method to the payOneEmployee method. To read more about things that you declare inside (and outside) of methods, see 
Chapter 10.

--- Chunk #704 ---
Who moved my file? When you download the code from this book’s website ( www.allmycode.com/
JavaForDummies), you’ll find files named Employee.java and DoPayroll.java —  
the code in Listings 8-1 and 8-2. You’ll also find a file named EmployeeInfo.txt. That’s good because, if Java can’t find the EmployeeInfo.txt file, the whole proj-
ect doesn’t run properly. Instead, you get a FileNotFoundException. In general, when you get a FileNotFoundException, some file that your program 
needs isn’t available to it. This is an easy mistake to make. It can be frustrating 
because, to you, a file such as EmployeeInfo.txt may look like it’s available to 
your program. But remember: Computers are stupid. If you make a tiny mistake, 
the computer can’t read between the lines for you. So, if your EmployeeInfo.txt 
file isn’t in the right directory on your hard drive or the filename is spelled incor-
rectly, the computer chokes when it tries to run your code. Sometimes you know darn well that an EmployeeInfo.txt (or whatever.xyz) file 
exists on your hard drive. But when you run your program, you still get a mean-
looking FileNotFoundException. When this happens, the file is usually in the 
wrong directory on your hard drive. (Of course, it depends on your point of view. Maybe the file is in the right directory, but your Java program is looking for the 
CHAPTER 8  Saving Time and Money: Reusing Existing Code      211
file in the wrong directory.) To diagnose this problem, add the following code to 
Listing 8-2:
File employeeInfo = new File("EmployeeInfo.txt");
System.out.println("Looking for " + employeeInfo.getCanonicalPath());
When you run the code, Java tells you where, on your hard drive, the Employee 
Info.txt file should be. Adding directory names to your filenames
You can specify a file’s exact location in your Java code. Code like new File("C:\\
Users\\bburd\\workspace\\08-01\\EmployeeInfo.txt") looks really ugly, but 
it works. In the preceding paragraph, did you notice the double backslashes in “ C: \\
Users\\bburd\\workspace ...”? If you’re a Windows user, you’d be tempted to 
write C:\Users\bburd\workspace ... with single backslashes. But in Java, the 
single backslash has its own, special meaning. (For example, back in Listing 7-7, 
\n means to go to the next line.) So, in Java, to indicate a backslash inside a quoted 
string, you use a double backslash instead. Macintosh and Linux users might find comfort in the fact that their path separa-
tor, /, has no special meaning in a Java string. On a Mac, the code new File("/
Users/bburd/workspace/08-01/EmployeeInfo.txt") is as normal as breathing. (Well, it’s almost that normal!) But Mac users and Linux wonks shouldn’t claim 
superiority too quickly. Lines such as new File("/Users/bburd/workspace ... work in Windows as well. In Windows, you can use either a slash (/) or a backslash 
(\) as the path name separator. At the Windows command prompt, I can type cd 
c:/users\bburd to get to my home directory. If you know where your Java program looks for files, you can worm your way from 
that place to the directory of your choice. Assume, for the moment, that the code 
in Listing 8-2 normally looks for the EmployeeInfo.txt file in a directory named 
08-01. As an experiment, go to the 08-01 directory and create a new subdirectory 
named dataFiles. Then move my EmployeeInfo.txt file to the new dataFiles 
directory. To read numbers and words from the file that you moved, modify 
 Listing 8-2 with the code new File("dataFiles\\EmployeeInfo.txt") or new 
File("dataFiles/EmployeeInfo.txt"). 212      PART 3  Working with the Big Picture: Object-Oriented Programming
Reading a line at a time
In Listing  8-2, the payOneEmployee method illustrates some useful tricks for 
reading data. In particular, every scanner that you create has a nextLine method. (You might not use this nextLine method, but the method is available nonethe -
less.) When you call a scanner’s nextLine method, the method grabs everything 
up to the end of the current line of text. In Listing 8-2, a call to nextLine can read 
a whole line from the EmployeeInfo.txt file. (In another program, a scanner’s 
nextLine call may read everything the user types on the keyboard up to the press-
ing of the Enter key.)
Notice my careful choice of words: nextLine reads everything “up to the end of 
the current line.” Unfortunately, what it means to read up to the end of the cur -
rent line isn’t always what you think it means. Intermingling nextInt, next 
Double, and nextLine calls can be messy. You have to watch what you’re doing 
and check your program’s output carefully. To understand all of this, you need to be painfully aware of a data file’s line breaks. Think of a line break as an extra character, stuck between one line of text and the 
next. Then imagine that calling nextLine means to read everything up to and 
including the next line break. Now take a look at Figure 8-4:
 » If one call to nextLine reads Barry Burd[LineBreak], the subsequent call 
to nextLine reads CEO[LineBreak]. » If one call to nextDouble reads the number 5000.00, the subsequent call to 
nextLine reads the [LineBreak] that comes immediately after the number 
5000.00. (That’s all the nextLine reads — a [LineBreak] and nothing more.)
 » If a call to nextLine reads the [LineBreak] after the number 5000.00, the 
subsequent call to nextLine reads Harriet Ritter[LineBreak]. So, after reading the number 5000.00, you need two calls to nextLine in order to 
scoop up the name Harriet Ritter. The mistake that I usually make is to forget the 
first of those two calls. Look again at the file in Figure 8-3. For this section’s code to work correctly, you 
must have a line break after the last 10000.00. If you don’t, a final call to  nextLine 
makes your program crash and burn. The error message reads NoSuchElement 
Exception: No line found. CHAPTER 8  Saving Time and Money: Reusing Existing Code      213
I’m always surprised by the number of quirks that I find in each programming 
language’s scanning methods. For example, the first nextLine that reads from 
the file in Figure  8-3 devours Barry Burd[LineBreak] from the file. But that 
nextLine call delivers Barry Burd (with no line break) to the running code. So 
nextLine looks for a line break, and then nextLine loses the line break. Yes, this 
is a subtle point. And no, this subtle point hardly ever causes problems for 
anyone. If this business about nextDouble and nextLine confuses you, please don’t put 
the blame on Java. Mixing input calls is delicate work in any computer program-
ming language. And the really nasty thing is that each programming language 
approaches the problem a little differently. What you find out about nextLine in 
Java helps you understand the issues when you get to know C++ or Visual Basic, 
but it doesn’t tell you all the details. Each language’s details are unique to that 
language.

--- Chunk #705 ---
(Yes, it’s a big pain. But because all computer programmers become rich 
and famous, the pain eventually pays off.)
Closing the connection to a disk file
To the average computer user, a keyboard doesn’t feel anything like a file stored 
on a computer’s hard drive. But disk files and keyboard input have a lot in com-
mon. In fact, a basic principle of computer operating systems dictates that any 
differences between two kinds of input be, for the programmer, as blurry as pos-
sible. As a Java programmer, you should treat disk files and keyboard input almost 
the same way. That’s why Listing 8-2 contains a diskScanner.close() call. When you run a Java program, you normally execute the main method’s state-
ments, starting with the first statement in the method body and ending with the 
last statement in the method body. You take detours along the way, skipping past 
else parts and diving into method bodies, but basically you finish executing 
FIGURE 8-4: 
Calling next 
Double and 
nextLine. 214      PART 3  Working with the Big Picture: Object-Oriented Programming
statements at the end of the main method. That’s why, in Listing 8-2, the call to 
close is at the end of the main method’s body. When you run the code in 
 Listing 8-2, the last thing you do is disconnect from the disk file. And, fortu -
nately, that disconnection takes place after you’ve executed all the nextLine and 
nextDouble calls. Previously in this chapter, you create instances of your own PlaceToLive class 
and display information about those instances. Modify the text-based version of 
your code so that it gets each instance’s characteristics (address, number of bed-
rooms, and area) from a disk file. Defining Subclasses (What It Means to  
Be a Full-Time or Part-Time Employee)
This time last year, your company paid $10 million for a piece of software. That 
software came in the Employee.class file. People at Burd Brain Consulting (the 
company that created the software) don’t want you to know about the innards of 
the software. (Otherwise, you may steal their ideas.) So you don’t have the Java 
program file that the software came from. (In other words, you don’t have 
Employee.java.) You can run the bytecode in the Employee.class file. You can 
also read the documentation in a web page named Employee.html. But you can’t see 
the statements inside the Employee.java program, and you can’t change any of 
the program’s code. Since this time last year, your company has grown. Unlike in the old days, your 
company now has two kinds of employees: full-time and part-time. Each full-time 
employee is on a fixed, weekly salary. (If the employee works nights and weekends, 
then in return for this monumental effort, the employee receives a hearty hand-
shake.) In contrast, each part-time employee works for an hourly wage. Your com-
pany deducts an amount from each full-time employee’s paycheck to pay for the 
company’s benefits package. Part-time employees, however, don’t get benefits. The question is whether the software that your company bought last year can keep 
up with the company’s growth. You invested in a great program to handle employ-
ees and their payroll, but the program doesn’t differentiate between your full-
time and part-time employees. You have several options:
 » Call your next-door neighbor, whose 12-year-old child knows more about 
computer programming than anyone in your company. Get this uppity 
CHAPTER 8  Saving Time and Money: Reusing Existing Code      215
little brat to take the employee software apart, rewrite it, and hand it back to 
you with all the changes and additions your company requires. On second thought, you can’t do that. No matter how smart that kid is, the 
complexities of the employee software will probably confuse the kid. By the 
time you get the software back, it’ll be filled with bugs and inconsistencies. Besides, you don’t even have the Employee.java file to hand to the kid. All 
you have is the Employee.class file, which can’t be read or modified with a 
text editor. (See Chapter 2.) Besides, your kid just beat up the neighbor’s kid. You don’t want to give your neighbor the satisfaction of seeing you beg for the 
whiz kid’s help. » Scrap the $10 million employee software. Get someone in your company to 
rewrite the software from scratch. In other words, say goodbye to your time and money. » Write a new front end for the employee software. That is, build a piece of 
code that does some preliminary processing on full-time employees and then 
hands the preliminary results to your $10 million software. Do the same for 
part-time employees. This idea could be decent or spell disaster. Are you sure that the existing 
employee software has convenient hooks in it? (That is, does the employee 
software contain entry points that allow your front-end software to easily 
send preliminary data to the expensive employee software?) Remember: This 
plan treats the existing software as one big, monolithic lump, which can 
become cumbersome. Dividing the labor between your front-end code and 
the existing employee program is difficult. And if you add layer upon layer to 
existing black box code, you’ll probably end up with a fairly inefficient system. » Call Burd Brain Consulting, the company that sold you the employee 
software. Tell Dr. Burd that you want the next version of his software to 
differentiate between full-time and part-time employees. “No problem,” says Dr. Burd. “It’ll be ready by the start of the next fiscal 
quarter.” That evening, Dr. Burd makes a discreet phone call to his next-door 
neighbor. .

--- Chunk #706 ---
.

--- Chunk #707 ---
. » Create two new Java classes named FullTimeEmployee and 
PartTimeEmployee. Have each new class extend the existing functionality of 
the expensive Employee class, but have each new class define its own, 
specialized functionality for certain kinds of employees. Way to go! Figure 8-5 shows the structure that you want to create. 216      PART 3  Working with the Big Picture: Object-Oriented Programming
Creating a subclass
In Listing 8-1, I define an Employee class. I can use what I define in Listing 8-1 and 
extend the definition to create new, more specialized classes. So, in Listing 8-3, 
I define a new class: a FullTimeEmployee class. LISTING 8-3: What Is a FullTimeEmployee? public class FullTimeEmployee extends Employee {
    private double weeklySalary;
    private double benefitDeduction;
    public void setWeeklySalary(double weeklySalaryIn) {
        weeklySalary = weeklySalaryIn;
    }
    public double getWeeklySalary() {
        return weeklySalary;
    }
    public void setBenefitDeduction(double benefitDedIn) {
        benefitDeduction = benefitDedIn;
    }
    public double getBenefitDeduction() {
        return benefitDeduction;
    }
    public double findPaymentAmount() {
        return weeklySalary - benefitDeduction;
    }
}
FIGURE 8-5: 
The Employee 
class family tree. CHAPTER 8  Saving Time and Money: Reusing Existing Code      217
Looking at Listing 8-3, you can see that each instance of the FullTimeEmployee 
class has two fields: weeklySalary and benefitDeduction. But are those the only 
fields that each FullTimeEmployee instance has? No, they’re not. The first line of 
Listing 8-3 says that the FullTimeEmployee class extends the existing Employee 
class. This means that in addition to having a weeklySalary and a benefit 
Deduction, each FullTimeEmployee instance also has two other fields: name and 
jobTitle. These two fields come from the definition of the Employee class, which 
you can find in Listing 8-1. In Listing  8-3, the magic word is extends. When one class extends an existing 
class, the extending class automatically inherits functionality that’s defined in the 
existing class. So, the FullTimeEmployee class inherits  the name and jobTitle 
fields. The FullTimeEmployee class also inherits all the methods that are declared 
in the Employee class: setName, getName, setJobTitle, getJobTitle, and 
cutCheck. The FullTimeEmployee class is a subclass of the Employee class. That 
means the Employee class is the superclass of the FullTimeEmployee class. You can 
also talk in terms of blood relatives: The FullTimeEmployee class is the child of the 
Employee class, and the Employee class is the parent of the FullTimeEmployee 
class. It’s almost (but not quite) as if the FullTimeEmployee class were defined by the 
code in Listing 8-4. LISTING 8-4: Fake (But Informative) Code
import static java.lang.System.out;
public class FullTimeEmployee {
    private String name;
    private String jobTitle;
    private double weeklySalary;
    private double benefitDeduction;
    public void setName(String nameIn) {
        name = nameIn;
    }
    public String getName() {
        return name;
    }
    public void setJobTitle(String jobTitleIn) {
        jobTitle = jobTitleIn;
    }
(continued)
218      PART 3  Working with the Big Picture: Object-Oriented Programming
    public String getJobTitle() {
        return jobTitle;
    }
    public void setWeeklySalary(double weeklySalaryIn) {
        weeklySalary = weeklySalaryIn;
    }
    public double getWeeklySalary() {
        return weeklySalary;
    }
    public void setBenefitDeduction(double benefitDedIn) {
        benefitDeduction = benefitDedIn;
    }
    public double getBenefitDeduction() {
        return benefitDeduction;
    }
    public double findPaymentAmount() {
        return weeklySalary - benefitDeduction;
    }
    public void cutCheck(double amountPaid) {
        out.printf("Pay to the order of %s ", name);
        out.printf("(%s) ***$", jobTitle);
        out.printf("%,.2f\n", amountPaid);
    }
}
Why does the title for Listing  8-4 call that code fake? (Should the code feel 
insulted?) Well, the main difference between Listing 8-4 and the inheritance situ-
ation in Listings  8-1 and  8-3 is this: A child class can’t directly reference the 
private fields of its parent class.

--- Chunk #708 ---
To do anything with the parent class’s private 
fields, the child class has to call the parent class’s accessor methods. Back in 
 Listing 8-3, calling setName("Rufus") would be legal, but the code name="Rufus" 
wouldn’t be. If you believe everything you read in Listing 8-4, you’d think that 
code in the FullTimeEmployee class can do name="Rufus". Well, it can’t. (My, 
what a subtle point this is!)
You don’t need the Employee.java file on your hard drive to write code that 
extends the Employee class. All you need is the file Employee.class. LISTING 8-4: (continued)
CHAPTER 8  Saving Time and Money: Reusing Existing Code      219
Creating subclasses is habit-forming
After you’re accustomed to extending classes, you can get extend-happy. If you 
created a FullTimeEmployee class, you might as well create a PartTimeEmployee 
class, as shown in Listing 8-5. LISTING 8-5: What Is a PartTimeEmployee? public class PartTimeEmployee extends Employee {
    private double hourlyRate;
    public void setHourlyRate(double rateIn) {
        hourlyRate = rateIn;
    }
    public double getHourlyRate() {
        return hourlyRate;
    }
    public double findPaymentAmount(int hours) {
        return hourlyRate * hours;
    }
}
Unlike the FullTimeEmployee class, PartTimeEmployee has no salary or deduc-
tion. Instead PartTimeEmployee has an hourlyRate field. (Adding a numberOf 
HoursWorked field would also be a possibility. I chose not to do this, figuring 
that  the number of hours a part-time employee works will change drastically 
from week to week.)
Using Subclasses
The preceding section tells a story about creating subclasses. It’s a good story, but 
it’s incomplete. Creating subclasses is fine, but you gain nothing from these sub-
classes unless you write code to use them. So in this section, you explore code that 
uses subclasses. Now the time has come for you to classify yourself as either a type-F person, a 
type-P person, or a type-T person. (I’m this book’s author, so I get to make up 
some personality types. I can even point to someone in public and say, “Look! He’s a type-T person!”)
220      PART 3  Working with the Big Picture: Object-Oriented Programming
 » A type-F person wants to see the fundamentals. (The letter F stands for 
fundamentals.) “Show me a program that lays out the principles in their barest, 
most basic form,” says the type-F person. A type-F person isn’t worried about 
bells and whistles. The bells come later, and the whistles may never come. If 
you’re a type-F person, you want to see a program that uses the FullTime 
Employee and PartTimeEmployee subclasses and then moves out of your 
way so that you can get some work done. » A type-P person wants practical applications. (The letter P stands for practi-
cal.) Type-P people need to see ideas in context; otherwise, the ideas float 
away too quickly. “Show me a program that demonstrates the usefulness of 
the FullTimeEmployee and PartTimeEmployee subclasses,” says the type-P 
person. “I have no use for your stinking abstractions. I want real-life examples, 
and I want them now!”
 » A type-T person is inspired by something that I write about briefly in 
Chapter 7: The type-T person wants to test the code in the FullTimeEmployee 
and PartTimeEmployee subclasses. Testing the code means putting the 
code through its paces — checking the output’s accuracy when the input is 
ordinary, when the input is unexpected, and even when the input is com-
pletely unrealistic. What’s more, the type-T person wants to use a standard, 
easily recognizable outline for the testing code so that other programmers 
can quickly understand the test results. The type-T person creates JUnit tests 
that use the FullTimeEmployee and PartTimeEmployee subclasses. Listing 8-6, which is for the type-F crowd, is lean and simple and makes good 
bedtime reading. If you’re a type-P or type-T person, please visit this book’s website ( www. allmycode.com/JavaForDummies). The site contains examples to satisfy type-P 
and type-T readers. Listing 8-6 shows you a bare-bones program that uses the subclasses FullTime 
Employee and PartTimeEmployee. Figure 8-6 shows the program’s output. LISTING 8-6: Putting Subclasses to Good Use
public class DoPayrollTypeF {
  public static void main(String args[]) {
    FullTimeEmployee ftEmployee = new FullTimeEmployee();
    ftEmployee.setName("Barry Burd");
    ftEmployee.setJobTitle("CEO");
    ftEmployee.setWeeklySalary(5000.00);
CHAPTER 8  Saving Time and Money: Reusing Existing Code      221
    ftEmployee.setBenefitDeduction(500.00);
    ftEmployee.cutCheck(ftEmployee.findPaymentAmount());
    System.out.println();
    PartTimeEmployee ptEmployee = new PartTimeEmployee();
    ptEmployee.setName("Steve Surace");
    ptEmployee.setJobTitle("Driver");
    ptEmployee.setHourlyRate(7.53);
    ptEmployee.cutCheck(ptEmployee.findPaymentAmount(10));
  }
}
To understand Listing 8-6, you need to keep an eye on three classes: Employee, 
FullTimeEmployee, and PartTimeEmployee. (For a look at the code that defines 
these classes, see Listings 8-1, 8-3, and 8-5.)
The first half of Listing 8-6 deals with a full-time employee. Notice how many 
methods are available for use with the ftEmployee variable? For instance, you 
can call ftEmployee.setWeeklySalary because ftEmployee has type Full 
TimeEmployee. You can also call ftEmployee.setName because the FullTime 
Employee class extends the Employee class. Because cutCheck is declared in the Employee class, you can call ftEmployee. cutCheck. But you can also call ftEmployee.findPaymentAmount because a find 
PaymentAmount method is in the FullTimeEmployee class. Making types match
Look again at the first half of Listing  8-6. Take special notice of that last 
 statement — the one in which the full-time employee is actually cut a check. The 
statement forms a nice, long chain of values and their types. You can see this by 
reading the statement from the inside out:
 » Method ftEmployee.findPaymentAmount is called with an empty parameter 
list. (Refer to Listing 8-6.) That’s good because the findPaymentAmount 
method takes no parameters. (Refer to Listing 8-3.)
FIGURE 8-6: 
The output of the 
program in 
Listing 8-6. 222      PART 3  Working with the Big Picture: Object-Oriented Programming
 » The findPaymentAmount method returns a value of type double. (Again, refer 
to Listing 8-3.)
 » The double value that ftEmployee.findPaymentAmount returns is passed to 
method ftEmployee.cutCheck. (Refer to Listing 8-6.) That’s good because 
the cutCheck method takes one parameter of type double. (Refer to 
Listing 8-1.)
For a fanciful graphical illustration, see Figure 8-7. Always feed a method the value types that it wants in its parameter list. The second half of the story
In the second half of Listing  8-6, the code creates an object of type PartTime 
Employee. A variable of type PartTimeEmployee can do some of the same things a 
FullTimeEmployee variable can do. But the PartTimeEmployee class doesn’t have 
the setWeeklySalary and setBenefitDeduction methods. Instead, the Part 
TimeEmployee class has the setHourlyRate method. (See Listing  8-5.) So in 
 Listing 8-6 the next-to-last line is a call to the setHourlyRate method. The last line of Listing 8-6 is by far the most interesting. On that line, the code 
hands the number 10 (the number of hours worked) to the findPaymentAmount 
method. Compare this with the earlier call to findPaymentAmount  — the call 
for  the full-time employee in the first half of Listing  8-6. Between the two 
 subclasses, FullTimeEmployee and PartTimeEmployee, are two different 
FIGURE 8-7: 
Matching 
parameters. CHAPTER 8  Saving Time and Money: Reusing Existing Code      223
findPaymentAmount methods. The two methods have two different kinds of 
parameter lists:
 » The FullTimeEmployee class’s findPaymentAmount method takes no 
parameters (refer to Listing 8-3). » The PartTimeEmployee class’s findPaymentAmount method takes one int 
parameter (refer to Listing 8-5). This is par for the course. Finding the payment amount for a part-time employee 
isn’t the same as finding the payment amount for a full-time employee. A part-
time employee’s pay changes each week, depending on the number of hours the 
employee works in a week. The full-time employee’s pay stays the same each 
week. So the FullTimeEmployee and PartTimeEmployee classes both have find 
PaymentAmount methods, but each class’s method works quite differently. Yes, I have some things for you to try:
 » Previously in this chapter, you create instances of your own PlaceToLive 
class and display information about those instances. Create two subclasses of 
your PlaceToLive class: a House class and an Apartment class. Each House 
object has a mortgage cost (a monthly amount) and a property tax cost (a 
yearly amount). Each Apartment object has a rental cost (a monthly amount). A separate DisplayThePlaces class creates some houses and some apart-
ments. For each house or apartment, your DisplayThePlaces class displays 
the total cost per square foot (or square meter) and the total cost per 
bedroom, both calculated monthly. » In Chapter 7, you create an Organization class. Each instance of your 
Organization class has a name, an annual revenue amount, and a boolean 
value indicating whether the organization is or is not a profit-making 
organization. Create a new Organization_2.0 class. Each instance of this new class has 
only a name and an annual revenue amount. Create two subclasses: a 
ProfitMakingOrganization class and a NonProfitOrganization class. A profit-making organization pays 10 percent of its revenue in tax, but a 
nonprofit organization pays only 2 percent of its revenue in tax. Make a separate class that creates ProfitMakingOrganization instances 
and NonProfitOrganization instances while also displaying information 
about each instance, including the amount of tax the organization pays. 224      PART 3  Working with the Big Picture: Object-Oriented Programming
Overriding Existing Methods (Changing the 
Payments for Some Employees)
Wouldn’t you know it! Some knucklehead in the human resources department 
offered double pay for overtime to one of your part-time employees. Now word is 
getting around, and some of the other part-timers want double pay for their over-
time work. If this keeps up, you’ll end up in the poorhouse, so you need to send 
out a memo to all the part-time employees, explaining why earning more money 
is not to their benefit. In the meantime, you have two kinds of part-time employees — the ones who 
receive double pay for overtime hours and the ones who don’t — so you need to 
modify your payroll software. What are your options? » Well, you can dig right into the PartTimeEmployee class code, make a few 
changes, and hope for the best. (Not a good idea!)
 » You can follow the previous section’s advice and create a subclass of the 
existing PartTimeEmployee class. “But wait,” you say. “The existing 
PartTimeEmployee class already has a findPaymentAmount method. Do I 
need some tricky way of bypassing this existing findPaymentAmount method 
for each double-pay-for-overtime employee?”
At this point, you can thank your lucky stars that you’re doing object-oriented 
programming in Java. With object-oriented programming, you can create a 
subclass that overrides the functionality of its parent class. Listing 8-7 has just 
such a subclass. LISTING 8-7: Yet Another Subclass
public class PartTimeWithOver extends PartTimeEmployee {
    @Override
    public double findPaymentAmount(int hours) {
        if(hours <= 40) {
            return getHourlyRate() * hours;
        } else {
            return getHourlyRate() * 40 + getHourlyRate() * 2 * (hours - 40);
        }
    }
}
CHAPTER 8  Saving Time and Money: Reusing Existing Code      225
Figure  8-8 shows the relationship between the code in Listing  8-7 and other 
pieces of code in this chapter. In particular, PartTimeWithOver is a subclass of a 
subclass. In object-oriented programming, a chain of this kind is not the least bit 
unusual. In fact, as subclasses go, this chain is rather short. The PartTimeWithOver class extends the PartTimeEmployee class, but PartTime 
WithOver picks and chooses what it wants to inherit from the PartTimeEmployee 
class. Because PartTimeWithOver has its own declaration for the findPayment 
Amount method, the PartTimeWithOver class doesn’t inherit a findPayment 
Amount method from its parent. (See Figure 8-9.)
FIGURE 8-8: 
A tree of classes. FIGURE 8-9: 
Method 
findPayment 
Amount isn’t 
inherited. 226      PART 3  Working with the Big Picture: Object-Oriented Programming
According to the official terminology, the PartTimeWithOver class overrides  its 
parent class’s findPaymentAmount method. If you create an object from the 
PartTimeWithOver class, that object has the name, jobTitle, hourlyRate, and 
cutCheck of the PartTimeEmployee class, but the object has the findPayment 
Amount method that’s defined in Listing 8-7. A Java annotation
The word @Override in Listing 8-7 is an example of an annotation. A Java annota-
tion tells your computer something about your code. In particular, the @Override 
annotation in Listing 8-7 tells the Java compiler to be on the lookout for a com-
mon coding error. The annotation says, “Make sure that the method immediately 
following this annotation has the same stuff (the same name, the same parame -
ters, and so on) as one of the methods in the superclass. If not, then display an 
error message.”
So if I accidentally type
public double findPaymentAmount(double hours) {
instead of int hours as in Listings 8-5 and 8-7, the compiler reminds me that my 
new findPaymentAmount method doesn’t really override anything that’s in 
Listing 8-5. Java has other kinds of annotations (such as @Deprecated and @Suppress 
Warnings). You can read a bit about the @SuppressWarnings annotation in 
Chapter 9. Java’s annotations are optional. If you remove the word @Override from 
 Listing  8-7, your code still runs correctly. But the @Override annotation gives 
your code some added safety. With @Override, the compiler checks to make sure 
that you’re doing something you intend to do (namely, overriding one of the 
superclass’s methods). And with apologies to George Orwell, some types of anno-
tations are less optional than others. You can omit certain annotations from your 
code only if you’re willing to replace the annotation with lots and lots of unan-
notated Java code. Using methods from classes and subclasses
If you need clarification on this notion of overriding a method, look at the code in 
Listing 8-8.

--- Chunk #709 ---
A run of that code is shown in Figure 8-10. CHAPTER 8  Saving Time and Money: Reusing Existing Code      227
LISTING 8-8: Testing the Code from Listing 8-7
public class DoPayrollTypeF {
  public static void main(String args[]) {
    FullTimeEmployee ftEmployee = new FullTimeEmployee();
    ftEmployee.setName("Barry Burd");
    ftEmployee.setJobTitle("CEO");
    ftEmployee.setWeeklySalary(5000.00);
    ftEmployee.setBenefitDeduction(500.00);
    ftEmployee.cutCheck(ftEmployee.findPaymentAmount());
    PartTimeEmployee ptEmployee = new PartTimeEmployee();
    ptEmployee.setName("Chris Apelian");
    ptEmployee.setJobTitle("Computer Book Author");
    ptEmployee.setHourlyRate(7.53);
    ptEmployee.cutCheck(ptEmployee.findPaymentAmount(50));
    PartTimeWithOver ptoEmployee = new PartTimeWithOver();
    ptoEmployee.setName("Steve Surace");
    ptoEmployee.setJobTitle("Driver");
    ptoEmployee.setHourlyRate(7.53);
    ptoEmployee.cutCheck(ptoEmployee.findPaymentAmount(50));
  }
}
The code in Listing 8-8 writes checks to three employees. The first employee is a 
full-timer.

--- Chunk #710 ---
The second is a part-time employee who hasn’t yet gotten wind of the 
overtime payment scheme. The third employee knows about the overtime pay -
ment scheme and demands a fair wage. With the subclasses, all three of these employees coexist in Listing 8-8. Sure, one 
subclass comes from the old PartTimeEmployee class, but that doesn’t mean you 
can’t create an object from the PartTimeEmployee class. In fact, Java is smart 
FIGURE 8-10: 
Running the code 
of Listing 8-8. 228      PART 3  Working with the Big Picture: Object-Oriented Programming
about this. Listing  8-8 has three calls to the findPaymentAmount method, and 
each call reaches out to a different version of the method:
 » In the first call, ftEmployee.findPaymentAmount, the ftEmployee variable is 
an instance of the FullTimeEmployee class. So the method that’s called is the 
one in Listing 8-3. » In the second call, ptEmployee.findPaymentAmount, the ptEmployee 
variable is an instance of the PartTimeEmployee class. So the method that’s 
called is the one in Listing 8-5. » In the third call, ptoEmployee.findPaymentAmount, the ptoEmployee 
variable is an instance of the PartTimeWithOver class. So the method that’s 
called is the one in Listing 8-7. This code is fantastic.

--- Chunk #711 ---
It’s clean, elegant, and efficient. With all the money that 
you save on software, you can afford to pay everyone double for overtime hours. (Whether you do that or keep the money for yourself is another story.)
Here are some things for you to try. » In previous sections, you create House and Apartment subclasses of your 
PlaceToLive class. Create an ApartmentWithFees subclass of your 
Apartment class. In addition to the monthly rental price, someone living in an 
ApartmentWithFees pays a fixed amount every quarter (every three months). Create a separate class that displays the monthly cost of living in a House 
instance, an Apartment instance, and an ApartmentWithFees instance. » What output do you see when you run the following code? What does this 
output tell you about variable declarations and method calling in Java? public class Main {
    public static void main(String[] args) {
        MyThing myThing, myThing2;
        myThing = new MySubThing();
        myThing2 = new MyOtherThing();
        myThing.value = 7;
        myThing2.value = 44;
CHAPTER 8  Saving Time and Money: Reusing Existing Code      229
         myThing.display();
        myThing2.display();
    }
}
class MyThing {
    int value;
    public void display() {
        System.out.println("In MyThing, value is " + value);
    }
}
class MySubThing extends MyThing {
    @Override
    public void display() {
        System.out.println("in MySUBThing, value is " + value);
    }
}
class MyOtherThing extends MyThing {
    @Override
    public void display() {
        System.out.println("In MyOTHERThing, value is " + value);
    }
}
CHAPTER 9  Constructing New Objects      231
IN THIS CHAPTER
 » Defining constructors
 » Using constructors in subclasses
 » Using Java’s default constructor 
features
 » Constructing a simple GUI from 
scratch
Constructing New 
Objects
M
 
 
s. Jennie Burd
121 Schoolhouse Lane
Anywhere, Kansas
Dear Ms.

--- Chunk #712 ---
Burd,
In response to your letter of June 21, I believe I can say with complete assurance 
that objects are not created spontaneously from nothing. Although I’ve never 
actually seen an object being created (and no one else in this office can claim to 
have seen an object in its moment of creation), I have every confidence that some 
process or another is responsible for the building of these interesting and useful 
thingamajigs. We here at ObjectsAndClasses.com support the unanimous opinions 
of both the scientific community and the private sector in matters of this nature. Furthermore, we agree with the recent finding of a Blue Ribbon Presidential Panel, 
which concludes beyond any doubt that spontaneous object creation would impede 
the present economic outlook. Chapter 9
232      PART 3  Working with the Big Picture: Object-Oriented Programming
Please be assured that I have taken all steps necessary to ensure the safety and 
well-being of you, our loyal customer. If you have any further questions, please do 
not hesitate to contact our complaint department.

--- Chunk #713 ---
The department’s manager is 
Mr. Blake Wholl. You can contact him by visiting our company’s website. Once again, let me thank you for your concern, and I hope you continue to patron-
ize ObjectsAndClasses.com.

--- Chunk #714 ---
Yours truly,
Mr. Scott Brickenchicker
The one who couldn’t get on the elevator in Chapter 4
Defining Constructors (What It Means  
to Be a Temperature)
Here’s a statement that creates an object:
Account myAccount = new Account();
I know this works — I got it from one of my own examples in Chapter 7. Anyway, 
in Chapter 7 I say, “when Java executes new Account(), you’re creating an object 
by calling the Account class’s constructor.” What does this mean? Well, when you ask the computer to create a new object, the computer responds 
by performing certain actions. For starters, the computer finds a place in its 
memory to store information about the new object. If the object has fields, the 
fields should eventually have meaningful values. To find out about fields, see Chapter 7. One question is, when you ask the computer to create a new object, can you con-
trol what’s placed in the object’s fields? And what if you’re interested in doing 
more than filling fields? Perhaps, when the computer creates a new object, you 
have a whole list of jobs for the computer to carry out. For instance, when the 
computer creates a new window object, you want the computer to realign the sizes 
of all buttons in that window. CHAPTER 9  Constructing New Objects      233
Creating a new object can involve all kinds of tasks, so in this chapter you create 
constructors. A constructor tells the computer to perform a new object’s start-up 
tasks. What is a temperature? “Good morning, and welcome to Object News. The local temperature in your area 
is a pleasant 73 degrees Fahrenheit.”
Each temperature consists of two things: a number and a temperature scale. A 
number is just a double value, such as 32.0 or 70.52. But what’s a temperature 
scale? Is it a string of characters, like "Fahrenheit" or "Celsius"? Not really, 
because some strings aren’t temperature scales. There’s no "Quelploof" tem-
perature scale, and a program that can display the temperature "73 degrees 
Quelploof” is a bad program. So how can you limit the temperature scales to the 
small number of scales that people use? One way to do it is with Java’s enum type. What is a temperature scale? (Java’s enum type)
Java provides lots of ways for you to group things together. In Chapter 11, you 
group things to form an array. And in Chapter 12, you group things together to 
form a collection. In this chapter, you group things into an enum type. (Of course, 
you can’t group anything unless you can pronounce enum. The word enum is pro-
nounced “ee-noom,” like the first two syllables of the word enumeration.)
Creating a complicated enum type isn’t easy, but to create a simple enum type, just 
write a bunch of words inside a pair of curly braces. Listing 9-1 defines an enum 
type. The name of the enum type is TempScale. LISTING 9-1: The TempScale Type (an enum Type)
public enum TempScale {
    CELSIUS, FAHRENHEIT, KELVIN, RANKINE,
    NEWTON, DELISLE, RÉAUMUR, RØMER, LEIDEN
}
In Listing 9-1, I’m showing off my physics prowess by naming not two, not four, 
but nine different temperature scales. Some readers’ computers have trouble with 
the special characters in the words RÉAUMUR and RØMER. If you’re one of those 
readers, simply delete the words RÉAUMUR and RØMER from the code. I promise: It 
won’t mess up the example. 234      PART 3  Working with the Big Picture: Object-Oriented Programming
When you define an enum type, two important things happen:
 » You create values. Just as 13 and 151 are int values, CELSIUS and FAHRENHEIT are TempScale 
values. » You can create variables to refer to those values. In Listing 9-2, I declare the fields number and scale. Just as
double number;
declares that a number variable is of type double,
TempScale scale;
declares variable scale to be of type TempScale. “To be of type TempScale” means that you can have values CELSIUS, 
FAHRENHEIT, KELVIN, and so on. So, in Listing 9-2, I can give the scale 
variable the value FAHRENHEIT (or TempScale.FAHRENHEIT, to be more 
precise). An enum type is a Java class in disguise. That’s why Listing 9-1 contains an entire 
file devoted to one thing; namely, the declaration of an enum type (the TempScale 
type). Like the declaration of a class, an enum type declaration belongs in a file all 
its own. The code in Listing 9-1 belongs in a file named TempScale.java. Okay, so then what is a temperature? Each temperature consists of two things: a number and a temperature scale. The 
code in Listing 9-2 makes this fact abundantly clear. LISTING 9-2: The Temperature Class
public class Temperature {
    private double number;
    private TempScale scale;
    public Temperature() {
        number = 0.0;
        scale = TempScale.FAHRENHEIT;
    }
CHAPTER 9  Constructing New Objects      235
    public Temperature(double number) {
        this.number = number;
        scale = TempScale.FAHRENHEIT;
    }
    public Temperature(TempScale scale) {
        number = 0.0;
        this.scale = scale;
    }
    public Temperature(double number, TempScale scale) {
        this.number = number;
        this.scale = scale;
    }
    public void setNumber(double number) {
        this.number = number;
    }
    public double getNumber() {
        return number;
    }
    public void setScale(TempScale scale) {
        this.scale = scale;
    }
    public TempScale getScale() {
        return scale;
    }
}
The code in Listing 9-2 has the usual setter and getter methods (accessor meth-
ods for the number and scale fields). For some good reading on setter and getter methods (also known as accessor 
methods), see Chapter 7. On top of all of that, Listing 9-2 has four other method-like-looking things. Each 
of these method-like things has the name Temperature, which happens to be the 
same as the name of the class. None of these Temperature method-like things has 
a return type of any kind — not even void, which is the cop-out return type. Each of these method-like things is called a constructor. A constructor is like a 
method, except that a constructor has a special purpose: to create new objects. 236      PART 3  Working with the Big Picture: Object-Oriented Programming
Whenever the computer creates a new object, the computer executes the state-
ments inside a constructor. You can omit the word public in the first lines of Listings 9-1 and 9-2. If you omit 
public, other Java programs might not be able to use the features defined in the 
TempScale type and in the Temperature class. (Don’t worry about the programs in 
this chapter: With or without the word public, all programs in this chapter can 
use the code in Listings 9-1 and 9-2. To find out which Java programs can use 
classes that aren’t public, see Chapter 14.) If you do use the word public in the 
first line of Listing  9-1, Listing  9-1 must be in a file named TempScale.java, 
starting with a capital letter T. And if you do use the word public in the first line 
of Listing 9-2, Listing 9-2 must be in a file named Temperature.java, starting 
with a capital letter T. (For an introduction to public classes, see Chapter 7.)
What you can do with a temperature
Listing 9-3 gives form to some of the ideas that I describe in the preceding sec-
tion. In Listing 9-3, you call the constructors that are declared back in Listing 9-2. Figure 9-1 shows what happens when you run all this code. LISTING 9-3: Using the Temperature Class
import static java.lang.System.out;
public class UseTemperature {
   public static void main(String args[]) {
       final String format = "%5.2f degrees %s\n";
       Temperature temp = new Temperature();
       temp.setNumber(70.0);
       temp.setScale(TempScale.FAHRENHEIT);
       out.printf(format, temp.getNumber(), temp.getScale());
       temp = new Temperature(32.0);
       out.printf(format, temp.getNumber(), temp.getScale());
FIGURE 9-1: 
Running the code 
from Listing 9-3. CHAPTER 9  Constructing New Objects      237
       temp = new Temperature(TempScale.CELSIUS);
       out.printf(format, temp.getNumber(), temp.getScale());
       temp = new Temperature(2.73, TempScale.KELVIN);
       out.printf(format, temp.getNumber(), temp.getScale());
   }
}
In Listing 9-3, each statement of the kind
temp = new Temperature(blah,blah,blah);
calls one of the constructors from Listing  9-2. So, by the time the code in 
 Listing 9-3 is done running, it creates four instances of the Temperature class. Each instance is created by calling a different constructor from Listing 9-2. In Listing 9-3, the last of the four constructor calls has two parameters: 2.73 and 
TempScale.KELVIN. This isn’t particular to constructor calls. A method call or a 
constructor call can have a bunch of parameters. You separate one parameter 
from  another with a comma. Another name for “a bunch of parameters” is a 
parameter list. The only rule you must follow is to match the parameters in the call with the 
parameters in the declaration. For example, in Listing 9-3, the fourth and last 
constructor call
new Temperature(2.73, TempScale.KELVIN)
has two parameters: the first of type double and the second of type TempScale. Java approves of this constructor call because Listing 9-2 contains a matching 
declaration. That is, the header
public Temperature(double number, TempScale scale)
has two parameters: the first of type double and the second of type TempScale. If 
a Temperature constructor call in Listing  9-3 had no matching declaration in 
Listing 9-2, Listing 9-3 would crash and burn. (To state things more politely, Java 
would display errors when you tried to compile the code in Listing 9-3.)
By the way, this business about multiple parameters isn’t new. Over in Chapter 6, 
I write keyboard.findWithinHorizon(".",0).charAt(0). In that line, the 
method call findWithinHorizon(".",0) has two parameters: a string and an int 
value. Luckily for me, the Java API has a method declaration for findWithin 
Horizon  — a declaration whose first parameter is a string and whose second 
parameter is an int value. 238      PART 3  Working with the Big Picture: Object-Oriented Programming
HOW TO CHEAT: ENUM TYPES  
AND SWITCH STATEMENTS
Listings 9-2 and 9-3 contain long-winded names such as TempScale.FAHRENHEIT and 
TempScale.CELSIUS. Names such as FAHRENHEIT and CELSIUS belong to my 
TempScale type (the type defined in Listing 9-1). These names have no meaning out-
side of my TempScale context. (If you think I’m being egotistical with this "no meaning 
outside of my context" remark, try deleting the TempScale. part of TempScale. FAHRENHEIT in Listing 9-2. Suddenly, Java tells you that your code contains an error.)
Java is normally fussy about type names and dots. But when they created enum types, 
the makers of Java decided that enum types and switch statements deserved special 
treatment. You can use an enum value to decide which case to execute in a switch 
statement. When you do this, you don’t use the enum type name in the case expres-
sions. For example, the following Java code is correct:
TempScale scale = TempScale.RANKINE;
char letter;
switch (scale) {
case CELSIUS:
    letter = 'C';
    break;
case KELVIN:
    letter = 'K';
    break;
case RANKINE:
case RÉAUMUR:
case RØMER:
    letter = 'R';
    break;
default:
    letter = 'X';
    break;
}
In the first line of code, I write TempScale.RANKINE because this first line isn’t inside a 
switch statement. But in the next several lines of code, I write case CELSIUS, case 
KELVIN, and case RANKINE without the word TempScale. In fact, if I create a case 
clause by writing case TempScale.RANKINE, Java complains with a loud, obnoxious 
error message. CHAPTER 9  Constructing New Objects      239
Calling new Temperature(32.0):  
A case study
When the computer executes one of the new Temperature  statements in 
 Listing 9-3, the computer has to decide which of the constructors in Listing 9-2 
to use. The computer decides by looking at the parameter list  — the stuff in 
parentheses after the words new Temperature. For instance, when the computer 
executes
temp = new Temperature(32.0);
from Listing 9-3, the computer says to itself, “The number 32.0 in parentheses is 
a double value. One of the Temperature constructors in Listing 9-2 has just one 
parameter with type double. The constructor’s header looks like this:
public Temperature(double number)
“So, I guess I’ll execute the statements inside that particular constructor.” The 
computer goes on to execute the following statements:
this.number = number;
scale = TempScale.FAHRENHEIT;
As a result, you get a brand-new object whose number field has the value 32.0 and 
whose scale field has the value TempScale.FAHRENHEIT. In the two lines of code, you have two statements that set values for the fields 
number and scale. Take a look at the second of these statements, which is a bit 
easier to understand. The second statement sets the new object’s scale field to 
TempScale.FAHRENHEIT. You see, the constructor’s parameter list is (double 
number), and that list doesn’t include a scale value. So whoever programmed this 
code had to make a decision about what value to use for the scale field. The 
 programmer could have chosen FAHRENHEIT or CELSIUS, but she could also have 
chosen KELVIN, RANKINE, or any of the other obscure scales named in Listing 9-1. (This programmer happens to live in New Jersey, in the United States, where 
 people commonly use the old Fahrenheit temperature scale.)
Marching back to the first of the two statements, this first statement assigns a 
value to the new object’s number field. The statement uses a cute trick that you can 
see in many constructors (and in other methods that assign values to objects’ 
fields). To understand the trick, take a look at Listing 9-4. The listing shows you 
two ways that I could have written the same constructor code. 240      PART 3  Working with the Big Picture: Object-Oriented Programming
LISTING 9-4: Two Ways to Accomplish the Same Thing
//Use this constructor ... public Temperature(double whatever) {
          number = whatever;
          scale = TempScale.FAHRENHEIT;
      }
//... or use this constructor ... public Temperature(double number) {
          this.number = number;
          scale = TempScale.FAHRENHEIT;
      }
//... but don't put both constructors in your code. Listing 9-4 has two constructors in it. In the first constructor, I use two different 
names: number and whatever. In the second constructor, I don’t need two names. Rather than make up a new name for the constructor’s parameter, I reuse an 
existing name by writing this.number. Here’s what’s going on in Listing 9-2:
 » In the statement this.number = number, the name this.number refers to the 
new object’s number field — the field that’s declared near the top of Listing 9-2. (See Figure 9-2.)
In the statement this.number = number, number (on its own, without this) 
refers to the constructor’s parameter. (Again, see Figure 9-2.)
FIGURE 9-2: 
What this. number and 
number mean. CHAPTER 9  Constructing New Objects      241
In general, this.someName refers to a field belonging to the object that contains 
the code. In contrast, plain old someName refers to the closest place where 
someName happens to be declared. In the statement this.number = number (refer 
to  Listing 9-2), that closest place happens to be the Temperature constructor’s 
parameter list. Some things never change
Chapter 7 introduces the printf method and explains that each printf call starts 
with a format string. The format string describes the way the other parameters 
are to be displayed. In previous examples, this format string is always a quoted literal. For instance, 
the first printf call in Listing 7-7 (see Chapter 7) is
out.printf("$%4.2f\n", myInterest);
WHAT’S THIS ALL ABOUT? Suppose your code contains a constructor — the first of the two constructors in 
Listing 9-4. The whatever parameter is passed a number like 32.0, for instance. Then 
the first statement in the constructor’s body assigns that value, 32.0, to the new object’s 
number field. The code works. But in writing this code, you had to make up a new name 
for a parameter — the name whatever. And the only purpose for this new name is to 
hand a value to the object’s number field. What a waste! To distinguish between the 
parameter and the number field, you gave a name to something that was just momen-
tary storage for the number value. Making up names is an art, not a science. I’ve gone through plenty of naming phases. Years ago, whenever I needed a new name for a parameter, I picked a confusing mis-
spelling of the original variable name. (I’d name the parameter something like numbr 
or nuhmber.) I’ve also tried changing a variable name’s capitalization to come up with 
a parameter name. (I’d use parameter names like Number or nUMBER.) In Chapter 8, 
I name all my parameters by adding the suffix In to their corresponding variable names. (The jobTitle variable matched up with the jobTitleIn parameter.) None of these 
naming schemes works well — I can never remember the quirky new names that I’ve 
created. The good news is that this parameter-naming effort isn’t necessary. You can 
give the parameter the same name as the variable. To distinguish between the two, you 
use the Java keyword this. 242      PART 3  Working with the Big Picture: Object-Oriented Programming
In Listing 9-3, I break with tradition and begin the printf call with a variable that 
I name format. out.printf(format, temp.getNumber(), temp.getScale());
That’s okay as long as my format variable is of type String. And indeed, in 
 Listing 9-3, the first variable declaration is
final String format = "%5.2f degrees %s\n";
In this declaration of the format variable, take special note of the word final. This Java keyword indicates that the value of format can’t be changed. If I add 
another assignment statement to Listing 9-3
format = "%6.2f (%s)\n";
the compiler barks back at me with the message cannot assign a value to 
final variable. When I write the code in Listing 9-3, the use of the final keyword isn’t absolutely 
necessary. But the final keyword provides some extra protection. When I initial-
ize format to "%5.2f degrees %s\n", I intend to use this same format just as it 
is, over and over again. I know darn well that I don’t intend to change the format 
variable’s value. Of course, in a 10,000-line program, I can become confused and 
try to assign a new value to format somewhere deep down in the code. To prevent 
me from accidentally changing the format string, I declare the format variable to 
be final. It’s just good, safe programming practice.

--- Chunk #715 ---
There’s always more stuff for you to try. » Create a Student class with a name, an ID number, a grade point average 
(GPA), and a major area of study. The student’s name is a String. The 
student’s ID number is an int value. The GPA is a double value between 0.0 
and 4.0. The Major is an enum type, with values such as COMPUTER_SCIENCE, 
MATHEMATICS, LITERATURE, PHYSICS, and HISTORY. Every student has a name and an ID number, but a brand-new student might 
not have a GPA or a major. Create constructors with and without GPA and 
Major parameters. As usual, create a separate class that makes use of your new Student class. » Create an AirplaneFlight class with a flight number, a departure airport, 
the time of departure, an arrival airport, and a time of arrival. The flight 
number is an int value. The departure and arrival airport fields belong to an 
Airport enum type, with values corresponding to some of the official IATA 
CHAPTER 9  Constructing New Objects      243
airport codes. (For example, London Heathrow Airport’s code is LHR; Los 
Angeles International Airport’s code is LAX; check out http://www.iata.org/
publications/Pages/code-search.aspx for a searchable database of 
airline codes.)
For the times of arrival and departure, use Java’s LocalTime class. (For more 
on LocalTime, check out the LocalTime documents page at https://docs. oracle.com/javase/8/docs/api/java/time/LocalTime.html.) To create 
a LocalTime object that’s set to 2:15 PM (also known as 14:15), execute
LocalTime twoFifteen = LocalTime.of(14, 15);
To create a LocalTime object that’s set to the current time (according to the 
computer’s system clock), execute
LocalTime currentTime = LocalTime.now();
Every flight has a number, a departure airport, and an arrival airport. But 
some flights might not have departure and arrival times. Create constructors 
with and without departure and arrival time parameters. Create a separate class that makes use of your new AirplaneFlight class. More Subclasses (Doing Something  
about the Weather)
In Chapter 8, I make a big fuss over the notion of subclasses. That’s the right thing 
to do. Subclasses make code reusable, and reusable code is good code. With that in 
mind, it’s time to create a subclass of the Temperature class (which I develop in 
this chapter’s first section). Building better temperatures
After perusing the code in Listing 9-3, you decide that the responsibility for dis -
playing temperatures has been seriously misplaced. Listing  9-3 has several 
tedious repetitions of the lines to print temperature values. A 1970s programmer 
would tell you to collect those lines into one place and turn them into a method. (The 1970s programmer wouldn’t have used the word method, but that’s not 
important right now.) Collecting lines into methods is fine, but with today’s 
object-oriented programming methodology, you think in broader terms. Why not 
get each temperature object to take responsibility for displaying itself? After all, 
244      PART 3  Working with the Big Picture: Object-Oriented Programming
if you develop a display method, you probably want to share the method with 
other people who use temperatures. So put the method right inside the declaration 
of a temperature object. That way, anyone who uses the code for temperatures 
has easy access to your display method. Now replay the tape from Chapter 8.

--- Chunk #716 ---
“Blah, blah, blah . .

--- Chunk #717 ---
. don’t want to modify 
existing code . .

--- Chunk #718 ---
. blah, blah, blah . .

--- Chunk #719 ---
. too costly to start again from scratch . .

--- Chunk #720 ---
. blah, 
blah, blah . .

--- Chunk #721 ---
. extend existing functionality.” It all adds up to one thing:
Don’t abuse it.

--- Chunk #722 ---
Instead, reuse it. So you decide to create a subclass of the Temperature class — the class defined in 
Listing 9-2. Your new subclass complements the Temperature class’s functional-
ity by having methods to display values in a nice, uniform fashion. The new class, 
TemperatureNice, is shown in Listing 9-5. LISTING 9-5: The TemperatureNice Class
import static java.lang.System.out;
public class TemperatureNice extends Temperature {
    public TemperatureNice() {
        super();
    }
    public TemperatureNice(double number) {
        super(number);
    }
    public TemperatureNice(TempScale scale) {
        super(scale);
    }
    public TemperatureNice(double number, TempScale scale) {
        super(number, scale);
    }
    public void display() {
        out.printf("%5.2f degrees %s\n", getNumber(), getScale());
    }
}
In the display method of Listing  9-5, notice the calls to the Temperature 
class’s  getNumber and getScale methods. Why do I do this? Well, inside the 
CHAPTER 9  Constructing New Objects      245
TemperatureNice class’s code, any direct references to the number and scale 
fields would generate error messages. It’s true that every TemperatureNice 
object has its own number and scale fields. (After all, TemperatureNice is a sub-
class of the Temperature class, and the code for the Temperature class defines the 
number and scale fields.) But because number and scale are declared to be private 
inside the Temperature class, only code that’s right inside the Temperature class 
can directly use these fields. Don’t put additional declarations of the number and scale fields inside the 
TemperatureNice class’s code. If you do, you inadvertently create four different 
variables (two called number and another two called scale). You’ll assign values to 
one pair of variables. Then you’ll be shocked that when you display the other pair 
of variables, those values seem to have disappeared. When an object’s code contains a call to one of the object’s own methods, you 
don’t need to preface the call with a dot. For instance, in the last statement of 
Listing 9-5, the object calls its own methods with getNumber() and getScale(), 
not with someObject.getNumber() and somethingOrOther.getScale(). If going 
dotless makes you queasy, you can compensate by taking advantage of yet another 
use for the this keyword: Just write this.getNumber() and this.getScale() in 
the last line of Listing 9-5. Constructors for subclasses
By far, the biggest news in Listing 9-5 is the way the code declares constructors. The TemperatureNice class has four of its own constructors. If you’ve gotten 
in  gear thinking about subclass inheritance, you may wonder why these con-
structor declarations are necessary. Doesn’t TemperatureNice inherit the parent 
Temperature class’s constructors? No, subclasses don’t inherit constructors. Subclasses don’t inherit constructors. That’s right. Subclasses don’t inherit constructors. In one oddball case, a con-
structor may look like it’s being inherited, but that oddball situation is a fluke, not 
the norm. In general, when you define a subclass, you declare new constructors to 
go with the subclass. I describe the oddball case (in which a constructor looks like it’s being inherited) 
later in this chapter, in the section “The default constructor.”
So the code in Listing 9-5 has four constructors. Each constructor has the name 
TemperatureNice, and each constructor has its own uniquely identifiable param-
eter list. That’s the boring part. The interesting part is that each constructor 
makes a call to something named super, which is a Java keyword. 246      PART 3  Working with the Big Picture: Object-Oriented Programming
In Listing 9-5, super stands for a constructor in the parent class:
 » The statement super() in Listing 9-5 calls the parameterless Temperature() 
constructor that’s in Listing 9-2. That parameterless constructor assigns 0.0 to 
the number field and TempScale.FAHRENHEIT to the scale field. » The statement super(number, scale) in Listing 9-5 calls the constructor 
Temperature(double number, TempScale scale) that’s in Listing 9-2. In 
turn, the constructor assigns values to the number and scale fields. » In a similar way, the statements super(number) and super(scale) in 
Listing 9-5 call constructors from Listing 9-2. The computer decides which of the Temperature class’s constructors is being 
called by looking at the parameter list after the word super. For instance, when 
the computer executes
super(number, scale);
from Listing 9-5, the computer says to itself, “The number and scale fields in 
parentheses have types double and TempScale. But only one of the Temperature 
constructors in Listing 9-2 has two parameters with types double and TempScale. The constructor’s header looks like this:
public Temperature(double number, TempScale scale)
“So, I guess I’ll execute the statements inside that particular constructor.”
Using all this stuff
In Listing 9-5, I define what it means to be in the TemperatureNice class. Now 
it’s time to put this TemperatureNice class to good use. Listing 9-6 has code that 
uses TemperatureNice. LISTING 9-6: Using the TemperatureNice Class
public class UseTemperatureNice {
    public static void main(String args[]) {
        TemperatureNice temp = new TemperatureNice();
        temp.setNumber(70.0);
        temp.setScale(TempScale.FAHRENHEIT);
        temp.display();
CHAPTER 9  Constructing New Objects      247
        temp = new TemperatureNice(32.0);
        temp.display();
        temp = new TemperatureNice(TempScale.CELSIUS);
        temp.display();
        temp = new TemperatureNice(2.73, TempScale.KELVIN);
        temp.display();
    }
}
The code in Listing 9-6 is much like its cousin code in Listing 9-3. The big differ-
ences are as follows:
 » Listing 9-6 creates instances of the TemperatureNice class. That is, Listing 9-6 
calls constructors from the TemperatureNice class, not the 
Temperature class. » Listing 9-6 takes advantage of the display method in the TemperatureNice 
class. So the code in Listing 9-6 is much tidier than its counterpart in Listing 9-3. A run of Listing 9-6 looks exactly like a run of the code in Listing 9-3 — it just 
gets to the finish line in a far more elegant fashion. (The run is shown previously 
in Figure 9-1.)
The default constructor
The main message in the previous section is that subclasses don’t inherit con-
structors. So what gives with all the listings over in Chapter 8? In Listing 8-6, a 
statement says
FullTimeEmployee ftEmployee = new FullTimeEmployee();
But, here’s the problem: The code defining FullTimeEmployee (refer to 
Listing 8-3) doesn’t seem to have any constructors declared inside it. So, in 
 Listing 8-6, how can you possibly call the FullTimeEmployee constructor? Here’s what’s going on. When you create a subclass and don’t put any explicit 
constructor declarations in your code, Java creates one constructor for you. It’s 
called a default constructor. If you’re creating the public FullTimeEmployee  
 subclass, the default constructor looks like the one in Listing 9-7. 248      PART 3  Working with the Big Picture: Object-Oriented Programming
LISTING 9-7: A Default Constructor
public FullTimeEmployee() {
    super();
}
The constructor in Listing 9-7 takes no parameters, and its one statement calls 
the constructor of whatever class you’re extending. (Woe be to you if the class that 
you’re extending doesn’t have a parameterless constructor.)
You’ve just read about default constructors, but watch out! Notice one thing that 
this talk about default constructors doesn’t say: It doesn’t say that you always get 
a default constructor. In particular, if you create a subclass and define any con-
structors yourself, Java doesn’t add a default constructor for the subclass (and the 
subclass doesn’t inherit any constructors, either). So how can this trip you up? Listing 9-8 has a copy of the code from Listing 8-3, 
but with one constructor added to it. Take a look at this modified version of the 
FullTimeEmployee code. LISTING 9-8: Look, I Have a Constructor! public class FullTimeEmployee extends Employee {
    private double weeklySalary;
    private double benefitDeduction;
    public FullTimeEmployee(double weeklySalary) {
        this.weeklySalary = weeklySalary;
    }
    public void setWeeklySalary(double weeklySalaryIn) {
        weeklySalary = weeklySalaryIn;
    }
    public double getWeeklySalary() {
        return weeklySalary;
    }
    public void setBenefitDeduction(double benefitDedIn) {
        benefitDeduction = benefitDedIn;
    }
    public double getBenefitDeduction() {
        return benefitDeduction;
    }
CHAPTER 9  Constructing New Objects      249
    public double findPaymentAmount() {
        return weeklySalary&#x00A0;- benefitDeduction;
    }
}
If you use the FullTimeEmployee code in Listing 9-8, a line like the following 
doesn’t work:
FullTimeEmployee ftEmployee = new FullTimeEmployee();
It doesn’t work because, having declared a FullTimeEmployee constructor that 
takes one double parameter, you no longer get a default parameterless construc-
tor for free. What do you do about this?

--- Chunk #723 ---
If you declare any constructors, declare all construc -
tors that you’ll possibly need. Take the constructor in Listing 9-7 and add it to the 
code in Listing 9-8. Then the call new FullTimeEmployee() starts working again. Under certain circumstances, Java automatically adds an invisible call to a parent 
class’s constructor at the top of a constructor body. This automatic addition of a 
super call is a tricky bit of business that doesn’t appear often, so when it does 
appear, it may seem quite mysterious. For more information, see this book’s web-
site (www.allmycode.com/JavaForDummies). In this section, I have three (count ’em — three) things for you to try:
 » In a previous section, you create your own Student class. Create a subclass 
that has a method named getString. Like the display method in this chapter’s TemperatureNice class, the 
getString method creates a nice-looking String representation of its object. But unlike the TemperatureNice class’s display method, the getString 
method doesn’t print that String representation on the screen. Instead, the 
getString method simply returns that String representation as its result. In a way, a getString method is much more versatile than a display method. With a display method, all you can do is show a String representation on the 
screen. But with a getString method, you can create a String representation 
and then do whatever you want with it. Create a separate class that creates some instances of your new subclass and 
puts their getString methods to good use. 250      PART 3  Working with the Big Picture: Object-Oriented Programming
 » In a previous section, you create your own AirplaneFlight class. Create a 
subclass that has a method named duration. The duration method, which 
has no parameters, returns the amount of time between the flight’s departure 
time and arrival time. To find the number of hours between two LocalTime objects (such as 
twoFifteen and currentTime), execute
long hours = ChronoUnit.HOURS.between(twoFifteen, currentTime);
To find the number of minutes between two LocalTime objects (such as 
twoFifteen and currentTime), execute
long minutes = ChronoUnit.MINUTES.between(twoFifteen, currentTime);
 » Create a new TemperatureEvenNicer class — a subclass of this section’s 
TemperatureNice class. The TemperatureEvenNicer class has a convertTo 
method. If the variable temp refers to a Fahrenheit temperature and Java 
executes
temp.convertTo(TempScale.CELSIUS);
then the temp object changes to a Celsius temperature, with the number 
converted appropriately. The same kind of thing happens if Java executes
temp.convertTo(TempScale.FAHRENHEIT);
with temp already referring to a Celsius temperature. A Constructor That Does More
Here’s a quote from somewhere near the start of this chapter: “And what if you’re 
interested in doing more than filling fields? Perhaps, when the computer creates 
a new object, you have a whole list of jobs for the computer to carry out.” Okay, 
what if? This section’s example has a constructor that does more than just assign values to 
fields. The example is in Listings 9-9 and 9-10.

--- Chunk #724 ---
The result of running the exam -
ple’s code is shown in Figure 9-3. CHAPTER 9  Constructing New Objects      251
LISTING 9-9: Defining a Frame
import java.awt.FlowLayout;
import javax.swing.JFrame;
import javax.swing.JButton;
@SuppressWarnings("serial")
public class SimpleFrame extends JFrame {
    public SimpleFrame() {
        setTitle("Don't click the button!");
        setLayout(new FlowLayout());
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        add(new JButton("Panic"));
        setSize(300, 100);
        setVisible(true);
    }
}
LISTING 9-10: Displaying a Frame
public class ShowAFrame {
    public static void main(String args[]) {
        new SimpleFrame();
    }
}
Like my DummiesFrame examples, the code in Listings 9-9 and 9-10 displays a 
window on the computer screen. But unlike my DummiesFrame examples, all the 
method calls in Listings 9-9 and 9-10 refer to methods in Java’s standard API 
(Application Programming Interface). To find my DummiesFrame examples, refer to Chapter 7. The code in Listing 9-9 contains lots of names that are probably unfamiliar to 
you — names from Java’s API. When I was first becoming acquainted with Java, 
I foolishly believed that knowing Java meant remembering all these names. Quite 
the contrary: These names are just carry-on baggage. The real Java is the way the 
language implements object-oriented concepts. FIGURE 9-3: 
Don’t panic. 252      PART 3  Working with the Big Picture: Object-Oriented Programming
PACKAGES AND IMPORT DECLARATIONS
Java has a feature that lets you lump classes into groups of classes. Each lump of classes 
is called a package. In the Java world, programmers customarily give these packages 
long, dot-filled names. For instance, because I’ve registered the domain name allmycode. com, I may name a package com.allmycode.utils.textUtils. The Java API is actu-
ally a big collection of packages. The API has packages with names like java.lang, 
java.util, java.awt, and javax.swing. With this information about packages, I can clear up some of the confusion about 
import declarations. Any import declaration that doesn’t use the word static must 
start with the name of a package and must end with either of the following:
• The name of a class within that package
• An asterisk (indicating all classes within that package)
For example, the declaration
import java.util.Scanner;
is valid because java.util is the name of a package in the Java API, and Scanner is the 
name of a class in the java.util package. The dotted name java.util.Scanner is 
called the fully qualified name of the Scanner class. A class’s fully qualified name 
includes the name of the package in which the class is defined. (You can find out all this 
stuff about java.util and Scanner by reading Java’s API documentation. For tips on 
reading the documentation, see Chapter 3 and this book’s website.)
Here’s another example. The declaration
import javax.swing.*;
is valid because javax.swing is the name of a package in the Java API, and the asterisk 
refers to all classes in the javax.swing package. With this import declaration at the 
top of your Java code, you can use abbreviated names for classes in the javax.swing 
package — names like JFrame, JButton, JMenuBar, JCheckBox, and many others. Here’s one more example. A line like
import javax.*; //Bad!! is not a valid import declaration. The Java API has no package with the one-word name 
javax. You may think that this line allows you to abbreviate all names beginning with 
javax (names like javax.swing.JFrame, and javax.sound.midi), but that’s not the 
way the import declaration works. Because javax isn’t the name of a package, the line 
import javax.* just angers the Java compiler. CHAPTER 9  Constructing New Objects      253
Anyway, Listing 9-10’s main method has only one statement: a call to the con-
structor in the SimpleFrame class. Notice how the object that this call creates isn’t 
even assigned to a variable. That’s okay because the code doesn’t need to refer to 
the object anywhere else. Up in the SimpleFrame class, there’s only one constructor declaration. Far from 
just setting variables’ values, this constructor calls method after method from the 
Java API. All the methods called in the SimpleFrame class’s constructor come from the 
 parent class, JFrame. The JFrame class lives in the javax.swing package. This 
package and another package, java.awt, have classes that help you put windows, 
images, drawings, and other gizmos on a computer screen. (In the java.awt 
package, the letters awt stand for abstract windowing toolkit.)
For a little gossip about the notion of a Java package, see the nearby sidebar, 
“Packages and import declarations.” For lots of gossip about the notion of a Java 
package, see Chapter 14. In the Java API, what people normally call a window is an instance of the javax. swing.JFrame class. Classes and methods from the Java API
Looking at Figure 9-3, you can probably tell that an instance of the SimpleFrame 
class doesn’t do much. The frame has only one button, and when you click the 
button, nothing happens. I made the frame this way to keep the example from 
becoming too complicated. Even so, the code in Listing  9-9 uses several API 
classes and methods. The setTitle, setLayout, setDefaultCloseOperation, 
add, setSize, and setVisible methods all belong to the javax.swing.JFrame 
class. Here’s a list of names used in the code:
 » setTitle: Calling setTitle puts words in the frame’s title bar. (The new 
SimpleFrame object is calling its own setTitle method.)
 » FlowLayout: An instance of the FlowLayout class positions objects on the 
frame in a centered, typewriter fashion. Because the frame in Figure 9-3 has 
only one button on it, that button is centered near the top of the frame. If the 
frame had eight buttons, five of them may be lined up in a row across the top 
of the frame and the remaining three would be centered along a second row. » setLayout: Calling setLayout puts the new FlowLayout object in charge of 
arranging components, such as buttons, on the frame. (The new SimpleFrame 
object is calling its own setLayout method.)
254      PART 3  Working with the Big Picture: Object-Oriented Programming
 » setDefaultCloseOperation: Calling setDefaultCloseOperation tells Java 
what to do when you click the little × in the frame’s upper-right corner. (On a 
Mac, you click the little red circle in the frame’s upper-left corner.) Without this 
method call, the frame itself disappears, but the Java Virtual Machine (JVM) 
keeps running. To stop your program’s run, you have to perform one more 
step. (You may have to look for a Terminate option in Eclipse, IntelliJ IDEA, or 
NetBeans.)
Calling setDefaultCloseOperation(EXIT_ON_CLOSE) tells Java to shut itself 
down when you click the × in the frame’s upper-right corner. The alternatives 
to EXIT_ON_CLOSE are HIDE_ON_CLOSE, DISPOSE_ON_CLOSE, and, my 
personal favorite, DO_NOTHING_ON_CLOSE. Use one of these alternatives when 
your program has more work to do after the user closes your frame. » JButton: The JButton class lives in the javax.swing package. One of the 
class’s constructors takes a String instance (such as "Panic") for its 
parameter. Calling this constructor makes that String instance into the label 
on the face of the new button. » add: The new SimpleFrame object calls its add method. Calling the add 
method places the button on the object’s surface (in this case, the surface of 
the frame). » setSize: The frame becomes 300 pixels wide and 100 pixels tall. (In the 
javax.swing package, whenever you specify two dimension numbers, the 
width number always comes before the height number.)
 » setVisible: When it’s first created, a new frame is invisible. But when the 
new frame calls setVisible(true), the frame appears on your computer 
screen. The SuppressWarnings annotation
Chapter 8 introduces the annotation — extra code that provides useful informa -
tion about the nature of your program. In particular, Chapter  8 describes the 
Override annotation. In this chapter, Listing 9-9 introduces another type of annotation: the Suppress 
Warnings annotation. When you use a SuppressWarnings annotation, you tell 
Java not to remind you that your program contains certain questionable code. In 
Listing 9-9, the line @SuppressWarnings("serial") tells Java not to remind you 
that you’ve omitted something called a serialVersionUID field. In other words, 
the SuppressWarnings annotation tells Java not to display a warning like the one 
in Figure 9-4. CHAPTER 9  Constructing New Objects      255
“And what,” you ask, “is a serialVersionUID field?” It’s something having to 
do with extending the JFrame class — something that you don’t care about. Not 
having a serialVersionUID field generates a warning, not an error. So live dan-
gerously! Just suppress the warning (with the annotation in Listing  9-9) and 
don’t worry about serialVersionUID fields. » In JShell, type the following sequence of declarations and statements. What 
happens?

--- Chunk #725 ---
Why? jshell> import javax.swing.JFrame
jshell> JFrame frame
jshell> frame.setSize(100, 100)
jshell> frame = new JFrame()
jshell> frame.setSize(100, 100)
jshell> frame.setVisible(true)
 » In Listing 9-9, change the statement
setLayout(new FlowLayout());
to
setLayout(new BorderLayout());
What difference does this change make when you run the program? FIGURE 9-4: 
Without a 
Suppress 
Warnings 
annotation, 
Java warns you 
about a missing 
serialVersion 
UID field. 4
Smart Java 
Techniques
IN THIS PART .

--- Chunk #726 ---
. . Decide where declarations belong in your Java program. Deal with bunches of things (bunches of rooms, bunches 
of sales, and even bunches of bunches). Fully embrace Java’s object-oriented features. Create a windowed app and respond to mouse clicks. Talk to your favorite database. CHAPTER 10  Putting Variables and Methods Where They Belong      259
IN THIS CHAPTER
 » Making something belong to an 
entire class
 » Putting variables inside and outside 
methods
 » Improving your batting average
Putting Variables and 
Methods Where They 
Belong
H
ello, again. You’re listening to radio station WWW, and I’m your host, Sam 
Burd.

--- Chunk #727 ---
It’s the start again of the big baseball season, and today station 
WWW brought you live coverage of the Hankees-versus-Socks game. At 
this moment, I’m awaiting news of the game’s final score. If you remember from earlier this afternoon, the Socks looked like they were going 
to take those Hankees to the cleaners. Then, the Hankees were belting ball after 
ball, giving the Socks a run for their money. Those Socks! I’m glad I wasn’t in 
their shoes. Anyway, as the game went on, the Socks pulled themselves up. Now the Socks are 
nose-to-nose with the Hankees. We’ll get the final score in a minute, but first, a 
few reminders. Stay tuned after this broadcast for the big Jersey’s game. And don’t 
forget to tune in next week when the Cleveland Gowns play the Bermuda Shorts. Okay, here’s the final score. Which team has the upper hand? Which team will 
come out a head? And the winner is .

--- Chunk #728 ---
.

--- Chunk #729 ---
.

--- Chunk #730 ---
oh, no — it’s a tie! Chapter 10
260      PART 4  Smart Java Techniques
Defining a Class (What It Means  
to Be a Baseball Player)
As far as I’m concerned, a baseball player has a name and a batting average. Listing 10-1 puts my feeling about this into Java program form. LISTING 10-1: The Player Class
import java.text.DecimalFormat;
public class Player {
  private String name;
  private double average;
  public Player(String name, double average) {
    this.name = name;
    this.average = average;
  }
  public String getName() {
    return name;
  }
  public double getAverage() {
    return average;
  }
  public String getAverageString() {
    DecimalFormat decFormat = new DecimalFormat();
    decFormat.setMaximumIntegerDigits(0);
    decFormat.setMaximumFractionDigits(3);
    decFormat.setMinimumFractionDigits(3);
    return decFormat.format(average);
  }
}
Here I go, picking apart the code in Listing 10-1. Luckily, earlier chapters cover 
lots of stuff in this code. The code defines what it means to be an instance of the 
Player class. Here’s what’s in the code:
 » Declarations of the fields name and average: For bedtime reading about 
field declarations, see Chapter 7. » A constructor to make new instances of the Player class: For the 
lowdown on constructors, see Chapter 9. CHAPTER 10  Putting Variables and Methods Where They Belong      261
 » Getter methods for the fields name and average: For chitchat about 
accessor methods (that is, setter and getter methods), see Chapter 7. » A method that returns the player’s batting average in String form: For 
the good word about methods, see Chapter 7. (I put a lot of good stuff in 
Chapter 7, didn’t I?)
Another way to beautify your numbers
The getAverageString method in Listing 10-1 takes the value from the average 
field (a player’s batting average), converts that value (normally of type double) 
into a String, and then sends that String value right back to the method caller. The use of DecimalFormat, which comes right from the Java API (Application Pro-
gramming Interface), ensures that the String value looks like a baseball player’s 
batting average. According to the decFormat.setMaximum ... and decFormat. setMinimum ... method calls, the String value has no digits to the left of the 
decimal point and has exactly three digits to the right of the decimal point. Java’s DecimalFormat class can be quite handy. For example, to display the values 
345 and –345 in an accounting-friendly format, you can use the following code:
DecimalFormat decFormat = new DecimalFormat();
decFormat.setMinimumFractionDigits(2);
decFormat.setNegativePrefix("(");
decFormat.setNegativeSuffix(")");
System.out.println(decFormat.format(345));
System.out.println(decFormat.format(-345));
In this little example’s format string, everything before the semicolon dictates the 
way positive numbers are displayed, and everything after the semicolon deter -
mines the way negative numbers are displayed. So, with this format, the numbers 
345 and –345 appear as follows:
345.00
(345.00)
To discover some other tricks with numbers, visit the DecimalFormat page of 
Java’s API documentation ( https://docs.oracle.com/javase/8/docs/api/
java/text/DecimalFormat.html). Using the Player class
Listings 10-2 and 10-3 have code that uses the Player class — the class that’s 
defined back in Listing 10-1. 262      PART 4  Smart Java Techniques
LISTING 10-2: Using the Player Class
import java.util.Scanner;
import java.io.File;
import java.io.IOException;
import javax.swing.JFrame;
import javax.swing.JLabel;
import java.awt.GridLayout;
@SuppressWarnings("serial")
public class TeamFrame extends JFrame {
  public TeamFrame() throws IOException {
    Player player;
    Scanner hankeesData = new Scanner(new File("Hankees.txt"));
    for (int num = 1; num <= 9; num++) {
      player = new Player(hankeesData.nextLine(), hankeesData.nextDouble());
      hankeesData.nextLine();
      addPlayerInfo(player);
    }
    setTitle("The Hankees");
    setLayout(new GridLayout(9, 2, 20, 3));
    setDefaultCloseOperation(EXIT_ON_CLOSE);
    pack();
    setVisible(true);
    hankeesData.close();
  }
  void addPlayerInfo(Player player) {
    add(new JLabel("  " + player.getName()));
    add(new JLabel(player.getAverageString()));
  }
}
LISTING 10-3: Displaying a Frame
import java.io.IOException;
public class ShowTeamFrame {
  public static void main(String args[]) throws IOException {
    new TeamFrame();
  }
}
CHAPTER 10  Putting Variables and Methods Where They Belong      263
For a run of the code in Listings 10-1, 10-2, and 10-3, see Figure 10-1. To run this program yourself, you need the Hankees.txt file. This file contains 
data on your favorite baseball players. (See Figure 10-2.)
You don’t have to create your own Hankees.txt file. The stuff that you download 
from this book’s website comes with a Hankees.txt file, as shown in Figure 10-2. (Visit www.allmycode.com/JavaForDummies.)
You may live in a country where the value of π is approximately 3,14159 (with a 
comma) instead of 3.14159 (with a period). If you do, the file shown in Figure 10-2 
won’t work for you. The program will crash with an InputMismatchException. To 
run this section’s example, you have to change the periods in the Hankees.txt file 
into commas. Alternatively, you can add a statement such as Locale.

--- Chunk #731 ---
setDefault(Locale.US) to your code. For details, see Chapter 8. You must have the Hankees.txt file in a certain place on your hard drive. If you’re 
using Eclipse, that “certain place” is a project directory within your Eclipse work-
space. On the other hand, if you’re running Java from the command line, that 
“place” may be the directory that contains the Listing  10-3 code. One way or 
another, you can’t get away with not having the Hankees.txt file in the right 
place on your hard drive. If you don’t have Hankees.txt in the right place, then 
FIGURE 10-1: 
Would you 
bet money on 
these people? FIGURE 10-2: 
What a team! 264      PART 4  Smart Java Techniques
when you try to run this section’s example, you get an unpleasant FileNotFound 
Exception message. You can download stuff from this book’s website, and get instructions for opening 
the book’s examples in your favorite IDE (Eclipse, NetBeans, or IntelliJ IDEA). When you open this chapter’s 10-01 project, the Hankees.txt file is exactly where 
it needs to be. You don’t have to worry about putting the file where it belongs. If you create this section’s example from scratch, you have to think about the 
 correct location of the Hankees.txt file. In that case, deciding where to put the 
Hankees.txt file depends on your computer. To read about all these topics, visit 
this book’s website (www.allmycode.com/JavaForDummies). For this section’s code to work correctly, you must have a line break after the last 
.212 in Figure 10-2. For details about line breaks, see Chapter 8. One class; nine objects
The code in Listing 10-2 calls the Player constructor nine times. This means that 
the code creates nine instances of the Player class. The first time through the 
loop, the code creates an instance with the name Barry Burd. The second time 
through the loop, the code abandons the Barry Burd instance and creates another 
instance with name Harriet Ritter. The third time through, the code abandons 
poor Harriet Ritter and creates an instance for Weelie J. Katz. The code has 
only one instance at a time but, all in all, the code creates nine instances. Each Player instance has its own name and average fields. Each instance also 
has  its own Player constructor and its own getName, getAverage, and get 
AverageString methods. Look at Figure 10-3 and think of the Player class with 
its nine incarnations. FIGURE 10-3: 
A class and 
its objects. CHAPTER 10  Putting Variables and Methods Where They Belong      265
Don’t get all GUI on me
The code in Listing 10-2 uses several names from the Java API. Some of these 
names are explained in Chapter 9. Others are explained right here:
 » JLabel: A JLabel is an object with some text in it. One way to display text 
inside the frame is to add an instance of the JLabel class to the frame. In Listing 10-2, the addPlayerInfo method is called nine times, once for each 
player on the team. Each time addPlayerInfo is called, the method adds two 
new JLabel objects to the frame. The text for each JLabel object comes from 
a player object’s getter method. » GridLayout: A GridLayout arranges things in evenly spaced rows and 
columns. This constructor for the GridLayout class takes two parameters: the 
number of rows and the number of columns. In Listing 10-2, the call to the GridLayout constructor takes parameters (9, 2, 
20, 3). So in Figure 10-1, the display has nine rows (one for each player) and 
two columns (one for a name and another for an average). The horizontal gap 
between the two columns is 20 pixels wide, and the vertical gap between any 
two rows is 3 pixels tall. » pack: When you pack a frame, you set the frame’s size. That’s the size the 
frame has when it appears on your computer screen. Packing a frame 
shrink-wraps the frame around whatever objects you’ve added inside the 
frame. In Listing 10-2, by the time you’ve reached the call to pack, you’ve already 
called addPlayerInfo nine times and added 18 labels to the frame. In 
executing the pack method, the computer picks a nice size for each label, 
given whatever text you’ve put inside the label. Then the computer picks a nice 
size for the whole frame, given that the frame has these 18 labels inside it. When you plop stuff onto frames, you have quite a bit of leeway with the order in 
which you do things. For instance, you can set the layout before or after you’ve 
added labels and other stuff to the frame. If you call setLayout and then add 
labels, the labels appear in nice, orderly positions on the frame. If you reverse this 
order (add labels and then call setLayout), the calling of setLayout rearranges 
the labels in a nice, orderly fashion. It works fine either way. In setting up a frame, the one thing that you shouldn’t do is violate the following 
sequence:
Add things to the frame, then
pack();
setVisible(true);
266      PART 4  Smart Java Techniques
If you call pack and then add more things to the frame, the pack method doesn’t 
take into consideration the more recent things that you’ve added. If you call 
setVisible before you add things or call pack, the user sees the frame as it’s 
being constructed. Finally, if you forget to set the frame’s size (by calling pack or 
another sizing method), the frame that you see looks like the one in Figure 10-4. (Normally, I wouldn’t show you an anomalous run like the one in Figure 10-4, but 
I’ve made the mistake so many times that I feel as if this puny frame is an old 
friend of mine.)
Tossing an exception from  
method to method
Chapter 8 introduces input from a disk file, and along with that topic comes the 
notion of an exception. When you tinker with a disk file, you need to acknowledge 
the possibility of raising an IOException. That’s the lesson from Chapter 8, and 
that’s why the constructor in Listing 10-2 has a throws IOException clause. But what about the main method in Listing 10-3? With no apparent reference to 
disk files in this main method, why does the method need its own throws 
IOException clause? Well, an exception is a hot potato. If you have one, you either 
have to eat it (as you can see in Chapter 13) or use a throws clause to toss it to 
someone else. If you toss an exception with a throws clause, someone else is stuck 
with the exception just the way you were. The constructor in Listing  10-2 throws an IOException, but to whom is 
this  exception thrown? Who in this chain of code becomes the bearer of responsi-
bility for the problematic IOException? Well, who called the constructor in 
Listing  10-2? It was the main method in Listing  10-3  — that’s who called the 
TeamFrame constructor. Because the TeamFrame constructor throws its hot potato 
to the main method in Listing 10-3, the main method has to deal with it. As shown 
in  Listing 10-3, the main method deals with it by tossing the IOException again 
(by having a throws IOException  clause of its own). That’s how the throws 
clause works in Java programs. If a method calls another method and the called method has a throws clause, the 
calling method must contain code that deals with the exception. To find out more 
about dealing with exceptions, read Chapter 13. FIGURE 10-4: 
A shrunken 
frame. CHAPTER 10  Putting Variables and Methods Where They Belong      267
At this point in the book, the astute For Dummies  reader may pose a follow-up 
question or two. “When a main method has a throws clause, someone else has to 
deal with the exception in that throws clause. But who called the main method? Who deals with the IOException in the throws clause of Listing  10-3?” The 
answer is that the Java Virtual Machine (or JVM, the thing that runs all your Java 
code) called the main method. So the JVM takes care of the IOException in 
 Listing 10-3. If the program has any trouble reading the Hankees.txt file, the 
responsibility ultimately falls on the JVM. The JVM takes care of the situation by 
displaying an error message and then ending the run of your program. How 
convenient!

--- Chunk #732 ---
Would you like some practice with the material in this section? If so, try this:
 » The code in Listing 10-2 reads from a file named Hankees.txt. Delete that 
Hankees.txt file from your computer’s hard drive, or temporarily move the 
file to a different directory. Then try to run the program in Listings 10-1 to 10-3. What horrible things happen when you do this? » A line of men’s clothing features shirts, pants, jackets, overcoats, neckties, and 
shoes. Create an enum to represent the six kinds of items. Then create a 
MensClothingItem class. Each instance of the class has a kind (one of the six 
enum values), and a name (such as Casual Summer Design #7). Write code to display a frame (like the frame in Figure 10-1). The frame has six 
rows to describe one complete men’s wardrobe. » Create an enum to represent the suits in a deck of playing cards (CLUBS, 
DIAMONDS, HEARTS, and SPADES). Create a PlayingCard class. Each playing 
card has a number (from 1 to 13) and a suit. In the numbering scheme, 11 
stands for a Jack, 12 stands for a Queen, and 13 stands for a King. Write code 
that creates several cards and displays them on the screen (in either text-only 
format or as a frame like the one in Figure 10-1). Making Static (Finding the Team Average)
Thinking about the code in Listings 10-1 through 10-3, you decide that you want 
to find the team’s overall batting average. Not a bad idea! The Hankees in 
 Figure 10-1 have an average of about .106, so the team needs some intensive train-
ing. While the players are out practicing on the ball field, you have a philosophical 
hurdle to overcome. 268      PART 4  Smart Java Techniques
In Listings  10-1 through 10-3, you have three classes: a Player class and two 
other classes that help display data from the Player class. So in this class morass, 
where do the variables storing your overall, team-average tally go? » It makes no sense to put tally variables in either of the displaying classes 
(TeamFrame and ShowTeamFrame). After all, the tally has something-or-other 
to do with players, teams, and baseball. The displaying classes are about 
creating windows, not about playing baseball. » You’re uncomfortable putting an overall team average in an instance of the 
Player class because an instance of the Player class represents just one 
player on the team. What business does a single player have storing overall 
team data? Sure, you could make the code work, but it wouldn’t be an elegant 
solution to the problem.

--- Chunk #733 ---
Finally, you discover the keyword static. Anything that’s declared to be static 
belongs to the whole class, not to any particular instance of the class. When you 
create the static field, totalOfAverages, you create just one copy of the field. This copy stays with the entire Player class. No matter how many instances of the 
Player class you create  — one, nine, or none  — you have just one totalOf 
Averages field. And, while you’re at it, you create other static fields ( player 
Count and decFormat) and static methods ( findTeamAverage and findTeam 
AverageString). To see what I mean, look at Figure 10-5. Going along with your passion for subclasses, you put code for team-wide tallies 
in a subclass of the Player class. The PlayerPlus subsclass code is shown in 
Listing 10-4. FIGURE 10-5: 
Some static and 
non-static fields 
and methods. CHAPTER 10  Putting Variables and Methods Where They Belong      269
LISTING 10-4: Creating a Team Batting Average
import java.text.DecimalFormat;
public class PlayerPlus extends Player {
  private static int playerCount = 0;
  private static double totalOfAverages = .000;
  private static DecimalFormat decFormat = new DecimalFormat();
  static {
    decFormat.setMaximumIntegerDigits(0);
    decFormat.setMaximumFractionDigits(3);
    decFormat.setMinimumFractionDigits(3);
  }
  public PlayerPlus(String name, double average) {
    super(name, average);
    playerCount++;
    totalOfAverages += average;
  }
  public static double findTeamAverage() {
    return totalOfAverages / playerCount;
  }
  public static String findTeamAverageString() {
    return decFormat.format(totalOfAverages / playerCount);
  }
}
Why is there so much static? Maybe you’ve noticed — the code in Listing 10-4 is overflowing with the word 
static. That’s because nearly everything in this code belongs to the entire 
PlayerPlus class and not to individual instances of the class. That’s good because 
something like playerCount (the number of players on the team) shouldn’t 
belong to individual players, and having each PlayerPlus object keep track of its 
own count would be silly. (“I know how many players I am. I’m just one player!”) 
If you had nine individual playerCount fields, either each field would store the 
number 1 (which is useless) or you would have nine different copies of the count, 
which is wasteful and prone to error. By making playerCount static, you’re keep-
ing the playerCount in just one place, where it belongs. The same kind of reasoning holds for the totalOfAverages. Eventually, the 
totalOfAverages field will store the sum of the players’ batting averages. For all 
nine members of the Hankees, this adds up to .956. It’s not until someone calls 
270      PART 4  Smart Java Techniques
the findTeamAverage or findTeamAverageString method that the computer 
actually finds the overall Hankee team batting average. You also want the methods findTeamAverage and findTeamAverageString to be 
static. Without the word static, there would be nine findTeamAverage methods — 
one for each instance of the PlayerPlus class. This wouldn’t make much sense. Each instance would have the code to calculate totalOfAverages / playerCount 
on its own, and each of the nine calculations would yield the same answer. In general, any task that all the instances have in common (and that yields the 
same result for each instance) should be coded as a static method. Constructors are never static. Meet the static initializer
In Listing  10-4, the decFormat field is static. This makes sense because dec 
Format makes totalOfAverages / playerCount look nice, and both fields in the 
expression totalOfAverages / playerCount are static. Thinking more directly, 
the code needs only one thing for formatting numbers. If you have several num-
bers to format, the same decFormat thing that belongs to the entire class can 
format each number. Creating a decFormat for each player is not only inelegant, 
but also wasteful. But declaring decFormat to be static presents a little problem. To set up the for-
matting, you have to call methods like decFormat.setMaximumIntegerDigits(0). You can’t just plop these method calls anywhere in the PlayerPlus class. For 
example, the following code is bad, invalid, illegal, and otherwise un-Java-like:
// THIS IS BAD CODE:
public class PlayerPlus extends Player {
  private static DecimalFormat decFormat = new DecimalFormat();
  decFormat.setMaximumIntegerDigits(0);      // Bad! decFormat.setMaximumFractionDigits(3);     // Bad! decFormat.setfsMinimumFractionDigits(3);   // Bad! Look at the examples from previous chapters. In those examples, I never let a 
method call just dangle on its own, the way I do in the bad, bad code. In this 
 chapter, in Listing 10-1, I don’t call setMaximumIntegerDigits without putting 
the method call inside the getAverageString method’s body. This no-dangling- 
method-calls business isn’t an accident. Java’s rules restrict the places in the 
code where you can issue calls to methods, and putting a lonely method call on its 
own immediately inside a class definition is a big no-no. CHAPTER 10  Putting Variables and Methods Where They Belong      271
In Listing 10-4, where can you put the necessary setMax and setMin calls? You 
can put them inside the body of the findTeamAverageString method, much the 
way I put them inside the getAverageString method in Listing 10-1. But putting 
those method calls inside the findTeamAverageString method’s body might 
defeat the purpose of having decFormat be static. After all, a programmer might 
call findTeamAverageString several times, calling decFormat.setMaximum 
IntegerDigits(0) each time. But that would be quite wasteful. The entire Player 
Plus class has only one decFormat field, and that decFormat field’s 
MaximumIntegerDigits value is always 0. Don’t keep setting MaximumInteger 
Digits(0) over and over again. The best alternative is to take the bad lines in this section’s bad code and put them 
inside a static initializer. Then they become good lines inside good code. (See 
 Listing 10-4.) A static initializer is a block that’s preceded by the word static. Java executes the static initializer’s statements once for the entire class. That’s 
exactly what you want for something called “static.”
Displaying the overall team average
You may be noticing a pattern. When you create code for a class, you generally 
write two pieces of code.

--- Chunk #734 ---
One piece of code defines the class, and the other piece of 
code uses the class. (The ways to use a class include calling the class’s constructor, 
referencing the class’s non-private fields, calling the class’s methods, and so on.) 
Listing 10-4, shown previously, contains code that defines the PlayerPlus class, 
and Listing 10-5 contains code that uses this PlayerPlus class. LISTING 10-5: Using the Code from Listing 10-4
import java.util.Scanner;
import java.io.File;
import java.io.IOException;
import javax.swing.JFrame;
import javax.swing.JLabel;
import java.awt.GridLayout;
@SuppressWarnings("serial")
public class TeamFrame extends JFrame {
  public TeamFrame() throws IOException {
    PlayerPlus player;
    Scanner hankeesData = new Scanner(new File("Hankees.txt"));
    for (int num = 1; num <= 9; num++) {
      player =
(continued)
272      PART 4  Smart Java Techniques
          new PlayerPlus(hankeesData.nextLine(), hankeesData.nextDouble());
      hankeesData.nextLine();
      addPlayerInfo(player);
    }
    add(new JLabel());
    add(new JLabel("  ------"));
    add(new JLabel("Team Batting Average:"));
    add(new JLabel(PlayerPlus.findTeamAverageString()));
    setTitle("The Hankees");
    setLayout(new GridLayout(11, 2, 20, 3));
    setDefaultCloseOperation(EXIT_ON_CLOSE);
    pack();
    setVisible(true);
    hankeesData.close();
  }
  void addPlayerInfo(PlayerPlus player) {
    add(new JLabel("  " + player.getName()));
    add(new JLabel(player.getAverageString()));
  }
}
To run the code in Listing  10-5, you need a class with a main method. The 
ShowTeamFrame class in Listing 10-3 works just fine. Figure 10-6 shows a run of the code from Listing 10-5. This run depends on the 
availability of the Hankees.txt file from Figure 10-2. The code in Listing 10-5 is 
almost an exact copy of the code from Listing 10-2. (So close is the copy that if I 
could afford it, I’d sue myself for theft of intellectual property.) The only thing 
new in Listing 10-5 is the stuff shown in bold. FIGURE 10-6: 
A run of the code 
in Listing 10-5. LISTING 10-5: (continued)
CHAPTER 10  Putting Variables and Methods Where They Belong      273
In Listing  10-5, the GridLayout has two extra rows: one row for spacing and 
another row for the Hankee team’s average. Each of these rows has two Label 
objects in it. » The spacing row has a blank label and a label with a dashed line. The 
blank label is a placeholder. When you add components to a GridLayout, 
the components are added row by row, starting at the left end of a row and 
working toward the right end. Without this blank label, the dashed-line label 
would appear at the left end of the row, under Hugh R. DaReader’s name. » The other row has a label displaying the words Team Batting Average, and 
another label displaying the number .106. The method call that gets the 
number .106 is interesting. The call looks like this:
PlayerPlus.findTeamAverageString()
Take a look at that method call. That call has the following form:
ClassName.methodName()
That’s new and different. In earlier chapters, I say that you normally preface a 
method call with an object’s name, not a class’s name. So why do I use a class 
name here? The answer: When you call a static method, you preface the 
method’s name with the name of the class that contains the method. The 
same holds true whenever you reference another class’s static field. This 
makes sense. Remember: The whole class that defines a static field or 
method owns that field or method. So, to refer to a static field or method, 
you preface the field or method’s name with the class’s name. When you’re referring to a static field or method, you can cheat and use an 
object’s name in place of the class name. For instance, in Listing 10-5, with judi-
cious rearranging of some other statements, you can use the expression player. findTeamAverageString(). The static keyword is yesterday’s news
This section makes a big noise about static fields and methods, but static 
things have been part of the picture since early in this book. For example, 
 Chapter 3 introduces System.out.println. The name System refers to a class, 
and out is a static field in that class. That’s why, in Chapter 4 and beyond, I use 
the static keyword to import the out field:
import static java.lang.System.out;
274      PART 4  Smart Java Techniques
In Java, static fields and methods show up all over the place. When they’re 
declared in someone else’s code and you’re making use of them in your code, you 
hardly ever have to worry about them. But when you’re declaring your own fields 
and methods and must decide whether to make them static, you have to think a 
little harder. In this book, my first serious use of the word static is way back in Listing 3-1. I use 
the static keyword as part of every main method (and lots of main methods are 
in this book’s listings). So why does main have to be static? Well, remember that 
non-static things belong to objects, not classes. If the main method isn’t static, 
you can’t have a main method until you create an object. But, when you start up a 
Java program, no objects have been created yet. The statements that are executed 
in the main method start creating objects. So, if the main method isn’t static, you 
have a big chicken-and-egg problem. Could cause static; handle with care
When I first started writing Java programs, I had recurring dreams about get-
ting a certain error message. The message was non-static variable or method 
cannot be referenced from a static context. So often did I see this message, 
so thoroughly was I perplexed, that the memory of this message became burned 
into my subconscious existence. These days, I know why I got that error message so often. I can even make the 
message occur if I want. But I still feel a little shiver whenever I see this message 
on my screen. Before you can understand why the message occurs and how to fix the problem, 
you need to get some terminology under your belt. If a field or method isn’t 
static, it’s called non-static. (Real surprising, hey?) Given that terminology, there 
are at least two ways to make the dreaded message appear:
 » Put Class.nonstaticThing somewhere in your program. » Put nonstaticThing somewhere inside a static method. In either case, you’re getting yourself into trouble. You’re taking something that 
belongs to an object (the non-static thing) and putting it in a place where no 
objects are in sight. Take, for instance, the first of the two situations I just described.

--- Chunk #735 ---
To see this 
calamity in action, go back to Listing 10-5. Toward the end of the listing, change 
player.getName() to Player.getName(). That does the trick. What could Player. getName possibly mean? If anything, the expression Player.getName means 
CHAPTER 10  Putting Variables and Methods Where They Belong      275
“call the getName method that belongs to the entire Player class.” But look back 
at Listing  10-1. The getName method isn’t static. Each instance of the Player 
(or  PlayerPlus) class has a getName method. None of the getName methods 
belongs to the entire class. So the call Player.getName doesn’t make any sense. (Maybe the computer is pulling punches when it displays the inoffensive cannot 
be referenced ... message. Perhaps a harsh, nonsensical expression message 
would be more fitting.)
For a taste of the second situation (in the bullet list earlier in this section), go back 
to Listing 10-4. While no one’s looking, quietly remove the word static from the 
declaration of the decFormat field (near the top of the listing). This removal turns 
decFormat into a non-static field. Suddenly, each player on the team has a sepa-
rate decFormat field. Well, things are just hunky-dory until the computer reaches the findTeam 
AverageString method. That static method has four decFormat.SuchAndSuch 
statements in it. Once again, you’re forced to ask what a statement of this kind 
could possibly mean. Method findTeamAverageString belongs to no instance 
in  particular. (The method is static, so the entire PlayerPlus class has one 
findTeamAverageString method.) But with the way you’ve just butchered 
the  code, plain old decFormat without reference to a particular object has no 
meaning. So again, you’re referencing the non-static field, decFormat, from 
inside a static method’s context. For shame, for shame, for shame! I don’t know about you, but I can always use some practice with static variables 
and methods:
 » In a previous section, you create a class to represent items in a line of men’s 
clothing. Create a subclass that includes the name of the designer (Dummies 
House of Fashion), the color of the item, and the cost of the item. The designer’s name will be static because all items in the line have the same 
designer. The color can be a static field from Java’s own Color class. (See 
https://docs.oracle.com/javase/8/docs/api/java/awt/Color.html.)
Write code to display a frame (like the frame in Figure 10-1). The frame has 
eight rows.

--- Chunk #736 ---
The first row displays the name of the designer. The next six rows 
describe one complete men’s wardrobe. The last row shows the wardrobe’s 
total cost. » In a previous section, you create a class to represent a playing card. Add a 
static field to your PlayingCard class. The field keeps track of the number 
of times the class’s constructor has been called, and thus has a count of the 
number of playing cards. 276      PART 4  Smart Java Techniques
 » What’s the output of the following code? Make some predictions, and then run 
the code to see whether your predictions are correct:
import static java.lang.System.out;
public class Main {
  public static void main(String[] args) {
    out.println(“bigValue: “ + MutableInteger.bigValue);
    // out.println(“bigValue: “ + IntegerHolder.value); ILLEGAL
    MutableInteger holder1 = new MutableInteger(42);
    MutableInteger holder2 = new MutableInteger(7);
    out.println(“holder1: “ + holder1.value);
    out.println(“holder2: “ + holder2.value);
    out.println();
    holder1.value++;
    holder2.value++;
    MutableInteger.bigValue++;
    out.println(“bigValue: “ + MutableInteger.bigValue);
    out.println(“holder1: “ + holder1.value);
    out.println(“holder2: “ + holder2.value);
    out.println();
    holder1.bigValue++;
    out.println(“bigValue according to holder1: “ + holder1.bigValue);
    out.println(“bigValue according to holder2: “ + holder2.bigValue);
  }
}
class MutableInteger {
  int value;
  static int bigValue = 1_000_000;
  public MutableInteger(int value) {
    this.value = value;
  }
}
CHAPTER 10  Putting Variables and Methods Where They Belong      277
Experiments with Variables
One summer during my college days, I was sitting on the front porch, loafing 
around, talking with someone I’d just met. I think her name was Janine.

--- Chunk #737 ---
“Where 
are you from?” I asked. “Mars,” she answered. She paused to see whether I’d ask 
a follow-up question. As it turned out, Janine was from Mars, Pennsylvania, a small town about 20 miles 
north of Pittsburgh. Okay, so what’s my point? The point is that the meaning of a 
name depends on the context. If you’re just north of Pittsburgh and ask, “How do 
I get to Mars from here?” you may get a sensible, nonchalant answer. But if you 
ask the same question standing on a street corner in Manhattan, you’ll probably 
arouse some suspicion. (Okay, knowing Manhattan, people would probably just 
ignore you.)
Of course, the people who live in Mars, Pennsylvania, are very much aware that 
their town has an oddball name. Fond memories of teenage years at Mars High 
School don’t prevent a person from knowing about the big red planet. On a clear 
evening in August, you can still have the following conversation with one of the 
local residents:
You: How do I get to Mars? Local resident: You’re in Mars, pal. What particular part of Mars are you looking for? You: No, I don’t mean Mars, Pennsylvania. I mean the planet Mars. Local resident: Oh, the planet! Well, then, catch the 8:19 train leaving for Cape 
Canaveral . . . No, wait — that’s the local train. That’d take you through West 
Virginia. .

--- Chunk #738 ---
.

--- Chunk #739 ---
. So the meaning of a name depends on where you’re using the name. Although 
most English-speaking people think of Mars as a place with a carbon dioxide 
atmosphere, some folks in Pennsylvania think about all the shopping they can do 
in Mars. And those folks in Pennsylvania really have two meanings for the name 
Mars. In Java, those names may look like this: Mars and planets.Mars. Putting a variable in its place
Your first experiment is shown in Listings  10-6 and  10-7. The listings’ code 
 highlights the difference between variables that are declared inside and outside 
methods. 278      PART 4  Smart Java Techniques
LISTING 10-6: Two Meanings for Mars
import static java.lang.System.out;
class EnglishSpeakingWorld {
    String mars = "   red planet";
    void visitPennsylvania() {
        out.println("visitPA is running:");
        String mars = "   Janine's home town";
        out.println(mars);
        out.println(this.mars);
    }
}
LISTING 10-7: Calling the Code of Listing 10-6
import static java.lang.System.out;
public class GetGoing {
    public static void main(String args[]) {
        out.println("main is running:");
        EnglishSpeakingWorld e = new EnglishSpeakingWorld();
        //out.println(mars);   cannot resolve symbol
        out.println(e.mars);
        e.visitPennsylvania();
   }
}
Figure 10-7 shows a run of the code in Listings 10-6 and 10-7. Figure 10-8 shows 
a diagram of the code’s structure. In the GetGoing class, the main method cre-
ates an instance of the EnglishSpeakingWorld class. The variable e refers to the 
new instance. The new instance is an object with a variable named mars inside it. That mars variable has the value "red planet". The "red planet"mars variable 
is a field. FIGURE 10-7: 
A run of the code 
in Listings 10-6 
and 10-7. CHAPTER 10  Putting Variables and Methods Where They Belong      279
Another way to describe that mars field is to call it an instance variable because 
that mars variable (the variable whose value is "red planet" ) belongs to an 
instance of the EnglishSpeakingWorld class. In contrast, you can refer to static 
fields (like the playerCount, totalOfAverages, and decFormat fields in 
Listing  10-4) as class variables. For example, playerCount in Listing  10-4 is a 
class variable because one copy of playerCount belongs to the entire PlayerPlus 
class. Now look at the main method in Listing 10-7. Inside the GetGoing class’s main 
method, you aren’t permitted to write out.println(mars). In other words, a 
bare-faced reference to any mars variable is a definite no-no. The mars variable 
that I mention in the preceding paragraph belongs to the EnglishSpeakingWorld 
object, not the GetGoing class. However, inside the GetGoing class’s main method, you can certainly write e.mars 
because the e variable refers to your EnglishSpeakingWorld object. That’s nice. Near the bottom of the code, the visitPennsylvania method is called. When 
you’re inside visitPennsylvania, you have another declaration of a mars vari-
able, whose value is "Janine's home town" . This particular mars variable is 
called a method-local variable because it belongs to just one method: the visit 
Pennsylvania method. FIGURE 10-8: 
The structure of 
the code in 
Listings 10-6 
and 10-7. 280      PART 4  Smart Java Techniques
Now you have two variables, both with the name mars. One mars variable, a field, 
has the value "red planet". The other mars variable, a method-local variable, has 
the value "Janine's home town" . In the code, when you use the word mars, to 
which of the two variables are you referring? The answer is, when you’re visiting Pennsylvania, the variable with value 
"Janine's home town" wins. When in Pennsylvania, think the way the Pennsyl-
vanians think. When you’re executing code inside the visitPennsylvania 
method, resolve any variable name conflicts by going with method-local 
 variables — variables declared right inside the visitPennsylvania method. What if you’re in Pennsylvania and need to refer to that 2-mooned celestial object? More precisely, how does code inside the visitPennsylvania method refer to the 
field with value "red planet" ? The answer is, use this.mars. The word this  
points to whatever object contains all this code (and not to any methods inside the 
code). That object, an instance of the EnglishSpeakingWorld class, has a big, fat 
mars field, and that field’s value is "red planet". So that’s how you can force code 
to see outside the method it’s in — you use the Java keyword this. For more information on the keyword this, see Chapter 9. Telling a variable where to go
Years ago, when I lived in Milwaukee, Wisconsin, I made frequent use of the local 
bank’s automatic teller machines. Machines of this kind were just beginning to 
become standardized. The local teller machine system was named TYME, which 
stood for Take Your Money Everywhere. I remember traveling by car out to California. At one point, I got hungry and 
stopped for a meal, but I was out of cash. So I asked a gas station attendant, “Do 
you know where there’s a TYME machine around here?”
So you see, a name that works well in one place could work terribly, or not at all, 
in another place. In Listings 10-8 and 10-9, I illustrate this point (with more than 
just an anecdote about teller machines). LISTING 10-8: Tale of Atomic City
import static java.lang.System.out;
class EnglishSpeakingWorld2 {
    String mars;
CHAPTER 10  Putting Variables and Methods Where They Belong      281
    void visitIdaho() {
        out.println("visitID is running:");
        mars = "   red planet";
        String atomicCity = "   Population: 25";
        out.println(mars);
        out.println(atomicCity);
    }
    void visitNewJersey() {
        out.println("visitNJ is running:");
        out.println(mars);
        //out.println(atomicCity);   cannot resolve symbol
    }
}
LISTING 10-9: Calling the Code of Listing 10-8
public class GetGoing2 {
    public static void main(String args[]) {
       EnglishSpeakingWorld2 e = new EnglishSpeakingWorld2();
       e.visitIdaho();
       e.visitNewJersey();
    }
}
Figure 10-9 shows a run of the code in Listings 10-8 and 10-9. Figure 10-10 shows 
a diagram of the code’s structure. The code for EnglishSpeakingWorld2 has two 
variables. The mars variable, which isn’t declared inside a method, is a field. The 
other variable, atomicCity, is a method-local variable and is declared inside 
the visitIdaho method. FIGURE 10-9: 
A run of the code 
in Listings 10-8 
and 10-9. 282      PART 4  Smart Java Techniques
In Listing 10-8, notice where each variable can and can’t be used. When you try to 
use the atomicCity variable inside the visitNewJersey method, you get an error 
message. Literally, the message says cannot resolve symbol. Figuratively, the 
message says, “Hey, buddy, Atomic City is in Idaho, not New Jersey.” Technically, 
the message says that the method-local variable atomicCity is available only in 
the visitIdaho method because that’s where the variable was declared. Back inside the visitIdaho method, you’re free to use the atomicCity variable 
as  much as you want. After all, the atomicCity variable is declared inside the 
visitIdaho method. And what about Mars? Have you forgotten about your old friend, that lovely 
80-degrees-below-0 planet? Well, both the visitIdaho and visitNewJersey 
methods can access the mars variable. That’s because the mars variable is a field. That is, the mars variable is declared in the code for the EnglishSpeakingWorld2 
class but not inside any particular method. (In my stories about the names for 
things, remember that people who live in both states, Idaho and New Jersey, have 
heard of the planet Mars.)
The life cycle of the mars field has three separate steps:
 » When the EnglishSpeakingWorld2 class first flashes into existence, the 
computer sees String mars and creates space for the mars field. EnglishSpeakingWorld2
red planet
visitIdaho
Population: 25
visitNewJersey
mars (instance variable)
atomicCity
(method-local variable
FIGURE 10-10: 
The structure of 
the code in 
Listings 10-8 
and 10-9. CHAPTER 10  Putting Variables and Methods Where They Belong      283
 » When the visitIdaho method is executed, the method assigns the value 
"red planet" to the mars field. (The visitIdaho method also prints the 
value of the mars field.)
 » When the visitNewJersey method is executed, the method prints the mars 
value once again. In this way, the mars field’s value is passed from one method to another. Try out these programs.

--- Chunk #740 ---
See what you think. » What’s the output of the following code? Why? public class Main1 {
  static String name = "George";
  public static void main(String[] args) {
    System.out.println(name);
    String name = "Barry";
    System.out.println(name);
  }
}
 » What’s the output of the following code? Why? public class Main2 {
  String name = "George";
  public static void main(String[] args) {
    new Main2();
  }
  Main2() {
    System.out.println(name);
    String name = "Barry";
    System.out.println(name);
    System.out.println(this.name);
  }
}
284      PART 4  Smart Java Techniques
 » What’s the output of the following code? Why? public class Main3 {
  static String name = "George";
  public static void main(String[] args) {
    String name = "Barry";
    new OtherClass();
  }
}
class OtherClass {
  OtherClass() {
    String name = "Leonard";
    System.out.println(name);
    System.out.println(Main3.name);
  }
}
 » What’s the output of the following code? Why? public class Main4 {
  String name = "George";
  public static void main(String[] args) {
    new Main4();
  }
  Main4() {
    String name = "Barry";
    new YetAnotherClass(this);
  }
}
class YetAnotherClass {
  YetAnotherClass(Main4 whoCreatedMe) {
    String name = "Leonard";
    System.out.println(name);
    // System.out.println(Main4.name); ILLEGAL
    System.out.println(whoCreatedMe.name);
  }
}
CHAPTER 10  Putting Variables and Methods Where They Belong      285
Passing Parameters
A method can communicate with another part of your Java program in several 
ways. One way is through the method’s parameter list. Using a parameter list, you 
pass on-the-fly information to a method as the method is being called. Imagine that the information you pass to the method is stored in one of your 
 program’s variables. What, if anything, does the method actually do with that 
variable? The following sections present a few interesting case studies. Pass by value
According to my web research, the town of Smackover, Arkansas, has 2,232 people 
in it. But my research isn’t current. Just yesterday, Dora Kermongoos celebrated a 
joyous occasion over at Smackover General Hospital — the birth of her healthy, 
blue-eyed baby girl. (The girl weighs 7 pounds, 4 ounces, and is 21 inches tall.) 
Now the town’s population has risen to 2,233. Listing 10-10 has a very bad program in it. The program is supposed to add 1 to a 
variable that stores Smackover’s population, but the program doesn’t work. Take 
a look at Listing 10-10 and see why. LISTING 10-10: This Program Doesn’t Work
public class TrackPopulation {
    public static void main(String args[]) {
        int smackoverARpop = 2232;
        birth(smackoverARpop);
        System.out.println(smackoverARpop);
    }
    static void birth(int cityPop) {
        cityPop++;
    }
}
When you run the program in Listing 10-10, the program displays the number 
2,232 onscreen. After nine months of planning and anticipation and Dora’s whop-
ping seven hours in labor, the Kermongoos family’s baby girl wasn’t registered in 
the system. What a shame! 286      PART 4  Smart Java Techniques
The improper use of parameter passing caused the problem. In Java, when you 
pass a parameter that has one of the eight primitive types, that parameter is passed 
by value. For a review of Java’s eight primitive types, see Chapter 4. Here’s what this means in plain English: Any changes that the method makes to 
the value of its parameter don’t affect the values of variables back in the calling 
code. In Listing 10-10, the birth method can apply the ++ operator to cityPop all 
it wants — the application of ++ to the cityPop parameter has absolutely no effect 
on the value of the smackoverARpop variable back in the main method. Technically, what’s happening is the copying of a value. (See Figure 10-11.) When 
the main method calls the birth method, the value stored in smackoverARpop 
is  copied to another memory location  — a location reserved for the cityPop 
parameter’s value. During the birth method’s execution, 1 is added to the 
cityPop parameter. But the place where the original 2232 value was stored — 
the memory location for the smackoverARpop variable — remains unaffected. FIGURE 10-11: 
Pass by value, 
under the hood. CHAPTER 10  Putting Variables and Methods Where They Belong      287
When you do parameter passing with any of the eight primitive types, the 
 computer uses pass by value. The value stored in the calling code’s variable remains 
unchanged. This happens even if the calling code’s variable and the called 
 method’s parameter happen to have exactly the same name. Returning a result
You must fix the problem that the code in Listing 10-10 poses. After all, a young 
baby Kermongoos can’t go through life untracked. To record this baby’s existence, 
you have to add 1 to the value of the smackoverARpop variable. You can do this in 
plenty of ways, and the way presented in Listing 10-11 isn’t the simplest. Even so, 
the way shown in Listing  10-11 illustrates a point: Returning a value from a 
method call can be an acceptable alternative to parameter passing. Look at 
 Listing 10-11 to see what I mean. LISTING 10-11: This Program Works
public class TrackPopulation2 {
    public static void main(String args[]) {
        int smackoverARpop = 2232;
        smackoverARpop = birth(smackoverARpop);
        System.out.println(smackoverARpop);
    }
    static int birth(int cityPop) {
        return cityPop + 1;
    }
}
After running the code in Listing 10-11, the number you see on your computer 
screen is the correct number, 2,233. The code in Listing 10-11 has no new features in it (unless you call working correctly 
a new feature). The most important idea in Listing 10-11 is the return statement, 
which also appears in Chapter 7. Even so, Listing 10-11 presents a nice contrast to 
the approach in Listing 10-10, which had to be discarded. Pass by reference
In the previous section or two, I take great pains to emphasize a certain point — 
that when a parameter has one of the eight primitive types, the parameter is 
288      PART 4  Smart Java Techniques
passed by value. If you read this, you probably missed the emphasis on the param-
eter’s having one of the eight primitive types. The emphasis is needed because 
passing objects (reference types) doesn’t quite work the same way. When you pass an object to a method, the object is passed by reference. What this 
means to you is that statements in the called method can change any values that 
are stored in the object’s variables. Those changes do affect the values that are 
seen by whatever code called the method. Listings 10-12 and 10-13 illustrate the 
point. LISTING 10-12: What Is a City? class City {
    int population;
}
LISTING 10-13: Passing an Object to a Method
public class TrackPopulation3 {
    public static void main(String args[]) {
        City smackoverAR = new City();
        smackoverAR.population = 2232;
        birth(smackoverAR);
        System.out.println(smackoverAR.population);
    }
    static void birth(City aCity) {
        aCity.population++;
    }
}
When you run the code in Listings 10-12 and 10-13, the output that you get is the 
number 2,233. That’s good because the code has things like ++ and the word birth 
in it. The deal is, adding 1 to aCity.population inside the birth method actually 
changes the value of smackoverAR.population, as it’s known in the main method. To see how the birth method changes the value of smackoverAR.population, 
look at Figure 10-12. When you pass an object to a method, the computer doesn’t 
make a copy of the entire object. Instead, the computer makes a copy of a refer -
ence to that object. (Think of it the way it’s shown in Figure 10-12. The computer 
makes a copy of an arrow that points to the object.)
CHAPTER 10  Putting Variables and Methods Where They Belong      289
In Figure 10-12, you see just one instance of the City class, with a population 
variable inside it. Now keep your eye on that object as you read the following 
steps:
1. Just before the birth method is called, the smackoverAR variable refers to that 
object — the instance of the City class. 2. When the birth method is called and smackoverAR is passed to the birth 
method’s aCity parameter, the computer copies the reference from 
smackoverAR to aCity. Now aCity refers to that same object — the 
instance of the City class. 3. When the statement aCity.population++ is executed inside the birth 
method, the computer adds 1 to the object’s population field. Now the 
program’s one and only City instance has 2233 stored in its population field. 4.

--- Chunk #741 ---
The flow of execution goes back to the main method. The value of smackoverAR. population is printed. But smackoverAR refers to that one instance of the City 
class. So smackoverAR.population has the value 2233. The Kermongoos family 
is so proud. Returning an object from a method
Believe it or not, the previous sections on parameter passing left one nook and 
cranny of Java methods unexplored. When you call a method, the method can 
FIGURE 10-12: 
Pass by 
 reference, 
under the hood. 290      PART 4  Smart Java Techniques
return something right back to the calling code. In previous chapters and sections, 
I return primitive values, such as int values, or nothing (otherwise known as 
void). In this section, I return a whole object. It’s an object of type City from 
 Listing 10-12. The code that makes this happen is in Listing 10-14. LISTING 10-14: Here, Have a City
public class TrackPopulation4 {
    public static void main(String args[]) {
        City smackoverAR = new City();
        smackoverAR.population = 2232;
        smackoverAR = doBirth(smackoverAR);
        System.out.println(smackoverAR.population);
    }
    static City doBirth(City aCity) {
        City myCity = new City();
        myCity.population = aCity.population + 1;
        return myCity;
    }
}
If you run the code in Listing 10-14, you get the number 2,233. That’s good. The 
code works by telling the doBirth method to create another City instance. In the 
new instance, the value of population is 2233. (See Figure 10-13.)
FIGURE 10-13: 
The doBirth 
method creates a 
City instance. CHAPTER 10  Putting Variables and Methods Where They Belong      291
After the doBirth method is executed, that City instance is returned to the main 
method. Then, back in the main method, that instance (the one that doBirth 
returns) is assigned to the smackoverAR variable. (See Figure  10-14.) Now 
smackoverAR refers to a brand-new City instance — an instance whose popula -
tion is 2,233. In Listing 10-14, notice the type consistency in the calling and returning of the 
doBirth method:
 » The smackoverAR variable has type City. The smackoverAR variable is 
passed to the aCity parameter, which is also of type City. » The myCity variable is of type City. The myCity variable is sent back in the 
doBirth method’s return statement. That’s consistent, because the doBirth 
method’s header begins with static City doBirth(blah, blah, blah ... —   
a promise to return an object of type City. » The doBirth method returns an object of type City. Back in the main method, 
the object that the call to doBirth returns is assigned to the smackoverAR 
variable, and (you guessed it) the smackoverAR variable is of type City. FIGURE 10-14: 
The new City 
instance is 
assigned to the 
smack overAR 
variable. 292      PART 4  Smart Java Techniques
Aside from being quite harmonious, all this type agreement is absolutely neces -
sary. If you write a program in which your types don’t agree with one another, the 
compiler spits out an unsympathetic incompatible types message. Epilogue
Dora Kermongoos and her newborn baby daughter are safe, healthy, and resting 
happily in their Smackover, Arkansas, home. CHAPTER 11  Using Arrays to Juggle Values      293
IN THIS CHAPTER
 » Dealing with several values at once
 » Searching for things
 » Creating values as you get a program 
running
Using Arrays to Juggle 
Values
W
elcome to the Java Motel! No haughty bellhops, no overpriced room 
service, none of the usual silly puns.

--- Chunk #742 ---
Just a clean double room that’s a 
darn good value! Getting Your Ducks All in a Row
The Java Motel, with its ten comfortable rooms, sits in a quiet place off the main 
highway. Aside from a small, separate office, the motel is just one long row of 
ground-floor rooms. Each room is easily accessible from the spacious front park-
ing lot. Oddly enough, the motel’s rooms are numbered 0 through 9. I could say that the 
numbering is a fluke — something to do with the builder’s original design plan. But the truth is that starting with 0 makes the examples in this chapter easier to 
write. Chapter 11
294      PART 4  Smart Java Techniques
Anyway, you’re trying to keep track of the number of guests in each room. Because 
you have ten rooms, you may think about declaring ten variables:
int guestsInRoomNum0, guestsInRoomNum1, guestsInRoomNum2,
    guestsInRoomNum3, guestsInRoomNum4, guestsInRoomNum5,
    guestsInRoomNum6, guestsInRoomNum7, guestsInRoomNum8,
    guestsInRoomNum9;
Doing it this way may seem a bit inefficient — but inefficiency isn’t the only thing 
wrong with this code. Even more problematic is the fact that you can’t loop 
through these variables. To read a value for each variable, you have to copy the 
nextInt method ten times. guestsInRoomNum0 = diskScanner.nextInt();
guestsInRoomNum1 = diskScanner.nextInt();
guestsInRoomNum2 = diskScanner.nextInt();
// ... and so on.

--- Chunk #743 ---
Surely a better way exists. That better way involves an array. An array  is a row of values, like the row of 
rooms in a 1-floor motel. To picture the array, just picture the Java Motel:
 » First, picture the rooms, lined up next to one another. » Next, picture the same rooms with their front walls missing. Inside each room 
you can see a certain number of guests. » If you can, forget that the two guests in Room 9 are putting piles of bills into a 
big briefcase. Ignore the fact that the guests in Room 6 haven’t moved away 
from the TV set in a day-and-a-half. Instead of all these details, see only 
numbers. In each room, see a number representing the count of guests in 
that room. (If free-form visualization isn’t your strong point, look at 
Figure 11-1.)
In the lingo of this chapter, the entire row of rooms is called an array. Each room 
in the array is called a component of the array (also known as an array element). Each component has two numbers associated with it:
 » The room number (a number from 0 to 9), which is called an index of the array
 » A number of guests, which is a value stored in a component of the array
CHAPTER 11  Using Arrays to Juggle Values      295
Using an array saves you from all the repetitive nonsense in the sample code 
shown at the beginning of this section. For instance, to declare an array with ten 
values in it, you can write one fairly short statement:
int guests[] = new int[10];
If you’re especially verbose, you can expand this statement so that it becomes two 
separate statements:
int guests[];
guests = new int[10];
In either of these code snippets, notice the use of the number 10. This number tells 
the computer to make the guests array have ten components. Each component of 
the array has a name of its own. The starting component is named guests[0],  the 
next is named guests[1], and so on. The last of the ten components is named 
guests[9]. In creating an array, you always specify the number of components. The array’s 
indices start with 0 and end with the number that’s one less than the total number 
of components. The snippets that I show you give you two ways to create an array. The first way 
uses one line.

--- Chunk #744 ---
The second way uses two lines. If you take the single-line route, you 
can put that line inside or outside a method. The choice is yours. On the other 
hand, if you use two separate lines, the second line, guests = new int[10] , 
should be inside a method. FIGURE 11-1: 
An abstract 
snapshot of 
rooms in the 
Java Motel. 296      PART 4  Smart Java Techniques
In an array declaration, you can put the square brackets before or after the vari-
able name. In other words, you can write int guests[] or int[] guests. The 
computer creates the same guests variable no matter which form you use. Creating an array in two easy steps
Look again at the two lines that you can use to create an array:
int guests[];
guests = new int[10];
Each line serves its own distinct purpose:
 » int guests[]: This first line is a declaration. The declaration reserves the 
array name (a name like guests) for use in the rest of the program. In the Java 
Motel metaphor, this line says, “I plan to build a motel here and put a certain 
number of guests in each room.” (See Figure 11-2.)
Never mind what the declaration int guests[] actually does. It’s more 
important to notice what the declaration int guests[] doesn’t do. The 
declaration doesn’t reserve ten memory locations. Indeed, a declaration like 
int guests[] doesn’t really create an array. All the declaration does is set up 
the guests variable. At that point in the code, the guests variable still doesn’t 
refer to a real array. (In other words, the motel has a name, but the motel 
hasn’t been built yet.)
 » guests = new int[10]: This second line is an assignment statement. The 
assignment statement reserves space in the computer’s memory for ten int 
values. In terms of real estate, this line says, “I’ve finally built the motel. Go 
ahead and put guests in each room.” (Again, see Figure 11-2.)
FIGURE 11-2: 
Two steps in 
creating an array. CHAPTER 11  Using Arrays to Juggle Values      297
Storing values
After you’ve created an array, you can put values into the array’s components. For 
instance, you want to store the fact that Room 6 contains four guests. To put the 
value 4 in the component with index 6, you write guests[6] = 4. Now business starts to pick up.

--- Chunk #745 ---
A big bus pulls up to the motel. On the side of the 
bus is a sign that says Noah’s Ark. Out of the bus come 25 couples, each walking, 
stomping, flying, hopping, or slithering to the motel’s small office. Only 10 of the 
couples can stay at the Java Motel, but that’s okay because you can send the other 
15 couples down the road to the old C-Side Resort and Motor Lodge. Anyway, to register ten couples into the Java Motel, you put a couple (two guests) 
in each of your ten rooms. Having created an array, you can take advantage of the 
array’s indexing and write a for loop, like this:
for (int roomNum = 0; roomNum < 10; roomNum++) {
    guests[roomNum] = 2;
}
This loop takes the place of ten assignment statements. Notice how the loop’s 
counter goes from 0 to 9. Compare this with Figure 11-2 and remember that the 
indices of an array go from zero to one less than the number of components in the 
array. However, given the way the world works, your guests won’t always arrive in neat 
pairs, and you’ll have to fill each room with a different number of guests. You 
probably store information about rooms and guests in a database. If you do, you 
can still loop through an array, gathering numbers of guests as you go. The code 
to perform such a task may look like this:
resultset = statement.executeQuery("select GUESTS from RoomData");
for (int roomNum = 0; roomNum < 10; roomNum++) {
    resultset.next();
    guests[roomNum] = resultset.getInt("GUESTS");
}
But because this book doesn’t cover databases until Chapter 17, you may be better 
off reading numbers of guests from a plain-text file. A sample file named 
GuestList.txt is shown in Figure 11-3.

--- Chunk #746 ---
FIGURE 11-3: 
The GuestList. txt file. 298      PART 4  Smart Java Techniques
After you’ve made a file, you can call on the Scanner class to get values from the 
file. The code is shown in Listing 11-1, and the resulting output is in Figure 11-4. This book’s website ( www.allmycode.com/JavaForDummies) has tips for readers 
who need to create data files. This includes instructions for Windows, Linux, and 
Macintosh environments. LISTING 11-1: Filling an Array with Values
import static java.lang.System.out;
import java.util.Scanner;
import java.io.File;
import java.io.IOException;
public class ShowGuests {
    public static void main(String args[]) throws IOException {
        int guests[] = new int[10];
        Scanner diskScanner = new Scanner(new File("GuestList.txt"));
        for(int roomNum = 0; roomNum < 10; roomNum++) {
            guests[roomNum] = diskScanner.nextInt();
        }
        out.println("Room\tGuests");
        for(int roomNum = 0; roomNum < 10; roomNum++) {
            out.print(roomNum);
            out.print("\t");
            out.println(guests[roomNum]);
        }
        diskScanner.close();
    }
}
FIGURE 11-4: 
Running the code 
from Listing 11-1. CHAPTER 11  Using Arrays to Juggle Values      299
The code in Listing 11-1 has two for loops: The first loop reads numbers of guests, 
and the second loop writes numbers of guests. Every array has a built-in length field. An array’s length is the number of compo-
nents in the array. So, in Listing 11-1, if you print the value of guests.length, you 
get 10. Tab stops and other special things
In Listing 11-1, some calls to print and println use the \t escape sequence. It’s 
called an escape sequence  because you escape from displaying the letter t on the 
screen. Instead, the characters \t stand for a tab. The computer moves forward to 
the next tab stop before printing any more characters. Java has a few of these 
handy escape sequences. Some of them are shown in Table 11-1. Using an array initializer
Besides what you see in Listing 11-1, you have another way to fill an array in Java: 
with an array initializer. When you use an array initializer, you don’t even have to 
tell the computer how many components the array has. The computer figures this 
out for you. Listing 11-2 shows a new version of the code to fill an array. The program’s output 
is the same as the output of Listing 11-1. (It’s the stuff shown in Figure 11-4.) The 
only difference between Listings 11-1 and 11-2 is the bold text in Listing 11-2. That 
bold doodad is an array initializer. TABLE 11-1 Escape Sequences
Sequence Meaning
\b backspace
\t horizontal tab
\n line feed
\f form feed
\r carriage return
\" double quote "
\' single quote '
\\ backslash \
300      PART 4  Smart Java Techniques
LISTING 11-2: Using an Array Initializer
import static java.lang.System.out;
public class ShowGuests {
    public static void main(String args[]) {
        int guests[] = {1, 4, 2, 0, 2, 1, 4, 3, 0, 2};
        out.println("Room\tGuests");
        for (int roomNum = 0; roomNum < 10; roomNum++) {
            out.print(roomNum);
            out.print("\t");
            out.println(guests[roomNum]);
        }
    }
}
An array initializer can contain expressions as well as literals. In plain English, 
this means that you can put all kinds of things between the commas in the initial-
izer.

--- Chunk #747 ---
For instance, an initializer like {1 + 3, keyboard.nextInt(), 2, 0, 2, 1, 
4, 3, 0, 2} works just fine. Use my DummiesFrame (from Chapter  7) to create a GUI program based on the 
ideas in Listings 11-1 and 11-2. In your program, the frame has only one input row: 
a Room number row. If the user types 3 in the Room number row and then clicks the 
button, the program displays the number of guests in Room 3. Stepping through an array with the  
enhanced for loop
Java has an enhanced for loop — a for loop that doesn’t use counters or indices. Listing 11-3 shows you how to do it.

--- Chunk #748 ---
The material in this section applies to Java 5.0 and later Java versions. But this 
section’s material doesn’t work with older versions of Java — versions such as 1.3, 
1.4, and so on. For a bit more about Java’s version numbers, see Chapter 2. CHAPTER 11  Using Arrays to Juggle Values      301
LISTING 11-3: Get a Load o’ That for Loop! import static java.lang.System.out;
public class ShowGuests {
    public static void main(String args[]) {
        int guests[] = {1, 4, 2, 0, 2, 1, 4, 3, 0, 2};
        int roomNum = 0;
        out.println("Room\tGuests");
        for (int numGuests : guests) {
            out.print(roomNum++);
            out.print("\t");
            out.println(numGuests);
        }
    }
}
Listings 11-1 and 11-3 have the same output. It’s in Figure 11-4. An enhanced for statement has three parts:
for (variable-type variable-name : range-of-values)
The first two parts are variable-type and variable-name. The loop in Listing 11-3 
defines a variable named numGuests, and numGuests has type int. During each 
loop iteration, the variable numGuests takes on a new value. Look at Figure 11-4 to 
see these values. The initial value is 1. The next value is 4. After that comes 2. And 
so on. Where is the loop finding all these numbers? The answer lies in the loop’s range- 
of-values. In Listing 11-3, the loop’s range-of-values is guests. So, during the ini-
tial loop iteration, the value of numGuests is guests[0] (which is 1). During the 
next iteration, the value of numGuests is guests[1] (which is 4). After that comes 
guests[2] (which is 2). And so on. Java’s enhanced for loop requires a word of caution. Each time through the loop, 
the variable that steps through the range of values stores a copy of the value in the 
original range. The variable does not point to the range itself. For example, if you add an assignment statement that changes the value of 
numGuests in Listing 11-3, this statement has no effect on any of the values stored 
302      PART 4  Smart Java Techniques
in the guests array. To drive this point home, imagine that business is bad and 
I’ve filled my hotel’s guests array with zeros. Then I execute the following code:
for (int numGuests : guests) {
    numGuests += 1;
    out.print(numGuests + " ");
}
out.println();
for (int numGuests : guests) {
    out.print(numGuests + " ");
}
The numGuests variable takes on values stored in the guests array. But the 
numGuests += 1 statement doesn’t change the values stored in this guests array. The code’s output looks like this:
1 1 1 1 1 1 1 1 1 1
0 0 0 0 0 0 0 0 0 0
Write a program that stores five double values in an array and then displays the 
average of the values in the array. Searching
You’re sitting behind the desk at the Java Motel.

--- Chunk #749 ---
Look!

--- Chunk #750 ---
Here comes a party of 
five. These people want a room, so you need software that checks whether a room 
is vacant. If one is, the software modifies the GuestList.txt file (refer to 
 Figure 11-3) by replacing the number 0 with the number 5. As luck would have it, 
the software is on your hard drive.

--- Chunk #751 ---
The software is shown in Listing 11-4.

--- Chunk #752 ---
LISTING 11-4: Do You Have a Room? import static java.lang.System.out;
import java.util.Scanner;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
public class FindVacancy {
    public static void main(String args[]) throws IOException {
CHAPTER 11  Using Arrays to Juggle Values      303
        int guests[] = new int[10];
        int roomNum;
        Scanner diskScanner = new Scanner(new File("GuestList.txt"));
        for (roomNum = 0; roomNum < 10; roomNum++) {
            guests[roomNum] = diskScanner.nextInt();
        }
        diskScanner.close();
        roomNum = 0;
        while (roomNum < 10 && guests[roomNum] != 0) {
            roomNum++;
        }
        if (roomNum == 10) {
            out.println("Sorry, no v cancy");
        } else {
            out.print("How many people for room ");
            out.print(roomNum);
            out.print("? ");
            Scanner keyboard = new Scanner(System.in);
            guests[roomNum] = keyboard.nextInt();
            keyboard.close();
            PrintStream listOut = new PrintStream("GuestList.txt");
            for (roomNum = 0; roomNum < 10; roomNum++) {
                listOut.print(guests[roomNum]);
                listOut.print(" ");
            }
            listOut.close();
        }
    }
}
Figures 11-5 through 11-7 show the running of the code in Listing 11-4. Back in 
Figure 11-3, the motel starts with two vacant rooms — Rooms 3 and 8. (Remember, 
the rooms start with Room 0.) The first time that you run the code in Listing 11-4, 
the program tells you that Room 3 is vacant and puts five people into the room. The second time you run the code, the program finds the remaining vacant room 
(Room 8) and puts a party of ten in the room. (What a party!) The third time you 
run the code, you have no more vacant rooms. When the program discovers this, 
it displays the message Sorry, no v cancy , omitting at least one letter in the 
tradition of all motel neon signs. 304      PART 4  Smart Java Techniques
A run of the code in Listing 11-4 writes a brand-new GuestList.txt file. This can 
be confusing because each Java IDE has its own way of displaying the GuestList. txt file’s content. Some IDEs don’t automatically display the newest GuestList. txt file, so after running the code from Listing 11-4, you may not immediately see 
a change. (For example, in Figure 11-5, Room 3 is empty. But after a run of the 
code, Figure  11-6 shows Room 3 having five guests.) Even if you don’t see a 
change, consecutive runs of Listing  11-4 change the GuestList.txt file. Poke 
around within your favorite IDE to find out how to make the IDE refresh the 
GuestList.txt file’s display. In Listing 11-4, the condition roomNum < 10 && guests[roomNum] != 0  can be 
really tricky. If you move things around and write guests[roomNum] != 0 && 
roomNum < 10, you can get yourself into lots of trouble. For details, see this 
book’s website (www.allmycode.com/JavaForDummies). FIGURE 11-5: 
Filling a vacancy. FIGURE 11-6: 
Filling the last 
vacant room. FIGURE 11-7: 
Sorry, Bud. No 
rooms. CHAPTER 11  Using Arrays to Juggle Values      305
Writing to a file
The code in Listing 11-4 uses tricks from other chapters and sections of this book. The code’s only brand-new feature is the use of PrintStream to write to a disk file. Think about any example in this book that calls System.out.print, out.println, 
or their variants. What’s really going on when you call one of these methods? The thing called System.out is an object. The object is defined in the Java API. In 
fact, System.out is an instance of a class named java.io.PrintStream (or just 
PrintStream to its close friends). Now each object created from the PrintStream 
class has methods named print and println. Just as each Account object in 
 Listing 7-3 has a display method, and just as the DecimalFormat object in 
 Listing  10-1 has a format method, so the PrintStream object named out has 
print and println methods. When you call System.out.println, you’re calling 
a method that belongs to a PrintStream instance. Okay, so what of it? Well, System.out always stands for some text area on your 
computer screen. If you create your own PrintStream object and you make that 
object refer to a disk file, that PrintStream object refers to the disk file. When you 
call that object’s print method, you write text to a file on your hard drive. In Listing 11-4, when you say
PrintStream listOut = new PrintStream("GuestList.txt");
listOut.print(guests[roomNum]);
listOut.print(" ");
you’re telling Java to write text to a file on your hard drive — the GuestList.txt file. That’s how you update the count of guests staying in the hotel. When you call 
listOut.print for the number of guests in Room 3, you may print the number 5. So, between Figures  11-5 and 11-6, a number in the GuestList.txt file changes 
from 0 to 5. Then in Figure 11-6, you run the program a second time. When the 
program gets data from the newly written GuestList.txt file, Room 3 is no lon-
ger vacant. This time, the program suggests Room 8. This is more of an observation than a tip. Say that you want to read data from a file 
named Employees.txt. To do this, you make a scanner. You call new Scanner(new 
File("Employees.txt")). If you accidentally call new Scanner("Employees. txt") without the new File part, the call doesn’t connect to your Employees.txt 
file. But notice how you prepare to write data to a file. You make a PrintStream 
instance by calling new PrintStream("GuestList.txt"). You don’t use new File 
anywhere in the call. If you goof and accidentally include new File, the Java com-
piler becomes angry, jumps out, and bites you. 306      PART 4  Smart Java Techniques
When to close a file
Notice the placement of new Scanner calls, new PrintStream calls, and close 
calls in Listing 11-4. As in all the examples, each new Scanner call has a corre -
sponding close call. And in Listing 11-4, the new PrintStream call has its own 
close call (the listOut.close() call). But in Listing 11-4, I’m careful to place 
these calls tightly around their corresponding nextInt and print calls. For exam-
ple, I don’t set up diskScanner at the very start of the program, and I don’t wait 
until the very end of the program to close diskScanner. Instead, I perform all my 
diskScanner tasks one after the other in quick succession:
Scanner diskScanner = new Scanner(new File("GuestList.txt"));   //construct
for (roomNum = 0; roomNum < 10; roomNum++) {
    guests[roomNum] = diskScanner.nextInt();                    //read
}
diskScanner.close();                                            //close
I do the same kind of thing with the keyboard and listOut objects. I do this quick dance with input and output because my program uses GuestList. txt twice — once for reading numbers and a second time for writing numbers. If 
I’m not careful, the two uses of GuestList.txt might conflict with one another. Consider the following program:
// THIS IS BAD CODE
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Scanner;
public class BadCode {
    public static void main(String args[]) throws IOException {
        int guests[] = new int[10];
        Scanner diskScanner = new Scanner(new File("GuestList.txt"));
        PrintStream listOut = new PrintStream("GuestList.txt");
        guests[0] = diskScanner.nextInt();
        listOut.print(5);
        diskScanner.close();
        listOut.close();
    }
}
CHAPTER 11  Using Arrays to Juggle Values      307
Like many methods and constructors of its kind, the PrintStream constructor 
doesn’t pussyfoot around with files. If it can’t find a GuestList.txt file, the 
constructor creates a GuestList.txt file and prepares to write values into it. But, 
if a GuestList.txt file already exists, the PrintStream constructor deletes the 
existing file and prepares to write to a new, empty GuestList.txt file. In the 
BadCode class, the new PrintStream constructor call deletes whatever GuestList. txt file already exists. This deletion comes before the call to diskScanner. nextInt(). So diskScanner.nextInt() can’t read whatever was originally in the 
GuestList.txt file. That’s bad! To avoid this disaster, I carefully separate the two uses of the GuestList.txt file 
in Listing 11-4. Near the top of the listing, I construct diskScanner, and then read 
from the original GuestList.txt file, and then close diskScanner. Later, toward 
the end of the listing, I construct listOut, and then write to a new GuestList.txt 
file, and then close listOut. With writing separated completely from reading, 
everything works correctly. The keyboard variable in Listing 11-4 doesn’t refer to GuestList.txt, so keyboard 
doesn’t conflict with the other input or output variables. No harm would come 
from following my regular routine — putting keyboard = new Scanner(System. in) at the start of the program and putting keyboard.close() at the end of the 
program. But to make Listing 11-4 as readable and as uniform as possible, I place 
the keyboard constructor and the close call very tightly around the keyboard. nextInt call. Use my DummiesFrame (from Chapter  7) to create a GUI program based on the 
ideas in Listing 11-4. In your program, the frame has only one input row. If room 3 
is vacant, the input row’s label is How many people for room 3? If the user types 5 in 
the How many people for room 3 row and then clicks the button, the program puts 5 
people in room 3. Arrays of Objects
The Java Motel is open for business, now with improved guest registration soft -
ware! The people who brought you this chapter’s first section are always scratch-
ing their heads, looking for the best ways to improve their services. Now, with 
some ideas from object-oriented programming, they’ve started thinking in terms 
of a Room class. “And what,” you ask, “would a Room instance look like?” That’s easy. A Room 
instance has three properties: the number of guests in the room, the room rate, 
and a smoking/nonsmoking stamp. Figure 11-8 illustrates the situation. 308      PART 4  Smart Java Techniques
Listing  11-5 shows the code that describes the Room class. As promised, each 
instance of the Room class has three fields: the guests, rate, and smoking fields. (A  false value for the boolean field, smoking, indicates a nonsmoking room.) 
In  addition, the entire Room class has a static field named currency. On my 
 computer in the United States, this currency object makes room rates look like 
dollar amounts. To find out what static means, see Chapter 10. LISTING 11-5: So This Is What a Room Looks Like! import static java.lang.System.out;
import java.util.Scanner;
import java.text.NumberFormat;
public class Room {
    private int guests;
    private double rate;
    private boolean smoking;
    private static NumberFormat currency = NumberFormat.getCurrencyInstance();
    public void readRoom(Scanner diskScanner) {
        guests = diskScanner.nextInt();
        rate = diskScanner.nextDouble();
        smoking = diskScanner.nextBoolean();
    }
    public void writeRoom() {
        out.print(guests);
        out.print("\t");
        out.print(currency.format(rate));
        out.print("\t");
        out.println(smoking ? "yes" : "no");
    }
}
FIGURE 11-8: 
Another abstract 
snapshot of 
rooms in the 
Java Motel. CHAPTER 11  Using Arrays to Juggle Values      309
Listing 11-5 has a few interesting quirks, but I’d rather not describe them until 
after you see all the code in action. That’s why, at this point, I move right on to the 
code that calls the Listing 11-5 code. After you read about arrays of rooms (shown 
in Listing 11-6), check out my description of the Listing 11-5 quirks. This warning is a deliberate repeat of an idea from Chapter 4, Chapter 7, and from 
who-knows-what-other chapter: Be careful  when you use type double or type 
float to store money values. Calculations with double or float can be inaccurate. For more information (and more finger wagging), see Chapters 4 and 7.

--- Chunk #753 ---
This tip has absolutely nothing to do with Java. If you’re the kind of person who 
prefers a smoking room (with boolean field smoking = true in Listing 11-5), find 
someone you like — someone who can take three consecutive days off work. Have 
that person sit with you and comfort you for 72 straight hours while you refrain 
from smoking. You might become temporarily insane while the nicotine leaves 
your body, but eventually you’ll be okay. And your friend will feel like a real hero. Using the Room class
Now you need an array of rooms. The code to create such a thing is in Listing 11-6. The code reads data from the RoomList.txt file. (Figure 11-9 shows the contents 
of the RoomList.txt file.)
Figure 11-10 shows a run of the code in Listing 11-6. LISTING 11-6: Would You Like to See a Room? import static java.lang.System.out;
import java.util.Scanner;
import java.io.File;
import java.io.IOException;
public class ShowRooms {
    public static void main(String args[]) throws IOException {
        Room rooms[];
        rooms = new Room[10];
        Scanner diskScanner = new Scanner(new File("RoomList.txt"));
        for (int roomNum = 0; roomNum < 10; roomNum++) {
            rooms[roomNum] = new Room();
            rooms[roomNum].readRoom(diskScanner);
        }
(continued)
310      PART 4  Smart Java Techniques
        out.println("Room\tGuests\tRate\tSmoking?");
        for (int roomNum = 0; roomNum < 10; roomNum++) {
            out.print(roomNum);
            out.print("\t");
            rooms[roomNum].writeRoom();
        }
        diskScanner.close();
    }
}
FIGURE 11-9: 
A file of 
Room data. FIGURE 11-10: 
A run of the code 
in Listing 11-6.

--- Chunk #754 ---
LISTING 11-6: (continued)
CHAPTER 11  Using Arrays to Juggle Values      311
Say what you want about the code in Listing 11-6. As far as I’m concerned, only 
one issue in the whole listing should concern you. And what, you ask, is that issue? Well, to create an array of objects — as opposed to an array made up of primitive 
values — you have to do three things: Make the array variable, make the array 
itself, and then construct each individual object in the array. This is different from 
creating an array of int values or an array containing any other primitive type 
values. When you create an array of primitive type values, you do only the first two 
of these three things. To help make sense of all this, follow along in Listing 11-6 and Figure 11-11 as you 
read the following points:
 » Room rooms[];: This declaration creates a rooms variable. This variable is 
destined to refer to an array (but doesn’t yet refer to anything). » rooms = new Room[10];: This statement reserves ten slots of storage in the 
computer’s memory. The statement also makes the rooms variable refer to 
the group of storage slots. Each slot is destined to refer to an object (but 
doesn’t yet refer to anything). » rooms[roomNum] = new Room();: This statement is inside a for loop. The 
statement is executed once for each of the ten room numbers. For example, 
the first time through the loop, this statement says rooms[0] = new Room(). That first time around, the statement makes the slot rooms[0] refer to an 
actual object (an instance of the Room class). FIGURE 11-11: 
Steps in creating 
an array of 
objects. 312      PART 4  Smart Java Techniques
Although it’s technically not considered a step in array making, you still have to 
fill each object’s fields with values. For instance, the first time through the loop, 
the readRoom call says rooms[1].readRoom(diskScanner), which means, “Read 
data from the RoomList.txt file into the rooms[1] object’s fields (the guests, 
rate, and smoking fields).” Each time through the loop, the program creates a 
new object and reads data into that new object’s fields. You can squeeze the steps together just as you do when creating arrays of primi -
tive values. For instance, you can do the first two steps in one fell swoop, like this:
Room rooms[] = new Room[10];
You can also use an array initializer. (For an introduction to array initializers, see 
the section “Using an array initializer,” earlier in this chapter.)
Yet another way to beautify your numbers
You can make numbers look nice in plenty of ways. If you take a peek at some 
earlier chapters, for example, you can see that Listing 7-7 uses printf, and 
Listing  10-1 uses a DecimalFormat. But in Listing  11-5, I display a currency 
amount. I use the NumberFormat class with its getCurrencyInstance method. If you compare the formatting statements in Listings 10-1 and 11-5, you don’t see 
much difference. » One listing uses a constructor; the other listing calls getCurrency 
Instance. The getCurrencyInstance method is a good example of what’s 
called a factory method. A factory method is a convenient tool for creating 
commonly used objects. People always need code that displays currency 
amounts. So the getCurrencyInstance method creates a currency format 
without forcing you to write a complicated DecimalFormat constructor call. In 
the United States, this complicated constructor call would be new 
DecimalFormat ("$###0.00;($###0.00)"). Like a constructor, a factory method returns a brand-new object. But unlike a 
constructor, a factory method has no special status. If you create your own 
factory method, you can name it anything you want. When you call a factory 
method, you don’t use the keyword new. » One listing uses DecimalFormat; the other listing uses NumberFormat. A 
decimal number is a certain kind of number. (In fact, a decimal number is a 
number written in the base-10 system.) Accordingly, the DecimalFormat class 
is a subclass of the NumberFormat class. The DecimalFormat methods are 
more specific, so for most purposes, I use DecimalFormat. But it’s harder to 
CHAPTER 11  Using Arrays to Juggle Values      313
use the DecimalFormat class’s getCurrencyInstance method. For programs 
that involve money, I tend to use NumberFormat. » Both listings use format methods. In the end, you just write something like 
currency.format(rate) or decFormat.format(average). After that, Java 
does the work for you. From Chapter  4 onward, I issue gentle warnings against using types such as 
double and float for storing currency values. For the most accurate currency 
calculations, use int, long, or — best of all — BigDecimal. You can read more about the dangers of double types and currency values in 
Chapter 7. The conditional operator
Listing 11-5 uses an interesting doodad called the conditional operator. This condi-
tional operator takes three expressions and returns the value of just one of them. It’s like a mini if statement. When you use the conditional operator, it looks 
something like this:
conditionToBeTested ? expression1 : expression2
The computer evaluates the conditionToBeTested condition. If the condition is true, 
the computer returns the value of expression1. But, if the condition is false, the 
computer returns the value of expression2. So, in the code
smoking ? "yes" : "no"
the computer checks whether smoking has the value true. If so, the whole 3-part 
expression stands for the first string, "yes". If not, the whole expression stands 
for the second string, "no". In Listing 11-5, the call to out.println causes either "yes" or "no" to display. Which string gets displayed depends on whether smoking has the value true or 
false. How do you learn Java? You learn it the same way you get to Carnegie Hall — 
Practice! Practice! Practice! » In Chapter 9, you create a Student class. Each student has a name and an ID 
number. For this programming challenge, imagine that each student has five 
314      PART 4  Smart Java Techniques
grades — one for each of the five courses the student takes. Each grade is a 
double value from 0.0 to 4.0 (4.0 is the best). A student’s grade point average 
(GPA) is the average of the student’s five grade values. In this chapter’s Student class, one of the fields is an array of five double 
values. Your program finds the student’s GPA and displays it (along with the 
student’s name and ID number) on the screen. » Here’s a challenging exercise: Write a primitive word processor program. To 
show you what your program might do, I’ve created a sample run. In this run, 
I’ve set the user’s input in boldface text. >
>
>
>
>
Line to replace (or -1 to quit): 0
Type the new line: There once was an old man with glasses
> There once was an old man with glasses
>
>
>
>
Line to replace (or -1 to quit): 1
Type the new line: Who learned about objects and classes. > There once was an old man with glasses
> Who learned about objects and classes. >
>
>
Line to replace (or -1 to quit): 3
Type the new line: Go climb a tree. > There once was an old man with glasses
> Who learned about objects and classes. >
> Go climb a tree. >
CHAPTER 11  Using Arrays to Juggle Values      315
 Line to replace (or -1 to quit): 2
Type the new line: "At last, I see! > There once was an old man with glasses
> Who learned about objects and classes. > "At last, I see! > Go climb a tree. >
Line to replace (or -1 to quit): 4
Type the new line: I'll teach these ideas to the masses!"
> There once was an old man with glasses
> Who learned about objects and classes. > "At last, I see! > Go climb a tree. > I'll teach these ideas to the masses!"
Line to replace (or -1 to quit): 3
Type the new line: It's not only for me. > There once was an old man with glasses
> Who learned about objects and classes. > "At last, I see!

--- Chunk #755 ---
> It's not only for me. > I'll teach these ideas to the masses!"
Line to replace (or -1 to quit): -1
Command Line Arguments
Once upon a time, most programmers used a text-based development interface. To run the Displayer example in Chapter 3, they didn’t select Run from a menu 
in a fancy integrated development environment. Instead, they typed a command 
in a plain-looking window, usually with white text on a black background. Figure 11-12 illustrates the point. In Figure 11-12, I type the words java Displayer 
and the computer responds with my Java program’s output (the words You'll 
love Java!). 316      PART 4  Smart Java Techniques
The plain-looking window goes by the various names, depending on the kind of 
operating system that you use. In Windows, a text window of this kind is a com-
mand prompt window. On a Macintosh and in Linux, this window is the terminal. Some versions of Linux and UNIX call this window a shell. Anyway, back in ancient times, you could write a program that sucked up extra 
information when you typed the command to launch the program. Figure 11-13 
shows you how this worked. In Figure  11-13, the programmer types java MakeRandomNumsFile to run the 
MakeRandomNumsFile program. But the programmer follows java MakeRandom 
NumsFile with two extra pieces of information: MyNumberedFile.txt and 5. When 
the MakeRandomNumsFile program runs, the program sucks up two extra pieces of 
information and uses them to do whatever the program has to do. In Figure 11-13, 
the program sucks up MyNumberedFile.txt 5, but on another occasion the pro-
grammer might type SomeStuff 28 or BunchONumbers 2000. The extra informa-
tion can be different each time you run the program. The next question is, “How does a Java program know that it’s supposed to snarf 
up extra information each time it runs?” Since you first started working with Java, 
you’ve been seeing this String args[]  business in the header of every main 
method. Well, it’s high time you found out what that’s all about. The parameter 
args[] is an array of String values. These String values are called command line 
arguments. Some programmers write
public static void main(String args[])
FIGURE 11-13: 
When you launch 
MakeRandom 
NumsFile, you 
type some extra 
information. FIGURE 11-12: 
How dull! CHAPTER 11  Using Arrays to Juggle Values      317
and other programmers write
public static void main(String[] args)
Either way, args is an array of String values. Using command line arguments  
in a Java program
Listing 11-7 shows you how to use command line arguments in your code. LISTING 11-7: Generate a File of Numbers
import java.util.Random;
import java.io.PrintStream;
import java.io.IOException;
public class MakeRandomNumsFile {
   public static void main(String args[]) throws IOException {
      Random generator = new Random();
      if (args.length < 2) {
         System.out.println("Usage: MakeRandomNumsFile filename number");
         System.exit(1);
      }
      PrintStream printOut = new PrintStream(args[0]);
      int numLines = Integer.parseInt(args[1]);
      for (int count = 1; count <= numLines; count++) {
         printOut.println(generator.nextInt(10) + 1);
      }
      printOut.close();
   }
}
If a particular program expects some command line arguments, you can’t start 
the program running the same way you’d start most of the other programs in this 
book. The way you feed command line arguments to a program depends on the 
IDE that you’re using — Eclipse, NetBeans, or whatever. That’s why this book’s 
website ( www.allmycode.com/JavaForDummies) has instructions for feeding 
arguments to programs using various IDEs. 318      PART 4  Smart Java Techniques
When the code in Listing 11-7 begins running, the args array gets its values. With 
the run shown in Figure 11-13, the array component args[0] automatically takes 
on the value "MyNumberedFile.txt", and args[1] automatically becomes "5". So 
the program’s assignment statements end up having the following meaning:
PrintStream printOut = new PrintStream("MyNumberedFile.txt");
int numLines = Integer.parseInt("5");
The program creates a file named MyNumberedFile.txt and sets numLines to 5. So later in the code, the program randomly generates five values and puts those 
values into MyNumberedFile.txt. One run of the program gives me the file shown 
in Figure 11-14. After running the code in Listing  11-7, where can you find the new file 
(MyNumberedFile.txt) on your hard drive? The answer depends on a lot of differ-
ent things, so I don’t want to commit to one particular answer. If you use an IDE 
with programs divided into projects, then the new file is somewhere in the proj-
ect’s folder. One way or another, you can change Listing 11-7 to specify a full path 
name — a name like "c:\\Users\\MyName\\Documents\\MyNumberedFile.txt" 
or "/Users/MyName/Documents/MyNumberedFile.txt". In Windows, file path names contain backslash characters. And in Java, when you 
want to indicate a backslash inside a double-quoted String literal, you use a 
 double backslash instead. That’s why "c:\\Users\\MyName\\Documents\\My 
NumberedFile.txt" contains pairs of backslashes. In contrast, file paths in the 
Linux and Macintosh operating systems contain forward slashes. To indicate a 
forward slash in a Java String, use only one forward slash. Notice how each command line argument in Listing 11-7 is a String value. When 
you look at args[1], you don’t see the number 5 — you see the string "5" with a 
digit character in it. Unfortunately, you can’t use that "5" to do any counting. To 
get an int value from "5", you have to apply the parseInt method. (Again, see 
Listing 11-7.)
The parseInt method lives inside a class named Integer. So, to call parseInt, you 
preface the name parseInt with the word Integer. The Integer class has all kinds of 
handy methods for doing things with int values. FIGURE 11-14: 
A file from a run 
of the code in 
Listing 11-7. CHAPTER 11  Using Arrays to Juggle Values      319
In Java, Integer is the name of a class, and int is the name of a primitive (simple) 
type. The two things are related, but they’re not the same. The Integer class has 
methods and other tools for dealing with int values. Checking for the right number of  
command line arguments
What happens if the user makes a mistake? What if the user forgets to type the 
number 5 on the first line in Figure 11-13? Then the computer assigns "MyNumberedFile.txt" to args[0], but it doesn’t assign 
anything to args[1]. This is bad. If the computer ever reaches the statement
int numLines = Integer.parseInt(args[1]);
the program crashes with an unfriendly ArrayIndexOutOfBoundsException. What do you do about this? In Listing  11-7, you check the length of the args 
array. You compare args.length with 2. If the args array has fewer than two 
components, you display a message on the screen and exit from the program. Figure 11-15 shows the resulting output. Despite the checking of args.length in Listing 11-7, the code still isn’t crash-
proof. If the user types five instead of 5, the program takes a nosedive with a 
NumberFormatException. The second command line argument can’t be a word. The argument has to be a number (and a whole number, at that). I can add state-
ments to Listing 11-7 to make the code more bulletproof, but checking for the 
NumberFormatException is better done in Chapter 13. When you’re working with command line arguments, you can enter a String 
value with a blank space in it. Just enclose the value in double quote marks. For 
instance, you can run the code of Listing 11-7 with arguments "My Big Fat File. txt" 7. The sun is about to set on this book’s discussion of arrays. But before you leave 
the subject of arrays, think about this: An array is a row of things, and not every 
kind of thing fits into just one row. Take the first few examples in this chapter 
involving the motel. The motel rooms, numbered 0 through 9, are in one long line. FIGURE 11-15: 
The code in 
Listing 11-7 tells 
you how to run it. 320      PART 4  Smart Java Techniques
But what if you move up in the world? You buy a big hotel with 50 floors and with 
100 rooms on each floor. Then the data is square shaped. You have 50 rows, and 
each row contains 100 items. Sure, you can think of the rooms as if they’re all in 
one long row, but why should you have to do that? How about having a 
2-dimensional array? It’s a square-shaped array in which each component 
has two indices: a row number and a column number. Alas, I have no space in 
this  book to show you a 2-dimensional array (and I can’t afford a big hotel’s 
prices, anyway). But if you visit this book’s website ( www.allmycode.com/
JavaForDummies), you can read all about it. You can never get too much practice:
 » Write a program whose command line arguments include three int values. As its output, the program displays the largest of the three int values. » In a previous section, you create a simple word processing program. Improve 
the program by adding two command line arguments:
• The first argument is the name of an input file. The input file contains 
five lines of text, some or all of which may be blank. At the start of its run, 
the program reads lines from the input file and displays them on the 
screen. • The second argument is the name of another file — an output file. At 
the end of its run, the program writes the edited text to the output file. CHAPTER 12  Using Collections and Streams (When Arrays Aren’t Good Enough)      321
IN THIS CHAPTER
 » Facing the limitations of arrays
 » Dealing with a bunch of objects at once
 » Using Java’s cool functional 
programming features
 » Developing code for multicore 
processors
Using Collections and 
Streams (When Arrays 
Aren’t Good Enough)
C
hapter 11 is about arrays. With an array, you can manage a bunch of things 
all at once. In a hotel-management program, you can keep track of all the 
rooms. You can quickly find the number of people in a room or find one of 
the vacant rooms. However, arrays don’t always fit the bill. In this chapter, you find out where arrays 
fall short and how collections can save the day. Understanding the Limitations of Arrays
Arrays are nice, but they have some serious limitations. Imagine that you store 
customer names in some predetermined order. Your code contains an array, and 
the array has space for 100 names:
String name[] = new String[100];
for (int i = 0; i < 100; i++) {
Chapter 12
322      PART 4  Smart Java Techniques
    name[i] = new String();
}
All is well until, one day, customer number 101 shows up. As your program runs, 
you enter data for customer 101, hoping desperately that the array with 100 com-
ponents can expand to fit your growing needs. No such luck. Arrays don’t expand. Your program crashes with an ArrayIndex 
OutOfBoundsException. “In my next life, I’ll create arrays of length 1,000,” you say to yourself. And when 
your next life rolls around, you do just that:
String name[] = new String[1000];
for (int i = 0; i < 1000; i++) {
    name[i] = new String();
}
But during your next life, an economic recession occurs. Instead of having 
101  customers, you have only 3 customers. Now you’re wasting space for 1,000 
names when space for 3 names would do. And what if no economic recession occurs? You’re sailing along with your array of 
size 1,000, using a tidy 825 spaces in the array. The components with indices 
0 through 824 are being used, and the components with indices 825 through 999 
are waiting quietly to be filled. One day, a brand-new customer shows up. Because your customers are stored in 
order (alphabetically by last name, numerically by Social Security number, what-
ever), you want to squeeze this customer into the correct component of your array. The trouble is that this customer belongs very early on in the array, at the com-
ponent with index 7. What happens then? You take the name in component number 824 and move it to component 825. Then you take the name in component 823 and move it to component 824. Take 
the name in component 822 and move it to component 823. You keep doing this 
until you’ve moved the name in component 7. Then you put the new customer’s 
name into component 7. What a pain! Sure, the computer doesn’t complain. (If the 
computer has feelings, it probably likes this kind of busywork.) But as you move 
around all these names, you waste processing time, you waste power, and you 
waste all kinds of resources. “In my next life, I’ll leave three empty components between every two names.” 
And of course, your business expands. Eventually you find that three aren’t enough. CHAPTER 12  Using Collections and Streams (When Arrays Aren’t Good Enough)      323
Collection Classes to the Rescue
The issues in the preceding section aren’t new. Computer scientists have been 
working on these issues for a long time. They haven’t discovered any magic one- 
size-fits-all solution, but they’ve discovered some clever tricks. The Java API has a bunch of classes known as collection classes. Each collection 
class has methods for storing bunches of values, and each collection class’s meth-
ods use some clever tricks. For you, the bottom line is as follows: Certain collec-
tion classes deal as efficiently as possible with the issues raised in the preceding 
section. If you have to deal with such issues when writing code, you can use these 
collection classes and call the classes’ methods. Rather than fret about a customer 
whose name belongs in position 7, you can just call a class’s add method. The 
method inserts the name at a position of your choice and deals reasonably with 
whatever ripple effects have to take place. In the best circumstances, the insertion 
is very efficient.

--- Chunk #756 ---
In the worst circumstances, you can rest assured that the code 
does everything the best way it can. Using an ArrayList
One of the most versatile of Java’s collection classes is the ArrayList. Listing 12-1 
shows you how it works. LISTING 12-1: Working with a Java Collection
import static java.lang.System.out;
import java.util.Scanner;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
public class ShowNames {
    public static void main(String args[]) throws IOException {
        ArrayList<String> people = new ArrayList<>();
        Scanner diskScanner = new Scanner(new File("names.txt"));
        while (diskScanner.hasNext()) {
            people.add(diskScanner.nextLine());
        }
        people.remove(0);
        people.add(2, "Jim Newton");
(continued)
324      PART 4  Smart Java Techniques
        for (String name : people) {
            out.println(name);
        }
        diskScanner.close();
    }
}
Figure 12-1 shows you a sample names.txt file. The code in Listing 12-1 reads that 
names.txt file and prints the stuff in Figure 12-2. All the interesting things happen when you execute the remove and add methods. The variable named people refers to an ArrayList object. When you call that 
object’s remove method,
people.remove(0);
you eliminate a value from the list. In this case, you eliminate whatever value is in 
the list’s initial position (the position numbered 0). So in Listing 12-1, the call to 
remove takes the name Barry Burd out of the list. That leaves only eight names in the list, but then the next statement,
people.add(2, "Jim Newton");
inserts a name into position number 2. (After Barry is removed, position number 2 
is the position occupied by Harry Spoonswagler, so Harry moves to position 3, and 
Jim Newton becomes the number 2 man.)
FIGURE 12-1: 
Several names  
in a file. FIGURE 12-2: 
The code in 
Listing 12-1 
changes some of 
the names. LISTING 12-1: (continued)
CHAPTER 12  Using Collections and Streams (When Arrays Aren’t Good Enough)      325
Notice that an ArrayList object has two different add methods. The method that 
adds Jim Newton has two parameters: a position number and a value to be added. Another add method
people.add(diskScanner.nextLine());
takes only one parameter. This statement takes whatever name it finds on a line 
of the input file and appends that name to the end of the list. (The add method 
with only one parameter always appends its value to what’s currently the end of 
the ArrayList object.)
The last few lines of Listing 12-1 contain an enhanced for loop. Like the loop in 
Listing 11-3, the enhanced loop in Listing 12-1 has the following form:
for (variable-type variable-name : range-of-values)
In Listing 12-1, the variable-type is String, the variable-name is name, and the 
range-of-values includes the things stored in the people collection. During an 
iteration of the loop, name refers to one of the String values stored in people. (So 
if the people collection contains nine values, the for loop goes through nine iter-
ations.) During each iteration, the statement inside the loop displays a name on 
the screen. Using generics
Look again at Listing  12-1, shown earlier, and notice the funky ArrayList 
declaration:
ArrayList<String> people = new ArrayList<>();
Starting with Java 5.0, each collection class is generified. That ugly-sounding word 
means that every collection declaration should contain some angle-bracketed 
stuff, such as <String>. The thing that’s sandwiched between < and > tells Java 
what kinds of values the new collection may contain. For example, in Listing 12-1, 
the words ArrayList<String> people tell Java that people is a bunch of strings. That is, the people list contains String objects (not Room objects, not Account 
objects, not Employee objects, nothing other than String objects). You can’t use generics in any version of Java before Java 5.0, and the code in 
 Listing 12-1 goes kablooey in any version before Java 7. For more about generics, 
see the nearby sidebar, “All about generics.” And for more about Java’s version 
numbers, see Chapter 2. 326      PART 4  Smart Java Techniques
ALL ABOUT GENERICS
One of the original design goals for Java was to keep the language as simple as possible. James Gosling, the language’s creator, took some unnecessarily complicated features of 
C++ and tossed them out the window. The result was a language that was elegant and 
sleek. Some people said the language was too sleek. So, after several years of discussion 
and squabbling, Java became a bit more complicated. By the year 2004, Java had enum 
types, enhanced for loops, static import, and some other interesting new features. But 
the most talked-about new feature was the introduction of generics:
ArrayList<String> people = new ArrayList<String>();
The use of anything like <String> was new in Java 5.0. In old-style Java, you’d write
ArrayList people = new ArrayList();
In those days, an ArrayList could store almost anything you wanted to put in it: a 
number, an Account, a Room, a String — anything. The ArrayList class was  
versatile, but with this versatility came some headaches. If you could put anything into 
an ArrayList, you couldn’t easily predict what you would get out of an ArrayList. In particular, you couldn’t easily write code that assumed you had stored certain types 
of values in the ArrayList. Here’s an example:
ArrayList things = new ArrayList();
things.add(new Account());
Account myAccount = things.get(0);
//DON'T USE THIS. IT'S BAD CODE. In Listing  12-1, the words ArrayList<String> people  say that the people  
variable can refer only to a collection of String values. So, from that point on, any 
reference to an item from the people collection is treated exclusively as a String. If you write
people.add(new Room());
the compiler coughs up your code and spits it out because a Room (created in 
 Chapter 11) isn’t the same as a String. (This coughing and spitting happens even 
if the compiler has access to the Room class’s code — the code in Chapter 11.) But 
the statement
people.add("George Gow");
is just fine. Because "George Gow" has type String, the compiler smiles happily. CHAPTER 12  Using Collections and Streams (When Arrays Aren’t Good Enough)      327
In the third line, the call to get(0) grabs the earliest value in the things collection. The 
call to get(0) is okay, but then the compiler chokes on the attempted assignment to 
myAccount. You get a message on the third line saying that whatever you get from the 
things list can’t be stuffed into the myAccount variable. You get this message because 
by the time the compiler reaches the third line, it has forgotten that the item added on 
the second line was of type Account! The introduction of generics fixes this problem:
ArrayList<Account> things = new ArrayList<Account>();
things.add(new Account());
Account myAccount = things.get(0);
//USE THIS CODE INSTEAD. IT'S GOOD CODE. Adding <Account> in two places tells the compiler that things stores Account 
instances — nothing else. So, in the third line in the preceding code, you get a value 
from the things collection. Then, because things stores only Account objects, you 
can make myAccount refer to that new value. Java 5.0 added generics to Java. But soon after the birth of Java 5.0, programmers 
noticed how clumsy the code for generics can be. After all, you can create generics 
within generics. An ArrayList can contain a bunch of arrays, each of which can be an 
ArrayList. So you can write
ArrayList<ArrayList<String>[]> mess = new ArrayList<ArrayList 
<String>[]>();
All the repetition in that mess declaration gives me a headache! To avoid this ugliness, 
Java 7 and later versions have a diamond operator: <>. The diamond operator tells Java 
to reuse whatever insanely complicated stuff you put in the previous part of the generic 
declaration. In this example, the <> tells Java to reuse <ArrayList<String>[]>, even 
though you write <ArrayList<String>[]> only once. Here’s how the streamlined Java 
7 code looks:
ArrayList<ArrayList<String>[]> mess = new ArrayList<>();
In Java 7 and later, you can write either of these mess declarations: the original, nasty 
declaration with two occurrences of ArrayList<String>[] or the streamlined (only 
mildly nasty) declaration with the diamond operator and only one 
ArrayList<String>[] occurrence. Yes, the streamlined code is still complicated. But without all the ArrayList<String>[] 
repetition, the streamlined code is less cumbersome. The Java 7 diamond operator takes 
away one chance for you to copy something incorrectly and have a big error in your code. 328      PART 4  Smart Java Techniques
Wrapper classes
In Chapter 4, I point out that Java has two kinds of types: primitive types and ref-
erence types. (If you didn’t read those sections, or you don’t remember them, 
don’t feel guilty. You’ll be okay.) Things like int, double, char, and boolean are 
primitive types, and things like String, JFrame, ArrayList, and Account are ref-
erence types. The distinction between primitive types and reference types has been a source of 
contention since Java’s birth in 1995. Even now, Oracle’s wizards are hatching 
plans to get around the stickier consequences of having two kinds of types. One of 
those consequences is the fact that collections, such as the ArrayList, can’t con-
tain values of a primitive type. For example, it’s okay to write
ArrayList<String> people = new ArrayList<>();
but it’s not okay to write
ArrayList<int> numbers = new ArrayList<>(); // BAD! BAD! because int is a primitive type. So, if you want to store values like 3, 55, and 21 in 
an ArrayList, what do you do? Rather than store int values in the ArrayList, 
you store Java’s Integer values:
ArrayList<Integer> list = new ArrayList<>();
In previous chapters, you see the Integer class in connection with the parseInt 
method:
int numberOfCows = Integer.parseInt("536");
The Integer class has many methods, such as parseInt, for dealing with int 
values. The class also has fields such as MAX_VALUE and MIN_VALUE, which stand 
for the largest and smallest values that int variables may have. The Integer class is an example of a wrapper class. Each of Java’s eight primitive 
types has a corresponding wrapper class. You can use methods and fields in Java’s 
Double, Character, Boolean, Long, Float, Short, and Byte wrapper classes. For example, the Double class has methods named parseDouble, compareTo, 
toHexString, and fields named MAX_VALUE and MAX_EXPONENT. The Integer class wraps the primitive int type with useful methods and values. In addition, you can create an Integer instance that wraps a single int value:
Integer myInteger = new Integer(42);
CHAPTER 12  Using Collections and Streams (When Arrays Aren’t Good Enough)      329
In this line of code, the myInteger variable has one int value inside it: the int 
value 42. In Paul’s words, wrapping the int value 42 into an Integer object 
myInteger is “something like putting lots of extra breading on okra. It makes 42 
more digestible for finicky eaters like collections.”
Instances of the other wrapper classes work the same way. For example, an 
instance of the Double class wraps up a single primitive double value. Double averageNumberOfTomatoes = new Double(1.41421356237);
Here’s a program that stores five Integer values in an ArrayList:
import java.util.ArrayList;
public class Main {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>();
        fillTheList(list);
        for (Integer n : list) {
            System.out.println(n);
        }
    }
    public static void fillTheList(ArrayList<Integer> list) {
        list.add(85);
        list.add(19);
        list.add(0);
        list.add(103);
        list.add(13);
    }
}
In the code, notice calls like list.add(85) that have int value parameters. At this 
point, little Billy gets excited and says, “Look, Mom! I added the primitive int 
value 85 to my ArrayList!” No, Billy. That’s not what’s really going on. In this code, the list collection contains Integer values, not int values. A primi-
tive int value is a lot like an instance of the Integer class. But a primitive int 
value isn’t exactly the same as an Integer instance. What’s going on is called autoboxing. Before Java 5.0, you had to write
list.add(new Integer(85));
330      PART 4  Smart Java Techniques
if you wanted to add an Integer to an ArrayList. But Java 5.0 and later Java ver-
sions can automatically wrap an int value inside a box. An int value in a param-
eter list becomes an Integer in ArrayList. Java’s autoboxing feature makes 
programs easier to read and write. Testing for the presence of more data
Here’s a pleasant surprise. When you write a program like the one shown previ-
ously in Listing 12-1, you don’t have to know how many names are in the input 
file. Having to know the number of names may defeat the purpose of using the 
easily expandable ArrayList class. Rather than loop until you read exactly nine 
names, you can loop until you run out of data. The Scanner class has several nice methods, such as hasNextInt, hasNextDouble, 
and plain old hasNext. Each of these methods checks for more input data. If 
there’s more data, the method returns true. Otherwise, the method returns false. Listing  12-1 uses the general-purpose hasNext method. This hasNext method 
returns true as long as there’s anything more to read from the program’s input. After the program scoops up that last Hugh R. DaReader line in Figure 12-1, the 
subsequent hasNext call returns false. This false condition ends execution 
of  the while loop and plummets the computer toward the remainder of the 
 Listing 12-1 code. The hasNext method is quite handy. In fact, hasNext is so handy that it’s part of 
a bigger concept known as an iterator, and iterators are baked into all of Java’s col-
lection classes. Using an iterator
An iterator spits out a collection’s values, one after another. To obtain a value 
from the collection, you call the iterator’s next method. To find out whether the 
collection has any more values in it, you call the iterator’s hasNext method. Listing 12-2 uses an iterator to display people’s names. LISTING 12-2: Iterating through a Collection
import static java.lang.System.out;
import java.util.Iterator;
import java.util.Scanner;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
CHAPTER 12  Using Collections and Streams (When Arrays Aren’t Good Enough)      331
public class ShowNames {
    public static void main(String args[]) throws IOException {
        ArrayList<String> people = new ArrayList<>();
        Scanner diskScanner = new Scanner(new File("names.txt"));
        while (diskScanner.hasNext()) {
            people.add(diskScanner.nextLine());
        }
        people.remove(0);
        people.add(2, "Jim Newton");
        Iterator<String> iterator = people.iterator();
        while (iterator.hasNext()) {
            out.println(iterator.next());
        }
        diskScanner.close();
    }
}
You can replace the enhanced for loop at the end of Listing 12-1 with the boldface 
code in Listing 12-2. When you do, you get the same output as before. (You get the 
output in Figure 12-2.) In Listing 12-2, the first boldface line of code creates an 
iterator from the people collection. The second and third lines call the iterator’s 
hasNext and next methods to grab all objects stored in the people collection — 
one for each iteration of the loop. These lines display each of the people collec-
tion’s values. Which is better? An enhanced for loop or an iterator? Java programmers prefer 
the enhanced for loop because the for loop involves less baggage — no iterator 
object to carry from one line of code to the next. But as you see later in this chap-
ter, the most programming-enhanced feature can be upgraded, streamlined, 
tweaked, and otherwise reconstituted. There’s no end to the way you can improve 
upon your code. Java’s many collection classes
The ArrayList class that I use in many of this chapter’s examples is only the tip 
of the Java collections iceberg. The Java library contains many collections classes, 
each with its own advantages. Table 12-1 contains an abbreviated list. 332      PART 4  Smart Java Techniques
Each collection class has its own set of methods (in addition to the methods that 
it inherits from AbstractCollection, the ancestor of all collection classes). To find out which collection classes best meet your needs, visit the Java API 
 documentation pages at http://docs.oracle.com/javase/8/docs/api. Once again, I’d like to put you to work:
 » Create an ArrayList containing Integer values. Then step through the 
values in the list to find the largest value among all values in the list. For 
example, if the list contains the numbers 85, 19, 0, 103, and 13, display the 
number 103. » Create an ArrayList containing String values in alphabetical order. When 
the user types an additional word on the keyboard, the program inserts the 
new word into the ArrayList in the proper (alphabetically ordered) place. For example, imagine that the list starts off containing the words "cat", 
"dog", "horse", and "zebra" (in that order). After the user types the word 
fish on the keyboard (and presses Enter), the list contains the words "cat", 
"dog", "fish", "horse", and "zebra" (in that order). To write this program, you may find the String class’s compareToIgnoreCase 
method and the ArrayList class’s size method useful. You can find out 
about these methods by visiting https://docs.oracle.com/javase/8/
docs/api/java/lang/String.html#compareToIgnoreCase-java.lang. String- and http://docs.oracle.com/javase/8/docs/api/java/util/
ArrayList.html#size--. TABLE 12-1	 Some Collection Classes
Class Name Characteristic
ArrayList A resizable array. LinkedList A list of values, each having a field that points to the next one in the list. Stack A structure that grows from bottom to top. The structure is optimized for access to the 
topmost value. You can easily add a value to the top or remove the value from the top. Queue A structure that grows at one end. The structure is optimized for adding values to one 
end (the rear) and removing values from the other end (the front). PriorityQueue A structure, like a queue, that lets certain (higher-priority) values move toward the front. HashSet A collection containing no duplicate values. HashMap A collection of key/value pairs. CHAPTER 12  Using Collections and Streams (When Arrays Aren’t Good Enough)      333
 » In Chapter 11, you create a simple word processor. Your program stores lines 
of text in an array, so the number of lines is limited by the size of the array. In this chapter, you can improve on your work from Chapter 11 by storing 
lines of text in an ArrayList. An ArrayList has no fixed size, so the number 
of lines can grow to meet the user’s needs. Your improved word processor supports three kinds of commands:
• The command i 21 tells your program to insert the 21st line of text into 
the document. (If there’s already a 21st line of text, the new line goes 
between the existing 20th and 21st lines.)
• The command r 13 tells your program to replace the 13th line of text in 
the document. (If there’s already a 13th line of text, that old line of text 
goes away.)
• The command d 7 tells your program to delete the seventh line of text. (If 
there’s already an eighth line of text, that existing line becomes the seventh 
line of text.)
This word processor program may be quite challenging. Work slowly and 
carefully and don’t be discouraged.

--- Chunk #757 ---
If you don’t get it at first, put the project 
aside and come back to it later. Functional Programming
From 1953 to 1957, John Backus and others developed the FORTRAN programming 
language, which contained the basic framework for thousands of 20th century 
programming languages. The framework has come to be known as imperative pro-
gramming because of its do-this-then-do-that nature. A few years after the rise of FORTRAN, John McCarthy created another language, 
named Lisp. Unlike FORTRAN, the underlying framework for Lisp is functional pro-
gramming. In a purely functional program, you avoid writing “do this, then do 
that.” Instead, you write things like “Here’s how you’ll be transforming this into 
that when you get around to doing the transformation.”
For one reason or another, imperative programming became the dominant mode. As a result, Java is fundamentally an imperative programming language. But 
recently, functional programming has emerged as a powerful and useful way of 
thinking about code. To help you understand functional programming, I start this section with an 
analogy. Then, in the rest of this chapter, I present some Java examples. 334      PART 4  Smart Java Techniques
The analogy that I use to describe functional programming is very rough. A friend 
of mine called this analogy a stretch because it applies to many different pro-
gramming frameworks, not only to functional programming. One way or another, 
I think the analogy is helpful. Here’s the analogy: Imagine a programming problem as a cube, and imagine an 
imperative programming solution as a way of slicing up the cube into manageable 
pieces. (See Figure 12-3.)
All was well until 2007, when, for the first time, computers sold to consumers had 
multicore processors. A multicore processor can perform more than one instruc -
tion at a time. Figure  12-4 shows what happens when you try to squeeze an 
imperative program into a multicore processor. To get the most out of a four-core processor, you divide your code into four 
pieces — one piece for each core. But with imperative programming, your pro-
gram’s pieces don’t fit neatly into your processor’s cores. FIGURE 12-3: 
Imperative 
programming 
slices up a 
problem. FIGURE 12-4: 
An imperative 
program’s  
pieces don’t fit 
neatly into a 
multicore chip. CHAPTER 12  Using Collections and Streams (When Arrays Aren’t Good Enough)      335
In imperative programming, your code’s pieces interact with one another. All the 
pieces might be updating the current price of Oracle stock shares (ticker symbol: 
ORCL). The simultaneous updates become tangled. It’s like several high school 
boys asking the same girl to the senior prom — nothing good ever comes of it. You’ve experienced the same phenomenon if you’ve ever clicked a website’s 
 Purchase button, only to learn that the item you’re trying to purchase is out of 
stock. Someone else completed a purchase while you were filling in your credit 
card information. Too many customers were grabbing for the same goods at the 
same time. Figure 12-3 suggests that, with imperative programming, you divide your code 
into several pieces. Functional programming also divides code into pieces, but it 
does so along different lines. (See Figure 12-5.) And here’s the good news: With 
functional programming, the pieces of the code fit neatly into the processor’s 
cores. (See Figure 12-6.)
FIGURE 12-5: 
Functional 
programming 
slices the 
problem along 
different lines. FIGURE 12-6: 
A functional 
program’s pieces 
fit neatly into a 
multicore chip. 336      PART 4  Smart Java Techniques
Solving a problem the old-fashioned way
In Chapter 11, you use arrays to manage the Java Motel. But that venture is behind 
you now.

--- Chunk #758 ---
You’ve given up the hotel business. (You tell people that you decided to 
move on. But in all honesty, the hotel was losing a lot of money. According to the 
United States bankruptcy court, the old Java Motel is currently in Chapter 11.)
Since leaving the hotel business, you’ve transitioned into online sales. Nowadays, 
you run a website that sells books, DVDs, and other content-related items. (Barry 
Burd’s Java For Dummies, 7th Edition, is currently your best seller, but that’s beside 
the point.)
In your world, the sale of a single item looks something like the stuff in   
Listing 12-3. Each sale has an item and a price. LISTING	12-3:	 The Sale Class
public class Sale {
    private String item;
    private double price;
    public String getItem() {
      return item;
    }
    public void setItem(String item) {
      this.item = item;
    }
    public double getPrice() {
      return price;
    }
    public void setPrice(double price) {
      this.price = price;
    }
    public Sale(String item, double price) {
        this.item = item;
        this.price = price;
    }
}
CHAPTER 12  Using Collections and Streams (When Arrays Aren’t Good Enough)      337
To make use of the Sale class, you create a small program. The program totals up 
the sales on DVDs. The program is shown in Listing 12-4. LISTING	12-4:	 Using the Sale Class
import java.text.NumberFormat;
import java.util.ArrayList;
public class TallySales {
    public static void main(String[] args) {
        ArrayList<Sale> sales = new ArrayList<Sale>();
        NumberFormat currency = NumberFormat.getCurrencyInstance();
        fillTheList(sales);
        double total = 0;
        for (Sale sale : sales) {
            if (sale.getItem().equals("DVD")) {
                total += sale.getPrice();
            }
        }
        System.out.println(currency.format(total));
    }
    static void fillTheList(ArrayList<Sale> sales) {
        sales.add(new Sale("DVD", 15.00));
        sales.add(new Sale("Book", 12.00));
        sales.add(new Sale("DVD", 21.00));
        sales.add(new Sale("CD", 5.25));
    }
}
In Chapter 11, you step through an array by using an enhanced for statement. Listing 12-4 has its own enhanced for statement. But in Listing 12-4, the enhanced 
for statement steps through the values in a collection. Each such value is a sale. The loop repeatedly checks a sale to find out whether the item sold is a DVD. If so, 
the code adds the sale’s price to the running total. The program’s output is 
$36.00 — the running total displayed as a currency amount. 338      PART 4  Smart Java Techniques
The scenario in Listing 12-4 isn’t unusual. You have a collection of items (a col-
lection of sales, perhaps). You step through the items in the collection, finding the 
items that meet certain criteria (the sale of a DVD, for example). You grab a certain 
value (such as the sale price) of each item that meets your criteria. Then you do 
something useful with the values that you’ve grabbed (for example, adding the 
values together). Here are some other examples:
 » Step through your list of employees. Find each employee whose performance 
evaluation scored 3 or higher. Give each such employee a $100 bonus and 
then determine the total amount of money you’ll pay in bonuses. » Step through your list of customers. For each customer who has shown 
interest in buying a smartphone, send the customer an email about this 
month’s discount plans. » Step through the list of planets that have been discovered. For each M-class 
planet, find the probability of finding intelligent life on that planet. Then find 
the average of all such probabilities. This scenario is so common that it’s worth finding better and better ways to deal 
with the scenario. One way to deal with it is to use some of the functional pro-
gramming features in Java. Streams
The earlier section “Using an iterator” introduces iterators. You use an iterator’s 
next method to spit out a collection’s values. Java takes this concept one step 
further with the notion of a stream. A stream is like an iterator except that, with a 
stream, you don’t have to call a next method. After being created, a stream spits 
out a collection’s values automatically. To get values from a stream, you don’t call 
a stream’s next method. In fact, a typical stream has no next method. How does this work as part of a Java program? How do you create a stream that 
spits out values? How does the stream know when to start spitting, and where 
does the stream aim when it spits? For answers to these and other questions, read 
the next several sections. CHAPTER 12  Using Collections and Streams (When Arrays Aren’t Good Enough)      339
Lambda expressions
In the 1930s, mathematician Alonzo Church used the Greek letter lambda (λ) to 
represent a certain mathematical construct that’s created on the fly.* Over the 
next several decades, the idea survived quietly in mathematics and computer sci-
ence journals. These days, in Java, the term lambda expression represents a short 
piece of code that serves as both a method declaration and a method call, all cre -
ated on the fly. Your first lambda expression
Here’s an example of a lambda expression:
(sale) -> sale.getItem().equals("DVD")
Figure 12-7 describes the lambda expression’s meaning. A lambda expression is a concise way of defining a method and calling the method 
without even giving the method a name. The lambda expression in Figure 12-7 
does (roughly) what the following code does:
boolean itemIsDVD(Sale sale) {
    if sale.getItem().equals("DVD") {
        return true;
    } else {
        return false;
    }
}
itemIsDVD(sale);
The lambda expression in Figure  12-7 takes objects from a stream and calls a 
method resembling itemIsDVD on each object. The result is a bunch of boolean 
values — true for each sale of a DVD and false for a sale of something other than 
a DVD. * I attended a lecture given by Alonzo Church many years ago at the University of 
Illinois.

--- Chunk #759 ---
He was the world’s most meticulous presenter. Every detail of his lecture 
was carefully planned and scrupulously executed.

--- Chunk #760 ---
He handed out paper copies of 
his notes, and I spent half the lecture staring at the notes, trying to decide whether 
the notes were hand-written or typed. 340      PART 4  Smart Java Techniques
With or without lambda expressions, you can rewrite the itemIsDVD method with 
a 1-line body:
boolean itemIsDVD(Sale sale) {
    return sale.getItem().equals("DVD");
}
A lambda expression with two parameters
Consider the following lambda expression:
(price1, price2) -> price1 + price2
Figure 12-8 describes the new lambda expression’s meaning. The lambda expression in Figure 12-8 does (roughly) what the following code does:
double sum(double price1, double price2) {
    return price1 + price2;
}
sum(price1, price2);
FIGURE 12-7: 
Does the item 
that’s being  
sold happen  
to be a DVD? CHAPTER 12  Using Collections and Streams (When Arrays Aren’t Good Enough)      341
The lambda expression in Figure  12-8 takes values from a stream and calls a 
method resembling sum to combine the values. The result is the total of all prices. The black sheep of lambda expressions
Here’s an interesting lambda expression:
(sale) -> System.out.println(sale.getPrice())
This lambda expression does (roughly) what the following code does:
void display(Sale sale) {
    System.out.println(sale.getPrice());
}
display(sale);
The lambda expression takes objects from a stream and calls a method resembling 
display on each object. In the display method’s header, the word void indicates 
that the method doesn’t return a value. When you call the display method (or you 
use the equivalent lambda expression), you don’t expect to get back a value. Instead, you expect the code to do something in response to the call (something 
like displaying text on the computer’s screen). To draw a sharp distinction between returning a value and “doing something,” 
functional programmers have a name for “doing something without returning a 
value” — they call that something a side effect. In functional programming, a side 
effect is considered a second-class citizen, a last resort, a tactic that you use when 
you can’t simply return a result. Unfortunately, displaying information on a 
screen (something that so many computer programs do) is a side effect. Any 
FIGURE 12-8: 
Add two prices. 342      PART 4  Smart Java Techniques
program that displays output (on a screen, on paper, or as tea leaves in a cup) isn’t 
a purely functional program. A taxonomy of lambda expressions
Java divides lambda expressions into about 45 different categories. Table  12-2 
lists a few of the categories. The categories in Table  12-2 aren’t mutually exclusive. For example, every  
Predicate is a Function.

--- Chunk #761 ---
(Every Predicate accepts one parameter and returns a 
result. The result happens to be boolean.)
Using streams and lambda expressions
Java has fancy methods that make optimal use of streams and lambda expres-
sions. With streams and lambda expressions, you can create an assembly line that 
elegantly solves this chapter’s sales problem. Unlike the code in Listing 12-4, the 
new assembly-line solution uses concepts from functional programming. The assembly line consists of several methods. Each method takes the data, trans-
forms the data in some way or other, and hands its results to the next method in 
line. Figure 12-9 illustrates the assembly line for this chapter’s sales problem. In Figure 12-9, each box represents a bunch of raw materials as they’re trans -
formed along an assembly line. Each arrow represents a method (or, metaphori-
cally, a worker on the assembly line). TABLE 12-2	 A Few Kinds of Lambda Expressions
Name Description Example
Function Accepts one parameter; produces a result 
of any type
(sale) -> sale. price
Predicate Accepts one parameter; produces a 
boolean valued result
(sale) -> sale.item. equals("DVD")
BinaryOperator Accepts two parameters of the same type; 
produces a result of the same type
(price1, price2) -> price1 +  
price2
Consumer Accepts one parameter; produces no result (sale) -> System.out. println 
(sale. price)
CHAPTER 12  Using Collections and Streams (When Arrays Aren’t Good Enough)      343
For example, in the transition from the second box to the third box, a worker 
method (the filter method) sifts out sales of items that aren’t DVDs. Imagine 
Lucy Ricardo standing between the second and third boxes, removing each book 
or CD from the assembly line and tossing it carelessly onto the floor. The parameter to Java’s filter method is a Predicate — a lambda expression 
whose result is boolean. (See Tables  12-2 and  12-3.) The filter method in 
 Figure 12-9 sifts out items that don’t pass the lambda expression’s true / false 
test. For some help understanding the words in the third column of Table  12-3 
 (Predicate, Function and BinaryOperator), see the earlier section “A taxonomy 
of lambda expressions.”
FIGURE 12-9: 
A functional 
programming 
assembly line. 344      PART 4  Smart Java Techniques
In Figure 12-9, in the transition from the third box to the fourth box, a worker 
method (the map method) pulls the price out of each sale. From that worker’s 
place onward, the assembly line contains only price values. To be more precise, Java’s map method takes a Function such as
(sale) -> sale.getPrice()
and applies the Function to each value in a stream. (See Tables 12-2 and 12-3.) So 
the map method in Figure  12-9 takes an incoming stream of sale objects and 
 creates an outgoing stream of price values. In Figure 12-9, in the transition from the fourth box to the fifth box, a worker 
method (the reduce method) adds up the prices of DVD sales. Java’s reduce 
method takes two parameters:
 » The first parameter is an initial value. In Figure 12-9, the initial value is 0.0. » The second parameter is a BinaryOperator. (See Tables 12-2 and 12-3.)
In Figure 12-9, the reduce method’s BinaryOperator is
(price1, price2) -> price1 + price2
TABLE 12-3	 Some Functional Programming Methods
Method Name Member Of Parameter(s) Result Type Result Value
stream Collection (for 
example, an 
ArrayList object)
(none) Stream A stream that spits  
out elements of the 
collection
filter Stream Predicate Stream A new stream 
containing values  
for which the lambda 
expression returns  
true
map Stream Function Stream A new stream 
containing the results 
of applying the 
lambda expression to 
the incoming stream
reduce Stream BinaryOperator The type  
used by the 
BinaryOperator
The result of 
combining all the 
values in the 
incoming stream
CHAPTER 12  Using Collections and Streams (When Arrays Aren’t Good Enough)      345
The reduce method uses its BinaryOperator to combine the values from the 
incoming stream. The initial value serves as the starting point for all the 
 combining. So, in Figure  12-9, the reduce method does two additions. (See 
Figure 12-10.)
For comparison, imagine calling the method
reduce(10.0, (value1, value2) -> value1 * value2)
with the stream whose values include 3.0, 2.0, and 5.0. The resulting action is 
shown in Figure 12-11. You might have heard of Google’s MapReduce programming model. The similarity 
between the programming model’s name and the Java method names map and 
reduce is not a coincidence. FIGURE 12-10: 
The reduce 
method adds two 
values from an 
incoming stream. FIGURE 12-11: 
The reduce 
method 
multiplies values 
from an incoming 
stream. 346      PART 4  Smart Java Techniques
Taken as a whole, the entire assembly line shown in Figure  12-9 adds up the 
prices of DVDs sold. Listing 12-5 contains a complete program using the streams 
and lambda expressions of Figure 12-9. LISTING	12-5:	 Living the Functional Way of Life
import java.text.NumberFormat;
import java.util.ArrayList;
public class TallySales {
  public static void main(String[] args) {
    ArrayList<Sale> sales = new ArrayList<>();
    NumberFormat currency = NumberFormat.getCurrencyInstance();
    fillTheList(sales);
    double total = sales.stream()
                        .filter((sale) -> sale.getItem().equals("DVD"))
                        .map((sale) -> sale.getPrice())
                        .reduce(0.0, (price1, price2) -> price1 + price2);
    System.out.println(currency.format(total));
  }
  static void fillTheList(ArrayList<Sale> sales) {
    sales.add(new Sale("DVD", 15.00));
    sales.add(new Sale("Book", 12.00));
    sales.add(new Sale("DVD", 21.00));
    sales.add(new Sale("CD", 5.25));
  }
}
The code in Listing 12-5 requires Java 8 or later. If your IDE is set for an earlier 
Java version, you might have to tinker with the IDE’s settings.

--- Chunk #762 ---
You may even have 
to download a newer version of Java. The boldface code in Listing 12-5 is one big Java assignment statement. The right 
side of the statement contains a sequence of method calls. Each method call 
returns an object, and each such object is the thing before the dot in the next 
method call. That’s how you form the assembly line. CHAPTER 12  Using Collections and Streams (When Arrays Aren’t Good Enough)      347
For example, near the start of the boldface code, the name sales refers to an 
ArrayList object. Each ArrayList object has a stream method. In Listing 12-5, 
sales.stream() is a call to that ArrayList object’s stream method. The stream method returns an instance of Java’s Stream class. (What a surprise!) 
So sales.stream() refers to a Stream object. (See Figure 12-12.)
Every Stream object has a filter method. So
sales.stream().filter ((sale) -> sale.getItem().equals("DVD"))
is a call to the  Stream object’s filter method. (Refer to Figure 12-12.)
The pattern continues. The Stream object’s map method returns yet another 
Stream object — a Stream object containing prices. (See Figure 12-13.) To that 
Stream of prices you apply the reduce method, which yields one double value — 
the total of the DVD prices. (See Figure 12-14.)
FIGURE 12-12: 
Getting all  
DVD sales. FIGURE 12-13: 
Getting the price 
from each  
DVD sale. 348      PART 4  Smart Java Techniques
Why bother? The chain of method calls in Listing 12-5 accomplishes everything that the loop in 
Listing 12-4 accomplishes. But the code in Figure 12-14 uses concepts from func-
tional programming. What’s the big deal? Are you better off with Listing 12-5 than 
with Listing 12-4? You are. For the past several years, the big trend in chip design has been multicore 
processors. With several cores, a processor can execute several statements at the 
same time, speeding up a program’s execution by a factor of 2, or 4 or 8 or even 
more. Programs run much faster if you divide the work among several cores. But 
how do you divide the work? You can modify the imperative code in Listing 12-4. For example, with some fancy 
features, you can hand different loop iterations to different cores. But the result-
ing code is messy. For the code to work properly, you have to micromanage the 
loop iterations, checking carefully to make sure that the final total is correct. In contrast, the functional code is easy to modify. To take advantage of multicore 
processors, you change only one word in Listing 12-5! sales.parallelStream()
     .filter((sale) -> sale.getItem().equals("DVD"))
     .map((sale) -> sale.getPrice())
     .reduce(0.0, (price1, price2) -> price1 + price2);
In Listing  12-5, the stream() method call creates a serial stream. With a serial 
stream, Java does its processing one sale at a time. But a call to parallelStream() 
creates a slightly different kind of stream: a parallel stream. With a parallel stream, 
Java divides the work among the number of cores in the computer’s processor (or 
according to some other useful measure of computing power). If you have 4  million 
sales and four cores, each core processes 1 million of the sales. Each core works independently of the others, and each core dumps its result into 
a final reduce method. The reduce method combines the cores’ results into a final 
tally. In the best possible scenario, all the work gets done in one-fourth of the 
time it would take with an ordinary serial stream. FIGURE 12-14: 
Getting the total 
price of all  
DVD sales. CHAPTER 12  Using Collections and Streams (When Arrays Aren’t Good Enough)      349
When you read the preceding paragraph, don’t gloss over the phrase best possible 
scenario. Parallelism isn’t magic. And sometimes, parallelism isn’t your friend. Con-
sider the situation in which you have only 20 sale amounts to tally. The time it takes 
to divide the problem into four groups of 5 sales each far exceeds the amount of time 
you save in using all four cores. In addition, some problems don’t lend themselves 
to parallel processing. Imagine that the price of an item depends on the number of 
similar items being sold. In that case, you can’t divide the problem among four 
independently operating cores. If you try, each core has to know what the other 
cores are doing. You lose the advantage of having four threads of execution. NO VARIABLES?

--- Chunk #763 ---
NO PROBLEM! Consider the problems posed at the start of the earlier section “Functional 
Programming.” Several clients try to update Oracle’s stock price at the same time, or two 
visitors try to buy the same item on a website. The source of the problem is shared data. How many clients share access to Oracle’s stock price? How many customers share 
access to a web page’s Purchase button? How many of your processor’s cores can 
modify the same variable’s value? If you get rid of data sharing, your multicore process-
ing problems go away. In imperative programming, a variable is a place where statements share their values 
with one another. Can you avoid using variables in your code? Compare the loop in Listing 12-4 with the functional programming code in Listing 12-5. In Listing 12-4, the total variable is shared among all loop iterations. Because each 
 iteration can potentially change the value of total, you can’t assign each iteration to a 
different processor core. If you did, you’d risk having two cores updating the total at the 
same time. (Chances are good that, because of the simultaneous updating, neither core 
would do its update correctly!) But the functional programming code in Listing 12-5 has 
no total variable. A running total plays no role in the functional version of the code. Instead, in Listing 12-5, the reduce method applies the sum operation to values coming 
from a stream. This incoming stream pops out of the previous method call (the map 
method), so the incoming stream has no name. That’s nice.

--- Chunk #764 ---
You don’t even need a 
 variable to store a stream of values. In imperative programming, a variable is a place where statements share their values 
with one another. But functional programming shuns variables. So, when you do func-
tional programming, you don’t have a lot of data sharing. Many of the difficulties associ-
ated with multicore processors vanish into thin air. Your code can take advantage of 
many cores at the same time. When you write the code, you don’t worry about data being 
shared among the cores. It’s an elegant solution to an important computing problem. 350      PART 4  Smart Java Techniques
Method references
Take a critical look at the last lambda expression in Listing 12-5:
(price1, price2) -> price1 + price2)
This expression does roughly the same work as a sum method. (In fact, you can find 
a sum method’s declaration in the earlier section “Lambda expressions.”) If your 
choice is between typing a 3-line sum method and typing a 1-line lambda expres-
sion, you’ll probably choose the lambda expression. But what if you have a third 
alternative? Rather than type your own sum method, you can refer to an existing 
sum method. Using an existing method is the quickest and safest thing to do. As luck would have it, Java’s Double class contains a static sum method. You don’t 
have to create your own sum method. If you run the following code:
double i = 5.0, j = 7.0;
System.out.println(Double.sum(i, j));
the computer displays 12.0. So, rather than type the price1 + price2  lambda 
expression in Listing 12-5, you can create a method reference — an expression that 
refers to an existing method. sales.stream()
     .filter((sale) -> sale.getItem().equals("DVD"))
     .map((sale) -> sale.getPrice())
     .reduce(0.0, Double :: sum);
The expression Double::sum refers to the sum method belonging to Java’s Double 
class. When you use this Double::sum method reference, you do the same thing 
that the last lambda expression does in Listing 12-5. Everybody is happy.

--- Chunk #765 ---
For information about static methods, see Chapter 10. You can always try the programming challenges that you dream up on your own. If you don’t have any ideas to give you practice with functional programming, 
I have a couple of suggestions for you:
 » Each employee has a name and a performance evaluation score. Find the 
total amount of money that you’ll pay in bonuses if you give a $100 bonus to 
each employee whose score is 3 or higher. » Each recipe has a name, a list of ingredients (some of which involve meat 
products), and an estimated preparation time.

--- Chunk #766 ---
Find the average time estimate 
for cooking one of the vegetarian recipes. CHAPTER 13  Looking Good When Things Take Unexpected Turns      351
IN THIS CHAPTER
 » Recovering from bad input and other 
nasty situations
 » Making your code (more or less) 
crash proof
 » Defining your own exception class
Looking Good When 
Things Take Unexpected 
Turns
S
eptember 9, 1945: A moth flies into one of the relays of the Harvard Mark II 
 computer and gums up the works. This becomes the first recorded case of a 
real computer bug. April 19, 1957: Herbert Bright, manager of the data processing center at Westing -
house in Pittsburgh, receives an unmarked deck of computer punch cards in the 
mail (which is like getting an unlabeled CD-ROM in the mail today). Mr. Bright 
guesses that this deck comes from the development team for FORTRAN — the 
first computer programming language. He’s been waiting a few years for this 
software. (No web downloads were available at the time.)
Armed with nothing but this good guess, Bright writes a small FORTRAN program 
and tries to compile it on his IBM 704. (The IBM 704 lives in its own, specially 
built, 2,000-square-foot room. With vacuum tubes instead of transistors, the 
machine has a whopping 32K of RAM. The operating system has to be loaded from 
tape before the running of each program, and a typical program takes between 
two and four hours to run.) After the usual waiting time, Bright’s attempt to 
Chapter 13
352      PART 4  Smart Java Techniques
compile a FORTRAN program comes back with a single error: a missing comma in 
one of the statements. Bright corrects the error, and the program runs like a 
charm. July 22, 1962: Mariner I, the first US spacecraft aimed at another planet, is destroyed 
when it behaves badly four minutes after launch. The bad behavior is attributed to 
a missing bar (like a hyphen) in the formula for the rocket’s velocity. Around the same time, orbit computation software at NASA is found to contain the 
incorrect statement DO 10 I=1.10  (instead of the correct DO 10 I=1,10 ). In 
 modern notation, this is like writing do10i = 1.10  in place of for (int i=1; 
i<=10; i++). The change from a comma to a period turns a loop into an assign -
ment statement. January 1, 2000: The Year 2000 Problem wreaks havoc on the modern world. Any historically accurate facts in these notes were borrowed from the following 
sources: the Computer Folklore newsgroup ( https://groups.google.com/
forum/#!forum/alt.folklore.computers), the Free On-line Dictionary of Com-
puting (http://foldoc.org), Computer magazine (www.computer.org/computer- 
magazine/), and other web pages of the IEEE (www.computer.org). Handling Exceptions
You’re taking inventory. This means counting item after item, box after box, and 
marking the numbers of such things on log sheets, in little handheld gizmos, and 
into forms on computer keyboards. A particular part of the project involves enter-
ing the number of boxes that you find on the Big Dusty Boxes That Haven’t Been 
Opened Since Year One shelf. Rather than break the company’s decades-old habit, 
you decide not to open any of these boxes. You arbitrarily assign the value $3.25 to 
each box. Listing 13-1 shows the software to handle this bit of inventory. The software has 
a flaw, which is revealed in Figure 13-1. When the user enters a whole number 
value, things are okay. But when the user enters something else (like the 
 number 3.5), the program comes crashing to the ground. Surely something can be 
done about this. Computers are stupid, but they’re not so stupid that they should 
fail royally when a user enters an improper value. CHAPTER 13  Looking Good When Things Take Unexpected Turns      353
LISTING 13-1: Counting Boxes
import static java.lang.System.out;
import java.util.Scanner;
import java.text.NumberFormat;
public class InventoryA {
   public static void main(String args[]) {
      final double boxPrice = 3.25;
      Scanner keyboard = new Scanner(System.in);
      NumberFormat currency = NumberFormat.getCurrencyInstance();
      out.print("How many boxes do we have? ");
      String numBoxesIn = keyboard.next();
      int numBoxes = Integer.parseInt(numBoxesIn);
      out.print("The value is ");
      out.println(currency.format(numBoxes * boxPrice));
      keyboard.close();
   }
}
The key to fixing a program bug is examining the message that appears when the 
program crashes. The inventory program’s message says java.lang.Number 
FormatException. That means a class named NumberFormatException is in the 
java.lang API package. Somehow, the call to Integer.parseInt brought this 
NumberFormatException class out of hiding. For a brief explanation of the Integer.parseInt method, see Chapter 11. Well, here’s what’s going on. The Java programming language has a mechanism 
called exception handling. With exception handling, a program can detect that 
things are about to go wrong and respond by creating a brand-new object. In the 
official terminology, the program is said to be throwing an exception. That new 
FIGURE 13-1: 
Three separate 
runs of the code 
in Listing 13-1. 354      PART 4  Smart Java Techniques
object, an instance of the Exception class, is passed like a hot potato from one 
piece of code to another until some piece of code decides to catch the exception. When the exception is caught, the program executes some recovery code, buries 
the exception, and moves on to the next normal statement as if nothing had ever 
happened. The process is illustrated in Figure 13-2. The whole thing is done with the aid of several Java keywords. These keywords are 
described in this list:
 » throw: Creates a new exception object. » throws: Passes the buck from a method up to whatever code called the 
method. » try: Encloses code that has the potential to create a new exception object. In the usual scenario, the code inside a try clause contains calls to methods 
whose code can create one or more exceptions. » catch: Deals with the exception, buries it, and then moves on. So the truth is out. Through some chain of events like the one shown in Figure 13-2, 
the method Integer.parseInt can throw a NumberFormatException. When you 
call Integer.parseInt, this NumberFormatException is passed on to you. FIGURE 13-2: 
Throwing, 
passing, and 
catching an 
exception. CHAPTER 13  Looking Good When Things Take Unexpected Turns      355
The Java API (Application Programming Interface) documentation for the parse 
Int method says, “Throws: NumberFormatException  — if the string does not 
contain a parsable integer.” Once in a while, reading the documentation actually 
pays. If you call yourself a hero, you’d better catch the exception so that all the other 
code can get on with its regular business. Listing 13-2 shows the catching of an 
exception. LISTING 13-2: A Hero Counts Boxes
import static java.lang.System.out;
import java.util.Scanner;
import java.text.NumberFormat;
public class InventoryB {
   public static void main(String args[]) {
       final double boxPrice = 3.25;
       Scanner keyboard = new Scanner(System.in);
       NumberFormat currency = NumberFormat.getCurrencyInstance();
       out.print("How many boxes do we have? ");
       String numBoxesIn = keyboard.next();
       try {
           int numBoxes = Integer.parseInt(numBoxesIn);
           out.print("The value is ");
           out.println(currency.format(numBoxes * boxPrice));
       } catch (NumberFormatException e) {
           out.println("That's not a number.");
       }
       keyboard.close();
   }
}
Figure 13-3 shows three runs of the code from Listing 13-2. When a misguided 
user types three instead of 3, the program maintains its cool by displaying 
That's not a number. The trick is to enclose the call to Integer.parseInt inside 
a try clause. If you do this, the computer watches for exceptions when any 
 statement inside the try clause is executed. If an exception is thrown, the com-
puter jumps from inside the try clause to a catch clause below it. In Listing 13-2, 
the computer jumps directly to the catch (NumberFormatException e)  clause. The computer executes the println statement inside the clause and then marches 
356      PART 4  Smart Java Techniques
on with normal processing. (If there were statements in Listing 13-2 after the end 
of the catch clause, the computer would go on and execute them.)
An entire try-catch assembly — complete with a try clause, catch clause, and 
what-have-you — is called a try statement. Sometimes, for emphasis, I call it a 
try-catch statement. The parameter in a catch clause
Take a look at the catch clause in Listing 13-2 and pay particular attention to the 
words (NumberFormatException e). This looks a lot like a method’s parameter 
list, doesn’t it? In fact, every catch clause is like a little mini-method with its own 
parameter list. The parameter list always has an exception type name and then a 
parameter. In Listing 13-2, I don’t do anything with the catch clause’s e parameter, but I 
certainly could if I wanted to. Remember: The exception that’s thrown is an 
object — an instance of the NumberFormatException class. When an exception is 
caught, the computer makes the catch clause’s parameter refer to that exception 
object. In other words, the name e stores a bunch of information about the excep-
tion. To take advantage of this, you can call some of the exception object’s 
methods. } catch (NumberFormatException e) {
    out.println("Message: ***" + e.getMessage() + "***");
    e.printStackTrace();
}
With this new catch clause, a run of the inventory program may look like the 
run shown in Figure 13-4. When you call getMessage, you fetch some detail about 
the exception. (In Figure 13-4, the detail is Message: ***For input string: 
"three"***.) When you call printStackTrace, you get some additional informa-
tion; namely, a display showing the methods that were running at the moment 
when the exception was thrown. (In Figure 13-4, the display includes Integer. parseInt and the main method.) Both getMessage and printStackTrace present 
information to help you find the source of the program’s difficulties. FIGURE 13-3: 
Three runs of 
the code in 
Listing 13-2. CHAPTER 13  Looking Good When Things Take Unexpected Turns      357
When you mix System.out.println calls with printStackTrace calls, the order 
in which Java displays the information is not predictable. For example, in 
 Figure 13-4, the text Message: ***For input string: "three"*** may appear 
before or after the stack trace. If the ordering of this output matters to you, change 
out.println("Message: ***" to System.err.println("Message: ***". Exception types
What else can go wrong today? Are there other kinds of exceptions — things that 
don’t come from the NumberFormatException class? Sure, plenty of different 
exception types are out there. You can even create one of your own.

--- Chunk #767 ---
You wanna 
try?

--- Chunk #768 ---
If so, look at Listings 13-3 and 13-4. LISTING 13-3: Making Your Own Kind of Exception
@SuppressWarnings("serial")
class OutOfRangeException extends Exception {
}
LISTING 13-4: Using Your Custom-Made Exception
import static java.lang.System.out;
import java.util.Scanner;
import java.text.NumberFormat;
public class InventoryC {
   public static void main(String args[]) {
      final double boxPrice = 3.25;
      Scanner keyboard = new Scanner(System.in);
      NumberFormat currency = NumberFormat.getCurrencyInstance();
      out.print("How many boxes do we have? ");
      String numBoxesIn = keyboard.next();
      try {
         int numBoxes = Integer.parseInt(numBoxesIn);
FIGURE 13-4: 
Calling an 
exception object’s 
methods. (continued)
358      PART 4  Smart Java Techniques
         if (numBoxes < 0) {
            throw new OutOfRangeException();
         }
         out.print("The value is ");
         out.println(currency.format(numBoxes * boxPrice));
      } catch (NumberFormatException e) {
         out.println("That's not a number.");
      } catch (OutOfRangeException e) {
         out.print(numBoxesIn);
         out.println("? That's impossible!");
      }
      keyboard.close();
   }
}
Listings 13-3 and 13-4 remedy a problem that cropped up earlier, in Figure 13-3. Look at the last of the three runs in Figure 13-3. The user reports that the shelves 
have –25 boxes, and the computer takes this value without blinking an eye. The 
truth is that you would need a black hole (or some other exotic space-time warp-
ing phenomenon) to have a negative number of boxes on any shelf in your ware-
house. So the program should get upset if the user enters a negative number of 
boxes, which is what the code in Listing 13-4 does. To see the upset code, look at 
Figure 13-5. The code in Listing  13-3 declares a new kind of exception class: OutOfRange 
Exception. In many situations, typing a negative number would be just fine, so 
OutOfRangeException isn’t built in to the Java API. However, in the inventory 
program, a negative number should be flagged as an anomaly. The OutOfRangeException class in Listing 13-3 wins the award for the shortest 
self-contained piece of code in this book. The class’s code is just a declaration line 
and an empty pair of braces. The code’s operative phrase is extends Exception. Being a subclass of the Java API Exception class allows any instance of the 
OutOfRangeException class to be thrown. FIGURE 13-5: 
Three runs of the 
code from 
Listings 13-3 
and 13-4. LISTING 13-4: (continued)
CHAPTER 13  Looking Good When Things Take Unexpected Turns      359
Back in Listing 13-4, a new OutOfRangeException instance is thrown. When this 
happens, the catch clause ( OutOfRangeException e) catches the instance. The 
clause echoes the user’s input and displays the message That's impossible! The text @SuppressWarnings("serial") in Listing  13-3 is a Java annotation. For  an introduction to annotations, see Chapter  8. For a few words about the 
SuppressWarnings annotation, see Chapter 9. If you use Eclipse, you might see a yellow warning marker next to the throw new 
OutOfRangeException() line in Listing 13-4. When you hover the pointer over 
the warning marker, Eclipse says, Resource leak: 'keyboard' is not closed 
at this location. Eclipse is being persnickety to make sure that your code even-
tually executes the keyboard.close() statement. (Yes, under certain circum-
stances, throwing the OutOfRangeException can cause the program to skip the 
keyboard.close() statement. But no, that can’t happen when you run the code in 
 Listing 13-4.) In my opinion, you can safely ignore this warning. Who’s going to catch the exception? Take one more look at Listing 13-4. Notice that more than one catch clause can 
accompany a single try clause. When an exception is thrown inside a try clause, 
the computer starts going down the accompanying list of catch clauses. The com-
puter starts at whatever catch clause comes immediately after the try clause and 
works its way down the program’s text. For each catch clause, the computer asks itself, “Is the exception that was just 
thrown an instance of the class in this clause’s parameter list?”
 » If not, the computer skips this catch clause and moves on to the next catch 
clause in line. » If so, the computer executes this catch clause and then skips past all other 
catch clauses that come with this try clause. The computer goes on and 
executes whatever statements come after the whole try-catch statement. For some concrete examples, see Listings 13-5 and 13-6. LISTING 13-5: Yet Another Exception
@SuppressWarnings("serial")
class NumberTooLargeException extends OutOfRangeException {
}
360      PART 4  Smart Java Techniques
LISTING 13-6: Where Does the Buck Stop? import static java.lang.System.out;
import java.util.Scanner;
import java.text.NumberFormat;
public class InventoryD {
   public static void main(String args[]) {
       final double boxPrice = 3.25;
       Scanner keyboard = new Scanner(System.in);
       NumberFormat currency = NumberFormat.getCurrencyInstance();
       out.print("How many boxes do we have? ");
       String numBoxesIn = keyboard.next();
       try {
           int numBoxes = Integer.parseInt(numBoxesIn);
           if (numBoxes < 0) {
               throw new OutOfRangeException();
           }
           if (numBoxes > 1000) {
               throw new NumberTooLargeException();
           }
           out.print("The value is ");
           out.println(currency.format(numBoxes * boxPrice));
       }
       catch (NumberFormatException e) {
           out.println("That's not a number.");
       }
       catch (OutOfRangeException e) {
           out.print(numBoxesIn);
           out.println("? That's impossible!");
       }
       catch (Exception e) {
           out.print("Something went wrong, ");
           out.print("but I'm clueless about what ");
           out.println("it actually was.");
       }
       out.println("That's that.");
       keyboard.close();
   }
}
CHAPTER 13  Looking Good When Things Take Unexpected Turns      361
To run the code in Listings 13-5 and 13-6, you need one additional Java program 
file. You need the OutOfRangeException class in Listing 13-3. Listing 13-6 addresses the scenario in which you have limited shelf space. You 
don’t have room for more than 1,000 boxes, but once in a while the program asks 
how many boxes you have, and somebody enters the number 100000 by accident. In cases like this, Listing 13-6 does a quick reality check. Any number of boxes 
over 1,000 is tossed out as being unrealistic. Listing  13-6 watches for a NumberTooLargeException, but to make life more 
interesting, Listing  13-6 doesn’t have a catch clause for the NumberTooLarge 
Exception. In spite of this, everything still works out just fine. It’s fine because 
NumberTooLargeException is declared to be a subclass of OutOfRangeException, 
and Listing 13-6 has a catch clause for the OutOfRangeException. You see, because NumberTooLargeException is a subclass of OutOfRange 
Exception, any instance of NumberTooLargeException is just a special kind of 
OutOfRangeException. So, in Listing 13-6, the computer may start looking for a 
clause to catch a NumberTooLargeException. When the computer stumbles upon 
the OutOfRangeExceptioncatch clause, the computer says, “Okay, I’ve found a 
match. I’ll execute the statements in this catch clause.”
To keep from having to write this whole story over and over again, I introduce 
some new terminology. I say that the catch clause with parameter OutOfRange 
Exception matches the NumberTooLargeException that’s been thrown. I call this 
catch clause a matching catch clause. The following list describes different things that the user may do and how the 
computer responds. As you read, you can follow along by looking at the runs 
shown in Figure 13-6:
FIGURE 13-6: 
Four runs of 
the code from 
Listing 13-6. 362      PART 4  Smart Java Techniques
 » The user enters an ordinary whole number, like the number 3. All 
statements in the try clause are executed. Then the computer skips past all 
the catch clauses and executes the code that comes immediately after all the 
catch clauses. (See Figure 13-7.)
 » The user enters something that’s not a whole number, like the word fish. The code throws a NumberFormatException. The computer skips past the 
remaining statements in the try clause. The computer executes the state-
ments inside the first catch clause — the clause whose parameter is of type 
NumberFormatException. Then the computer skips past the second and 
third catch clauses and executes the code that comes immediately after all 
the catch clauses. (See Figure 13-8.)
 » The user enters a negative number, like the number –25. The code throws 
an OutOfRangeException. The computer skips past the remaining state-
ments in the try clause. The computer even skips past the statements in the 
first catch clause. (After all, an OutOfRangeException isn’t any kind of a 
NumberFormatException. The catch clause with parameter NumberFormat 
Exception isn’t a match for this OutOfRangeException.) The computer 
executes the statements inside the second catch clause — the clause whose 
parameter is of type OutOfRangeException. Then the computer skips past 
the third catch clause and executes the code that comes immediately after 
all the catch clauses. (See Figure 13-9.)
FIGURE 13-7: 
No exception 
is thrown. CHAPTER 13  Looking Good When Things Take Unexpected Turns      363
 » The user enters an unrealistically large number, like the number 1001. The code throws a NumberTooLargeException. The computer skips past the 
remaining statements in the try clause. The computer even skips past the 
statements in the first catch clause. (After all, a NumberTooLargeException 
isn’t any kind of NumberFormatException.)
But, according to the code in Listing 13-5, NumberTooLargeException is a 
subclass of OutOfRangeException. When the computer reaches the second 
catch clause, the computer says, “Hmm! A NumberTooLargeException is a 
FIGURE 13-8: 
A Number 
FormatException 
is thrown. FIGURE 13-9: 
An OutOfRange 
Exception is 
thrown. 364      PART 4  Smart Java Techniques
kind of OutOfRangeException. I’ll execute the statements in this catch 
clause — the clause with parameter of type OutOfRangeException.” In other 
words, it’s a match. The computer executes the statements inside the second catch clause. Then 
the computer skips the third catch clause and executes the code that comes 
immediately after all the catch clauses. (See Figure 13-10.)
 » Something else, something quite unpredictable, happens. (I don’t know 
what.) With my unending urge to experiment, I reached into the try clause of 
Listing 13-6 and added a statement that throws an IOException. No reason —  
I just wanted to see what would happen. When the code threw an IOException, the computer skipped past the 
remaining statements in the try clause. Then the computer skipped past the 
statements in the first and second catch clauses. When the computer 
reached the third catch clause, I could hear the computer say, “Hmm! An 
IOException is a kind of Exception. I’ve found a matching catch clause — a 
clause with a parameter of type Exception. I’ll execute the statements in this 
catch clause.”
So the computer executed the statements inside the third catch clause. Then 
the computer executed the code that comes immediately after all the catch 
clauses. (See Figure 13-11.)
FIGURE 13-10: 
A Number 
TooLarge 
Exception is 
thrown. CHAPTER 13  Looking Good When Things Take Unexpected Turns      365
When the computer looks for a matching catch clause, the computer latches on to 
the topmost clause that fits one of the following descriptions:
 » The clause’s parameter type is the same as the type of the exception that 
was thrown. » The clause’s parameter type is a superclass of the exception’s type. If a better match appears farther down the list of catch clauses, that’s just too 
bad. Imagine that you added a catch clause with a parameter of type Number 
TooLargeException to the code in Listing 13-6. Imagine, also, that you put this 
new catch clause after the catch clause with parameter of type OutOfRange 
Exception. Then, because NumberTooLargeException is a subclass of the Out 
OfRangeException class, the code in the new NumberTooLargeException clause 
would never be executed. That’s just the way the cookie crumbles. Catching two or more exceptions at a time
Starting with Java 7, you can catch more than one kind of exception in a single 
catch clause. For example, in a particular inventory program, you might not want 
to distinguish between the throwing of a NumberFormatException and your own 
OutOfRangeException. In that case, you can rewrite part of Listing 13-6 this way:
FIGURE 13-11: 
An IOException  
is thrown. 366      PART 4  Smart Java Techniques
try {
    int numBoxes = Integer.parseInt(numBoxesIn);
    if (numBoxes < 0) {
        throw new OutOfRangeException();
    }
    if (numBoxes > 1000) {
        throw new NumberTooLargeException();
    }
    out.print("The value is ");
    out.println(currency.format(numBoxes * boxPrice));
}
catch (NumberFormatException | OutOfRangeException e) {
    out.print(numBoxesIn);
    out.println("? That's impossible!");
}
catch (Exception e) {
    out.print("Something went wrong, ");
    out.print("but I'm clueless about what ");
    out.println("it actually was.");
}
The pipe symbol, |, tells Java to catch either a NumberFormatException or an 
OutOfRangeException. If you throw an exception of either type, the program 
 displays the value of numBoxesIn followed by the text ? That's impossible! If 
you throw an exception that is neither a NumberFormatException nor an Out 
OfRangeException, the program jumps to the last catch clause and displays 
Something went wrong, but I'm clueless .... Throwing caution to the wind
Are you one of those obsessive-compulsive types? Do you like to catch every pos-
sible exception before the exception can possibly crash your program? Well, watch 
out. Java doesn’t let you become paranoid. You can’t catch an exception if the 
exception has no chance of being thrown. Consider the following code. The code has an innocent i++ statement inside a try 
clause. That’s fair enough. But then the code’s catch clause is pretending to catch 
an IOException:
// Bad code! try {
    i++;
} catch (IOException e) {
    e.printStackTrace();
}
CHAPTER 13  Looking Good When Things Take Unexpected Turns      367
Who is this catch clause trying to impress? A statement like i++ doesn’t do 
any  input or output. The code inside the try clause can’t possibly throw an 
IOException. So the compiler comes back and says, “Hey, catch clause. Get real. Get off your high horse.” Well, to be a bit more precise, the compiler’s reprimand 
reads as follows:
exception java.io.IOException is never thrown
in body of corresponding try statement
Doing useful things
So far, each example in this chapter catches an exception, prints a “bad input” 
message, and then closes up shop. Wouldn’t it be nice to see a program that actu-
ally carries on after an exception has been caught? Well, it’s time for something 
nice. Listing 13-7 has a try-catch statement inside a loop. The loop keeps run -
ning until the user types something sensible. LISTING 13-7: Keep Pluggin’ Along
import static java.lang.System.out;
import java.util.Scanner;
import java.text.NumberFormat;
public class InventoryLoop {
   public static void main(String args[]) {
      final double boxPrice = 3.25;
      boolean gotGoodInput = false;
      Scanner keyboard = new Scanner(System.in);
      NumberFormat currency = NumberFormat.getCurrencyInstance();
      do {
         out.print("How many boxes do we have? ");
         String numBoxesIn = keyboard.next();
         try {
            int numBoxes = Integer.parseInt(numBoxesIn);
            out.print("The value is ");
            out.println(currency.format(numBoxes * boxPrice));
            gotGoodInput = true;
         } catch (NumberFormatException e) {
            out.println();
            out.println("That's not a number.");
         }
      } while (!gotGoodInput);
(continued)
368      PART 4  Smart Java Techniques
      out.println("That's that.");
      keyboard.close();
   }
}
Figure 13-12 shows a run of the code from Listing 13-7. In the first three attempts, 
the user types just about everything except a valid whole number. At last, the 
fourth attempt is a success. The user types 3, and the computer leaves the loop. Our friends, the good exceptions
A rumor is going around that Java exceptions always come from unwanted, erro-
neous situations. Although there’s some truth to this rumor, the rumor isn’t 
entirely accurate. Occasionally, an exception arises from a normal, expected 
occurrence. Take, for instance, the detection of the end of a file. The following 
code makes a copy of a file:
try {
    while (true) {
        dataOut.writeByte(dataIn.readByte());
    }
} catch (EOFException e) {
    numFilesCopied = 1;
}
To copy bytes from dataIn to dataOut, you just go into a while loop. With its  
true condition, the while loop is seemingly endless. But eventually, you reach the 
end of the dataIn file. When this happens, the readByte method throws an 
EOFException (an end-of-file exception). The throwing of this exception sends 
the computer out of the try clause and out of the while loop. From there, you do 
whatever you want to do in the catch clause and then proceed with normal 
processing. LISTING 13-7: (continued)
FIGURE 13-12: 
A run of the code 
in Listing 13-7. CHAPTER 13  Looking Good When Things Take Unexpected Turns      369
Try your hand at these coding tasks:
 » Add try-catch statements to keep the following code from crashing:
import java.util.Scanner;
public class Main {
  public static void main(String[] args) {
    Scanner keyboard = new Scanner(System.in);
    String[] words = new String[5];
    int i = 0;
    do {
      words[i] = keyboard.next();
    } while (!words[i++].equals("Quit"));
    for (int j = 0; j < 5; j++) {
      System.out.println(words[j].length());
    }
    keyboard.close();
  }
}
 » In Listing 13-6, the price of each box and the number of boxes that are too 
large are fixed values. Make improvements to the code so that the user enters 
both of those values. Remember that some values for these quantities don’t 
make sense. For example, a negative number of boxes is never too many 
boxes. Use try-catch statements to handle inappropriate user input. Handle an Exception or Pass the Buck
So you’re getting to know Java, hey? What?

--- Chunk #769 ---
You say you’re all the way up to 
 Chapter 13? I’m impressed. You must be a hard worker. But remember, all work 
and no play . .

--- Chunk #770 ---
. So, how about taking a break? A little nap could do you a world of good. Is ten 
seconds okay? Or is that too long? Better make it five seconds. 370      PART 4  Smart Java Techniques
Listing 13-8 has a program that’s supposed to pause its execution for five seconds. The problem is that the program in Listing  13-8 is incorrect. Take a look at 
 Listing 13-8 for a minute, and then I’ll tell you what’s wrong with it. LISTING 13-8: An Incorrect Program
/*
 * This code does not compile. */
import static java.lang.System.out;
public class NoSleepForTheWeary {
    public static void main(String args[]) {
        out.print("Excuse me while I nap ");
        out.println("for just five seconds...");
        takeANap();
        out.println("Ah, that was refreshing.");
    }
    static void takeANap() {
        Thread.sleep(5000);
    }
}
The strategy in Listing 13-8 isn’t bad. The idea is to call the sleep method, which 
is defined in the Java API. This sleep method belongs to the API Thread class. When you call the sleep method, the number that you feed it is a number of 
 milliseconds. So Thread.sleep(5000) means pause for five seconds. The problem is that the code inside the sleep method can throw an exception. This kind of exception is an instance of the InterruptedException class. When 
you try to compile the code in Listing 13-8, you get a message such as
unreported exception java.lang.InterruptedException;
must be caught or declared to be thrown
Maybe the message reads
Unhandled exception type InterruptedException
One way or another, the message is unwelcome. CHAPTER 13  Looking Good When Things Take Unexpected Turns      371
For the purpose of understanding exceptions in general, you don’t need to know 
exactly what an InterruptedException is. All you really have to know is that a 
call to Thread.sleep can throw one of these InterruptedException objects. But 
if you’re really curious, an InterruptedException is thrown when some code 
interrupts some other code’s sleep. Imagine that you have two pieces of code run-
ning at the same time. One piece of code calls the Thread.sleep method. At the 
same time, another piece of code calls the interrupt method. By calling the 
interrupt method, the second piece of code brings the first code’s Thread.sleep 
method to a screeching halt. The Thread.sleep method responds by spitting out 
an InterruptedException. Now, the Java programming language has two kinds of exceptions. They’re called 
checked and unchecked exceptions:
 » The potential throwing of a checked exception must be acknowledged 
in the code. » The potential throwing of an unchecked exception doesn’t need to be 
acknowledged in the code. An InterruptedException is one of Java’s checked exception types. When you 
call a method that has the potential to throw an InterruptedException, you need 
to acknowledge that exception in the code. Now, when I say that an exception is acknowledged in the code, what do I really 
mean? // The author wishes to thank that InterruptedException,
// without which this code could not have been written. No, that’s not what it means to be acknowledged in the code. Acknowledging an 
exception in the code means one of two things:
 » The statements (including method calls) that can throw the exception are 
inside a try clause. That try clause has a catch clause with a matching 
exception type in its parameter list. » The statements (including method calls) that can throw the exception are 
inside a method that has a throws clause in its header. The throws clause 
contains a matching exception type. If you’re confused by the wording of these two bullets, don’t worry. The next two 
listings illustrate the points made in the bullets. 372      PART 4  Smart Java Techniques
In Listing  13-9, the method call that can throw an InterruptedException is 
inside a try clause. That try clause has a catch clause with exception type 
InterruptedException. LISTING 13-9: Acknowledging with a try-catch Statement
import static java.lang.System.out;
public class GoodNightsSleepA {
    public static void main(String args[]) {
        out.print("Excuse me while I nap ");
        out.println("for just five seconds...");
        takeANap();
        out.println("Ah, that was refreshing.");
    }
    static void takeANap() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            out.println("Hey, who woke me up?");
        }
    }
}
It’s my custom, at this point in a section, to remind you that a run of Listing 
Such-and-Such is shown in Figure So-and-So. But the problem here is that 
 Figure  13-13 doesn’t do justice to the code in Listing  13-9. When you run 
the  program in Listing 13-9, the computer displays Excuse me while I nap for 
just five seconds , pauses for five seconds, and then displays Ah, that was 
refreshing. The code works because the call to the sleep method, which can 
throw an InterruptedException, is inside a try clause. That try clause has a 
catch clause whose exception is of type InterruptedException. So much for acknowledging an exception with a try-catch statement. You can 
acknowledge an exception another way, shown in Listing 13-10. FIGURE 13-13: 
A 5-second  
pause before  
the “Ah” line. CHAPTER 13  Looking Good When Things Take Unexpected Turns      373
LISTING 13-10: Acknowledging with throws
import static java.lang.System.out;
public class GoodNightsSleepB {
    public static void main(String args[]) {
        out.print("Excuse me while I nap ");
        out.println("for just five seconds...");
        try {
            takeANap();
        } catch (InterruptedException e) {
            out.println("Hey, who woke me up?");
        }
        out.println("Ah, that was refreshing.");
    }
    static void takeANap() throws InterruptedException {
        Thread.sleep(5000);
    }
}
To see a run of the code in Listing  13-10, refer to Figure  13-13. Once again, 
 Figure  13-13 fails to capture the true essence of the run, but that’s okay. Just 
remember that in Figure  13-13, the computer pauses for five seconds before it 
displays Ah, that was refreshing. The important part of Listing  13-10 is in the takeANap method’s header. That 
header ends with throws InterruptedException. By announcing that it throws 
an InterruptedException, method takeANap passes the buck. What this throws 
clause really says is, “I realize that a statement inside this method has the poten-
tial to throw an InterruptedException, but I’m not acknowledging the exception 
in a try-catch statement. Java compiler, please don’t bug me about this. Instead 
of having a try-catch statement, I’m passing the responsibility for acknowledg-
ing the exception to the main method (the method that called the takeANap 
method).”
Indeed, in the main method, the call to takeANap is inside a try clause. That try 
clause has a catch clause with a parameter of type InterruptedException. So 
everything is okay. Method takeANap passes the responsibility to the main method, 
and the main method accepts the responsibility with an appropriate try-catch 
statement. Everybody’s happy. Even the Java compiler is happy. 374      PART 4  Smart Java Techniques
To better understand the throws clause, imagine a volleyball game in which the 
volleyball is an exception. When a player on the other team serves, that player is 
throwing the exception. The ball crosses the net and comes right to you. If you 
pound the ball back across the net, you’re catching the exception. But if you pass 
the ball to another player, you’re using the throws clause. In essence, you’re say-
ing, “Here, other player. You deal with this exception.”
A statement in a method can throw an exception that’s not matched by a catch 
clause. This includes situations in which the statement throwing the exception 
isn’t even inside a try block. When this happens, execution of the program jumps 
out of the method that contains the offending statement. Execution jumps back to 
whatever code called the method in the first place. A method can name more than one exception type in its throws clause. Just use 
commas to separate the names of the exception types, as in the following 
example:
throws InterruptedException, IOException, ArithmeticException
The Java API has hundreds of exception types. Several of them are subclasses of 
the RuntimeException class. Anything that’s a subclass of RuntimeException 
(or a sub-subclass, sub-sub-subclass, and so on) is unchecked. Any exception 
that’s not a descendent of RuntimeException is checked. The unchecked excep-
tions include things that would be hard for the computer to predict. Such things 
include the NumberFormatException (of Listings  13-2,  13-4, and others), 
the  ArithmeticException, the IndexOutOfBoundsException, the infamous 
NullPointerException, and many others. When you write Java code, much of 
your code is susceptible to these exceptions, but enclosing the code in try clauses 
(or passing the buck with throws clauses) is completely optional. The Java API also has its share of checked exceptions. The computer can readily 
detect exceptions of this kind. So Java insists that, for an exception of this kind, 
any potential exception-throwing statement is acknowledged with either a try 
 statement or a throws clause. Java’s checked exceptions include the Interrupted 
Exception (Listings 13-9 and 13-10), the IOException, the SQLException, and a 
gang of other interesting exceptions. I can’t think of a clever way to connect the “Try” in “TryItOut” with the try in 
try-catch statements. If you think of something, scribble it in the margin on this 
page. Then try these little challenges:
CHAPTER 13  Looking Good When Things Take Unexpected Turns      375
 » The following code doesn’t compile because the code throws an unacknowl-
edged FileNotFoundException:
// BAD CODE:
import java.io.File;
import java.util.Scanner;
public class Main {
  public static void main(String[] args) {
    Scanner diskScanner = new Scanner(new File("numbers.txt"));
    int[] numerators = new int[5];
    int[] denominators = new int[5];
    int i = 0;
    while (diskScanner.hasNextInt()) {
      numerators[i] = diskScanner.nextInt();
      denominators[i] = diskScanner.nextInt();
      i++;
    }
    for (int j = 0; j < numerators.length; j++) {
      System.out.println(numerators[j] / denominators[j]);
    }
    diskScanner.close();
  }
}
Fix the unacknowledged FileNotFoundException so that the code compiles. Then notice that, depending on the values in the numbers.txt file, some 
other exceptions may be thrown during a run of the program. Add one or 
more try-catch statements to display messages about these exceptions 
without letting the program crash. » Add try-catch statements or throws clauses (or a mixture of these two 
things) to fix the following broken code:
// BAD CODE:
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
376      PART 4  Smart Java Techniques
  public class Main {
  public static void main(String[] args) {
    File fileIn = new File("input");
    FileInputStream fileInStrm = new FileInputStream(fileIn);
    DataInputStream dataInStrm = new DataInputStream(fileInStrm);
    File fileOut = new File("output");
    FileOutputStream fileOutStrm = new FileOutputStream(fileOut);
    DataOutputStream dataOutStrm = new DataOutputStream(fileOutStrm);
    int numFilesCopied = 0;
    try {
      while (true) {
        dataOutStrm.writeByte(dataInStrm.readByte());
      }
    } catch (EOFException e) {
      numFilesCopied = 1;
    }
  }
}
When you’ve gotten the code to compile, create a file named input and run 
the code to see whether it creates the file named output. Finishing the Job with a finally Clause
Once upon a time, I was a young fellow, living with my parents in Philadelphia, 
just starting to drive a car.

--- Chunk #771 ---
I was heading toward a friend’s house and thinking 
about who-knows-what when another car came from nowhere and bashed my 
car’s passenger door. This kind of thing is called a RunARedLightException. Anyway, both cars were still drivable, and we were right in the middle of a busy 
intersection. To avoid causing a traffic jam, we both pulled over to the nearest 
curb. I fumbled for my driver’s license (which had a very young picture of me on 
it) and opened the door to get out of my car. And that’s when the second accident happened. As I was getting out of my car, a 
city bus was coming by. The bus hit me and rolled me against my car a few times. This kind of thing is called a DealWithLawyersException. CHAPTER 13  Looking Good When Things Take Unexpected Turns      377
The truth is that everything came out just fine. I was bruised but not battered.

--- Chunk #772 ---
My 
parents paid for the damage to the car, so I never suffered any financial conse -
quences. (I managed to pass on the financial burden by putting the RunARed 
LightException into my throws clause.)
This incident helps to explain why I think the way I do about exception handling. In particular, I wonder, “What happens if, while the computer is recovering from 
one exception, a second exception is thrown?” After all, the statements inside a 
catch clause aren’t immune to calamities. Well, the answer to this question is anything but simple. For starters, you can put 
a try statement inside a catch clause. This protects you against unexpected, 
potentially embarrassing incidents that can crop up during the execution of the 
catch clause. But when you start worrying about cascading exceptions, you open 
up a very slimy can of worms. The number of scenarios is large, and things can 
become complicated very quickly. One not-too-complicated thing that you can do is to create a finally clause. Like 
a catch clause, a finally clause comes after a try clause. The big difference is 
that the statements in a finally clause are executed whether or not an exception 
is thrown. The idea is, “No matter what happens, good or bad, execute the state-
ments inside this finally clause.” Listing 13-11 has an example. LISTING 13-11: Jumping Around
import static java.lang.System.out;
public class DemoFinally {
    public static void main(String args[]) {
        try {
            doSomething();
        } catch (Exception e) {
            out.println("Exception caught in main.");
        }
    }
    static void doSomething() {
        try {
            out.println(0 / 0);
        } catch (Exception e) {
            out.println("Exception caught in doSomething.");
            out.println(0 / 0);
(continued)
378      PART 4  Smart Java Techniques
        } finally {
            out.println("I'll get printed.");
        }
        out.println("I won't get printed.");
    }
}
Normally, when I think about a try statement, I think about the computer recov-
ering from an unpleasant situation. The recovery takes place inside a catch clause, 
and then the computer marches on to whatever statements come after the try 
statement. Well, if something goes wrong during execution of a catch clause, this 
picture can start looking different. Listing  13-11 gets a workout in Figure  13-14. First, the main method calls do 
Something.

--- Chunk #773 ---
Then the stupid doSomething method goes out of its way to cause 
trouble. The doSomething method divides 0 by 0, which is illegal and undoable in 
anyone’s programming language. This foolish action by the doSomething method 
throws an ArithmeticException, which is caught by the try statement’s one and 
only catch clause. Inside the catch clause, that lowlife doSomething method divides 0 by 0 again. This time, the statement that does the division isn’t inside a protective try clause. That’s okay, because an ArithmeticException isn’t checked. (It’s one of those 
RuntimeException subclasses. It’s an exception that doesn’t have to be acknowl-
edged in a try or a throws clause. For details, see the preceding section.)
Well, checked or not, the throwing of another ArithmeticException causes con-
trol to jump out of the doSomething method. But, before leaving the doSomething 
method, the computer executes the try statement’s last will and testament: the 
statements inside the finally clause. That’s why in Figure  13-14 you see the 
words I'll get printed. Interestingly enough, you don’t see the words I won't get printed  in 
Figure  13-14. Because the catch clause’s execution throws its own, uncaught 
exception, the computer never makes it down past the try-catch-finally 
statement. LISTING 13-11: (continued)
FIGURE 13-14: 
Running the  
code from 
Listing 13-11. CHAPTER 13  Looking Good When Things Take Unexpected Turns      379
So the computer goes back to where it left off in the main method. Back in the main 
method, word of the doSomething method’s ArithmeticException mishaps 
causes execution to jump into a catch clause. The computer prints Exception 
caught in main, and then this terrible nightmare of a run is finished. At the end of the earlier section “Handle an Exception or Pass the Buck,” you add 
exception-handling code to a program that makes a copy of a file. Along with your 
code, you may see warnings telling you that you’ve forgotten to close dataInStrm 
and dataOutStrm. Fix this by adding dataInStrm.close() and dataOutStrm. close() calls inside finally clauses. A try Statement with Resources
Imagine a program that gets input from two different files or from a Scanner and 
a disk file. To make sure that you clean up properly, you put close method calls in 
a finally clause. (See Listing 13-12.)
LISTING 13-12: Using Two Files
import java.io.File;
import java.io.IOException;
import java.util.Scanner;
public class Main {
    public static void main(String args[]) {
        Scanner scan1 = null;
        Scanner scan2 = null;
        try {
            scan1 = new Scanner(new File("File1.txt"));
            scan2 = new Scanner(new File("File2.txt"));
            // Do useful stuff
        } catch (IOException e) {
            // Oops! } finally {
            scan1.close();
            scan2.close();
            System.out.println("Done!");
        }
    }
}
380      PART 4  Smart Java Techniques
In theory, the computer always executes scan1.close() and scan2.close() no 
matter what goes wrong during execution of the try clause. But that’s theory. In reality, another programmer (not you, of course) might modify the code by 
closing scan1 in the middle of the try clause:
try {
    scan1 = new Scanner(new File("File1.txt"));
    scan2 = new Scanner(new File("File2.txt"));
    // Do useful stuff but also ... scan1.close();
    scan1 = null;
} catch (IOException e) {
    // Oops! } finally {
    scan1.close();
    scan2.close();
    System.out.println("Done!");
}
Now you have a real predicament. Inside the finally clause, the value of scan1 is 
null. The call to scan1.close() fails, so the program throws a NullPointer 
Exception and stops running before reaching the call to scan2.close(). In the 
worst of circumstances, scan2 isn’t closed and your program has File2.txt 
locked up so that no other program can use the file. When a program uses several resources (many files, a database and a file, or 
whatever) the buildup of try statements becomes quite complicated. You can 
make try statements within catch clauses and all kinds of crazy combinations. But Java has a better way to solve the problem: In Java 7 (and later versions of 
Java), you can create a try-with-resources statement. Listing 13-13 shows you how. LISTING 13-13: Making Sure to Close Resources
import java.io.File;
import java.io.IOException;
import java.util.Scanner;
public class NewMain {
    public static void main(String args[]) {
        try (Scanner scan1 = new Scanner(new File("File1.txt"));
             Scanner scan2 = new Scanner(new File("File2.txt"))) {
            // Do useful stuff
        } catch (IOException e) {
CHAPTER 13  Looking Good When Things Take Unexpected Turns      381
            // Oops! }
        System.out.println("Done!");
    }
}
In Listing  13-13, the declarations of scan1 and scan2 are in parentheses after 
the word try. The parenthesized declarations tell Java to close scan1 and scan2 
automatically after execution of the statements in the try clause. You can declare 
several resources inside one try statement’s parentheses. When you do, Java 
closes all the resources automatically after execution of the try clause’s 
 statements. You can add catch clauses and a finally clause, if you want. You 
can  access all kinds of resources (files, databases, connections to servers, and 
others) and have peace of mind knowing that Java will sever the connections 
automatically. Life is good. At the end of the earlier section “Handle an Exception or Pass the Buck,” you add 
exception-handling code to a program that makes a copy of a file. Along with your 
code, you may see warnings telling you that you’ve forgotten to close dataInStrm 
and dataOutStrm. In a subsequent section (“Finishing the Job with a finally 
Clause”), you got rid of the warnings by adding dataInStrm.close() and data 
OutStrm.close() calls inside finally clauses. Instead of adding calls to the 
close method, fix the problem using a try-with-resources statement. CHAPTER 14  Sharing Names among the Parts of a Java Program      383
IN THIS CHAPTER
 » Hiding names from other classes
 » Exposing names to other classes
 » Tweaking your code to find the right 
middle ground
Sharing Names among 
the Parts of a Java 
Program
S
 
peaking of private fields and methods (and I do speak about these things in 
this chapter) . .

--- Chunk #774 ---
. I’m eating lunch with some friends at work. “They can read your email,” says one 
fellow. Another chimes in, “They know every single website that you visit. They 
know what products you buy, what you eat for dinner, what you wear, what you 
think. They even know your deepest, darkest secrets. Why, I wouldn’t be surprised 
if they know when you’re going to die.”
A third voice enters the fray. “It’s getting to the point where you can’t blow your 
nose without someone taking a record of it. I visited a website a few weeks ago, 
and the page wished me Happy Birthday. How did they know it was me, and how 
did they remember that it was my birthday?”
“Yeah,” says the first guy. “I have a tag on my car that lets me sail through toll 
booths. It senses that I’m going through and puts the charge on my credit card 
automatically. Every month, I get a list from the company showing where I’ve 
Chapter 14
384      PART 4  Smart Java Techniques
been and when I was there. I’m amazed it doesn’t say whom I was visiting and 
what I did when I got there.”
I think quietly to myself. I think about saying, “That’s just a bunch of baloney. Personally, I’d be flattered if my employer, the government, or some big company 
thought so much of me that they tracked my every move. I have enough trouble 
getting people’s attention when I really want it. And most agencies that keep logs 
of all my purchasing and viewing habits can’t even spell my name right when they 
send me junk mail. ‘Hello, this is a courtesy call for Larry Burg.

--- Chunk #775 ---
Is Mr. Burg at 
home?’ Spying on people is really boring. I can just see the headline on the front 
page of The Times: ‘Author of Java For Dummies Wears His Undershirt Inside Out!’ 
Big deal!”
I think for a few seconds, and then I say, “They’re out to get us. TV cameras! That’s the next big thing — TV cameras everywhere.”
Access Modifiers
If you’ve read this far into Java For Dummies, 7th Edition, you probably know one 
thing: Object-oriented programming is big on hiding details. Programmers who 
write one piece of code shouldn’t tinker with the details inside another program-
mer’s code. It’s not a matter of security and secrecy. It’s a matter of modularity. When you hide details, you keep the intricacies inside one piece of code from being 
twisted and broken by another piece of code. Your code comes in nice, discrete, 
manageable lumps. You keep complexity to a minimum. You make fewer mis -
takes. You save money. You help promote world peace. Other chapters have plenty of examples of the use of private fields. When a field is 
declared private, it’s hidden from all outside meddling. This hiding enhances 
modularity, minimizes complexity, and so on. Elsewhere in the annals of Java For Dummies, 7th Edition, are examples of things 
that are declared public. Just like a public celebrity, a field that’s declared public is 
left wide open. Plenty of people probably know what kind of toothpaste Elvis used, 
and any programmer can reference a public field, even a field that’s not named 
Elvis. In Java, the words public and private are called access modifiers. No doubt you’ve 
seen fields and methods without access modifiers in their declarations. A method 
or field of this kind is said to have default access. Many examples in this book use 
default access without making a big fuss about it. That’s okay in some chapters, 
CHAPTER 14  Sharing Names among the Parts of a Java Program      385
but not in this chapter. In this chapter, I describe the nitty-gritty details about 
default access. And you can find out about yet another access modifier that isn’t used in any 
example before this chapter. (At least, I don’t remember using it in any earlier 
examples.) It’s the protected access modifier. Yes, this chapter covers some of 
the slimy, grimy facts about protected access. Classes, Access, and Multipart Programs
With this topic, you can become all tangled up in terminology, so you need to get 
some basics out of the way. (Most of the terminology that you need comes from 
Chapter 10, but it’s worth reviewing at the start of this chapter.) Here’s a fake 
piece of Java code:
class MyClass {
    int myField;              //a field (a member)
    void myMethod() {         //a method (another member)
        int myOtherField;     //a method-local variable (NOT a member)
    }
}
The comments on the right side of the code tell the whole story. Two kinds of 
variables exist here: fields and method-local variables. This chapter isn’t about 
method-local variables. It’s about methods and fields. Believe me, carrying around the phrase methods and fields wherever you go isn’t 
easy. It’s much better to give these things one name and be done with it. That’s 
why both methods and fields are called members of a class. Members versus classes
At this point, you make an important distinction. Think about Java’s public key-
word. As you may already know from earlier chapters, you can put public in front 
of a member. For example, you can write
public static void main(String args[]) {
or
public amountInAccount = 50.22;
386      PART 4  Smart Java Techniques
These uses of the public keyword come as no big surprise. What you may not 
already know is that you can put the public keyword in front of a class. For exam-
ple, you can write
public class Drawing {
    // Your code goes here
}
In Java, the public keyword has two slightly different meanings — one meaning 
for members and another meaning for classes. Most of this chapter deals with the 
meaning of public (and other such keywords) for members. The last part of this 
chapter (appropriately titled “Access Modifiers for Java Classes”) deals with the 
meaning for classes. Access modifiers for members
Sure, this section is about members. But that doesn’t mean that you can ignore 
Java classes. Members or not, the Java class is still where all the action takes place. Each field is declared in a particular class, belongs to that class, and is a member 
of that class. The same is true of methods. Each method is declared in a particular 
class, belongs to that class, and is a member of that class. Can you use a certain 
member name in a particular place in your code? To begin answering the question, 
check whether that place is inside or outside of the member’s class:
 » If the member is private, only code that’s inside the member’s class can refer 
directly to that member’s name:
class SomeClass {
    private int myField = 10;
}
class SomeOtherClass {
    public static void main(String args[]) {
        SomeClass someObject = new SomeClass();
        //This doesn't work:
        System.out.println(someObject.myField);
    }
}
CHAPTER 14  Sharing Names among the Parts of a Java Program      387
 » If the member is public, any code running in the same Java Virtual Machine 
can refer directly to that member’s name. class SomeClass {
    public int myField = 10;
}
class SomeOtherClass {
    public static void main(String args[]) {
        SomeClass someObject = new SomeClass();
        //This works:
        System.out.println(someObject.myField);
    }
}
Figures 14-1 through 14-3 illustrate the ideas in a slightly different way. When you see this section’s examples, you may come to the wrong conclusion. You may have this little conversation with yourself: “In the example with private 
int myField, the code doesn’t work. But in the example with public int myField, 
the code works. So, to have a better chance of getting my code to work, I should 
make my fields public and avoid making them private. Right?”
FIGURE 14-1: 
Several classes 
and their 
subclasses. 388      PART 4  Smart Java Techniques
No, dear reader. That’s not right! Public fields are easy to use and even easier to misuse. The best way to engineer 
your code is to make access to each field as restrictive as possible. If a field doesn’t 
absolutely need to be public, try making it private. If other classes have to get or 
set the field’s values, provide public getter and setter methods. And that leads 
nicely into the next paragraph .

--- Chunk #776 ---
.

--- Chunk #777 ---
.

--- Chunk #778 ---
. FIGURE 14-2: 
The range of code 
in which a public 
field or method 
can be used 
(shaded). FIGURE 14-3: 
The range of code 
in which a private 
field or method 
can be used 
(shaded). CHAPTER 14  Sharing Names among the Parts of a Java Program      389
In one of this section’s examples, you can’t write someObject.myField because, in 
SomeClass, the variable myField is declared to be private. Fix this by adding get-
ters and setters, and modify the someObject.myField reference appropriately. Putting a drawing on a frame
To make this business about access modifiers clear, you need an example or two. In this chapter’s first example, almost everything is public. With public access, 
you don’t have to worry about who can use what. The code for this first example comes in several parts. The first part, which is in 
Listing 14-1, displays an ArtFrame. On the face of the ArtFrame is a Drawing. If all 
the right pieces are in place, running the code of Listing 14-1 displays a window 
like the one shown in Figure 14-4. LISTING 14-1: Displaying a Frame
import com.burdbrain.drawings.Drawing;
import com.burdbrain.frames.ArtFrame;
class ShowFrame {
    public static void main(String args[]) {
        ArtFrame artFrame = new ArtFrame(new Drawing());
        artFrame.setSize(200, 100);
        artFrame.setVisible(true);
    }
}
The code in Listing 14-1 creates a new ArtFrame instance. You may suspect that 
ArtFrame is a subclass of a Java frame class, and that’s certainly the case. Chapter 9 
says that Java frames are, by default, invisible. So, in Listing 14-1, to make the 
ArtFrame instance visible, you call the setVisible method. FIGURE 14-4: 
An ArtFrame. 390      PART 4  Smart Java Techniques
Now notice that Listing 14-1 starts with two import declarations. The first import 
declaration allows you to abbreviate the name Drawing from the com.burdbrain. drawings package. The second import declaration allows you to abbreviate the 
name ArtFrame from com.burdbrain.frames. For a review of import declarations, see Chapter 4. The detective in you may be thinking, “He must have written more code (code that 
I don’t see here) and put that code in packages that he named com.burdbrain.drawings 
and com.burdbrain.frames.” And, indeed, you are correct. To make Listing 14-1 work, 
I create something called a Drawing, and I’m putting all my drawings in the com. burdbrain.drawings package. I also need an ArtFrame class, and I’m putting all 
such classes in my com.burdbrain.frames package. So, really, what’s a Drawing? Well, if you’re so eager to know, look at 
Listing 14-2. LISTING 14-2: The Drawing Class
package com.burdbrain.drawings;
import java.awt.Graphics;
public class Drawing {
    public int x = 40, y = 40, width = 40, height = 40;
    public void paint(Graphics g) {
        g.drawOval(x, y, width, height);
    }
}
The code for the Drawing class is pretty slim — it contains a few int fields and a 
paint method. That’s all. Well, when I create my classes, I try to keep ’em lean. Anyway, here are some notes about my Drawing class:
 » At the top of the code is a package declaration. Lo and behold! I’ve made 
my Drawing class belong to a package — the com.burdbrain.drawings 
package. I didn’t pull this package name out of the air. The convention 
(handed down by the people who created Java) says that you start a package 
name by reversing the parts of your domain name, so I reversed burdbrain. com. Then you add one or more descriptive names, separated by dots. I added 
the name drawings because I intend to put all my drawing goodies in 
this package. CHAPTER 14  Sharing Names among the Parts of a Java Program      391
 » The Drawing class is public. A public class is vulnerable to intrusion from the 
outside. In general, I avoid plastering the public keyword in front of any old 
class. But in Listing 14-2, I have to declare my Drawing class to be public. If I 
don’t, classes that aren’t in the com.burdbrain.drawings package can’t use 
the goodies in Listing 14-2. In particular, the line
ArtFrame artFrame = new ArtFrame(new Drawing());
in Listing 14-1 is illegal unless the Drawing class is public. For more information on public and nonpublic classes, see the section “Access 
Modifiers for Java Classes,” later in this chapter. » The code has a paint method. This paint method uses a standard Java trick 
for making things appear onscreen. The parameter g in Listing 14-2 is called a 
graphics buffer. To make things appear, all you do is draw on this graphics 
buffer, and the buffer is eventually rendered on the computer screen. Here’s a little more detail: In Listing 14-2, the paint method takes a g param-
eter. This g parameter refers to an instance of the java.awt.Graphics class. Because a Graphics instance is a buffer, the things that you put onto this 
buffer are eventually displayed on the screen. Like all instances of the java. awt.Graphics class, this buffer has several drawing methods — and one of 
them is drawOval. When you call drawOval, you specify a starting position (x 
pixels from the left edge of the frame and y pixels from the top of the frame). You also specify an oval size by putting numbers of pixels in the width and 
height parameters. Calling the drawOval method puts a little round thing 
into the Graphics buffer. That Graphics buffer, round thing and all, is 
displayed onscreen. Directory structure
The code in Listing 14-2 belongs to the com.burdbrain.drawings package. When 
you put a class into a package, you have to create a directory structure that mirrors 
the name of the package. To house code that’s in the com.burdbrain.drawings package, you have to have 
three directories: a com directory, a subdirectory of com named burdbrain, and a 
subdirectory of burdbrain named drawings. The overall directory structure is 
shown in Figure 14-5. 392      PART 4  Smart Java Techniques
If you don’t have your code in the appropriate directories, you get a repulsive and 
disgusting NoClassDefFoundError. Believe me, this error is never fun to get. When you see this error, you don’t have any clues to help you figure out where the 
missing class is or where the compiler expects to find it. If you stay calm, you can 
figure out all this stuff on your own. If you panic, you’ll be poking around for 
hours. As a seasoned Java programmer, I can remember plenty of scraped knuck-
les that came from this heinous NoClassDefFoundError. Making a frame
This chapter’s first three listings develop one multipart example. This section has 
the last of three pieces in that example. This last piece isn’t crucial for the under-
standing of access modifiers, which is the main topic of this chapter. So, if you 
want to skip past the explanation of Listing 14-3, you can do so without losing the 
chapter’s thread. On the other hand, if you want to know more about the Java 
Swing classes, read on. LISTING 14-3: The ArtFrame Class
package com.burdbrain.frames;
import java.awt.Graphics;
import javax.swing.JFrame;
import com.burdbrain.drawings.Drawing;
FIGURE 14-5: 
The files and 
directories in 
your project. CHAPTER 14  Sharing Names among the Parts of a Java Program      393
public class ArtFrame extends JFrame {
    private static final long serialVersionUID = 1L;
    Drawing;
    public ArtFrame(Drawing drawing) {
        this.drawing = drawing;
        setTitle("Abstract Art");
        setDefaultCloseOperation(EXIT_ON_CLOSE);
    }
    public void paint(Graphics g) {
        drawing.paint(g);
    }
}
LOOKING FOR FILES IN ALL 
THE RIGHT PLACES
You try to compile the program in Listing 14-1. The Java compiler pokes through the 
code and stumbles upon some missing pieces. First there’s this thing called an 
ArtFrame. Then you have this Drawing business. Listing 14-1 defines a class named 
ShowFrame, not ArtFrame or Drawing. So where does the compiler go for information 
about the ArtFrame and Drawing classes? If you stop to think about it, the problem can be daunting. Should the compiler go 
searching all over your hard drive for files named ArtFrame.java or Drawing.class? How large is your new hard drive?

--- Chunk #779 ---
500GB? 750GB? 6,000,000GB? And what about refer-
ences to files on network drives? The search space is potentially unlimited. What if the 
compiler eventually resolves all these issues? Then you try to run your code, and the 
Java Virtual Machine (JVM) starts searching all over again. (For info on the Java Virtual 
Machine, see Chapter 2.)
To tame this problem, Java defines something called a CLASSPATH. The CLASSPATH is a 
list of places where the compiler and the JVM look for code. There are several ways to 
set a CLASSPATH. Some programmers create a new CLASSPATH each time they run a 
Java program. Others create a system-wide CLASSPATH variable. (If you’re familiar with 
the PATH variable on Windows and Unix computers, you may already know how this 
stuff works.) One way or another, the compiler and the JVM need a list of places to look 
for code. Without such a list, these Java tools don’t look anywhere. They don’t find 
classes like ArtFrame or Drawing. You get a cannot find symbol message or a 
NoClassDefFoundError message, and you’re very unhappy. 394      PART 4  Smart Java Techniques
Listing 14-3 has all the gadgetry that you need for putting a drawing on a Java 
frame. The code uses several names from the Java API (Application Programming 
Interface). I explain most of these names in Chapters 9 and 10. The only new name in Listing  14-3 is the word paint. The paint method in 
 Listing 14-3 defers to another paint method — the paint method belonging to a 
Drawing object. The ArtFrame object creates a floating window on your computer 
screen. What’s drawn in that floating window depends on whatever Drawing 
object was passed to the ArtFrame constructor. If you trace the flow of Listings 14-1 through 14-3, you may notice something 
peculiar: The paint method in Listing 14-3 never seems to be called. Well, for 
many of Java’s window-making components, you just declare a paint method 
and let the method sit there quietly in the code. When the program runs, the com-
puter calls the paint method automatically. That’s what happens with javax.swing.JFrame objects. In Listing  14-3, the 
frame’s paint method is called from behind the scenes. Then the frame’s paint 
method calls the Drawing object’s paint method, which in turn draws an oval on 
the frame. That’s how you get the stuff you see in Figure 14-4. In your computer’s File Explorer or Finder, navigate to this book’s 14-01 project 
folder. In that folder, poke around and find the ShowFrame.java, Drawing.java, 
and ArtFrame.java files. Notice how these Java files are nested inside a few dif -
ferent folders. Sneaking Away from the Original Code
Your preferred software vendor, Burd Brain Consulting, has sold you two files: 
Drawing.class and ArtFrame.class. As a customer, you can’t see the code inside 
the files Drawing.java and ArtFrame.java. So you have to live with whatever hap-
pens to be inside these two files. (If only you’d purchased a copy of Java For Dum-
mies, 6th Edition, which has the code for these files in Listings 14-2 and 14-3!) 
Anyway, you want to tweak the way the oval looks in Figure 14-4 so that it’s a bit 
wider. To do this, you create a subclass of the Drawing class — DrawingWide — and 
put it in Listing 14-4. CHAPTER 14  Sharing Names among the Parts of a Java Program      395
LISTING 14-4: A Subclass of the Drawing Class
import java.awt.Graphics;
import com.burdbrain.drawings.Drawing;
public class DrawingWide extends Drawing {
    int width = 100, height = 30;
    public void paint(Graphics g) {
        g.drawOval(x, y, width, height);
    }
}
To make use of the code in Listing 14-4, you remember to change one of the lines 
in Listing 14-1. You change the line to
ArtFrame = new ArtFrame(new DrawingWide());
In Listing  14-1 you can also remove the com.burdbrain.drawings.Drawing 
import declaration because you no longer need it. Listing 14-4 defines a subclass of the original Drawing class. In that subclass, you 
override the original class’s width and height fields and the original class’s paint 
method. The frame that you get is shown in Figure 14-6. In passing, you may notice that the code in Listing 14-4 doesn’t start with a pack-
age declaration. This means that your whole collection of files comes from the 
following three packages:
 » The com.burdbrain.drawings package: The original Drawing class from 
Listing 14-2 is in this package. » The com.burdbrain.frames package: The ArtFrame class from Listing 14-3 
is in this package. FIGURE 14-6: 
Another art 
frame. 396      PART 4  Smart Java Techniques
 » An ever-present, unnamed package: In Java, when you don’t start a file with 
a package declaration, all the code in that file goes into one big, unnamed 
package. Listings 14-1 and 14-4 are in the same unnamed package. In fact, 
most of the listings from the first 13 chapters of this book are in Java’s 
unnamed package. At this point, your project has two drawing classes: the original Drawing class and 
your new DrawingWide class. Similar as these classes may be, they live in two 
separate packages. That’s not surprising. The Drawing class, developed by your 
friends at Burd Brain Consulting, lives in a package whose name starts with com. burdbrain. But you developed DrawingWide on your own, so you shouldn’t put it in 
a com.burdbrain package. The most sensible thing to do is to put it in one of your own packages, such as 
com.myhomedomain.drawings; but putting your class in the unnamed package will 
do for now. One way or another, your DrawingWide subclass compiles and runs as planned. You 
go home, beaming with the confidence of having written useful, working code. Default access
If you’re reading these paragraphs in order, you know that the last example ends 
happily. The code in Listing 14-4 runs like a charm. Everyone, including my won-
derful editor, Paul Levesque, is happy.

--- Chunk #780 ---
But, wait! Do you ever wonder what life would be like if you hadn’t chosen that 
particular career, dated that certain someone, or read that certain For Dummies 
book? In this section, I roll back the clock a bit to show you what would have 
 happened if one word had been omitted from the code in Listing 14-2. Dealing with different versions of a program can give you vertigo, so I start this 
discussion by describing what you have. First, you have a Drawing class. In this 
class, the fields aren’t declared to be public and have the default access. The Drawing 
class lives in the com.burdbrain.drawings package. (See Listing 14-5.)
LISTING 14-5: Fields with Default Access
package com.burdbrain.drawings;
import java.awt.Graphics;
CHAPTER 14  Sharing Names among the Parts of a Java Program      397
public class Drawing {
    int x = 40, y = 40, width = 40, height = 40;
    public void paint(Graphics g) {
        g.drawOval(x, y, width, height);
    }
}
Next, you have a DrawingWide subclass (copied, for your convenience, in 
 Listing 14-6). The DrawingWide class is in Java’s unnamed package. LISTING 14-6: A Failed Attempt to Create a Subclass
import com.burdbrain.drawings.*;
import java.awt.Graphics;
public class DrawingWide extends Drawing {
    int width = 100, height = 30;
    public void paint(Graphics g) {
        g.drawOval(x, y, width, height);
    }
}
The trouble is that the whole thing falls apart at the seams. The code in  
Listing 14-6 doesn’t compile. Instead, you get the following error messages:
x is not public in com.burdbrain.drawings.Drawing;
cannot be accessed from outside package
y is not public in com.burdbrain.drawings.Drawing;
cannot be accessed from outside package
The code doesn’t compile, because a field that has default access can’t be directly 
referenced outside its package — not even by a subclass of the class containing 
the field. The same holds true for any methods that have default access. A class’s fields and methods are called members of the class. The rules for access — 
default and otherwise — apply to all members of classes. The access rules that I describe in this chapter don’t apply to method-local vari-
ables. A method-local variable can be accessed only within its own method. 398      PART 4  Smart Java Techniques
For the rundown on method-local variables, see Chapter 10. In Java, the default access for a member of a class is package-wide access. A mem-
ber declared without the word public, private, or protected in front of it is accessible 
in the package in which its class resides. Figures 14-7 and 14-8 illustrate the point. The names of packages, with all their dots and subparts, can be slightly mislead-
ing. For instance, when you write a program that responds to button clicks, you 
normally import classes from two separate packages. On one line, you may have 
import java.awt.*;. On another line, you may have import java.awt.event.*;. Importing all classes from the java.awt package doesn’t automatically import 
classes from the java.awt.event package. FIGURE 14-8: 
The range of code 
in which a default 
field or method 
can be used 
(shaded). FIGURE 14-7: 
Packages cut 
across subclass 
hierarchies. CHAPTER 14  Sharing Names among the Parts of a Java Program      399
Crawling back into the package
I love getting things in the mail. At worst, it’s junk mail that I can throw right into 
the trash. At best, it’s something I can use, a new toy, or something somebody 
sent especially for me.

--- Chunk #781 ---
Well, today is my lucky day. Somebody from Burd Brain Consulting sent a subclass 
of the Drawing class. It’s essentially the same as the code in Listing 14-6. The only 
difference is that this new DrawingWideBB class lives inside the com.burdbrain. drawings package. The code is shown in Listing 14-7. To run this code, I have to 
modify Listing 14-1 with the line
ArtFrame artFrame = new ArtFrame(new DrawingWideBB());
LISTING 14-7: Yes, Virginia, This Is a Subclass
package com.burdbrain.drawings;
import java.awt.Graphics;
public class DrawingWideBB extends Drawing {
    int width = 100, height = 30;
    public void paint(Graphics g) {
        g.drawOval(x, y, width, height);
    }
}
When you run Listing 14-7 alongside the Drawing class in Listing 14-5, everything 
works just fine. The reason? It’s because Drawing and DrawingWideBB are in the 
same package. Look back at Figure 14-8 and notice the shaded region that spans 
across an entire package. The code in the DrawingWideBB class has every right to 
use the x and y fields, which are defined with default access in the Drawing class 
because Drawing and DrawingWideBB are in the same package. To use the DrawingWideBB class in Listing  14-7, you make two changes in the 
original Listing 14-1. Change the first import declaration to
import com.burdbrain.drawings.DrawingWideBB;
Also, change the ArtFrame object’s constructor call to new ArtFrame(new 
DrawingWideBB()). 400      PART 4  Smart Java Techniques
This section explains default access, the kind of access that I use in most of the 
book’s examples. I use default access a lot because, with default access, you don’t 
have to make sense of the words public or private. So, in many examples, you 
have fewer words to worry about. But in real life, programmers shun the use of default access. With default access, 
all the other classes in your package can view and change the values of your fields. Other programmers can set daysInThisMonth to 32 or chaptersInThisBook to –7. By far, the best policy is to use default access only when such access is absolutely 
necessary. In most situations, if other classes have to get or set your field’s values, 
you should use private access and provide public getter and setter methods. Protected Access
When I was first getting to know Java, I thought the word protected meant nice and 
secure or something like that. “Wow, that field is protected. It must be hard to get 
at.” Well, this notion turned out to be wrong. In Java, a member that’s protected 
is less hidden, less secure, and available for use in more classes than one that has 
default access. In other words, protected access is more permissive than default 
access. For me, the terminology is misleading. But that’s the way it is. Subclasses that aren’t in the same package
Think of protected access this way. You start with a field that has default access 
(a field without the word public, private, or protected in its declaration). That 
field can be accessed only inside the package in which it lives. Now add the word 
protected to the front of the field’s declaration. Suddenly, classes outside that 
field’s package have some access to the field. You can now reference the field from 
a subclass (of the class in which the field is declared). You can also reference the 
field from a sub-subclass, a sub-sub-subclass, and so on. Any descendent class 
will do.

--- Chunk #782 ---
For an example, see Listings 14-8 and 14-9. LISTING 14-8: Protected Fields
package com.burdbrain.drawings;
import java.awt.Graphics;
public class Drawing {
    protected int x = 40, y = 40, width = 40, height = 40;
CHAPTER 14  Sharing Names among the Parts of a Java Program      401
    public void paint(Graphics g) {
        g.drawOval(x, y, width, height);
    }
}
LISTING 14-9: The Subclass from the Blue Lagoon, Part II
import java.awt.Graphics;
import com.burdbrain.drawings.Drawing;
public class DrawingWide extends Drawing {
    int width = 100, height = 30;
    public void paint(Graphics g) {
        g.drawOval(x, y, width, height);
    }
}
Listing 14-8 defines the Drawing class. Listing 14-9 defines DrawingWide, which 
is a subclass of the Drawing class. In the Drawing class, the x, y, width, and height fields are protected. The  
DrawingWide class has its own width and height fields, but DrawingWide refer-
ences the x and y fields that are defined in the parent Drawing class. That’s okay, 
even though DrawingWide isn’t in the same package as its parent Drawing class. (The Drawing class is in the com.burdbrain.drawings package; the DrawingWide 
class is in Java’s great, unnamed package.) It’s okay because the x and y fields are 
protected in the Drawing class. Compare Figures 14-8 and 14-9. Notice the extra bit of shading in Figure 14-9. A subclass can access a protected member of a class, even if that subclass belongs 
to some other package. Do you work with a team of programmers? Do people from outside your team use 
their own team’s package names? If so, when they use your code, they may make 
subclasses of the classes that you’ve defined. This is where protected access comes 
in handy. Use protected access when you want people from outside your team to 
make direct references to your code’s fields or methods. 402      PART 4  Smart Java Techniques
For the members of a class, private access is the most restrictive, then comes 
default access, then protected access, and finally, public access. Classes that aren’t subclasses  
(but are in the same package)
Those people from Burd Brain Consulting are sending you one piece of software 
after another. This time, they’ve sent an alternative to the ShowFrame class — the 
class in Listing 14-1. This new ShowFrameWideBB class displays a wider oval (how 
exciting!), but it does this without creating a subclass of the old Drawing class. Instead, the new ShowFrameWideBB code creates a Drawing instance and then 
changes the value of the instance’s width and height fields. The code is shown in 
Listing 14-10. LISTING 14-10: Drawing a Wider Oval
package com.burdbrain.drawings;
import com.burdbrain.frames.ArtFrame;
class ShowFrameWideBB {
    public static void main(String args[]) {
        Drawing drawing = new Drawing();
        drawing.width = 100;
        drawing.height = 30;
FIGURE 14-9: 
The range of code 
in which a 
protected field or 
method can be 
used (shaded). CHAPTER 14  Sharing Names among the Parts of a Java Program      403
        ArtFrame artFrame = new ArtFrame(drawing);
        artFrame.setSize(200, 100);
        artFrame.setVisible(true);
    }
}
Here’s the story. This ShowFrameWideBB class in Listing  14-10 is in the same  
package as the Drawing class (the com.burdbrain.drawings package). But  
ShowFrameWideBB isn’t a subclass of the Drawing class. Now imagine compiling ShowFrameWideBB with the Drawing class that’s shown in 
Listing  14-8  — the class with all those protected fields. What happens? Well, 
everything goes smoothly because a protected member is available in two (some-
what unrelated) places. Look again at Figure 14-9. A protected member is avail -
able to subclasses outside the package, but the member is also available to code 
(subclasses or not) within the member’s package. Listing 14-10 has a main method, which is inside a class, which is in turn inside 
the com.burdbrain.drawings package. With most Integrated Development Envi-
ronments (IDEs), you don’t think twice about running a main method that’s in a 
named package. But if you run programs from the command line, you may need 
to type a fully qualified class name. For example, to run the code in Listing 14-10, 
you type java com.burdbrain.drawings.ShowFrameWideBB. The real story about protected access is one step more complicated than the story 
that I describe in this section. The Java Language Specification (https://docs. oracle.com/javase/specs) mentions a hair-splitting point about code being 
responsible for an object’s implementation. When you’re first figuring out how to 
program in Java, don’t worry about this point. Wait until you’ve written many Java 
programs. Then when you stumble upon a variable has protected access  
error message, you can start worrying. Better yet, skip the worrying and take a 
careful look at the protected access section in the Java Language Specification. For info about the Java Language Specification, visit Chapter 3. Here are some things for you to try:
 » In Listing 14-2, I draw a circle on a frame. To fill the circle with green color, use 
the Graphics class’s setColor and fillOval methods, like this:
g.setColor(Color.GREEN)
g.fillOval(x, y, width, height);
404      PART 4  Smart Java Techniques
Values such as Color.GREEN belong to Color class in the java.awt package. Create a frame that displays a traffic signal with its green, yellow, and red 
lights. » A Book has a title (a String) and an author (an instance of the Author class).

--- Chunk #783 ---
An Author has a name (a String) and an ArrayList of Book instances. A 
separate class contains a main method that creates several books and several 
authors. The main method also displays information about the books and 
authors. Put each class in its own package. Wherever possible, make your fields 
private, and provide public getters and setters. » An Item has a name (a String) and an artist (an instance of the Artist class). Each Artist instance has a name (a String) and an ArrayList of items. The Song and Album classes are subclasses of the Item class. Each Song 
instance has a genre (a value from an enum named Genre). The values of 
Genre are ROCK, POP, BLUES, and CLASSICAL. Each Album instance has an 
ArrayList of songs. Finally, a Playlist has an ArrayList of items. Create these classes. In a separate class, construct instances of each class, and 
display information about these instances on the screen. » The following four classes live in four different .java files. Without typing 
these classes in an IDE’s editor, decide which statements will cause the IDE to 
display error messages. For each such statement, decide on the least permis-
sive access change that would eliminate the error message:
// THIS CODE DOES NOT COMPILE:
package com.allmycode.things;
import com.allyourcode.stuff.Stuff;
import com.allyourcode.stuff.morestuff.MoreStuff;
public class Things {
  protected int i = 0;
  private int j = 0;
  int k = 0;
  public static void main(String[] args) {
    Stuff stuff = new Stuff();
    System.out.println(stuff.i);
CHAPTER 14  Sharing Names among the Parts of a Java Program      405
      MoreStuff moreStuff = new MoreStuff();
    System.out.println(moreStuff.i);
  }
}
package com.allyourcode.stuff;
import com.allyourcode.stuff.morestuff.MoreStuff;
public class Stuff {
  protected int i = 0;
  void aMethod() {
    new MoreStuff().myMethod();
  }
}
package com.allyourcode.stuff.morestuff;
import com.allmycode.things.Things;
public class MoreStuff extends Things {
  protected void myMethod() {
    System.out.println(i);
  }
}
package com.allmycode.things;
public class MoreThings extends Things {
  public void anotherMethod() {
    System.out.println(i);
    System.out.println(j);
    System.out.println(k);
  }
}
406      PART 4  Smart Java Techniques
Access Modifiers for Java Classes
Maybe the things that you read about access modifiers for members make you a 
tad dizzy. After all, member access in Java is a complicated subject with lots of plot 
twists and cliffhangers.

--- Chunk #784 ---
Well, the dizziness is over. Compared with the saga for 
fields and methods, the access story for classes is rather simple. A class can be either public or nonpublic. If you see something like
public class Drawing
you’re looking at the declaration of a public class. But, if you see plain old
class ShowFrame
the class that’s being declared isn’t public. Public classes
If a class is public, you can refer to the class from anywhere in your code. Of 
course, some restrictions apply. You must obey all the rules in this chapter’s 
“Directory structure” section. You must also refer to a packaged class properly. For example, in Listing 14-1, you can write
import com.burdbrain.drawings.Drawing;
import com.burdbrain.frames.ArtFrame;
... ArtFrame artFrame = new ArtFrame(new Drawing());
or you can do without the import declarations and write
com.burdbrain.frames.ArtFrame artFrame =
    new com.burdbrain.frames.ArtFrame(new com.burdbrain.drawings.Drawing());
One way or another, your code must acknowledge that the ArtFrame and Drawing 
classes are in named packages. Nonpublic classes
If a class isn’t public, you can refer to the class only from code within the class’s 
package. CHAPTER 14  Sharing Names among the Parts of a Java Program      407
I tried it. First, I went back to Listing 14-2 and deleted the word public. I turned 
public class Drawing into plain old class Drawing, like this:
package com.burdbrain.drawings;
import java.awt.Graphics;
class Drawing {
    public int x = 40, y = 40, width = 40, height = 40;
    public void paint(Graphics g) {
        g.drawOval(x, y, width, height);
    }
}
Then I compiled the code in Listing 14-7. Everything was peachy because List -
ing 14-7 contains the following lines:
package com.burdbrain.drawings;
public class DrawingWideBB extends Drawing
Because both pieces of code are in the same com.burdbrain.drawings package, 
access from DrawingWideBB back to the nonpublic Drawing class was no problem 
at all. But then I tried to compile the code in Listing  14-3. The code in Listing  14-3  
begins with
package com.burdbrain.frames;
That code isn’t in the com.burdbrain.drawings package. So when the computer 
reached the line
Drawing drawing;
from Listing 14-3, the computer went poof! To be more precise, the computer dis-
played this message:
com.burdbrain.drawings.Drawing is not public in com.burdbrain.drawings;
cannot be accessed from outside package
Well, I guess I got what was coming to me. 408      PART 4  Smart Java Techniques
Things are never as simple as they seem. The rules that I describe in this section 
apply to almost every class in this book. But Java has fancy things called inner 
classes, and inner classes follow a different set of rules. Fortunately, a typical nov-
ice programmer has little contact with inner classes. The only inner classes in this 
book are in Chapter 15 (and a few inner classes disguised as enum types). So for 
now, you can live quite happily with the rules that I describe in this section. CHAPTER 15  Fancy Reference Types      409
IN THIS CHAPTER
 » Writing and using a Java interface
 » Working with abstract classes
Fancy Reference Types
I
n previous chapters, you may have read about the things that full-time and 
part-time employees have in common. In particular, both the FullTimeEmployee 
and PartTimeEmployee classes can extend the Employee class. That’s nice to 
know if you’re running a small business, but what if you’re not running a busi -
ness? What if you’re taking care of house pets? This chapter explores the care of house pets and other burning issues. Java’s Types
Chapter 4 explains that Java has these two kinds of types:
 » Java has eight primitive types. The four that you use most often are int, double, boolean, and char. » Java’s API has thousands of reference types. And, when you write a Java 
program, you define new reference types. Java’s String type is a reference type. So are Java’s Scanner, JFrame, 
ArrayList, and File types. My DummiesFrame is a reference type. In 
Chapter 7, you create your own Employee, FullTimeEmployee, and 
PartTimeEmployee reference types. Your first You’ll love Java! program has a 
main method inside of a class, and that class is a reference type. You may not 
realize it, but every array belongs to a reference type. Chapter 15
410      PART 4  Smart Java Techniques
In Java, reference types are everywhere. But until this point in the book, the only 
reference types that you see are classes and arrays. Java has other kinds of refer -
ence types, and this chapter explores the possibilities. The Java Interface
Think about a class (such as an Employee class) and a subclass (such as a Full 
TimeEmployee class). The relationship between a class and its subclass is one of 
inheritance. In many real-life families, a child inherits assets from a parent. And 
in Chapter 8, the FullTimeEmployee class inherits name and jobTitle fields from 
the Employee class. That’s the way it works.

--- Chunk #785 ---
But consider the relationship between an editor and an author. The editor says, "By 
signing this contract, you agree to submit a completed manuscript by the ninth of 
January." Despite any excuses that the author gives before the deadline date (and, 
believe me, authors make plenty of excuses), the relationship between the editor 
and the author is one of obligation. The author agrees to take on certain responsi-
bilities; and, in order to continue being an author, the author must fulfill those 
responsibilities. (By the way, there’s no subtext in this paragraph — none at all.)
Now consider Barry Burd. Who? Barry Burd  — that guy who writes Java For 
 Dummies and certain other For Dummies books (all from Wiley Publishing). He’s a 
college professor, and he’s also an author. You want to mirror this situation in a 
Java program, but Java doesn’t support multiple inheritance. You can’t make 
Barry extend both a Professor class and an Author class at the same time. Fortunately for Barry, Java has interfaces. An interface is a kind of reference type. In fact, the code to create an interface looks a lot like the code to create a class:
public interface MyInterfaceName {
  // blah, blah, blah
}
An interface is a lot like a class, but an interface is different. (So, what else is new? A cow is like a planet, but it’s quite a bit different. Cows moo; planets hang in space.)
Anyway, when you read the word interface,  you can start by thinking of a class. Then, in your head, note that
 » A class can extend only one parent class, but a class can implement many 
interfaces. CHAPTER 15  Fancy Reference Types      411
 » A parent class is a bunch of stuff that a class inherits. But an interface is a 
bunch of stuff that an implementing class is obliged to provide. What about poor Barry? He can be an instance of a Person class with all the fields 
that any person has — name, address, age, height, weight, and so on. He can also 
implement more than one interface:
 » Because Barry implements a Professor interface, he must have methods 
named teachStudents, adviseStudents, and gradePapers. » Because he implements an Author interface, he must have methods named 
writeChapters, reviewChapters, answerEmail, and so on. Two interfaces
Imagine two different kinds of data. One is a column of numbers that comes from 
an array. Another is a table (with rows and columns) that comes from a disk file. What might these two things have in common? I don’t know about you, but I may want to display both kinds of data. So I can write 
code to create a contract. The contract says, "Whoever signs this contract agrees 
to have a display method." In Listing 15-1, I declare a Displayable interface. LISTING 15-1: Behold! An Interface! public interface Displayable {
    public void display();
}
Wait just a darn minute! The display method declaration in Listing 15-1 has a 
header but no body. There are no curly braces after display() — only a lonely-
looking semicolon. What’s going on here? To answer the question, I’ll let the code in Listing 15-1 speak for itself. If the code 
in the listing could talk, here’s what the code would say:
“As an interface, my display method has a header but no body. A class that 
claims to implement me (the Displayable interface) must provide (either directly 
or indirectly) a body for the display method. That is, a class that claims to 
412      PART 4  Smart Java Techniques
implement Displayable must, in one way or another, provide its own code of the 
following kind:
public void display() {
    // Some statements go here
}
In order to implement me (the interface in Listing 15-1), the new code’s display 
method must take no parameters and return nothing (also known as void).”
The Displayable interface is like a legal contract. The Displayable interface 
doesn’t tell you what an implementing class already has. Instead, the Display 
able interface tells you what an implementing class must declare in its own code. In addition to displaying columns of numbers and tables, I may also want to sum-
marize both kinds of data. How do you summarize a column of numbers? I don’t 
know. Maybe you display the total of all the numbers. And how do you summarize a 
table? Maybe you display the table’s column headings. How you summarize the data 
isn’t my concern. All I care about is that you have some way to summarize the data. So I create code containing a second Java contract. The second contract says, 
"Whoever signs this contract agrees to have a summarize method." In Listing 15-2, 
I declare a Summarizable interface. LISTING 15-2: Another Interface
public interface Summarizable {
    public String summarize();
}
Any class claiming to implement the Summarizable interface must, by hook or by 
crook, provide an implementation of a summarize method — a method with no 
parameters that returns a String value. In the declaration of an interface, a particular method might have no body of its 
own. A method with no body is called an abstract method. Implementing interfaces
Listing 15-3 implements the Displayable and Summarizable interfaces, and pro-
vides bodies for the display and summarize methods. CHAPTER 15  Fancy Reference Types      413
LISTING 15-3: Implementing Two Interfaces
public class ColumnOfNumbers implements Displayable, Summarizable {
    double numbers[];
    public ColumnOfNumbers(double[] numbers) {
        this.numbers = numbers;
    }
    @Override
    public void display() {
        for (double d : numbers) {
            System.out.println(d);
        }
    }
    @Override
    public String summarize() {
        double total = 0.0;
        for (double d : numbers) {
            total += d;
        }
        return Double.toString(total);
    }
}
When you implement an interface, you provide bodies for the interface’s abstract 
methods. Java’s compiler is serious about the use of the implements keyword. If you remove 
either of the two method declarations from Listing  15-3 without removing the 
implements clause, you see some frightening error messages in your IDE’s editor. Java expects you to honor the contract that the implements keyboard implies. If 
you don’t honor the contract, Java refuses to compile your code. So there!

--- Chunk #786 ---
You can use Java’s error messages to your advantage. Start by typing some code 
containing the clause implements Displayable, Summarizable. Because of the 
implements clause, the editor displays an error mark and lists the names of the 
methods that you should have declared but didn’t. In this section’s example, those 
method names are display and summarize. After a few more mouse clicks, the 
IDE generates simple display and summarize methods for you. Listing  15-4 contains another class that implements the Displayable and 
 Summarizable interfaces. 414      PART 4  Smart Java Techniques
LISTING 15-4: Another Class Implements the Interfaces
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;
public class Table implements Displayable, Summarizable {
    Scanner diskFile;
    ArrayList<String> lines = new ArrayList<>();
    public Table(String fileName) {
        try {
            diskFile = new Scanner(new File(fileName));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        while (diskFile.hasNextLine()) {
            lines.add(diskFile.nextLine());
        }
    }
    @Override
    public void display() {
        for (String line : lines) {
            System.out.println(line);
        }
    }
    @Override
    public String summarize() {
        return lines.get(0);
    }
}
In Listings  15-3 and  15-4, notice several uses of the @Override annotation. Chapter  8 introduces the use of the @Override annotation.

--- Chunk #787 ---
Normally, you use  
@Override to signal the replacement of a method that’s already been declared in 
a superclass. But from Java 6 onward, you can also use @Override to signal an 
interface method’s implementation. That’s what I do in Listings 15-3 and 15-4. CHAPTER 15  Fancy Reference Types      415
Putting the pieces together
The code in Listing 15-5 makes use of all the stuff in Listings 15-1 to 15-4. LISTING 15-5: Getting the Most out of Your Interfaces
public class Main {
    public static void main(String[] args) {
        double numbers[] = { 21.7, 68.3, 5.5 };
        ColumnOfNumbers column = new ColumnOfNumbers(numbers);
        displayMe(column);
        summarizeMe(column);
        Table table = new Table("MyTable.txt");
        displayMe(table);
        summarizeMe(table);
    }
    static void displayMe(Displayable displayable) {
        displayable.display();
        System.out.println();
    }
    static void summarizeMe(Summarizable summarizable) {
        System.out.println(summarizable.summarize());
        System.out.println();
    }
}
With the MyTable.txt file shown in Figure 15-1, the output from Listing 15-5 is 
shown in Figure 15-2. FIGURE 15-1: 
The MyTable.txt 
file. 416      PART 4  Smart Java Techniques
Feast your eyes on the displayMe method in Listing 15-5. What kind of parameter 
does the displayMe method take? Is it a ColumnOfNumbers? No. Is it a Table? No. The displayMe method doesn’t know anything about ColumnOfNumbers instances 
or Table instances. All the displayMe method knows about is things that imple-
ment Displayable. That’s what the displayMe method’s parameter list says. When you hand something that implements the Displayable interface to the 
displayMe method, the displayMe method knows what it can do. The displayMe 
method can call the parameter’s display method, because that parameter object 
is guaranteed to have a display method. The same kind of thing is true about the summarizeMe method in Listing 15-5. How do you know that you can call summarizable.summarize() inside the body of 
the summarizeMe method? You can make this call because summarizable has to 
have a summarize() method. The rules about Java interfaces guarantee it. That’s the real power behind Java’s interfaces. In this section, the ColumnOfNumbers and Table classes implement the Display 
able and Summarizable interfaces. What about a Deletable interface? Any class 
implementing the Deletable interface must have its own delete method. Create the DeletableColumnOfNumbers class  — a subclass of the ColumnOf 
Numbers class. In addition to all the things ColumnOfNumbers does, the Deletable 
ColumnOfNumbers class also implements the Deletable interface. When you 
delete a column of numbers, you set the values of each of its entries to 0.0. Create the DeletableTable class — a subclass of the Table class. In addition to all 
the things Table does, the DeletableTable class also implements the Deletable 
interface. When you delete a table, you remove all rows except the first (table head-
ing) row. (Hint: If you call the lines list’s remove method starting from the 1 row 
and going to the lines.size() row, you won’t be happy with the results. A call to 
the remove method modifies the list immediately, and that can mess up your loop.)
FIGURE 15-2: 
Running the code 
in Listing 15-5. CHAPTER 15  Fancy Reference Types      417
Abstract Classes
Is there anything you can say that applies to animals of every kind? If you’re a 
biologist, maybe there is.

--- Chunk #788 ---
But if you’re a programmer, you can say very little. If 
you don’t believe me, consider the wondrous variety of life on the planet Earth:*
 » A gelada monkey spends the day on a grassy plateau. But at night the gelada 
goes for a snooze on the rocky, perilous edge of a mountain cliff. With any 
luck, the sleeping monkey doesn’t toss and turn much. TWO KINDS OF METHODS
Inside an interface declaration, any method without a body is called an abstract 
method. If you run Java 8 or later, you can also put methods with bodies inside an inter-
face declaration. A method with a body is called a default method. In an interface’s code, 
each default method declaration starts with the default keyword. public interface MyInterface {
    void method1();
    default void method2() {
        System.out.println("Hello!");
    }
}
In MyInterface, method1 is an abstract method, and method2 is a default method. If 
you create a class that implements MyInterface, like so
class MyClass implements MyInterface
then your newly declared MyClass must declare its own method1 and provide a body 
for method1. Optionally, your MyClass may declare its own method2. If MyClass 
doesn’t declare its own method2, then MyClass inherits a method2 body from 
MyInterface. *See smithsonianmag.com/science-nature/ethiopias-exotic-monkeys- 
147893502, http://news.nationalgeographic.com/news/2004/12/1208_ 
041208_pompeii_worms.html, psychologytoday.com/blog/choke/201207/
how-humans-learn-lessons-the-sea-squirt, and esa.int/Our_Activities/
Human_Spaceflight/Research/Tiny_animals_survive_exposure_to_space. 418      PART 4  Smart Java Techniques
 » A Pompeii worm lives in an underwater tube. The temperature by the worm’s 
head is about 72 degrees Fahrenheit (22 degrees Celsius). But at the other 
end of the worm, the water temperature is normally 176 degrees Fahrenheit 
(80 degrees Celsius). If you know one of these worms personally, don’t buy 
any warm socks for it. » A sea squirt lives part of its life as an animal. At a certain point in its life cycle, 
the sea squirt attaches itself permanently to a rock and then digests its own 
brain, effectively turning itself into a plant. » A tiny water bear can survive 12 days (and maybe more) with no atmosphere 
in the vacuum of outer space. Even the cosmic radiation in outer space doesn’t 
harm a water bear. That’s what I want to be in my next life — a water bear. With so much biological diversity on our planet, the only thing I can say that 
applies to every animal is that every animal has a certain weight (measured in 
pounds or kilograms) and every animal makes (or, possibly, doesn’t make) a 
characteristic sound. Listing 15-6 has the complete scoop. LISTING 15-6: What a Programmer Knows about Animals
public class Animal {
    double weight;
    String sound;
    public Animal(double weight, String sound) {
        this.weight = weight;
        this.sound = sound;
    }
}
While I typed the code for the Animal class, I had to stop and correct several typing 
mistakes. The mistakes weren’t really my fault. My cat was walking back and 
forth across my computer keyboard. And that brings me from the subject of all 
animals to the topic of house pets. A house pet is an animal. But every house pet has a name — like Fluffy, Blacky, or 
Princess. And every house pet has a recommended routine for taking care of the pet. Of course, the care routines differ greatly from one kind of pet to another. If I had 
a dog, I’d have to walk the dog. But I’d never try to walk a cat. In fact, I don’t even 
let our cat out of the house. So when I define my HousePet class, I want to be 
vague about pet care instructions. And in Java, a class that’s somewhat vague is 
called an abstract class. Listing 15-7 has an example. CHAPTER 15  Fancy Reference Types      419
LISTING 15-7: What It Means to Be a House Pet
public abstract class HousePet extends Animal {
    String name;
    public HousePet(String name, double weight, String sound) {
        super(weight, sound);
        this.name = name;
    }
    abstract public void howToCareFor();
    public void about() {
        System.out.print(name + " weighs " + weight + " pounds");
        System.out.print(sound != null ? (" and says '" + sound + "'") : "");
        System.out.println(".");
    }
}
On the first line of Listing 15-7, the keyword abstract tells Java that HousePet is 
an abstract class. Because HousePet is an abstract class, HousePet can have an 
abstract method. And in Listing 15-7, howToCareFor is an abstract method. An 
abstract method has a header but no body. In an abstract method’s declaration, 
there are no curly braces — only a semicolon where curly braces would normally 
appear. So, when you try to execute the howToCareFor method, what happens? Well, you 
can’t really execute the howToCareFor method in Listing 15-7. In fact, you can’t 
even create an instance of the abstract class declared in Listing 15-7. The follow-
ing code is illegal:
// VERY BAD CODE:
HousePet myPet = new HousePet("Boop", 12.0, "Meow");
An abstract class has no life of its own. In order to use an abstract class, you have 
to create an ordinary (non-abstract) class that extends the abstract class. In the 
ordinary class, all methods have bodies. So everything works out. Before you walk away from Listing 15-7, notice the super(weight, sound) call in 
that listing. As in Chapter 9, the keyword super triggers a call to the superclass’s 
constructor. In Listing  15-7, calling super(weight, sound)  is like calling the 
Animal(double weight, String sound) constructor from Listing 15-6. The con-
structor assigns values to the new object’s weight and sound fields. 420      PART 4  Smart Java Techniques
Caring for your pet
Here’s a quotation from the book Java For Dummies, 7th Edition:
"In order to use an abstract class, you have to create an ordinary (non-abstract) 
class that extends the abstract class."
So, to use the HousePet class in Listing  15-7, you have to create a class that 
extends the HousePet class. The code in Listing 15-8 extends the abstract HousePet 
class and provides a body for the method named howToCareFor. LISTING 15-8: It’s a Dog’s Life
public class Dog extends HousePet {
    int walksPerDay;
    public Dog(String name, double weight, int walksPerDay) {
        super(name, weight, "Woof");
        this.walksPerDay = walksPerDay;
    }
    @Override
    public void howToCareFor() {
        System.out.print("Walk " + name);
        System.out.println(" " + walksPerDay + " times each day.");
    }
}
In addition to having a name, a weight, and a sound, every dog gets walked a cer-
tain number of times per day. And now, because of the howToCareFor method’s 
body, you know what caring for a dog means: It means walking the dog a certain 
number of times each day. It’s a good thing that the howToCareFor method is 
abstract in the HousePet class. You wouldn’t necessarily want to walk some other 
kind of pet. Take, for example, a domestic cat. "Caring" for a cat may mean not bothering it too 
often. And cats have other characteristics  — characteristics that don’t apply to 
dogs. For example, some cats go outdoors; others don’t. You can make walks 
PerDay be 0 for an indoor cat, but that feels like cheating. Instead, each cat can 
have a boolean value representing the cat’s outdoor indoor/outdoor status. List-
ing 15-9 has the code. CHAPTER 15  Fancy Reference Types      421
LISTING 15-9: How to Be a Cat
public class Cat extends HousePet {
    boolean isOutdoor;
    public Cat(String name, double weight, boolean isOutdoor) {
        super(name, weight, "Meow");
        this.isOutdoor = isOutdoor;
    }
    @Override
    public void howToCareFor() {
        System.out.println(
          isOutdoor ? "Let " : "Do not let " + name + " outdoors.");
    }
}
Both the Dog and Cat classes are subclasses of the HousePet class. And, because of 
the abstract method declaration in Listing 15-7, both the Dog and Cat classes must 
have howToCareFor methods. But the howToCareFor methods in the two classes 
are quite different. One method refers to a walksPerDay field; the other method 
refers to an isOutdoor field. And because the HousePet class’s howToCareFor 
method is abstract, there’s no default behavior. Either the Dog and Cat classes 
implement their own howToCareFor methods or the Dog and Cat classes can’t 
claim to extend HousePet. This paragraph describes a picky detail, and you should ignore it if you have any 
inclination to do so: The Dog and Cat classes must implement the howToCareFor 
method because the Dog and Cat classes aren’t abstract. If the Dog and Cat classes 
were abstract (that is, if they were abstract classes extending the abstract HousePet 
class), then the Dog and Cat classes would not have to implement the howToCare 
For method. The Dog and Cat classes could pass the implementation buck to their 
own subclasses. For that matter, an abstract class that implements an interface 
doesn’t have to provide bodies for all the interfaces abstract methods. Abstract 
classes can take advantage of many little loopholes. But in order to use these loop-
holes, you have to create some exotic programming examples. So, in this chapter 
I simplify the story and write that (a) a class that extends an abstract class must 
provide bodies for the abstract class’s abstract methods, and (b) a class that 
implements an interface must provide bodies for the interface’s abstract methods. It’s not exactly true, but it’s good enough for now.

--- Chunk #789 ---
If you live in a very small apartment, you may not have room for a dog or a cat.

--- Chunk #790 ---
In 
that case, Listing 15-10 is for you. 422      PART 4  Smart Java Techniques
LISTING 15-10: You May Grow Up to Be a Fish
public class Fish extends HousePet {
    public Fish(String name, double weight) {
        super(name, weight, null);
    }
    @Override
    public void howToCareFor() {
        System.out.println("Feed " + name + " daily.");
    }
}
I could go on and on creating subclasses of the HousePet class. Many years ago, 
our daughter had some pet mice. Caring for the mice meant keeping the cat away 
from them. In Java, subclasses multiply like rabbits. Using all your classes
Your work isn’t finished until you’ve tested your code. Most programs require 
hours, days, and even months of testing. But for this chapter’s HousePet example, 
I’ll do only one test.

--- Chunk #791 ---
The test is in Listing 15-11. LISTING 15-11: The Class Menagerie
public class Main {
    public static void main(String[] args) {
        Dog dog1 = new Dog("Fido", 54.7, 3);
        Dog dog2 = new Dog("Rover", 15.2, 2);
        Cat cat1 = new Cat("Felix", 10.0, false);
        Fish fish1 = new Fish("Bubbles", 0.1);
        dog1.howToCareFor();
        dog2.howToCareFor();
        cat1.howToCareFor();
        fish1.howToCareFor();
        dog1.about();
        dog2.about();
CHAPTER 15  Fancy Reference Types      423
        cat1.about();
        fish1.about();
    }
}
When you run the code in Listing 15-11, you get the output shown in Figure 15-3. Notice how the code in Listing 15-11 seamlessly and effortlessly calls many ver-
sions of the howToCareFor method. With the dog1.howToCareFor() and dog2. howToCareFor() calls, Java executes the method in Listing 15-8. With the cat1. howToCareFor() call, Java executes the method in Listing  15-9. And, with the 
fish1.howToCareFor() call, Java executes the method in Listing 15-10 — it’s like 
having a big if statement without writing the if statement’s code. When you add 
a new class for a pet mouse, you don’t have to enlarge an existing if statement. There’s no if statement to enlarge. Notice also how the about method in the abstract HousePet class keeps track of 
the object that called it. For example, when you call dog1.about() in Listing 15-11, 
the HousePet class’s nonspecific about method knows that the sound dog1 makes 
is Woof. Everything falls into place very nicely. Do you like abstract art? You can use abstract classes to create abstract art! » Create an abstract class named Shape. The Shape class has a size field (of type 
int) and an abstract show method. Extend the abstract Shape class with two 
other classes: a Square class and a Triangle class. In the bodies of the Square 
and Triangle classes’ show methods, place the code that creates a text-based 
rendering of the shape in question. For example, a Square of size 5 looks like this:
 --------
|        |
|        |
|        |
 --------
FIGURE 15-3: 
Please don’t pet 
the Pompeii 
worm. 424      PART 4  Smart Java Techniques
A Triangle of size 2 looks like this:
  /\
 /  \
 ----
 » For an extra-special challenge, create an abstract Shape class with an abstract 
paint method. The Shape class also has size, color, and isFilled fields. The size field has type int, the color field has type java.awt.Color, and 
the isFilled field has type boolean. Extend the abstract Shape class with 
two other classes: a Square class and a Circle class. In the bodies of the 
Square and Circle classes’ paint methods, place the code that draws the 
shape in question on a Java JFrame. Relax! You’re Not Seeing Double! If you’ve read this chapter’s earlier sections on interfaces and abstract methods, 
your head might be spinning. Both interfaces and abstract classes have abstract 
methods. But the abstract methods play slightly different roles in these two kinds 
of reference types. How can you keep it all straight in your mind? The first thing to do is to remember that no one learns about object-oriented pro-
gramming concepts without getting lots of practice in writing code. If you’ve read 
this chapter and you’re confused, that may be a good thing. It means you’ve 
understood enough to know how complicated this stuff is. The more code you 
write, the more comfortable you’ll become with classes, interfaces, and all these 
other ideas. The next thing to do is to sort out the differences in the way you declare abstract 
methods. Table 15-1 has the story. Both interfaces and abstract classes have abstract methods. So you may be won-
dering how you should choose between declaring an interface and declaring an 
abstract class. In fact, you might ask three professional programmers how inter-
faces and abstract classes differ from one another. If you do, you may get five 
different answers. (Yes, five answers; not three answers.)
Interfaces and abstract classes are similar beasts, and the new features in Java 8 
made them even more similar than in previous Java versions. But the basic idea is 
about the relationships among things. CHAPTER 15  Fancy Reference Types      425
 » Extending a subclass represents an is a relationship. Think about the relationships in this chapter’s earlier section "Abstract 
Classes." A house pet is an animal. A dog is a house pet. A cat is a house pet. A fish is a house pet. » Implementing an interface represents a can do relationship. Think about the relationships in this chapter’s earlier section "The Java 
Interface." The first line in Listing 15-3 says implements Displayable. With 
these words, the code promises that each ColumnOfNumbers object can be 
displayed. Later in same listing, you make good on the promise by declaring a 
display method. Think about the relationships in this chapter’s earlier section "The Java 
Interface." A column of numbers isn’t always a summarizable thing. But in 
Listing 15-3, you promise that the ColumnOfNumbers objects will be summari-
zable, and you make good on the promise by declaring a summarize method. If you want more tangible evidence of the difference between an interface and an 
abstract class, consider this: A class can implement many interfaces, but a class 
can extend only one other class, even if that one class is an abstract class. So, after 
you’ve declared
public class Dog extends HousePet
you can’t also make Dog extend a Friend class. But you can make Dog implement 
a Befriendable interface. And then you can make the same Dog class implement 
a Trainable interface. (By the way, I’ve tried making my Cat class implement a 
Trainable interface but, for some reason, it never works.)
TABLE 15-1:	 Using (or Not Using) Abstract Methods
In an Ordinary  
(Non-Abstract) Class
In an  
Interface
In an 
Abstract Class
Are abstract methods allowed? No Yes Yes
Can a method declaration contain  
the abstract keyword? No Yes Yes
Can a method declaration contain  
the default keyword (meaning "not 
abstract")? No Yes No
With neither the abstract nor the 
default keyword, a method is:
Not abstract Abstract Not abstract
426      PART 4  Smart Java Techniques
And, if you want an even more tangible difference between an interface and an 
abstract class, I have one for you: An interface can’t contain any non-static, non-
final fields. For example, if the HousePet class in Listing 15-7 were an interface, it 
couldn’t have a name field. That simply wouldn’t be allowed. So there. Interfaces and abstract classes are different from one another. But if 
you’re new at the game, you shouldn’t worry about the difference. Just read as 
much code as you can, and don’t get scared when you see an abstract method.

--- Chunk #792 ---
That’s all there is to it. CHAPTER 16  Responding to Keystrokes and Mouse Clicks      427
IN THIS CHAPTER
 » Creating code to handle mouse clicks
 » Responding when the user presses a 
key or selects a drop down box item
 » Putting classes inside of other classes
Responding to 
Keystrokes and 
Mouse Clicks
I
n the late 1980s, I bought my first mouse. I paid $100 and, because I didn’t 
really need a mouse, I checked with my wife before buying it. (At the time, my 
computer ran a hybrid text/windowed environment. Anything that I could do 
with a mouse, I could just as easily do with the Alt key.)
Now it’s the 21st century. The last ten mice that I got were free. Ordinary ones just 
fall into my lap somehow. A few exotic mice were on sale at the local computer 
superstore. One cost $10 and came with a $10 rebate. As I write this chapter, I’m using the most recent addition to my collection: an 
official For Dummies mouse. This yellow-and-white beauty has a little compart-
ment filled with water. Instead of a snowy Atlantic City scene, the water sur -
rounds a tiny Dummies Man charm. It’s so cute.

--- Chunk #793 ---
It was a present from the folks at 
Wiley Publishing. Chapter 16
428      PART 4  Smart Java Techniques
Go On . .

--- Chunk #794 ---
. Click That Button
In previous chapters, I create windows that don’t do much. A typical window dis-
plays some information but doesn’t have any interactive elements. Well, the time 
has come to change all that. This chapter’s first example is a window with a but-
ton on it. When the user clicks the button, darn it, something happens. The code 
is shown in Listing 16-1, and the main method that calls the code in Listing 16-1 
is in Listing 16-2. LISTING 16-1: A Guessing Game
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Random;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JTextField;
class GameFrame extends JFrame implements ActionListener {
   private static final long serialVersionUID = 1L;
   int randomNumber = new Random().nextInt(10) + 1;
   int numGuesses = 0;
   JTextField textField = new JTextField(5);
   JButton button = new JButton("Guess");
   JLabel label = new JLabel(numGuesses + " guesses");
   public GameFrame() {
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      setLayout(new FlowLayout());
      add(textField);
      add(button);
      add(label);
      button.addActionListener(this);
      pack();
      setVisible(true);
   }
   @Override
   public void actionPerformed(ActionEvent e) {
      String textFieldText = textField.getText();
CHAPTER 16  Responding to Keystrokes and Mouse Clicks      429
      if (Integer.parseInt(textFieldText)==randomNumber) {
         button.setEnabled(false);
         textField.setText(textField.getText() + " Yes!");
         textField.setEnabled(false);
      } else {
         textField.setText("");
         textField.requestFocus();
      }
      numGuesses++;
      String guessWord = (numGuesses == 1) ? " guess" : " guesses";
      label.setText(numGuesses + guessWord);
   }
}
LISTING 16-2: Starting the Guessing Game
public class ShowGameFrame {
   public static void main(String args[]) {
       new GameFrame();
   }
}
Some snapshots from a run of this section’s code are shown in Figures  16-1 
and 16-2. In a window, the user plays a guessing game. Behind the scenes, the 
program chooses a secret number (a number from 1 to 10). Then the program dis-
plays a text field and a button. The user types a number in the text field and clicks 
the button. One of two things happens next:
 » If the number that the user types isn’t the same as the secret number, 
the computer posts the number of guesses made so far. The user gets to 
make another guess. » If the number that the user types is the same as the secret number, the 
text field displays Yes!. Meanwhile, the game is over, so both the text field 
and the button become disabled. Both components have that gray, washed-
out look, and neither component responds to keystrokes or mouse clicks. FIGURE 16-1: 
An incorrect 
guess. 430      PART 4  Smart Java Techniques
In Listing 16-1, the code to create the frame, the button, and the text field isn’t 
earth-shattering. I did similar things in Chapters 9 and 10. The JTextField class 
is new in this chapter, but a text field isn’t much different from a button or a label. Like so many other components, the JTextField class is defined in the javax. swing package. When you create a new JTextField instance, you can specify a 
number of columns. In Listing 16-1, I create a text field that’s five columns wide. Listing 16-1 uses a fancy operator to decide between the singular guess and the 
plural guesses. If you’re not familiar with this use of the question mark and colon, 
see Chapter 11. Events and event handling
The big news in Listing 16-1, shown in the preceding section, is the handling of 
the user’s button click. When you’re working in a graphical user interface (GUI), 
anything the user does (like pressing a key, moving the mouse, clicking the mouse, 
or whatever) is called an event. The code that responds to the user’s press, move-
ment, or click is called event-handling code. Listing 16-1 deals with the button-click event with three parts of its code:
 » The top of the GameFrame class declaration says that this class implements 
ActionListener. By announcing that it will implement the ActionListener interface, the 
code in Listing 16-1 agrees that it will give meaning to the interface’s abstract 
actionPerformed method. In this situation, giving meaning means declaring 
an actionPerformed method with curly braces, a body, and maybe some 
statements to execute. » Sure enough, the code for the GameFrame class has an actionPerformed 
method, and that actionPerformed method has a body. » Finally, the constructor for the GameFrame class adds this to the button’s list 
of action listeners. Java will call this code’s actionPerformed method when the user clicks the 
button. Hooray! Taken together, all three of these tricks make the GameFrame class handle button 
clicks. FIGURE 16-2: 
The correct 
guess. CHAPTER 16  Responding to Keystrokes and Mouse Clicks      431
For the full story about Java interfaces, refer to Chapter 15. You can learn a lot about the code in Listing 16-1 by removing certain statements 
and observing the results. For each suggested removal, see whether your IDE 
 displays any error messages. If not, try to run the program. After observing the 
results, put the element back and try the next suggested removal:
 » Remove the entire actionPerformed method declaration — header and all. » Remove the call to setVisible(true). » Remove the call to pack(). » Remove the call to button.addActionListener(). Threads of execution
Here’s a well-kept secret: Java programs are multithreaded, which means that 
 several things are going on at once whenever you run a Java program. Sure, the 
computer is executing the code that you’ve written, but it’s executing other code 
as well (code that you didn’t write and don’t see). All this code is being executed 
at the same time. While the computer executes your main method’s statements, 
one after another, the computer takes time out, sneaks away briefly, and executes 
statements from other, unseen methods. For most simple Java programs, these 
other methods are ones that are defined as part of the Java Virtual Machine (JVM). For instance, Java has an event-handling thread. While your code runs, the event-
handling thread’s code runs in the background. The event-handling thread’s code 
listens for mouse clicks and takes appropriate action whenever a user clicks the 
mouse. Figure 16-3 illustrates how this works. FIGURE 16-3: 
Two Java threads. 432      PART 4  Smart Java Techniques
When the user clicks the button, the event-handling thread says, “Okay, the but-
ton was clicked. What should I do about that?” And the answer is, “Call some 
actionPerformed methods.” It’s as if the event-handling thread has code that 
looks like this:
if (buttonJustGotClicked()) {
    object1.actionPerformed(infoAboutTheClick);
    object2.actionPerformed(infoAboutTheClick);
    object3.actionPerformed(infoAboutTheClick);
}
Of course, behind every answer is yet another question. In this situation, the 
 follow-up question is, “Where does the event-handling thread find action 
Performed methods to call?” And there’s another question: “What if you don’t 
want the event-handling thread to call certain actionPerformed methods that are 
lurking in your code?”
Well, that’s why you call the addActionListener method. In Listing 16-1, the call
button.addActionListener(this);
tells the event-handling thread, “Put this code’s actionPerformed method on 
your list of methods to be called. Call this code’s actionPerformed method when-
ever the button is clicked.”
So that’s how it works. To have the computer call an actionPerformed method, 
you register the method with Java’s event-handling thread. You do this registra -
tion by calling addActionListener. The addActionListener method belongs to 
the object whose clicks (and other events) you’re waiting for. In Listing  16-1, 
you’re waiting for the button object to be clicked, and the addActionListener 
method belongs to that button object. The keyword this
In Chapters 9 and 10, the keyword this gives you access to instance variables from 
the code inside a method. What does the this keyword really mean? Well, com-
pare it with the English phrase state your name:
I, (state your name), do solemnly swear, to uphold the constitution of the Philadelphia 
Central High School Photography Society . .

--- Chunk #795 ---
.

--- Chunk #796 ---
. CHAPTER 16  Responding to Keystrokes and Mouse Clicks      433
The phrase state your name is a placeholder. It’s a space in which each person puts 
his or her own name:
I, Bob, do solemnly swear . . . I, Fred, do solemnly swear . .

--- Chunk #797 ---
. Think of the pledge (“I . .

--- Chunk #798 ---
. do solemnly swear . . .”) as a piece of code in a Java 
class. In that piece of code is the placeholder phrase state your name. Whenever an 
instance of the class (a person) executes the code (that is, takes the pledge), the 
instance fills in its own name in place of the phrase state your name. The this keyword works the same way. It sits inside the code that defines the 
GameFrame class. Whenever an instance of GameFrame is constructed, the instance 
calls addActionListener(this). In that call, the this keyword stands for 
the instance itself. button.addActionListener(thisGameFrameInstance);
By calling button.addActionListener(this), the GameFrame instance is saying, 
“Add my actionPerformed method to the list of methods that are called whenever 
the button is clicked.” And indeed, the GameFrame instance has an action 
Performed method. The GameFrame has to have an actionPerformed method 
because the GameFrame class implements the ActionListener interface. It’s funny 
how that all fits together. In your own words, describe the uses of the keyword this in the following code:
public class Main {
  public static void main(String[] args) {
    new IntegerHolder(42).displayMyN();
    new IntegerHolder(7).displayMyN();
  }
}
class IntegerHolder {
  private int n;
  IntegerHolder(int n) {
    this.n = n;
  }
  void displayMyN() {
    Displayer.display(this);
  }
434      PART 4  Smart Java Techniques
  public int getN() {
    return n;
  }
}
class Displayer {
  public static void display(IntegerHolder holder) {
    System.out.println(holder.getN());
  }
}
Inside the actionPerformed method
The actionPerformed method in Listing 16-1 uses a bunch of tricks from the Java 
API. Here’s a brief list of those tricks:
 » Every instance of JTextField (and of JLabel) has its own getter and setter 
methods, including getText and setText. Calling getText fetches what-
ever string of characters is in the component. Calling setText changes the 
characters that are in the component. In Listing 16-1, judicious use of getText 
and setText pulls a number out of the text field and replaces the number 
with either nothing (the empty string "") or the number, followed by the  
word Yes! » Every component in the javax.swing package (JTextField, JButton, or 
whatever) has a setEnabled method. When you call setEnabled(false), 
the component gets that limp, gray, washed-out look and can no longer 
receive button clicks or keystrokes. » Every component in the javax.swing package has a requestFocus method. When you call requestFocus, the component gets the privilege of receiving 
the user’s next input. For example, in Listing 16-1, the call textField. requestFocus() says, “Even though the user may have just clicked the 
button, put a cursor in the text field. That way, the user can type another 
guess in the text field without clicking the text field first.”
You can perform a test to make sure that the object referred to by the button 
 variable is really the thing that was clicked. Just write if (e.getSource() == 
button). If your code has two buttons, button1 and button2, you can test to find 
out which button was clicked. You can write if (e.getSource() == button1) 
and if (e.getSource() == button2). CHAPTER 16  Responding to Keystrokes and Mouse Clicks      435
The serialVersionUID
Chapter  9 introduces the SuppressWarnings annotation to avoid dealing with 
something called a serialVersionUID. A serialVersionUID is a number that 
helps Java avoid version conflicts when you send an object from one place to 
another. For example, you can send the state of your JFrame object to another 
computer’s screen. Then the other computer can check the frame’s version num-
ber to make sure that no funny business is taking place. In Chapter 9, I side-step the serialVersionUID issue by telling Java to ignore any 
warnings about missing serial version numbers. But in Listing 16-1, I take a bolder 
approach. I give my JFrame object a real serialVersionUID. This is my first ver-
sion of GameFrame, so I give this GameFrame the version number 1. (Actually, I give 
this GameFrame the number 1L, meaning the long value 1. See Chapter 4.)
So, when would you bother to change a class’s serialVersionUID number? If ver-
sion number 1 is nice, is version number 2 even better? The answer is complicated, 
but the bottom line is, don’t change the serialVersionUID number unless you 
make incompatible changes to the class’s code. By “incompatible changes,” 
I mean changes that make it impossible for the receiving computer’s existing code 
to handle your newly created objects. For more details about the serialVersionUID and what constitutes an incompat-
ible code change, check out this site:
http://docs.oracle.com/javase/8/docs/platform/serialization/spec/version. html
Every major Java IDE has visual tools to help you design a GUI interface. » Eclipse has WindowBuilder: www.eclipse.org/windowbuilder
 » IntelliJ IDEA has GUI Designer: www.jetbrains.com/help/idea/2016.3/
gui-designer-basics.html
 » NetBeans has GUI Builder: http://netbeans.org/kb/docs/java/
quickstart-gui.html
With any of these tools, you drag components from a palette onto a frame. (The 
components include buttons, text fields, and other goodies.) Using the mouse, you 
can move and resize each component. As you design the frame visually, the tools 
creates the frame’s code automatically. Each component on the frame has a little 
spreadsheet showing the component’s properties. For example, you can change 
the text on a button’s face by changing the text entry in the button’s spreadsheet. When you right-click or control-click the picture of a component, you get  
the option of jumping to the component’s actionPerformed method. In the  
436      PART 4  Smart Java Techniques
actionPerformed method, you add Java code, such as button.setText("You 
clicked me!"). Tools like WindowBuilder, GUI Designer, and GUI Builder make 
the design of GUI interfaces quicker, more natural, and more intuitive. This chapter describes features of Java’s Swing framework. Since 1998, Swing has 
been Java’s primary framework for developing GUI applications. But late in 2011, 
Oracle added a newer framework — JavaFX — to Java’s core. JavaFX provides a 
richer set of components than Swing. But for simple applications, JavaFX is more 
difficult to use. If you’re interested in reading more about JavaFX, visit Oracle’s 
Getting Started with JavaFX page. It’s at http://docs.oracle.com/javafx/2/
get_started/jfxpub-get_started.htm. Using the techniques shown in this chapter, create a program that displays a frame 
containing three components: a text field ( JTextField), a button (JButton), and 
a label (JLabel). The user types text into the text field. Then, when the user clicks 
the button, the program copies any text that’s in the text field onto the label. Responding to Things Other  
Than Button Clicks
When you know how to respond to one kind of event, responding to other kinds of 
events is easy. Listings 16-3 and 16-4 display a window that converts between US 
and UK currencies. The code in these listings responds to many kinds of events. Figures 16-4, 16-5, and 16-6 show some pictures of the code in action. LISTING 16-3: Displaying the Local Currency
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.text.NumberFormat;
import java.util.Locale;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JTextField;
CHAPTER 16  Responding to Keystrokes and Mouse Clicks      437
class MoneyFrame extends JFrame implements
                                KeyListener, ItemListener, MouseListener {
    private static final long serialVersionUID = 1L;
    JLabel fromCurrencyLabel = new JLabel(" ");
    JTextField textField = new JTextField(5);
    JLabel label = new JLabel("           ");
    JComboBox<String> combo = new JComboBox<>();
    NumberFormat currencyUS = NumberFormat.getCurrencyInstance();
    NumberFormat currencyUK = NumberFormat.getCurrencyInstance(Locale.UK);
    public MoneyFrame() {
        setLayout(new FlowLayout());
        add(fromCurrencyLabel);
        add(textField);
        combo.addItem("US to UK");
        combo.addItem("UK to US");
        add(label);
        add(combo);
        textField.addKeyListener(this);
        combo.addItemListener(this);
        label.addMouseListener(this);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setSize(300, 100);
        setVisible(true);
    }
    void setTextOnLabel() {
        String amountString = "";
        String fromCurrency = "";
        try {
            double amount = Double.parseDouble(textField.getText());
            if(combo.getSelectedItem().equals("US to UK")) {
                amountString = " = " + currencyUK.format(amount * 0.61214);
                fromCurrency = "$";
            }
            if(combo.getSelectedItem().equals("UK to US")) {
                amountString = " = " + currencyUS.format(amount * 1.63361);
                fromCurrency = "\u00A3";
            }
(continued)
438      PART 4  Smart Java Techniques
        } catch (NumberFormatException e) {
        }
        label.setText(amountString);
        fromCurrencyLabel.setText(fromCurrency);
    }
    @Override
    public void keyReleased(KeyEvent k) {
        setTextOnLabel();
    }
    @Override
    public void keyPressed(KeyEvent k) {
    }
    @Override
    public void keyTyped(KeyEvent k) {
    }
    @Override
    public void itemStateChanged(ItemEvent i) {
        setTextOnLabel();
    }
    @Override
    public void mouseEntered(MouseEvent m) {
        label.setForeground(Color.red);
    }
    @Override
    public void mouseExited(MouseEvent m) {
        label.setForeground(Color.black);
    }
    @Override
    public void mouseClicked(MouseEvent m) {
    }
    @Override
    public void mousePressed(MouseEvent m) {
    }
    @Override
    public void mouseReleased(MouseEvent m) {
    }
}
LISTING 16-3: (continued)
CHAPTER 16  Responding to Keystrokes and Mouse Clicks      439
LISTING 16-4: Calling the Code in Listing 16-3
public class ShowMoneyFrame {
    public static void main(String args[]) {
        new MoneyFrame();
    }
}
Okay, so Listing 16-3 is a little long. Even so, the outline of the code in Listing 16-3 
isn’t too bad. Here’s what the outline looks like:
class MoneyFrame extends JFrame implements
                                KeyListener, ItemListener, MouseListener {
    Variable declarations
    Constructor for the MoneyFrame class
    Declaration of a method named setTextOnLabel
    Methods that are required because the class implements three interfaces
}
The constructor in Listing 16-3 adds the following four components to the new 
MoneyFrame window:
 » A label: In Figure 16-4, the label displays a dollar sign. » A text field: In Figure 16-4, the user types 54 in the text field. FIGURE 16-4: 
US-to-UK 
currency. FIGURE 16-5: 
Using the  
combo box. FIGURE 16-6: 
UK-to-US 
currency. 440      PART 4  Smart Java Techniques
 » Another label: In Figure 16-4, the label displays £33.06. » A combo box: In Figure 16-4, the combo box displays US to UK. In Figure 16-5, 
the user selects an item in the box. In Figure 16-6, the selected item is UK 
to US. In Java, a JComboBox (commonly called a drop-down list) can display items of any 
kind. In Listing 16-3, the declaration
JComboBox<String> combo = new JComboBox<>();
constructs a JComboBox whose entries have type String. That seems sensible, 
but if your application has a Person class, you can declare JComboBox<Person>  
peopleBox. In that situation, Java has to know how to display each Person object 
in the drop-down list. (It isn’t a big deal. Java finds out how to display a person by 
looking for a toString() method inside the Person class.)
The MoneyFrame implements three interfaces: the KeyListener, ItemListener, 
and MouseListener interfaces. Because it implements three interfaces, the code 
can listen for three kinds of events. I discuss the interfaces and events in the 
 following list:
 » KeyListener: A class that implements the KeyListener interface must have 
three methods named keyReleased, keyPressed, and keyTyped. When you 
lift your finger off a key, the event-handling thread calls keyReleased. In Listing 16-3, the keyReleased method calls setTextOnLabel. My set 
TextOnLabel method checks to see what’s currently selected in the combo box. If the user selects the US-to-UK option, the setTextOnLabel method converts 
dollars to pounds. If the user selects the UK-to-US option, the setTextOnLabel 
method converts pounds to dollars. In the setTextOnLabel method, I use the string "\u00A3". The funny-looking 
\u00A3 code is Java’s UK pound sign. (The u in \u00A3 stands for Unicode —  
an international standard for representing characters in the world’s alpha-
bets.) If my operating system’s settings defaulted to UK currency, in the runs of 
Java programs the pound sign would appear on its own. For information about 
all of this, check out the Locale class in ’s API documentation (https://docs. oracle.com/javase/8/docs/api/java/util/Locale.html). By the way, if you’re thinking in terms of real currency conversion, forget 
about it. This program uses rates that may or may not have been accurate 
at one time. Sure, a program can reach out on the Internet for the most 
up-to-date currency rates, but at the moment, you have other Javafish to fry. CHAPTER 16  Responding to Keystrokes and Mouse Clicks      441
 » ItemListener: A class that implements the ItemListener interface must 
have an itemStateChanged method. When you select an item in a combo 
box, the event-handling thread calls itemStateChanged. In Listing 16-3, when the user selects US-to-UK or UK-to-US in the combo box, 
the event-handling thread calls the itemStateChanged method. In turn, the 
itemStateChanged method calls setTextOnLabel, and so on. » MouseListener: A class that implements the MouseListener interface must 
have mouseEntered, mouseExited, mouseClicked, mousePressed, and 
mouseReleased methods. Implementing MouseListener is different from 
implementing ActionListener. When you implement ActionListener, as 
in Listing 16-1, the event-handling thread responds only to mouse clicks. But 
with MouseListener, the thread responds to the user pressing the mouse, 
releasing the mouse, and more. In Listing 16-3, the mouseEntered and mouseExited methods are called 
whenever you move over or away from the label. How do you know that the 
label is involved? Just look at the code in the MoneyFrame constructor. The 
label variable’s addMouseListener method is the one that’s called. Look at the mouseEntered and mouseExited methods in Listing 16-3. When 
mouseEntered or mouseExited is called, the computer forges ahead and 
calls setForeground. This setForeground method changes the color of the 
label’s text. Isn’t modern life wonderful? The Java API even has a Color class with names 
like Color.red and Color.black. Listing 16-3 has several methods that aren’t really used. For instance, when you 
implement MouseListener, your code has to have its own mouseReleased method. You need the mouseReleased method not because you’re going to do anything 
special when the user releases the mouse button, but because you made a promise 
to the Java compiler and have to keep that promise. In a previous section, you create a program that copies text from a text field to a 
label whenever the user clicks a button. Modify the program so that the user 
doesn’t have to click a button. The program automatically updates the label’s text 
whenever the user modifies the text field’s content. Creating Inner Classes
Here’s big news!

--- Chunk #799 ---
You can define a class inside of another class! For the user, 
 Listing  16-5 behaves the same way as Listing  16-1. But in Listing  16-5, the 
GameFrame class contains a class named MyActionListener. 442      PART 4  Smart Java Techniques
LISTING 16-5: A Class within a Class
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Random;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JTextField;
class GameFrame extends JFrame {
   private static final long serialVersionUID = 1L;
   int randomNumber = new Random().nextInt(10) + 1;
   int numGuesses = 0;
   JTextField textField = new JTextField(5);
   JButton button = new JButton("Guess");
   JLabel label = new JLabel(numGuesses + " guesses");
   public GameFrame() {
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      setLayout(new FlowLayout());
      add(textField);
      add(button);
      add(label);
      button.addActionListener(new MyActionListener());
      pack();
      setVisible(true);
   }
   class MyActionListener implements ActionListener {
      @Override
      public void actionPerformed(ActionEvent e) {
         String textFieldText = textField.getText();
         if (Integer.parseInt(textFieldText) == randomNumber) {
            button.setEnabled(false);
            textField.setText(textField.getText() + " Yes!");
            textField.setEnabled(false);
         } else {
            textField.setText("");
            textField.requestFocus();
         }
CHAPTER 16  Responding to Keystrokes and Mouse Clicks      443
         numGuesses++;
         String guessWord = (numGuesses == 1) ? " guess" : " guesses";
         label.setText(numGuesses + guessWord);
      }
   }
}
The MyActionListener class in Listing 16-5 is an inner class. An inner class is a lot 
like any other class. But within an inner class’s code, you can refer to the enclos-
ing class’s fields. For example, several statements inside MyActionListener use 
the name textField, and textField is defined in the enclosing GameFrame class. Notice that the code in Listing 16-5 uses the MyActionListener class only once. (The only use is in a call to button.addActionListener.) So I ask, do you really 
need a name for something that’s used only once? No, you don’t. You can substi-
tute the entire definition of the inner class inside the call to button.addAction 
Listener. When you do this, you have an anonymous inner class. Listing  16-6 
shows you how it works. LISTING 16-6: A Class with No Name (Inside a Class with a Name)
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Random;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JTextField;
class GameFrame extends JFrame {
   private static final long serialVersionUID = 1L;
   int randomNumber = new Random().nextInt(10) + 1;
   int numGuesses = 0;
   JTextField textField = new JTextField(5);
   JButton button = new JButton("Guess");
   JLabel label = new JLabel(numGuesses + " guesses");
   public GameFrame() {
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      setLayout(new FlowLayout());
(continued)
444      PART 4  Smart Java Techniques
      add(textField);
      add(button);
      add(label);
      button.addActionListener(new ActionListener() {
         @Override
         public void actionPerformed(ActionEvent e) {
            String textFieldText = textField.getText();
            if (Integer.parseInt(textFieldText) == randomNumber) {
               button.setEnabled(false);
               textField.setText(textField.getText() + " Yes!");
               textField.setEnabled(false);
            } else {
               textField.setText("");
               textField.requestFocus();
            }
            numGuesses++;
            String guessWord = (numGuesses == 1) ? " guess" : " guesses";
            label.setText(numGuesses + guessWord);
         }
      });
      pack();
      setVisible(true);
   }
}
Inner classes are good for things like event handlers, such as the action 
Performed method in this chapter’s examples. The most difficult thing about an 
anonymous inner class is keeping track of the parentheses, the curly braces, and 
the indentation. My humble advice is, start by writing code without any inner 
classes, as in the code from Listing 16-1. Later, when you become bored with ordi-
nary Java classes, experiment by changing some of your ordinary classes into 
inner classes. In a previous section, you create a program that copies text from a text field to a 
label whenever the user clicks a button. Modify the code so that it has an inner 
class.

--- Chunk #800 ---
Then if you’re really ambitious, modify the code so that it has an anony-
mous inner class. LISTING 16-6: (continued)
CHAPTER 17  Using Java Database Connectivity      445
IN THIS CHAPTER
 » Connecting to a database
 » Inserting values into a database
 » Making queries to a database
Using Java Database 
Connectivity
W
henever I teach Java to professional programmers, I always hear the 
same old thing: “We don’t need to make attractive-looking layouts. No 
glitzy GUIs for us. We need to access databases. Yup, just [shut up and] 
show us how to write Java programs that talk to databases.”
So here it is, folks — the real deal! The Java Database Connectivity * (JDBC) classes provide common access to most 
database management systems. Just get a driver for your favorite vendor’s sys -
tem, customize one line of code in each of this chapter’s examples, and you’re 
ready to go. Chapter 17
*Apparently, there’s no evidence in any of Oracle’s literature that the acronym 
JDBC actually stands for Java Database Connectivity. But that’s okay. If Java Database 
Connectivity isn’t the correct terminology, it’s close enough. In the Java world, 
JDBC certainly doesn’t stand for John Digests Bleu Cheese. 446      PART 4  Smart Java Techniques
Creating a Database and a Table
The crux of JDBC is contained in two packages: java.sql and javax.sql, which 
are both in the Java API. This chapter’s examples use the classes in java.sql. The 
first example is shown in Listing 17-1. LISTING 17-1: Creating a Database and a Table
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
public class CreateTable {
  public static void main(String args[]) {
    final String CONNECTION = "jdbc:derby:AccountDatabase;create=true";
    try (Connection conn = DriverManager.getConnection(CONNECTION);
         Statement statement = conn.createStatement()) {
      statement.executeUpdate("create table ACCOUNTS                     " +
                              "  (NAME VARCHAR(32) NOT NULL PRIMARY KEY, " +
                              "   ADDRESS VARCHAR(32),                   " +
                              "   BALANCE FLOAT                         )");
      System.out.println("ACCOUNTS table created.");
    } catch (SQLException e) {
      e.printStackTrace();
    }
  }
}
Running the examples in this chapter is a bit trickier than running other chapters’ 
examples. To talk to a database, you need an intermediary piece of software known 
as a database driver. Database drivers come in all shapes and sizes, and many of 
them are quite expensive. But Listing 17-1 points to a small, freebie driver: the 
Derby JDBC driver. The code for the Derby JDBC driver is kept in the Embedded 
Driver class (which is a Java class). This class lives inside the org.apache.derby. jdbc package. When you install Java 9, you don’t get this org.apache.derby.jdbc package. You 
need a separate file named derby.jar, which you can download from http://
db.apache.org/derby/derby_downloads.html. CHAPTER 17  Using Java Database Connectivity      447
Even after you’ve downloaded a copy of derby.jar, your IDE might not know 
where you’ve put the file on your computer’s hard drive. It’s usually not enough 
to put derby.jar in a well-known directory. Instead, you have to tell Eclipse, 
IntelliJ IDEA, or NetBeans exactly where to find your derby.jar file. Here’s what 
you do:
 » Eclipse: Select Project ➪   Properties. In the resulting dialog box, select Java 
Build Path, and then select the Libraries tab. Click the Add External JARs 
button, and then navigate to the derby.jar file on your computer’s 
hard drive. » IntelliJ IDEA: Select File ➪   Project Structure. In the resulting dialog box, select 
Libraries. Click the plus sign (+) icon and, in the resulting drop-down box, 
select Java. Navigate to the derby.jar file on your computer’s hard drive. » NetBeans: Select File ➪   Project Properties. In the resulting dialog box, select 
Libraries and then select the Run tab. Click the Add JAR/Folder button, and 
navigate to the derby.jar file on your computer’s hard drive. What happens when you run the code
During a successful run of the code in Listing 17-1, you see an ACCOUNTS table 
created message. That’s about it. The code has no other visible output because 
most of the output goes to a database. If you poke around a bit, you can find direct evidence of the new database’s exis-
tence. Using your computer’s File Explorer or Finder, you can navigate to the 
project folder containing the code in Listing 17-1. (If you’ve downloaded the code 
from this book’s website, look in your IDE’s 17-01 project folder.) Inside that 
folder, you’ll see a brand-new AccountDatabase subfolder. That’s where the newly 
created database lives. Unfortunately, you can’t see what’s inside the database unless you run a couple 
more programs. Read on! Using SQL commands
In Listing  17-1, the heart of the code lies in the call to executeUpdate. The 
executeUpdate call contains a string — a normal, Java, double-quoted string of 
characters. To keep the code readable, I’ve chopped the string into four parts, and 
separate the parts with plus signs (Java’s string concatenation operator). 448      PART 4  Smart Java Techniques
If you’re familiar with Structured Query Language, or SQL, the command strings 
in the calls to executeUpdate make sense to you. If not, pick up a copy of SQL For 
Dummies, 8th Edition, by Allen G.

--- Chunk #801 ---
Taylor (Wiley). One way or another, don’t go 
fishing around this chapter for an explanation of the create table command. You won’t find an explanation, because the big create table string in Listing 17-1 
isn’t part of Java. This command is just a string of characters that you feed to 
Java’s executeUpdate method. This string, which is written in SQL, creates a new 
database table with three columns (columns for a customer’s NAME, the custom-
er’s ADDRESS, and the account’s BALANCE). When you write a Java database pro-
gram, that’s what you do. You write ordinary SQL commands and surround those 
commands with calls to Java methods. WHOSE DATABASE IS IT ANYWAY? Databases come in many shapes and sizes from many different vendors. In 2017, the 
top database vendors include Oracle, Microsoft, IBM, and SAP. Some popular open-
source databases include PostgreSQL and Oracle’s MySQL. The code in Listing 17-1 (and 
this chapter’s other listings) uses an open-source database from The Apache Software 
Foundation known as Apache Derby. If you don’t want to use Apache Derby, you have to replace the CONNECTION string in 
this chapter’s examples. What other string you use depends on the kind of database 
software you have, and on other factors. Check your database vendor’s documentation. By the way, database drivers are like people: some are quite old and others aren’t so 
old. As of January 2017, the latest version of JDBC is version 4.2. A "quite old" JDBC 
database driver is one that was created for a version of JDBC before Version 4.0 (circa 
December 2006). If your database driver doesn’t meet the JDBC 4.0 standards, you have 
to add a few extra statements to each of this chapter’s examples, as follows:
final public String DRIVER = "com.databasevendorname.databasebrandname.maybe
otherstuff";
try {
  Class.forName(DRIVER).newInstance();
} catch (InstantiationException |
         IllegalAccessException |
         ClassNotFoundException e) {
  e.printStackTrace();
}
Again, check your database vendor’s documentation. CHAPTER 17  Using Java Database Connectivity      449
Connecting and disconnecting
Aside from the call to the executeUpdate method, the code in Listing  17-1 is 
copy-and-paste stuff. Here’s a rundown on what each part of the code means:
 » DriverManager.getConnection: Establish a session with a particular  
database. The getConnection method lives in a Java class named DriverManager. In 
Listing 17-1, the call to getConnection creates an AccountDatabase and 
opens a connection to that database. Of course, you may already have an 
AccountDatabase before you start running the code in Listing 17-1. If you do, 
the text ;create=true in the CONNECTION string has no effect. In the CONNECTION string, notice the colons. The code doesn’t simply name 
the AccountDatabase — it tells the DriverManager class what protocols to 
use to connect with the database. The code jdbc:derby: — which is a lot 
like the http: in a web address — tells the computer to use the jdbc protocol 
to talk to the derby protocol, which in turn talks directly to your Account 
Database. » conn.createStatement: Make a statement. It seems strange, but in Java Database Connectivity, you create a single 
statement object. After you’ve created a statement object, you can use that 
object many times, with many different SQL strings, to issue many different 
commands to the database. So, before you start calling the statement. executeUpdate method, you have to create an actual statement object. The 
call to conn.createStatement creates that statement object for you. » try-with-resources: Release resources, come what may! As Ritter always says, you’re not being considerate of others if you don’t clean 
up your own messes. Every connection and every database statement lock up 
some system resources. When you’re finished using these resources, you 
release them. In Listing 17-1, Java’s try-with-resources block automatically closes and 
releases your resources at the end of the block’s execution. In addition, 
try-with-resources takes care of all the messy details associated with failed 
attempts to catch exceptions gracefully. For the scoop about try-with-resources, see Chapter 13. 450      PART 4  Smart Java Techniques
Putting Data in the Table
Like any other tabular configuration, a database table has columns and rows. When you run the code in Listing 17-1, you get an empty table. The table has three 
columns (NAME, ADDRESS, and BALANCE) but no rows. To add rows to the table, run 
the code in Listing 17-2. LISTING 17-2: Inserting Data
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
public class AddData {
  public static void main(String args[]) {
    final String CONNECTION = "jdbc:derby:AccountDatabase";
    try (Connection conn = DriverManager.getConnection(CONNECTION);
         Statement statement = conn.createStatement()) {
      statement.executeUpdate("insert into ACCOUNTS values               " +
                              "  ('Barry Burd', '222 Cyber Lane', 24.02) ");
      statement.executeUpdate("insert into ACCOUNTS values               " +
                              "  ('Joe Dow', '111 Luddite Street', 55.63)");
      System.out.println("Rows added.");
    } catch (SQLException e) {
      e.printStackTrace();
    }
  }
}
Listing 17-2 uses the same strategy as the code in Listing 17-1: Create Java strings 
containing SQL commands, and make those strings be arguments to Java’s 
executeUpdate method. In Listing 17-2, I put two rows in the ACCOUNTS table — 
one for me and another for Joe Dow. (Joe, I hope you appreciate this.)
CHAPTER 17  Using Java Database Connectivity      451
For the best results, put all this chapter’s listings in the same project. That 
way, you don’t have to add the derby.jar file to more than one project. You can 
also count on the AccountDatabase  folder being readily available to all four of 
this   chapter’s code listings. If you download this book’s examples for Eclipse, 
IntelliJ IDEA, or NetBeans, you’ll find all the code from this chapter in the project 
named 17-01. Retrieving Data
What good is a database if you can’t get data from it? In this section, you query the 
database that you created in the previous sections. The code to issue the query is 
shown in Listing 17-3. LISTING 17-3: Making a Query
import static java.lang.System.out;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.NumberFormat;
public class GetData {
  public static void main(String args[]) {
    NumberFormat currency = NumberFormat.getCurrencyInstance();
    final String CONNECTION = "jdbc:derby:AccountDatabase";
    try (Connection conn = DriverManager.getConnection(CONNECTION);
         Statement statement = conn.createStatement();
         ResultSet resultset = statement.executeQuery("select * from ACCOUNTS"))
    {
      while (resultset.next()) {
        out.print(resultset.getString("NAME"));
        out.print(", ");
        out.print(resultset.getString("ADDRESS"));
        out.print(" ");
        out.println(currency.format(resultset.getFloat("BALANCE")));
      }
(continued)
452      PART 4  Smart Java Techniques
    } catch (SQLException e) {
      e.printStackTrace();
    }
  }
}
To use a database other than Apache Derby, change the value of CONNECTION in 
each of this chapter’s examples. A run of the code from Listing 17-3 is shown in Figure 17-1.

--- Chunk #802 ---
The code queries the 
database and then steps through the rows of the database, printing the data from 
each of the rows. Listing 17-3 calls executeQuery and supplies the call with an SQL command. For 
those who know SQL commands, this particular command gets all data from the 
ACCOUNTS table (the table that you create in Listing 17-1). The thing returned from calling executeQuery is of type java.sql.ResultSet. (That’s one of the differences between the executeUpdate and executeQuery 
methods: executeQuery returns a result set, and executeUpdate doesn’t.) A result 
set is much like a database table. Like the original table, the result set has rows and 
columns. Each row contains the data for one account. In this example, each row 
has a name, an address, and a balance amount. After you call executeQuery and get your result set, you can step through the 
result set one row at a time. To do this, you go into a little loop and test the condi-
tion resultset.next() at the top of each loop iteration. Each time around, the 
call to resultset.next() does two things:
 » It moves you to the next row of the result set (the next account) if another 
row exists. » It tells you whether another row exists by returning a boolean value — true 
or false. If the condition resultset.next() is true, the result set has another row. The 
computer moves to that other row, so you can march into the body of the loop and 
scoop data from that row. On the other hand, if resultset.next() is false, the 
LISTING 17-3: (continued)
FIGURE 17-1: 
Getting data from 
the database. CHAPTER 17  Using Java Database Connectivity      453
result set doesn’t have any more rows. You jump out of the loop and start closing 
everything. Now, imagine that the computer is pointing to a row of the result set, and you’re 
inside the loop in Listing 17-3. Then you’re retrieving data from the result set’s 
row by calling the result set’s getString and getFloat methods. Back in 
 Listing 17-1, you set up the ACCOUNTS table with the columns NAME, ADDRESS, and 
BALANCE. Here in Listing 17-3, you’re getting data from these columns by calling 
your getSomeTypeOrOther methods and feeding the original column names to 
these methods. After you have the data, you display the data on the computer 
screen. Each Java ResultSet instance has several nice getSomeTypeOrOther methods. Depending on the type of data you put into a column, you can call methods get 
Array, getBigDecimal, getBlob, getInt, getObject, getTimestamp, and several 
others. Destroying Data
It’s true.

--- Chunk #803 ---
All good things must come to an end. By writing this, I’m referring both 
to this book’s content and to the information in this chapter’s AccountDatabase. To get rid of the database table that you create in Listing 17-1, run the code in 
Listing 17-4. LISTING 17-4: Arrivederci, Database Table
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
public class DropTable {
  public static void main(String[] args) {
    final String CONNECTION = "jdbc:derby:AccountDatabase";
    try (Connection conn = DriverManager.getConnection(CONNECTION);
         Statement statement = conn.createStatement()) {
      statement.executeUpdate("drop table ACCOUNTS");
(continued)
454      PART 4  Smart Java Techniques
      System.out.println("ACCOUNTS table dropped.");
    } catch (SQLException e) {
      e.printStackTrace();
    }
  }
}
When you run this code, you wipe the slate clean. Your AccountDatabase no lon-
ger contains an ACCOUNTS table. So, if you want to run Listing 17-1 again (perhaps 
with a change or two), you can. Who knows? You may even create a table to store your favorite Java For Dummies  
jokes. Naturally, I have some things for you to try:
 » Rerun the code in Listing 17-3. This time, use the following string in the 
executeQuery call:
"select * from ACCOUNTS where BALANCE > 30"
 » Run the AddData program (from Listing 17-2) two times in a row without 
modifying any of the program’s code. What error messages do you see?

--- Chunk #804 ---
Why? » Create a table containing three columns: an item name, a price, and a tax rate. Store data in several rows of the table. Retrieve the data from the table and display a row of output for each row in 
the table. Each row of output contains the item name followed by the price 
with tax added. For example, if an item’s price is $10 and the item’s tax rate is 
0.05 (meaning 5 percent), the item’s output row contains the number $10.50. On the last line of the program’s output, display the total of all items’ tax-
added prices. LISTING 17-4: (continued)
5
The Part of Tens
IN THIS PART . .

--- Chunk #805 ---
. Catch common mistakes before you make them. Explore the best resources for Java on the web. CHAPTER 18  Ten Ways to Avoid Mistakes      457
IN THIS CHAPTER
 » Checking your capitalization and 
value comparisons
 » Watching out for fall-through
 » Putting methods, listeners, and 
constructors where they belong
 » Using static and non-static references
 » Avoiding other heinous errors
Ten Ways to Avoid 
Mistakes
“
T
he only people who never make mistakes are the people who never do 
 anything at all.” One of my college professors said that. I don’t remember 
the professor’s name, so I can’t give him proper credit.

--- Chunk #806 ---
I guess that’s 
my mistake. Putting Capital Letters Where They Belong
Java is a case-sensitive language, so you really have to mind your p’s and q’s — 
along with every other letter of the alphabet. Here are some details to keep in 
mind as you create Java programs:
 » Java’s keywords are all completely lowercase. For instance, in a Java if 
statement, the word if can’t be If or IF. » When you use names from the Java API (Application Programming Interface), 
the case of the names has to match what appears in the API. Chapter 18
458      PART 5  The Part of Tens
 » You also need to make sure that the names you make up yourself are 
capitalized the same way throughout your entire program. If you declare 
a myAccount variable, you can’t refer to it as MyAccount, myaccount, or 
Myaccount. If you capitalize the variable name two different ways, Java 
thinks you’re referring to two completely different variables. For more info on Java’s case-sensitivity, see Chapter 3. Breaking Out of a switch Statement
If you don’t break out of a switch statement, you get fall-through. For instance, 
if the value of verse is 3, the following code prints all three lines — Last refrain, 
He's a pain, and Has no brain:
switch (verse) {
case 3:
    out.print("Last refrain, ");
    out.println("last refrain,");
case 2:
    out.print("He's a pain, ");
    out.println("he's a pain,");
case 1:
    out.print("Has no brain, ");
    out.println("has no brain,");
}
For the full story, see Chapter 5. Comparing Values with a Double  
Equal Sign
When you compare two values with one another, you use a double equal sign. The line
if (inputNumber == randomNumber)
CHAPTER 18  Ten Ways to Avoid Mistakes      459
is correct, but the line
if (inputNumber = randomNumber)
is not correct.

--- Chunk #807 ---
For a full report, see Chapter 5. Adding Components to a GUI
Here’s a constructor for a Java frame:
public SimpleFrame() {
    JButton button = new JButton("Thank you...");
    setTitle("...Katie Mohr and Paul Levesque");
    setLayout(new FlowLayout());
    add(button);
    button.addActionListener(this);
    setSize(300, 100);
    setVisible(true);
}
Whatever you do, don’t forget the call to the add method. Without this call, you go 
to all the work of creating a button, but the button doesn’t show up on your frame. For an introduction to such issues, see Chapter 9. Adding Listeners to Handle Events
Look again at the previous section’s code to construct a SimpleFrame. If you forget 
the call to addActionListener, nothing happens when you click the button. Click-
ing the button harder a second time doesn’t help. For the rundown on listeners, 
see Chapter 16. Defining the Required Constructors
When you define a constructor with parameters, as in
public Temperature(double number)
460      PART 5  The Part of Tens
then the computer no longer creates a default parameterless constructor for you. In other words, you can no longer call
Temperature roomTemp = new Temperature();
unless you explicitly define your own parameterless Temperature constructor. For 
all the gory details on constructors, see Chapter 9. Fixing Non-Static References
If you try to compile the following code, you get an error message:
class WillNotWork {
    String greeting = "Hello";
    public static void main(String args[]) {
        System.out.println(greeting);
    }
}
You get an error message because main is static, but greeting isn’t static. For the 
complete guide to finding and fixing this problem, see Chapter 10. Staying within Bounds in an Array
When you declare an array with ten components, the components have indices 
0 through 9. In other words, if you declare
int guests[] = new int[10];
then you can refer to the guests array’s components by writing guests[0], 
guests[1], and so on, all the way up to guests[9]. You can’t write guests[10], 
because the guests array has no component with index 10. For the latest gossip on arrays, see Chapter 11. CHAPTER 18  Ten Ways to Avoid Mistakes      461
Anticipating Null Pointers
This book’s examples aren’t prone to throwing the NullPointerException, but in 
real-life Java programming, you see that exception all the time. A NullPointer 
Exception comes about when you call a method that’s supposed to return an 
object, but instead the method returns nothing. Here’s a cheap example:
import static java.lang.System.out;
import java.io.File;
class ListMyFiles {
    public static void main(String args[]) {
        File myFile = new File("/Users");
        String dir[] = myFile.list();
        for (String fileName : dir) {
            out.println(fileName);
        }
    }
}
This program displays a list of all files in the Users directory. But what happens if you change /Users to something else  — something that 
doesn’t represent the name of a directory? File myFile = new File("&*%$!!");
Then the new File call returns null (a special Java word meaning nothing), so the 
variable myFile has nothing in it. Later in the code, the variable dir refers 
to nothing, and the attempt to loop through all the dir values fails miserably. You  get a big NullPointerException, and the program comes crashing down 
around you. To avoid this kind of calamity, check Java’s API documentation. If you’re calling a 
method that can return null, add exception-handling code to your program. For the story on handling exceptions, see Chapter 13. For some advice on reading 
the API documentation, see Chapter 3 and this book’s website ( www.allmycode. com/JavaForDummies). 462      PART 5  The Part of Tens
Helping Java Find Its Files
You’re compiling Java code, minding your own business, when the computer 
gives you a NoClassDefFoundError. All kinds of things can be going wrong, but 
chances are good that the computer can’t find a particular Java file. To fix this, you 
must align all the planets correctly:
 » Your project directory has to contain all the Java files whose names are used 
in your code. » If you use named packages, your project directory has to have appropriately 
named subdirectories. » If you’re running code from your computer’s command line, your CLASSPATH 
environment variable must be set properly. For specific guidelines, see Chapter 14 and this book’s website ( www.allmycode.

--- Chunk #808 ---
com/JavaForDummies). CHAPTER 19  Ten Websites for Java      463
IN THIS CHAPTER
 » Checking out this book’s website
 » Finding resources from Oracle
 » Reading more about Java
Ten Websites for Java
N
o wonder the web is popular: It’s both useful and fun. This chapter proves 
that fact by listing ten useful and fun websites. Each website has resources 
to help you use Java more effectively. And as far as I know, none of these 
sites uses adware, pop-ups, or other grotesque things. This Book’s Website
For all matters related to the technical content of this book, visit www.allmycode. com/JavaForDummies. For business issues (for example, “How can I purchase 100 more copies of Java For 
Dummies?”), visit www.dummies.com. The Horse’s Mouth
The official Oracle website for Java is www.oracle.com/technetwork/java. Check the official Java API documentation at http://docs.oracle.com/javase/8/
docs/api. Chapter 19
464      PART 5  The Part of Tens
Consumers of Java technology should visit www.java.com. Programmers and developers interested in sharing Java technology can go to 
https://community.oracle.com/community/java. Finding News, Reviews, and Sample Code
For articles by the experts, visit InfoQ at www.infoq.com and TheServerSide at 
www.theserverside.com. You always find good reading at these two sites. Got a Technical Question? If you’re stuck and need help, search for answers and post questions at Stack 
Overflow (stackoverflow.com). You can also post questions on the Beginning Java Forum at JavaRanch where the 
forum’s motto is “No question too simple or small . . .” (coderanch.com/f/33/
java). And don’t forget. If you have questions about anything you read in this book, 
send email to me at JavaForDummies@allmycode.com, post a question on www. facebook.com/allmycode, or tweet to the Burd with @allmycode. Index      465
Index
Special Characters
- - (double minus signs), 98, 100
- (minus sign), 94
! (not) logical operator, 121
!= (is not equal to) operator, 117
% (percent sign), 94, 204
&& (and) logical operator, 121
* (asterisk), 94, 121
/ (slash), 94
\ (backslash), 211, 318
\\ (double backslashes), 299
\b (backspace) escape sequence, 299
\f (form feed) escape sequence, 299
\n (line feed) escape sequence, 299
\r (carriage return) escape sequence, 299
\t (horizontal tab) escape sequence, 299
{} (curly braces), 112–113
|| (or) logical operator, 121, 126
+ (plus sign), 93–94
++ (double plus signs), 98–100
< (is less than) operator, 117
<= (is less than or equal to) operator, 117
< > (diamond) operator, 327
== (double equal sign), 112, 458–459
== (is equal to) operator, 117
> (is greater than) operator, 117
>= (is greater than or equal to) operator, 117
\ " (double quote) escape sequence, 299
\ ' (single quote) escape sequence, 299
A
abstract classes. See also classes
defined, 418
overview, 417–418
using, 422–424
using or not using abstract methods, 425–426
AbstractCollection, 332
abstract keyword, 419
abstract method, 412, 417, 425–426
access modifiers
classes, 385–386
default access, 384, 396–398
defined, 384
directory structure, 391–392
frame making, 392–393
members, 385–388
nonpublic classes, 406–407
original code, 394–396
overview, 384–395
package declaration, 390
public class, 391, 406
accessor methods.

--- Chunk #809 ---
See also methods
calling, 186
enforcing rules with, 190
making fields private, 188–189
simplicity, 186–187
Account class, 328
AccountDatabase folder, 447, 451
accumulator, 147
ActionListener class, 441
actionPerformed method
ActionListerer interface, 430–434
GUI interface, 436
overview, 434
addActionListener method, 432, 459
AddData program, 453–454
add method
adding components to GUI, 459
ArrayList object, 325
collection classes, 323
SimpleFrame object, 254
addMouseListener method, 441
and (&&) logical operator, 121
Android devices, 15
angle brackets (< >), 327
466      Java For Dummies
annotation, Java
@Override annotation, 414
overview, 226
SuppressWarnings annotation, 254–255, 435
anonymous inner class, 443–444
Apache Derby, 448
Apache Software Foundation, 448
application programming interface (API)
documentation for parse Int method, 355
identifiers from, 46–47
overview, 44–45
args array, 318–319
arguments, command line
checking for right number of, 319–320
defined, 316
overview, 315–317
using in programs, 317–318
ArithmeticException class, 374, 378–379
arithmetic operators, 93–94
array elements, 294–295
ArrayIndexOutOfBoundsException, 319, 322
ArrayList collection class, 323–325, 328, 332, 409
arrays
avoiding errors, 460
boundaries, 460
closing files, 306–307
component of, 294–295
creating, 296
defined, 294
enhanced for loop, 300–302
escape sequence, 299
initializer, 299–300
limitations of, 321–322
overview, 293–294
searching, 302–304
storing values, 297–298
writing to file, 305
arrays of objects
conditional operator, 313–315
NumberFormat class, 312–313
overview, 307–308
Room class, 309–310
ASCII character encoding, 85
assignment operators, 102–104
assignment statements, 70
asterisk (*), 94, 121
AT&T Bell Labs, 14
autoboxing, 329–330
B
backslash characters
double backslashes, 299
escape sequence, 299
in Java, 211, 318
backspace (\b) escape sequence, 299
Backus, John, 333
Beginning Java Forum, 464
BigDecimal class, 181
BigDecimal type, 74, 313
BinaryOperator lambda expression,  
342, 345
bits
ASCII character encoding, 85
defined, 71
interpretation as screen pixels, 71
Unicode, 85
blocks
defined, 97, 113
do statements, 154–155
JShell, 116–117
static initializer, 271
Blu-Ray devices, 15
Boldyshev, Konstantin, 33
boolean type, 83, 85–87
Boolean wrapper class, 328
break statements, 136–137
Bright, Herbert, 351
building blocks
application programming interface, 44–45
classes, 49–50
comments, 60–64
curly braces, 55–58
identifiers, 45–47
keywords, 45–47
methods, 50–53
specifications, 44
statements, 53–55
button, 436
bytecode, 29, 32, 35–36
Index      467
byte primitive type, 83
Byte wrapper class, 328
C
C# programming language, 15
C++ programming language, 14, 17–18, 326
calls
close , 306
printf , 204, 241–242
setMax, 271
setMin, 271
showMessageDialog, 125
System.out.println, 54–55, 84, 94, 104, 110, 305
cannot resolve symbol message, 282
capitalization, 457–458
carriage return (\r) escape sequence, 299
catch clause, 354, 359, 361–365, 373, 378
catch clause parameter, 356–357
Character.toUpperCase method, 84
character type, 83
Character wrapper class, 328
char type, 83–85
checked exceptions, 371, 374
child classes, 20, 217–218
Church, Alonzo, 339
classes
abstract
defined, 418
overview, 417–418
using, 422–424
using or not using abstract methods, 425–426
access modifiers, 385–386
child, 217–218
collection classes
AbstractCollection, 332
ArrayList, 332
HashMap, 332
HashSet, 332
LinkedList, 332
PriorityQueue, 332
Queue, 332
Stack, 332
creating objects, 164–167
defined, 18–19, 162–164
defining, 198–204, 260–261
defining method within, 169–173
free-form, 180
fully qualified name, 252, 403
inner, 408, 441–444
interface and, 410
members, 385
objects and, 18–19, 21–23
overview, 49–50
parameters
pass by reference, 287–289
pass by value, 285–287
returning object from method, 289–292
returning value from method, 287
parent, 217–218
programs and, 168
protected access, 402–403
public, 168–169
subclasses
constructors for, 245–246
creating, 216–219
overview, 214–215
protected access, 400–402
using, 219–224
using methods from, 226–229
superclass, 20
using methods from, 226–229
using object field, 167
variables
declaring, 164–167
initializing, 167
wrapper, 328–330
CLASSPATH environment variable, 462
class variables, 279
clauses
catch, 354, 359, 361–365, 373, 378
finally, 376–379
throw, 354
throws, 266, 354, 373–374
throws IOException, 207, 209
try, 354, 359, 364
close call, 306
COBOL programming language, 14
code name, 37
468      Java For Dummies
codes. See also software
abstract classes, 420–422
access modifiers, 386–387
Account class, 195–196
Account objects, 165
account that calculate its own interest, 174–175
account that displays itself, 171–172
adding comments to, 60–62
amountinAccount, 71–72
anonymous inner class, 443–444
ArtFrame class, 392–393
assignment operators, 103
checking out for first time, 47–48
class within class, 441–442
class with no name, 443–444
closing resources, 380–381
command line arguments, 317–318
counting boxes, 352–356
creating database and table, 446
default constructor, 248–249
defined, 12
defining frame, 251
destroying data, 453–454
displaying frame, 251, 262–263, 389
Drawing class, 390
drawing wider oval, 402–403
DummiesFrame, 191–193
employees, 199
exception handling, 359–360
fake code, 217–218
filling arrays with values, 298
FullTimeEmployee, 216
functional programming, 346
Guessing Game, 106, 114, 428–429
Hero Counts Boxes, 355
hiding fields, 186
incorrect program, 369
indenting if statements in, 113–114
interfaces, 415
int type, 75–76
InventoryLoop, 367–368
iterating through collection, 330–331
Java Collection, 323–324
local currency, 436–439
Looking for Vacant Room, 30
for loop, 144
MakeChange, 87
making numbers right, 181
making query, 451–453
nested if statements, 128
PartTimeEmployee, 219
password checking, 119–120
Pentium processor, 33
Player class, 260, 262
PowerPC processor, 34
protected fields, 400–401
reference types, 87
repeating guessing game, 140–141
reusing existing
classes, 198–204
disk files, 205–214
overriding existing methods, 224–228
subclasses, 214–224
Room class, 309–310
Sale class, 336–337
simple calculator, 194
simplest program, 48
storing Integer values in ArrayList, 329
subclasses, 401
subclass of Drawing class, 395
switch statements, 132–133
switch statement with fall-through, 135
Team Batting Average, 269
Temperature class, 234–237
TemperatureNice class, 243–244, 246–247
thinking of a number, 194–195
this keyword, 433–434
username and password checking, 122
using comments to experiment with, 63–64
using subclasses, 220–221
using two files, 379–380
writing payroll checks, 200
coding
arithmetic operators, 93–94
ASCII character encoding, 85
assignment operators, 102–104
assignment statements, 70
asterisk (*), 94, 121
bits
ASCII character encoding, 85
defined, 71
Unicode, 85
Index      469
blocks
defined, 97, 113
do statements, 154–155
JShell, 116–117
static initializer, 271
boolean type, 83, 85–87
break statements, 136–137
calls
close , 306
printf , 204, 241–242
setMax, 271
setMin, 271
showMessageDialog, 125
System.out.println, 54–55, 84, 94, 104,  
110, 305
char type, 83–85
comparison operators, 117–121
conditions, 111–112, 125–127
counting loops, 144–145
curly braces ({})
C programming language, 14
if statements, 112–113
overview, 55–59
decimal number types, 83
decimal point, 73–74
declarations
combining, 77–78
import , 91–93, 96, 115, 252
mess, 327
method, 52
package, 390
scan1, 381
scan2, 381
variables, 72, 77–78, 154–155
decrement operators, 98–102
do statements
blocks, 154–155
file handling, 154–156
overview, 150–152
reading single character, 154
variable declarations, 154–155
double equal sign (==), 112, 458–459
double minus signs (- -), 98, 100
double plus signs (++), 98–100
double primitive type, 83
double type, 72, 83
else part, if statements, 114–115
expressions
vs. conditions, 112
lambda, 339–347
fall-throughs, 134–136
false value, 87, 308
float type, 72–74, 83, 309
frames
defined, 91
defining, 251
displaying, 251, 262–263, 389
making, 392–394
putting drawing on, 389–390
graphical user interface (GUI), 190–193
adding components to, 459
avoiding errors, 459
if statements
conditions, 111–112
curly braces, 112–113
else part, 114–115
indenting, 113–114
nesting, 127–129
overview, 106–110
randomness, 110–111
import declaration
if statements, 115
overview, 91–93
packages and, 252
static, 96
increment operators, 98–102
indenting, if statements, 113–114
int primitive type, 83
int type, 83
int value, 311, 318–319
JFrame reference type, 88–89
keyboard.next method, 120, 123, 154
logical operators, 121–124
logical types, 83
long primitive type, 83
loops
counting, 144–145
do statements, 150–152, 154–156
overview, 140
range-of-values, 301
for statements, 143–146
while loop, 141
470      Java For Dummies
coding (continued)
method calls, 51
minus (-) sign, 94
not (!) logical operator, 121
null values, 124–125
numbers
comparing, 117–118
making numbers right, 181
whole, 77
without decimal points, 75–77
operators
arithmetic, 93–94
assigning, 97
asterisk (*), 94
comparison, 117–121
conditional, 313–315
decrement, 98–102
increment, 98–102
logical, 121–124
postdecrement, 100
postincrement, 99–100
predecrement, 100
preincrement, 98–99
remainder, 94–95
slash (/), 94
parentheses
conditions in parentheses, 125–127
expression in, 145
initialization in, 145
methods in, 172–173
update in, 145
postdecrement operators, 100
postincrement operators, 99–100
primitive (simple) types
boolean type, 85–87
byte type, 83
double type, 72, 83
float type, 72–74, 83
int type, 83
overview, 82–83, 409
short type, 83
wrapper class, 328
repeating statements
do statements, 150–152, 154–156
overview, 140
range-of-values, 301
for statements, 143–146
while loop, 141
reply variable, 156
short primitive type, 83
single character, reading, 154
slash (/), 94
statements
for , 143–146
assignment, 70
break, 136–137
comparison operators and, 117–121
do, 144, 150–157
expressions and, 101
for, 143–150
i++ statement, 366–367
if, 106–115, 127–129
logical operators, 121–124
null values, 124–125
overview, 53–55
return, 178–179
switch , 130–137, 238, 458
try, 356, 379–381
try-catch statement, 356, 367–369, 372, 374–375
try-with-resources, 449
while, 141
static keyword, 267–270, 273–274
switch statements
avoiding errors, 458
breaking out of, 458
enum types and, 238
fall-throughs, 134–136
overview, 130–134
strings in, 136–137
System.in, 108, 115
System.out.println call, 54–55, 84, 94, 104, 110, 
305
text, displaying, 73–74
types, value, 71–74
values
defined, 69
types of, 71–74
variables
assignment statements, 70
class, 279
combining declarations, 77–78
Index      471
declaring, 164–167
defined, 68
displaying text, 73–74
functional programming, 349
import declaration, 91–93
initializing, 77–78, 167
instance, 163, 279
method-local, 279–280
numbers without decimal points, 75–77
operators, 93–104
void, 412
while statements, 141
whole number types, 83
collection classes
AbstractCollection, 332
ArrayList, 323–325, 332
generics, 325–327
HashMap, 332
HashSet, 332
iterator, 330–331
LinkedList, 332
overview, 323
PriorityQueue, 332
Queue, 332
Stack, 332
testing for more data, 330
wrapper classes, 328–330
Color class, 441
ColumnOfNumbers class, 416
combo box, 440
command d, 333
command i, 333
command line arguments
checking for right number of, 319–320
defined, 316
overview, 315–317
using in programs, 317–318
command prompt window, 316
command r, 333
comments
adding to code, 60–62
defined, 60
end-of-line, 61
javadoc, 61–62
overview, 59
traditional, 61
using to experiment with code, 63–64
comparetoIgnoreCase method, 332
compareTo method, 328
comparison operators
comparing characters, 117–121
comparing numbers, 117–118
comparing objects, 118–121
importing with, 121
is equal to (==) operator, 117
is greater than (>) operator, 117
is greater than or equal to (>) operator, 117
is less than (< ) operator, 117
is less than or equal to (<) operator, 117
is not equal to (!=) operator, 117
compiler
defined, 28–29
overview, 30–32
computer, tools to install on, 28–36
computer bug, 351
Computer Folklore newsgroup, 352
Computer magazine, 352
computer programming language
C, 14
C#, 15
C++, 14, 17–18, 326
COBOL, 14
defined, 12
FORTRAN, 14
Fortran, 17
history of, 14–15
Java, 14–15, 18
object-oriented, 16
SIMULA, 17
Smalltalk, 17
computers
advantages of, 11–12
moving ideas with, 11
portability, 35
reasons for using, 11–12
working with, 11
Computer Science Advanced Placement exams, 15
concatenation
operator, 447
String values, 93–94
472      Java For Dummies
conditional operator, 313–315
conditions
double equal sign, 112
vs. expressions, 112
if statements, 111–112
in parentheses, 125–127
conditionToBeTested condition, 313
conn.createStatement, 449
CONNECTION, 452
constructors. See also objects
Account class, 166
avoiding errors, 459–460
default, 247–250
defined, 235
defining, 459–460
enum type, 233–241
FlowLayout method, 253
GameFrame class, 430
JButton class, 253–254
JCheckBox class, 253
JFrame class, 252–253
JMenuBar class, 253
overview, 232–233
setDefaultCloseOperation method, 253
setLayout method, 253
setSize method, 254
setTitle method, 253
setVisible method, 254
simpleFrame class, 254
subclasses and, 245–246
SuppressWarnings annotation, 254–255
Consumer lambda expression, 342
controlling program flow
with decision-making statements
comparison operators, 117–121
conditions in parentheses, 125–127
if statements, 106–115, 127–129
logical operators, 121–124
null values, 124–125
overview, 104–105
switch statements, 130–137
with loops
do statements, 150–152, 154–156
overview, 140
range-of-values, 301
for statements, 143–146
while loop, 141
copying code, disk files, 206–207
counting loops, 144–145
C programming language, 14
Cross Reference icon, 6
curly braces ({})
C programming language, 14
if statements, 112–113
overview, 55–59
D
data
destroying, 453–454
inserting, 450
retrieving, 451–453
storing, 205–206
testing for more, 330
database
creating, 446–447
drivers, 448
vendors, 448
dataIn, 368
dataInStrm, 379, 381
dataOut, 368
dataOutStrm, 379, 381
decFormat field, 270, 275
decFormat.setMaximum, 261
decFormat.setMaximumIntegerDigits, 270
decFormat. setMinimum, 261
DecimalFormat class, 261, 312–313
DecimalFormat object, 305
decimal number types, 83
decimal point, 73–74, 109
decision-making statements
comparison operators
comparing characters, 117–121
comparing numbers, 117–118
comparing objects, 118–121
importing with, 121
is equal to (==) operator, 117
is greater than (>) operator, 117
is greater than or equal to (>) operator, 117
is less than (< ) operator, 117
Index      473
is less than or equal to (<) operator, 117
is not equal to (!=) operator, 117
conditions in parentheses, 125–127
if statements
conditions, 111–112
curly braces, 112–113
else part, 114–115
indenting, 113–114
nesting, 127–129
overview, 106–110
randomness, 110–111
logical operators, 121–124
null values, 124–125
overview, 104–105
switch statements, 130–137
declarations
combining, 77–78
import , 91–93, 96, 115, 252
mess, 327
method, 52
package, 390
scan1, 381
scan2, 381
variables, 72, 77–78, 154–155
decrement operators, 98–102
default access, 164, 384, 396–398
default constructors, 247–250
default method, 417
DeletableColumnOfNumbers class, 416
Deletable interface, 416
DeletableTable class, 416
developer version, 37
diamond (< >) operator, 327
directory names, adding to file names, 211
directory structure, 391–392
disk files. See also files
adding directory names to filenames, 211
closing connection to, 213–214
copying and pasting code, 206–207
FileNotFoundException, 210
overview, 205
reading from, 208–210, 212
storing data, 205–206
diskScanner, 306–307
Displayable interfaces, 411–412
Displayer class, 26
displayMe method, 416
display method, 172–173, 305, 341, 411–413
do statements.

--- Chunk #810 ---
See also statements
blocks, 154–155
file handling, 154–156
overview, 150–152
reading single character, 154
variable declarations, 154–155
double backslashes (\\), 299
double equal sign (==), 112, 458–459
double minus signs (- -), 98, 100
double parameter, 249
double plus signs (++), 98–100
double primitive type, 73, 83, 309
double quote (\") escape sequence, 299
double value, 109
Double wrapper class, 328
DrawingWideBB class, 399
drawOval method, 390–391, 395–401, 407
DriverManager.getConnection, 449
drop-down list (JComboBox), 440
duration method, 250
E
Eclipse IDE, 26, 41, 203, 435, 446
else part, if statements, 114–115
end-of-line comments, 61
Enterprise Edition (EE), 26
enum type, 233–241
enum values, 267
equals method, 118
errors, avoiding
adding components to GUI, 459
adding listeners to handle events, 459
array boundaries, 460
capitalization, 457–458
comparing values, 458–459
defining constructors, 459–460
finding files, 462
fixing non-static references, 460
null pointers, 461
escape sequences
backspace, 299
carriage return, 299
defined, 299
474      Java For Dummies
escape sequences (continued)
double backslashes, 299
double quote, 299
form feed, 299
horizontal tab, 299
line feed, 299
single quote, 299
event handling, 430, 459
event-handling code, 430
events, 430
Exception class, 354
exception handling
catch clause parameter, 356–357
catching two or more exceptions, 365–366
checked exceptions, 371
defined, 353
exception types, 357–359
finally clause, 376–379
good exceptions, 368–369
IOException, 366–367
overview, 352–356
try-catch statement, 367–369, 372,  
374–375
try statement, 379–381
unchecked exceptions, 371
exceptions
cascading, 377
checked, 371, 374
custom, 357–358
detecting, 374
unchecked, 371, 374
executeQuery method, 452
executeUpdate method, 447–449, 452
existing codes, reusing
classes, 198–204
disk files
adding directory names to filenames, 211
closing connection to, 213–214
copying and pasting code, 206–207
FileNotFoundException, 210
overview, 205
reading from, 208–210, 212
storing data, 205–206
subclasses
creating, 216–219
overview, 214–215
using, 219–224
expressions
vs. conditions, 112
lambda
BinaryOperator, 342
categories, 342
Consumer, 342
Function, 342
overview, 339–340
Predicate, 342–343
side effect, 340–341
streams and, 342–347
with two parameters, 340–341
for statement, 145–146
statements and, 101
F
factorials, 147
factory method, 312
fall-throughs, 134–136
false value, 87, 308
fields
decFormat field, 270, 275
defined, 163
hiding, 186
making private, 188–189
MAX_EXPONENT field, 328
MAX_VALUE field, 328
number field, 235, 239, 245
objects, 167
protected, 400–401
scale field, 245
serialVersionUID field, 255, 435–436
text field, 436, 439
File class, 209
file handling, 154–156
File instance, 208
filenames
adding directory names to, 211
fully qualified, 252, 403
sharing
access modifiers, 384–394, 406–407
default access, 396–398
directory structure, 391–392
making frames, 392–394
packages, 399–400
protected access, 400–403
Index      475
file naming
Java convention, 50
public classes and, 169
FileNotFoundException, 210, 375
File object, 208
files
closing, 306–307
disk files
adding directory names to filenames, 211
closing connection to, 213–214
copying and pasting code, 206–207
FileNotFoundException, 210
overview, 205
reading from, 208–210, 212
storing data, 205–206
finding, 462
input, 320
output, 320
writing to, 305
fillOval method, 403
filter method, 343–344
final keyword, 242
finally clause, 376–379
findWithinHorizon, 237
float primitive type, 83
float type, 72–74, 83, 309
Float wrapper class, 328
FlowLayout method, 253
fonts, 122
for loop
enhanced, 300–302
iterations, 325
format method, 305
format string, 182–184
format variable, 242
form feed (\f) escape sequence, 299
for statements. See also statements
defined, 144
expression, 145–146
initialization, 145–146
overview, 143–144
update, 145–146
FORTRAN, 17, 333, 351–352
frames
components, 436
defined, 91
defining, 251
displaying, 251, 262–263, 389
making, 392–394
putting drawing on, 389–390
free-form classes, 180
Free On-line Dictionary of Computing, 352
functional programming
advantages of using, 348–349
assembly line, 343
lambda expressions
BinaryOperator, 342
categories, 342
Consumer, 342
Function, 342
overview, 339–340
Predicate, 342–343
side effect, 340–341
streams and, 342–347
with two parameters, 340–341
method references, 350
methods, 343
overview, 333–335
problem solving with, 336–338
side effect, 341
streams, 338
variables, 349
Function lambda expression, 342
G
GameFrame class, 430, 443
generics, collection classes, 325–327
getArray method, 453
getAverageString method, 261, 270–271
getBigDecimal method, 453
getBlob method, 453
getCurrencyInstance method, 312–313
getInt method, 453
getMessage, 356
getName method, 275
getNumber method, 245
getObject method, 453
getScale method, 245
getText, 434
getTimeStamp method, 453
Google, 15, 345
476      Java For Dummies
Gosling, James, 18, 326
g parameter, 391
grammar, 44
graphical user interface (GUI)
adding components to, 459
avoiding errors, 459
creating, 190–193
graphical user interface (GUI) program, 82
graphics buffer, 391
Graphics class, 403
GridLayout, 265
guests, 460
GUI Builder, 435–436
GUI Designer, 435–436
H
handling exceptions
catch clause parameter, 356–357
catching two or more exceptions, 365–366
checked exceptions, 371
defined, 353
exception types, 357–359
finally clause, 376–379
good exceptions, 368–369
IOException, 366–367
overview, 352–356
try-catch statement, 367–369, 372, 374–375
try statement, 379–381
unchecked exceptions, 371
Harvard Mark II computer, 351
HashMap collection class, 332
HashSet collection class, 332
hasNextDouble method, 330
hasNextInt method, 330
hasNext method, 330
header, 172–173
Hopper., Grace, 14
horizontal tab (\t) escape sequence, 299
I
i++ statement, 366–367
IBM, 448
IBM 704 computer, 351
icons, 5–6
IDE (integrated development environment)
defined, 26, 29
Eclipse IDE, 26, 41
IntelliJ IDEA, 26
NetBeans, 27, 42
overview, 40–42
identifiers, 46
if statements. See also statements
conditions, 111–112
curly braces, 112–113
else part, 114–115
indenting, 113–114
nesting, 127–129
overview, 106–110
randomness, 110–111
imperative programming, 333–335
implements keyword, 413
import declaration. See also declarations
if statements, 115
overview, 91–93
packages and, 252
static, 96
incompatible types message, 292
increment operators, 98–102
indenting, if statements, 113–114
IndexOutOfBoundsException class, 374
InfoQ, 464
inheritance, 20
initialization, for statement, 145–146
inner classes, 408, 441–444
input file, 320
instance variable, 163, 279
Integer class, 318–319, 328
Integer values, 332
integrated development environment (IDE)
defined, 26, 29
Eclipse IDE, 26, 41
IntelliJ IDEA, 26
NetBeans, 27, 42
overview, 40–42
IntelliJ IDEA, 26, 203, 435, 446
interfaces
abstract method, 417
classes and, 410
codes to create, 410
Index      477
default method, 417
Displayable, 411–412
implementing, 412–414
overview, 410–411
Summarizable, 412
InterruptedException, 371, 373–374
int primitive type, 83
int type, 83
int value, 311, 318–319
IOException class, 209, 266–267, 364, 366–367, 374
is equal to (==) operator, 117
is greater than (>) operator, 117
is greater than or equal to (>) operator, 117
is less than (< ) operator, 117
is less than or equal to (<) operator, 117
is not equal to (!=) operator, 117
ItemListener class, 441
itemStateChanged method., 441
iterator, 330–331
J
Java
building blocks
application programming interface, 44–45
classes, 49–50
comments, 60–64
curly braces, 55–58
identifiers, 45–47
keywords, 45–47
methods, 50–53
specifications, 44
statements, 53–55
bytecode, 29, 32, 35–36
defined, 12
event-handling thread, 431–432
file handling in, 154–156
history of computer programming, 14–15, 18
integrated development environment (IDE), 26–27
interface, 410–417
Java 2 Standard Edition 1.2, 37–38
Java 5.0, 327
object-oriented programming (OOP), 16–23
primitive types, 82–87
reason to use, 13
serialVersionUID, 435–436
source code, 30–31
versions, 37–38
websites, 462
java.awt.event package, 398
java.awt.Graphics class, 391, 395–401, 407
java.awt package, 398
Java Community Process (JCP), 45, 47
Java Database Connectivity (JDBC)
connecting, 449
creating database and table, 446–447
destroying data, 453–454
disconnecting, 449
overview, 445
putting data in table, 450
retrieving data, 451–453
running code, 447
SQL commands, 447–448
Java Development Kit (JDK)
defined, 37
installing, 26
javadoc comments, 61–62
.java extension, 169
JavaFX, 436
java.io.File class, 154–155
java.io.PrintStream, 305
Java Language Specification, 44, 403
Java programs
abstract classes, 420–422
access modifiers, 386–387
Account class, 195–196
Account objects, 165
account that calculate its own interest, 174–175
account that displays itself, 171–172
amountInAccount, 71–72
anonymous inner class, 443–444
ArtFrame class, 392–393
assignment operators, 103
class within class, 441–442
class with no name, 443–444
closing resources, 380–381
command line arguments, 317–318
counting boxes, 352–356
creating database and table, 446
default constructor, 248–249
defining frame, 251
destroying data, 453–454
478      Java For Dummies
Java programs (continued)
displaying frame, 251, 262–263, 389
Drawing class, 390
drawing wider oval, 402–403
DummiesFrame, 191–193
employees, 199
exception handling, 359–360
fake code, 217–218
filling arrays with values, 298
FullTimeEmployee, 216
functional programming, 346
Guessing Game, 106, 114, 428–429
Hero Counts Boxes, 355
hiding fields, 186
incorrect program, 369
interfaces, 415
int type, 75–76
InventoryLoop, 367–368
iterating through collection, 330–331
Java Collection, 323–324
local currency, 436–439
Looking for Vacant Room, 30
for loop, 144
MakeChange, 87
making numbers right, 181
making query, 451–453
nested if statements, 128
PartTimeEmployee, 219
password checking, 119–120
Pentium processor, 33
Player class, 260, 262
PowerPC processor, 34
protected fields, 400–401
reference types, 87
repeating guessing game, 140–141
Room class, 309–310
Sale class, 336–337
simple calculator, 194
simplest program, 48
storing Integer values in ArrayList, 329
subclasses, 401
subclass of Drawing class, 395
switch statements, 132–133
switch statement with fall-through, 135
Team Batting Average, 269
Temperature class, 234–237
TemperatureNice class, 243–244, 246–247
thinking of a number, 194–195
this keyword, 433–434
username and password checking, 122
using subclasses, 220–221
using two files, 379–380
writing payroll checks, 200
JavaRanch, 464
Java Runtime Environment (JRE), 37
java.sql, 446
java.util package, 252
java.util.Scanner
counting boxes, 353, 355
custom-made exception, 357–358
to delete or not to delete, 152
exceptions, 360, 367–368
filling arrays with values, 298
Guessing Game, 114, 140, 201
implementing interfaces, 414
import declaration, 252
importing, 108
iterating through collection, 330
keyboard, 107–108
nested if statements, 128
password checking, 119
payroll checks, 200
Player class, 262
repeating Guessing Game, 140
Room class, 309
switch statements, 132
switch statement with fall-through, 135
switch statement with string, 137
try-catch statement, 369
try-with-resources statement, 380–381
using two files, 379
working with Java collection, 323
Java Virtual Machine (JVM)
defined, 29, 32
overview, 32–36
threads of execution, 431
javax.sql package, 446
javax.swing, 92, 252–254, 434
JButton class, 253–254, 436
JCheckBox class, 253
Index      479
JCombox, 440
JCP (Java Community Process), 47
JDBC (Java Database Connectivity)
connecting, 449
creating database and table, 446–447
destroying data, 453–454
disconnecting, 449
overview, 445
putting data in table, 450
retrieving data, 451–453
running code, 447
SQL commands, 447–448
JDK (Java Development Kit)
defined, 37
installing, 26
Jetbrains, 26
JFrame class
creating objects, 89–90
import declaration, 92, 252–253
overview, 44, 409
wrapper classes, 328
JFrame reference type, 88–89
JLabel class, 265, 434, 436
JMenuBar class, 253
JOptionPane, 123–124
Journal Entries, 16–23
JShell
declarations and statements, 255
overview, 78–81
session, 201
using blocks in, 116–117
JTextField class, 430, 434, 436
JUnit, 180
JVM (Java Virtual Machine)
defined, 29, 32
overview, 32–36
threads of execution, 431
K
keyboard.next method, 120, 123, 154
keyboard variable, 307
KeyListener class, 440
keyPressed method, 440
keyReleased method, 440
keyTyped method, 440
keywords
abstract, 419
defined, 46
double, 72
final, 242
implements, 413
private, 188, 384
public, 384–386
static, 267–270, 273–274
super, 419
this, 432–434
L
labels, 436, 439
lambda expressions
BinaryOperator, 342, 345
categories, 342
Consumer, 342
Function, 342
overview, 339–340
Predicate, 342–343
side effect, 340–341
streams and, 342–347
with two parameters, 340–341
language specification (Java Language Specification),  
44, 403
line feed (\n) escape sequence, 299
LinkedList collection class, 332
Linux, 33–35, 206, 211, 298, 316, 318
list collection, 330
literals, 69
logical operators, 121–124
logical types, 83
long primitive type, 83
Long wrapper class, 328
loops
counting, 144–145
do statements
blocks, 154–155
file handling, 154–156
overview, 150–152
reading single character, 154
variable declarations, 154–155
overview, 140
range-of-values, 301
480      Java For Dummies
loops (continued)
for statements
defined, 144
expression, 145–146
initialization, 145–146
overview, 143–144
update, 145–146
while loop, 141
M
Macintosh operating system, 207, 211, 298, 316, 318
Macintosh TextEdit, 29
main method. See also methods
catch clause parameter, 356
exceptions, 266
GetGoing class, 278
overview, 52–53
ShowTeamFrame class, 272
MakeRandomNumsFile program, 316
map method
functional programming, 344
Stream object, 347
MapReduce programming model, 345
Mariner I spacecraft, 352
matching catch clause, 361
MAX_EXPONENT field, 328
MAX_VALUE field, 328
McCarthy, John, 333
members, 385
mess declaration, 327
method calls, 51
method declaration, 52
method-local variable, 279–280
method references, 350
methods
abstract, 412, 417, 425–426
accessor
calling, 186
enforcing rules with, 190
making fields private, 188–189
simplicity, 186–187
actionPerformed, 430–432, 434
add, 323, 325
addActionListener, 432, 459
addMouseListener, 441
from classes and subclasses, 226–229
compareTo, 328
comparetoIgnoreCase, 332
default, 417
defining within class, 169–173
display, 172–173, 305, 341, 411–413
displayMe, 416
duration, 250
equals, 118
factory, 312
fillOval, 403
filter, 343–344
FlowLayout, 253
format, 305
getArray, 453
getAverageString, 261, 270–271
getBigDecimal, 453
getBlob, 453
getCurrencyInstance, 312–313
getInt, 453
getName, 275
getNumber, 245
getObject, 453
getScale, 245
getTimeStamp, 453
hasNext, 330
hasNextDouble, 330
hasNextInt, 330
header, 172–173
itemStateChanged ., 441
keyPressed, 440
keyReleased, 440
keyTyped, 440
main, 52–53, 266, 272, 278, 356, 378
map, 344, 347
mouseClicked, 441
mouseEntered, 441
mouseExited, 441
mousePressed, 441
mouseReleased, 441
non-static, 274
overriding existing
annotation, 226
overview, 224–226
using methods from classes and subclasses,  
226–228
Index      481
overview, 50–52
paint, 391–393
parseDouble, 328
parseInt , 318
passing value to, 176–178
print, 305
printf, 182–184, 241
println, 305
readByte, 368
reduce, 344
remove, 324
returning object from, 289–292
returning value from, 287
returning values from, 178–180
return type, 174
return value, 174
sending values to and from, 173–180
setColor, 403
setDefaultCloseOperation , 253
setLayout , 253, 265
setSize , 254
setTextOnLabel, 440
setTitle, 253
setVisible , 254, 266, 430–431
size, 332
sleep, 370
static, 268
stream, 344, 347
summarize, 412–413, 416
summarizeMe, 416
Thread.sleep, 371
toHexString, 328
tossing exception from methods to, 266
Microsoft, 15, 448
minus (-) sign, 94
mistakes, avoiding
adding components to GUI, 459
adding listeners to handle events, 459
array boundaries, 460
capitalization, 457–458
comparing values, 458–459
defining constructors, 459–460
finding files, 462
fixing non-static references, 460
null pointers, 461
switch statement, 458
MoneyFrame window, 439–440
mouse
actionPerformed method, 434
event-handling, 430–431
events, 430–431
inner classes, 441–444
overview, 427–428
serialVersionUID, 435–436
this keyword, 432–434
threads of execution, 431–432
mouseClicked method, 441
mouseEntered method, 441
mouseExited method, 441
MouseListener class, 441
mousePressed method, 441
mouseReleased method, 441
multicore processors, 334
multithreaded programs, 431
MySQL, 448
N
names
adding directory names to filenames, 211
fully qualified, 252, 403
sharing
access modifiers, 384–394, 406–407
default access, 396–398
directory structure, 391–392
making frames, 392–394
packages, 399–400
protected access, 400–403
variable, 69
NASA, 352
nested if statements, 127–129
NetBeans, 27, 42, 203, 435, 446
news websites, 464
nextDouble, 109, 213
nextInt, 109
nextLine, 213
next method. See also methods
iterator, 330, 338
reading single character, 154
stream, 338
NoClassDefFoundError, 462
nonpublic classes, 406–407. See also access modifiers
482      Java For Dummies
non-static method, 274
non-static references, 460
non-static variable or method cannot be 
referenced from a static context message, 
273–274
not (!) logical operator, 121
NullPointerException message, 125, 127,  
374, 461
null pointers, 461
null values, 124–125
number field, 235, 239, 245
NumberFormat class, 312–313
NumberFormatException class, 319, 353, 356, 361,  
366, 374
numbers
comparing, 117–118
making numbers right, 181
whole, 77
without decimal points, 75–77
NumberTooLargeException class, 361, 363, 365
O
object-oriented languages, 15
object-oriented programming (OOP)
advantages of using, 19–21
classes, 18–19
objects, 18–19
overview, 16–17
terminology, 21
objects. See also constructors
arrays of
conditional operator, 313–315
NumberFormat class, 312–313
overview, 307–308
Room class, 309–310
classes and, 18–19, 21–23
comparing objects, 118–121
creating, 164–167
fields, 167
PrintStream, 305
returning from method, 289–292
Stream, 347
String, 325
online resources
book, 463
InfoQ, 464
Java, 464
JavaRanch, 464
news, 464
Oracle, 463
reviews, 464
sample code, 464
Stack Overflow, 464
technical questions, 464
TheServerSide, 464
OOP (object-oriented programming)
advantages of using, 19–21
classes, 18–19
objects, 18–19
overview, 16–17
terminology, 21
OpenJDK Project, 45
operating systems
IBM 704 computer, 351
information in, 109
input and, 213
Linux, 33–35, 206, 211, 298, 316, 318
Macintosh, 207, 211, 298, 316, 318
overview, 25
processors and, 33
shell/window/terminal, 316
Windows
bytecode interpretation, 35–36
command prompt window, 316
data files, 206
file path names, 318
overview, 25
PATH variable, 393
Pentium processor and, 34
operators
arithmetic, 93–94
assigning, 97
assignment, 102–104
asterisk (*), 94
comparison
importing with, 121
is equal to (==) operator, 117
is greater than (>) operator, 117
is greater than or equal to (>) operator, 117
is less than (< ) operator, 117
is less than or equal to (<) operator, 117
is not equal to (!=) operator, 117
Index      483
conditional, 313–315
decrement, 98–102
increment, 98–102
initializing, 97
logical, 121–124
overview, 93–96
postdecrement, 100
postincrement, 99–100
predecrement, 100
preincrement, 98–99
remainder, 94–95
slash (/), 94
or (||) logical operator, 121, 126
Oracle, 15, 29, 448, 463
OutOfRangeExceptioncatch class, 361
OutOfRangeException class, 362–366
output file, 320
@Override annotation, 414
P
package declaration, 390
packages
java.awt, 398
java.awt.event, 398
java.util, 252
javax.sql, 446
pack method, 265–266, 430–431
paint method, 391–393
parallel stream, 348
parameter list, 173, 237
parameters
overview, 173
pass by reference, 287–289
pass by value, 285–287
returning object from method, 289–292
returning value from method, 287
parent class, 217–218
parentheses
conditions in parentheses, 125–127
expression in, 145
initialization in, 145
methods in, 172–173
update in, 145
parseDouble method, 328
parseInt method, 318
pass by reference parameter, 287–289
pass by value parameter, 285–287
password, checking, 119–120
pasting code, disk files, 206–207
Pentium processor
Linux operating system, 33
simple program for, 33
percent sign (%), 94, 204
pixels, 71
Player class, 260, 262
PlayerPlus class, 268–273, 275, 279
plus sign (+), 93–94
Pope, Alexander, 150
PopularitY of Programming Language Index  
(PYPL), 15
portability, 35
postdecrement operators, 100
PostgreSQL, 448
postincrement operators, 99–100
PowerPC processor, 33–34
pow routine, 45
predecrement operators, 100
Predicate lambda expression, 342–343
preincrement operator, 98–100
primitive (simple) types
boolean type, 85–87
byte type, 83
double type, 72, 83
float type, 72–74, 83
int type, 83
overview, 82–83, 409
short type, 83
wrapper class, 328
printf call, 204, 241–242
printf method, 182, 241
println, 179
println method, 305
print method, 305
printStackTrace, 356–357
PrintStream, 110
PrintStream object, 305
PriorityQueue collection class, 332
private access, 164, 398
private keyword, 188, 384
484      Java For Dummies
product version, 37
program flow
controlling with decision-making statements
comparison operators, 117–121
conditions in parentheses, 125–127
if statements, 106–115, 127–129
logical operators, 121–124
null values, 124–125
overview, 104–105
switch statements, 130–137
controlling with loops
do statements, 150–152, 154–156
overview, 140
range-of-values, 301
for statements, 143–146
while loop, 141
programming language
C, 14
C#, 15
C++, 14, 17–18, 326
COBOL, 14
defined, 12
FORTRAN, 14
Fortran, 17
history of, 14–15
Java, 14–15, 18
object-oriented, 16
SIMULA, 17
Smalltalk, 17
programning, functional
advantages of using, 348–349
assembly line, 343
lambda expressions
BinaryOperator, 342
categories, 342
Consumer, 342
Function, 342
overview, 339–340
Predicate, 342–343
side effect, 340–341
streams and, 342–347
with two parameters, 340–341
method references, 350
methods, 343
overview, 333–335
problem solving with, 336–338
side effect, 341
streams, 338
variables, 349
programs
classes and, 168
defined, 12
using command line arguments in, 317–318
protected access
classes, 398, 402–403
overview, 164, 400
subclasses, 400–402
public access. See also access modifiers
public access, 164, 398
public class
access modifiers, 406
Drawing class, 391
overview, 168–169
public keyword, 236, 384–386
PYPL (PopularitY of Programming Language  
Index), 279
Q
query, making, 451–453
Queue collection class, 332
quick-start instructions, 25–28
R
randomnesss, creating, 110–111
range-of-values, 301
readByte method, 368
Read Evaluate Print Loop (REPL), 79
reduce method, 344
references
method, 350
non-static, 460
pass by (parameter), 287–289
reference types, 87–90, 329, 409
remainder operator, 94–95
Remember icon, 6
Index      485
Remington Rand, 14
remove method, 324
repeating statements
do statements
blocks, 154–155
file handling, 154–156
overview, 150–152
reading single character, 154
variable declarations, 154–155
overview, 140
range-of-values, 301
for statements
defined, 144
expression, 145–146
initialization, 145–146
overview, 143–144
update, 145–146
while loop, 141
REPL (Read Evaluate Print Loop), 79
reply variable, 156
result set, 452
ResultSet instance, 453
resultset.next, 452
return statement, 178–179
return type, 174
return value, 174
reusing existing code
classes, 198–204
disk files
adding directory names to filenames, 211
closing connection to, 213–214
copying and pasting code, 206–207
FileNotFoundException, 210
overview, 205
reading from, 208–210, 212
storing data, 205–206
subclasses
creating, 216–219
overview, 214–215
using, 219–224
reviews websites, 464
Ritchie, Dennis, 14
RunDisplayer.java, 26
RuntimeException class, 374
S
safe codes, 185
sample code websites, 464
SAP, 448
scale field, 245
scan1 declaration, 381
scan2 declaration, 381
Scanner class, 201–202, 330, 409
screen pixels, 71
SDK (Software Development Kit), 37
SE (Standard Edition), 26, 37–38
serial stream, 348
serialVersionUID field, 255, 435–436
setColor method, 403
setDefaultCloseOperation method, 253
setLayout method, 253, 265
setMax call, 271
setMaximumIntegerDigits, 270
setMin call, 271
setSize method, 254
setText, 434
setTextOnLabel method, 440
setTitle method, 253
setVisible method, 254, 266, 430–431
sharing names
access modifiers, 384–394, 406–407
default access, 396–398
directory structure, 391–392
making frames, 392–394
packages, 399–400
protected access, 400–403
shell, 316
short primitive type, 83
Short wrapper class, 328
ShowFrame class, 402
ShowFrameWideBB class, 402–403
showMessageDialog call, 125
side effect, 341
simple (primitive) types
boolean type, 85–87
byte type, 83
double type, 72, 83
float type, 72–74, 83
486      Java For Dummies
simple (primitive) types (continued)
int type, 83
overview, 82–83, 409
short type, 83
wrapper class, 329
simpleFrame class, 254
SIMULA computer programming language, 17
single character, reading, 154
single quote (\') escape sequence, 299
size method, 332
slash (/), 94
sleep method, 370
Smalltalk computer programming language, 17
software
compiler, 29–32
defined, 12
developing, 39–40
integrated development environment, 40–42
Java Virtual Machine, 32–36
Software Development Kit (SDK), 37
source code, 30–31
SQL (Structured Query Language) commands, 447–449
SQLException class, 374
Stack collection class, 332
Stack Overflow, 464
Standard Edition (SE), 26, 37–38
statements
for
defined, 144
expression, 145–146
initialization, 145–146
overview, 143–144
update, 145–146
assignment, 70
break, 136–137
comparison operators and, 117–121
do, 150–157
blocks, 154–155
defined, 144
file handling, 154–156
overview, 150–152
reading single character, 154
variable declarations, 154–155
expressions and, 101
for, 143–150
i++ statement, 366–367
if
conditions, 111–112
curly braces, 112–113
else part, 114–115
indenting, 113–114
nesting, 127–129
overview, 106–110
randomnesss, 110–111
logical operators, 121–124
null values, 124–125
overview, 53–55
return, 178–179
switch
avoiding errors, 458
breaking out of, 458
enum types and, 238
fall-throughs, 134–136
overview, 130–134
strings in, 136–137
try, 356, 379–381
try-catch statement
acknowledging exception with, 372, 374–375
handling inappropriate input, 369
inside loop, 367–368
overview, 356
try-with-resources, 449
while, 141
static initializer, 270–271
static keyword, 267–270, 273–274
static methods, 268
static variables, 275–276
stream method, 344, 347
Stream object, 347
streams
defined, 338
lambda expressions and, 342–347
parallel, 348
serial, 348
String class, 328, 332
string concatenation operator, 93–94, 447
String literal, 318
String objects, 325
strings, in switch statements, 136–137
String type, 88, 118, 409
Index      487
String values. See also values
ArrayList, 332
concatenating, 93–94
DecimalFormat class, 261
Stroustrup, Bjarne, 14, 17
Structured Query Language (SQL) commands, 447–449
subclasses. See also classes
constructors for, 245–246
creating, 216–219
overview, 214–215
protected access, 400–402
using, 219–224
using methods from, 226–229
Summarizable interface, 412
summarizeMe method, 416
summarize method, 412–413, 416
Sun Microsystems, 14
superclass, 20, 217
super keyword, 419
SuppressWarnings annotation, 254–255, 435
Swing, 436
switch statements
avoiding errors, 458
breaking out of, 458
enum types and, 238
fall-throughs, 134–136
overview, 130–134
strings in, 136–137
Sys-Con Media, 15
System.in, 108, 115
System.out, 108, 305
System.out.println call, 54–55, 84, 94, 104, 110, 305
T
Table class, 416
tables
creating, 446–447
putting data in, 450
technical questions, 464
Technical Stuff icon, 6
Ten Ways to Avoid Mistakes
adding components to GUI, 459
adding listeners to handle events, 459
array boundaries, 460
capitalization, 457–458
comparing values, 458–459
defining constructors, 459–460
finding files, 462
fixing non-static references, 460
null pointers, 461
switch statement, 458
terminal, 316
test case, 180
text, displaying, 73–74
text-based programs, 82
text editors, 29
text field, 436, 439
textField, 443
textMessage, 357
TheServerSide, 464
things collection, 327
this keyword, 432–434
Thread.sleep method, 371
throw clause, 354
throws clause, 266, 354, 373–374
throws IOException clause, 207, 209
TIOBE Programming Community Index, 15
Tip icon, 6
toHexString method, 328
totalOfAverages, 268–270
traditional comments, 61
try-catch statement. See also statements
acknowledging exception with, 372, 374–375
handling inappropriate input, 369
inside loop, 367–368
overview, 356
try clause, 354, 359, 364
try statement, 356, 379–381
try-with-resources statement, 449
types, value, 71–74
U
unchecked exceptions, 371, 374
Unicode, 85, 440
Unix, 316, 393
unreported exception error message, 209
update, for statements, 145–146
Users directory, 461
488      Java For Dummies
V
values. See also operators
arrays, 297–298
comparing, 458–459
creating, 93–104
defined, 69
double value, 109
enum values, 267
false, 87, 308
Integer values, 332
int value, 311, 318–319
null values, 124–125
passing to method, 176–178
range-of-values, 301
returning from method, 178–180, 287
return value, 174
sending to and from methods, 173–180
storing, 297–298
String values, 93–94, 261, 332
types of, 71–74
variable declarations, 72, 154–155
variable names, 69
variables
assignment statements, 70
class, 279
combining declarations, 77–78
declaring, 164–167
defined, 68
displaying text, 73–74
functional programming, 349
import declaration, 91–93
initializing, 77–78, 167
instance, 163, 279
method-local, 279–280
numbers without decimal points, 75–77
operators
assigning, 97
decrement, 98–102
increment, 98–102
overview, 93–96
overview, 68–69
putting in its place, 277–280
reference types, 87–90
reply, 156
static, 275–276
telling where to go, 280–284
value types, 71–74
versions, 37–38
vim editor, 29
void, 412
W
Warning icon, 6
websites
book, 463
InfoQ, 464
Java, 464
JavaRanch, 464
news, 464
Oracle, 463
reviews, 464
sample code, 464
Stack Overflow, 464
technical questions, 464
TheServerSide, 464
while loop, 141
while statements, 141
whole number types, 83
wildcard character (*), 121
WindowBuilder, 435–436
windows, 196
Windows Notepad, 29
Windows operating system
bytecode interpretation, 35–36
command prompt window, 316
data files, 206
file path names, 318
overview, 25
PATH variable, 393
Pentium processor and, 34
word processor, 333
wrapper classes, 328–330
Y
Year 2000 Problem, 352
About the Author
Barry Burd received a Master of Science degree in computer science at Rutgers 
University and a PhD in mathematics at the University of Illinois. As a teach-
ing  assistant in Champaign-Urbana, Illinois, he was elected five times to the 
 university-wide List of Teachers Ranked as Excellent by Their Students.

--- Chunk #811 ---
Since 1980, Dr. Burd has been a professor in the Department of Mathematics and 
Computer Science at Drew University in Madison, New Jersey. He has lectured at 
conferences in the United States, Europe, Australia, and Asia. He hosts podcasts 
and videos about software and other technology topics. He is the author of many 
articles and books, including Beginning Programming with Java For Dummies,  
Java  Programming for Android Developers For Dummies,  and Android Application 
 Development All-in-One For Dummies, all from Wiley. Dr. Burd lives in Madison, New Jersey, with his wife of n years, where n > 35. In 
his spare time, he enjoys being a workaholic.

--- Chunk #812 ---
Dedication
Author’s Acknowledgments
I heartily and sincerely thank Paul Levesque for his work on so many of my books 
in this series. Thanks also to Katie Mohr for her hard work and support in so many ways. Thanks to Chad Darby and Becky Whitney for their efforts in editing this book. Thanks to the staff at John Wiley & Sons, Inc. for helping to bring this book to 
bookshelves. Thanks to Jeanne Boyarsky, Frank Greco, Chandra Guntur, and Michael Redlich 
for their advice on technical matters. And a special thanks to Richard Bonacci and Cameron McKenzie for their long-
term help and support.

--- Chunk #813 ---
Publisher’s Acknowledgments
Acquisitions Editor: Katie Mohr
Senior Project Editor: Paul Levesque
Copy Editor: Becky Whitney
Technical Editor: Chad Darby
Editorial Assistant: Serena Novosel
Sr. Editorial Assistant: Cherie Case
Production Editor: Siddique Shaik
Cover Image: © Melpomene/Shutterstock
Praise for the Sun Certified Programmer & Developer for Java 2 Study Guide
"Kathy Sierra is one of the few people in the world who can make complicated 
things seem damn simple. And as if that isn't enough, she can make boring things 
seem interesting. I always look forward to reading whatever Kathy writes—she's one 
of my favorite authors."
—Paul Wheaton, Trail Boss JavaRanch.com
"Who better to write a Java study guide than Kathy Sierra, the reigning queen of 
Java instruction? Kathy Sierra has done it again—here is a study guide that almost 
guarantees you a certification!"
—James Cubeta, Systems Engineer, SGI
"The thing I appreciate most about Kathy is her quest to make us all remember that 
we are teaching people and not just lecturing about Java. Her passion and desire 
for the highest quality education that meets the needs of the individual student is 
positively unparalleled at SunEd. Undoubtedly there are hundreds of students who 
have benefited from taking Kathy's classes."
—Victor Peters, founder Next Step Education & Software Sun Certified Java Instructor
"I want to thank Kathy for the EXCELLENT Study Guide. The book is well written, 
every concept is clearly explained using a real life example, and the book states what 
you specifically need to know for the exam. The way it's written, you feel that you're 
in a classroom and someone is actually teaching you the difficult concepts, but not 
in a dry, formal manner. The questions at the end of the chapters are also REALLY 
good, and I am sure they will help candidates pass the test. Watch out for this 
Wickedly Smart book."
—Alfred Raouf, Web Solution Developer
"The Sun Certification exam was certainly no walk in the park, but Kathy's material 
allowed me to not only pass the exam, but Ace it!"
—Mary Whetsel, Sr. Technology Specialist, 
Application Strategy and Integration, The St. Paul Companies
"Bert has an uncanny and proven ability to synthesize complexity into simplicity 
offering a guided tour into learning what's needed for the certification exam."
—Thomas Bender, President, Gold Hill Software Design, Inc. "With his skill for clearly expressing complex concepts to his training audience, 
every student can master what Bert has to teach."
—David Ridge, CEO, Ridge Associates
"I found this book to be extremely helpful in passing the exam. It was very well 
written with just enough light-hearted comments to make you forget that you were 
studying for a very difficult test. HIGHLY RECOMMENDED!!"
— Nicole Y. McCullough
"I have never enjoyed reading a technical book as much as I did this one…This 
morning I took the SCJP test and got 98% (60 out of 61) correct. Such success 
would not have been possible without this book!"
— Yurie Nagorny
"I gave SCJP 1.4 in July 2004 & scored 95% (58/61). Kathy & Bert have an 
awesome writing style & they literally burnt the core concepts into my head."
— Bhushan P . Madan (Kansas, United States)
"I just took my certification test last week and passed with a score of 95%. Had I not 
gone through this book, there would have been little chance of doing so well on the 
test. Thank you Kathy and Bert for a wonderful book!"
— Jon W . Kinsting (Saratoga, California United States)
"Don't hesitate to make this book your primary guide for SCJP 1.4 preparation. The 
authors have made a marvellous job about delivering the vital facts you need to 
know for the exam while leaving out tons of otherwise valuable data that fall beyond 
the scope. Both authors have participated in creating the real questions for the real 
exam thus providing an invaluable insight to discern the true nature of what you are 
up to doing. Unlike many other certification guides…this one makes perfect reading. The most boring Sun objectives in the book are nicely interwoven with the gems of 
refreshingly spicy humor."
— Vad Fogel (Ontario, Canada)
SCJP Sun
®
 Certiﬁ ed 
Programmer for Java
™
 6 
Study Guide
(Exam 310-065)
			

SCJP Sun
®
 Certiﬁ ed 
Programmer for Java
™
 6 
Study Guide
Exam (310-065)
Kathy Sierra
Bert Bates
New York   Chicago   San Francisco   Lisbon   London   Madrid
   Mexico City   Milan   New Delhi   San Juan   Seoul   Singapore   Sydney   Toronto
McGraw-Hill is an independent entity from Sun Microsystems, Inc. and is 
not afﬁ  liated with Sun Microsystems, Inc. in any manner. This publication and 
CD may be used in assisting students to prepare for the Sun Certiﬁ  ed Java 
Programmer Exam. Neither Sun Microsystems nor McGraw-Hill warrants 
that use of this publication and CD will ensure passing the relevant exam. Sun, 
Sun Microsystems, and the Sun Logo are trademarks or registered trademarks 
of Sun Microsystems, Inc. in the United States and other countries. Java 
and all Java-based marks are trademarks or registered trademarks of Sun 
Microsystems, Inc. in the United States and other countries.

--- Chunk #814 ---
Copyright © 2008 by The McGraw-Hill Companies. All rights reserved. Manufactured in the United States of America. Except as 
permitted under the United States Copyright Act of 1976, no part of this publication may be reproduced or distributed in any fo rm or
by any means, or stored in a database or retrieval system, without the prior written permission of the publisher. 0-07-159107-9
The material in this eBook also appears in the print version of this title: 0-07-159106-0. All trademarks are trademarks of their respective owners. Rather than put a trademark symbol after every occurrence of a trademarked
name, we use names in an editorial fashion only, and to the benefit of the trademark owner, with no intention of infringement of the
trademark. Where such designations appear in this book, they have been printed with initial caps. McGraw-Hill eBooks are available at special quantity discounts to use as premiums and sales promotions, or for use in corporate  
training programs. For more information, please contact George Hoare, Special Sales, at george_hoare@mcgraw-hill.com or (212) 
904-4069. TERMS OF USE 
This is a copyrighted work and The McGraw-Hill Companies, Inc. (“McGraw-Hill”) and its licensors reserve all rights in and to the
work. Use of this work is subject to these terms. Except as permitted under the Copyright Act of 1976 and the right to store and retrieve
one copy of the work, you may not decompile, disassemble, reverse engineer, reproduce, modify, create derivative works based up on,
transmit, distribute, disseminate, sell, publish or sublicense the work or any part of it without McGraw-Hill’ s prior consent. Y ou may
use the work for your own noncommercial and personal use; any other use of the work is strictly prohibited. Y our right to use the work
may be terminated if you fail to comply with these terms. THE WORK IS PROVIDED “AS IS.” McGRAW-HILL AND ITS LICENSORS MAKE NO GUARANTEES OR W ARRANTIES AS
TO THE ACCURACY , ADEQUACY OR COMPLETENESS OF OR RESULTS TO BE OBTAINED FROM USING THE WORK,
INCLUDING ANY INFORMATION THAT CAN BE ACCESSED THROUGH THE WORK VIA HYPERLINK OR OTHER WISE,
AND EXPRESSL Y DISCLAIM ANY W ARRANTY , EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO IMPLIED
W ARRANTIES OF MERCHANTABILITY OR FITNESS FOR A P ARTICULAR PURPOSE. McGraw-Hill and its licensors do not
warrant or guarantee that the functions contained in the work will meet your requirements or that its operation will be uninterrupted or
error free. Neither McGraw-Hill nor its licensors shall be liable to you or anyone else for any inaccuracy, error or omission, regardless
of cause, in the work or for any damages resulting therefrom. McGraw-Hill has no responsibility for the content of any informat ion
accessed through the work. Under no circumstances shall McGraw-Hill and/or its licensors be liable for any indirect, incidental , 
special, punitive, consequential or similar damages that result from the use of or inability to use the work, even if any of them has been
advised of the possibility of such damages. This limitation of liability shall apply to any claim or cause whatsoever whether such claim
or cause arises in contract, tort or otherwise. DOI: 10.1036/0071591060

We hope you enjoy this
McGraw-Hill eBook!

--- Chunk #815 ---
If
you’d like more information about this book,
its author, or related books and websites,
please click here. Professional
Want to learn more? CONTRIBUTORS
About the Authors
Kathy Sierra was a lead developer for the SCJP exam for Java 5 and Java 6. Sierra 
worked as a Sun "master trainer," and in 1997, founded JavaRanch.com, the world's 
largest Java community website. Her bestselling Java books have won multiple 
Software Development Magazine awards, and she is a founding member of Sun's Java 
Champions program. Bert Bates was a lead developer for many of Sun's Java certification exams including 
the SCJP for Java 5 and Java 6. He is also a forum moderator on JavaRanch.com, and 
has been developing software for more than 20 years. Bert is the co-author of several 
bestselling Java books, and he's a founding member of Sun's Java Champions program. About the T echnical Review T eam
Johannes de Jong has been the leader of our technical review teams for ever and 
ever. (He has more patience than any three people we know.) For this book, he led 
our biggest team ever. Our sincere thanks go out to the following volunteers who 
were knowledgeable, diligent, patient, and picky, picky, picky!

--- Chunk #816 ---
Rob Ross, Nicholas Cheung, Jane Griscti, Ilja Preuss, Vincent Brabant, Kudret 
Serin, Bill Seipel, Jing Yi, Ginu Jacob George, Radiya, LuAnn Mazza, Anshu Mishra, 
Anandhi Navaneethakrishnan, Didier Varon, Mary McCartney, Harsha Pherwani, 
Abhishek Misra, and Suman Das. About LearnKey
LearnKey provides self-paced learning content and multimedia delivery solutions to 
enhance personal skills and business productivity. LearnKey claims the largest library 
of rich streaming-media training content that engages learners in dynamic media-rich 
instruction complete with video clips, audio, full motion graphics, and animated 
illustrations. LearnKey can be found on the Web at www.LearnKey.com.  
	
T echnical Review Superstars
Andrew
Bill M. Burk Devender
Gian
Jim
JeroenJef
MarilynMarceloKristin
Johannes
ValentinSeemaMikalaiMark
We don't know who 
burned the most midnight 
oil, but we can (and did) 
count everybody's edits—
so in order of most edits 
made, we proudly present 
our Superstars. Our top honors go to 
Kristin Stromberg—every 
time you see a semicolon 
used correctly, tip your 
hat to Kristin. Next up is 
Burk Hufnagel who fixed 
more code than we care 
to admit. Bill Mietelski 
and Gian Franco 
Casula caught every 
kind of error we threw 
at them—awesome job, 
guys! Devender Thareja 
made sure we didn't use 
too much slang, and Mark 
Spritzler kept the humor 
coming. Mikalai Zaikin 
and Seema Manivannan 
made great catches every 
step of the way, and 
Marilyn de Queiroz and 
Valentin Crettaz both 
put in another stellar 
performance (saving our 
butts yet again). Marcelo Ortega, Jef Cumps (another veteran), Andrew Monkhouse, and Jeroen Sterken rounded 
out our crew of superstars—thanks to you all. Jim Yingst was a member of the Sun exam creation 
team, and he helped us write and review some of the twistier questions in the book (bwa-ha-ha-ha). As always, every time you read a clean page, thank our reviewers, and if you do catch an error, it's 
most certainly because your authors messed up. And oh, one last thanks to Johannes.

--- Chunk #817 ---
You rule dude! The Java 6 Elite Review T eam
Since the upgrade to 
the Java 6 exam was 
a like a small, surgical 
strike we decided that 
the technical review 
team for this update 
to the book needed to 
be similarly fashioned. To that end we hand-
picked an elite crew of 
JavaRanch's top gurus 
to perform the review 
for the Java 6 exam. Marc Peabody gets special kudos for helping us out on a double header! In addition to helping us 
with Sun's new SCWCD exam, Marc pitched in with a great set of edits for this book—you saved our 
bacon this winter Marc! (BTW , we didn't learn until late in the game that Marc, Bryan Basham, and 
Bert all share a passion for ultimate Frisbee!)
Like several of our reviewers, not only does Fred Rosenberger volunteer copious amounts of his 
time moderating at JavaRanch, he also found time to help us out with this book. Stacey and Olivia, 
you have our thanks for loaning us Fred for a while. Marc Weber moderates at some of JavaRanch's busiest forums. Marc knows his stuff, and 
uncovered some really sneaky problems that were buried in the book. While we really appreciate 
Marc's help, we need to warn you all to watch out—he's got a Phaser! Finally, we send our thanks to Christophe Verre—if we can find him. It appears that Christophe 
performs his JavaRanch moderation duties from various locations around the globe, including France, 
Wales, and most recently Tokyo. On more than one occasion Christophe protected us from our own 
lack of organization. Thanks for your patience, Christophe! It's important to know that these guys all donated their reviewer honorariums to JavaRanch! The 
JavaRanch community is in your debt. Marc W.

--- Chunk #818 ---
Marc P . Fred
Christophe
Mikalai
Our endless gratitude goes to Mikalai 
Zaikin. Mikalai played a huge role in 
the Java 5 book, and he returned to 
help us out again for this Java 6 edition. We need to thank Volha, Anastasia, 
and Daria for letting us borrow Mikalai. His comments and edits helped us 
make huge improvements to the book.

--- Chunk #819 ---
Thanks, Mikalai! To the Java Community
xi
CONTENTS AT A GLANCE
 1 Declarations and Access Control  ........................... 1
 2 Object Orientation  ..................................... 8 5
 3 Assignments  .......................................... 1 8 3
 4 Operators  ............................................ 2 8 7
 5 Flow Control, Exceptions, and Assertions  .................... 3 2 7
 6 Strings, I/O, Formatting, and Parsing  ........................ 4 2 5
 7 Generics and Collections  ................................ 5 4 1
 8 Inner Classes  ......................................... 6 6 1
 9 Threads  ............................................. 7 0 1
10 Development  ......................................... 7 8 9
A About the CD  ........................................ 8 3 1
 Index  ............................................... 8 3 5
			

xiii
CONTENTS
Contributors  . .

--- Chunk #820 ---
. . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #821 ---
. vii
Acknowledgments  . .

--- Chunk #822 ---
. . . . . . . . . . . . . . . .

--- Chunk #823 ---
. xx 
Preface  . .

--- Chunk #824 ---
. . . . . . . . . . . . . . . . . . .

--- Chunk #825 ---
. xxi
Introduction   . .

--- Chunk #826 ---
. . . . . . . . . . . . . . . . .

--- Chunk #827 ---
. xxiii
1 Declarations and Access Control   ............... 1
Java Refresher   . .

--- Chunk #828 ---
. . . . . . . . . . . . . . . . . .

--- Chunk #829 ---
. 2
Identifiers & JavaBeans (Objectives 1.3 and 1.4)  . .

--- Chunk #830 ---
. . . . .

--- Chunk #831 ---
. 4
Legal Identifiers   . .

--- Chunk #832 ---
. . . . . . . . . . . . . .

--- Chunk #833 ---
. 5
Sun's Java Code Conventions  . .

--- Chunk #834 ---
. . . . . . . . .

--- Chunk #835 ---
. 6
JavaBeans Standards  . .

--- Chunk #836 ---
. . . . . . . . . . . . .

--- Chunk #837 ---
. 8
Declare Classes (Exam Objective 1.1)   . .

--- Chunk #838 ---
. . . . . . . . .

--- Chunk #839 ---
. 10
Source File Declaration Rules  . .

--- Chunk #840 ---
. . . . . . . . .

--- Chunk #841 ---
. 11
Class Declarations and Modifiers  . .

--- Chunk #842 ---
. . . . . . . .

--- Chunk #843 ---
. 12
Exercise 1-1: Creating an Abstract Superclass and 
Concrete Subclass   . .

--- Chunk #844 ---
. . . . . . . . . . . .

--- Chunk #845 ---
. 18
Declare Interfaces (Exam Objectives 1.1 and 1.2)  . .

--- Chunk #846 ---
. . . . .

--- Chunk #847 ---
. 19
Declaring an Interface  . .

--- Chunk #848 ---
. . . . . . . . . . . .

--- Chunk #849 ---
. 19
Declaring Interface Constants  . .

--- Chunk #850 ---
. . . . . . . . .

--- Chunk #851 ---
. 22
Declare Class Members (Objectives 1.3 and 1.4)   . .

--- Chunk #852 ---
. . . . .

--- Chunk #853 ---
. 24
Access Modifiers  . .

--- Chunk #854 ---
. . . . . . . . . . . . . .

--- Chunk #855 ---
. 24
Nonaccess Member Modifiers  . .

--- Chunk #856 ---
. . . . . . . . .

--- Chunk #857 ---
. 39
Constructor Declarations  . .

--- Chunk #858 ---
. . . . . . . . . . .

--- Chunk #859 ---
. 47
Variable Declarations   . .

--- Chunk #860 ---
. . . . . . . . . . . .

--- Chunk #861 ---
. 49
Declaring Enums  . .

--- Chunk #862 ---
. . . . . . . . . . . . . .

--- Chunk #863 ---
. 60
    ✓ T wo-Minute Drill  . .

--- Chunk #864 ---
. . . . . . . . . . . . . .

--- Chunk #865 ---
. 68
Q&A   Self Test   . .

--- Chunk #866 ---
. . . . . . . . . . . . . . . . .

--- Chunk #867 ---
. 74
Self Test Answers  . .

--- Chunk #868 ---
. . . . . . . . . . . . . .

--- Chunk #869 ---
. 79


	


	
xiv SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
2 Object Orientation   ......................... 8 5
Encapsulation (Exam Objective 5.1)  . .

--- Chunk #870 ---
. . . . . . . . . .

--- Chunk #871 ---
. 86
Inheritance, Is-A, Has-A (Exam Objective 5.5)  . .

--- Chunk #872 ---
. . . . . .

--- Chunk #873 ---
. 90
IS-A  . .

--- Chunk #874 ---
. . . . . . . . . . . . . . . . . . .

--- Chunk #875 ---
. 94
HAS-A  . .

--- Chunk #876 ---
. . . . . . . . . . . . . . . . . .

--- Chunk #877 ---
. 96
Polymorphism (Exam Objective 5.2)  . .

--- Chunk #878 ---
. . . . . . . . . .

--- Chunk #879 ---
. 98
Overriding / Overloading (Exam Objectives 1.5 and 5.4)  . .

--- Chunk #880 ---
. .

--- Chunk #881 ---
. 103
Overridden Methods . .

--- Chunk #882 ---
. . . . . . . . . . . . .

--- Chunk #883 ---
. 103
Overloaded Methods   . .

--- Chunk #884 ---
. . . . . . . . . . . .

--- Chunk #885 ---
. 109
Reference Variable Casting (Objective 5.2)  . .

--- Chunk #886 ---
. . . . . . .

--- Chunk #887 ---
. 116
Implementing an Interface (Exam Objective 1.2)  . .

--- Chunk #888 ---
. . . . .

--- Chunk #889 ---
. 120
Legal Return Types (Exam Objective 1.5)  . .

--- Chunk #890 ---
. . . . . . . .

--- Chunk #891 ---
. 126
Return Type Declarations  . .

--- Chunk #892 ---
. . . . . . . . . . .

--- Chunk #893 ---
. 126
Returning a Value  . .

--- Chunk #894 ---
. . . . . . . . . . . . . .

--- Chunk #895 ---
. 128
Constructors and Instantiation 
 (Exam Objectives 1.6, 5.3, and 5.4)   . .

--- Chunk #896 ---
. . . . . . . . .

--- Chunk #897 ---
. 130
Determine Whether a Default Constructor 
Will Be Created   . .

--- Chunk #898 ---
. . . . . . . . . . . . .

--- Chunk #899 ---
. 135
Overloaded Constructors  . .

--- Chunk #900 ---
. . . . . . . . . . .

--- Chunk #901 ---
. 139
Statics (Exam Objective 1.3)    . .

--- Chunk #902 ---
. . . . . . . . . . . .

--- Chunk #903 ---
. 145
Static Variables and Methods   . .

--- Chunk #904 ---
. . . . . . . . .

--- Chunk #905 ---
. 145
Coupling and Cohesion  (Exam Objective 5.1)  . .

--- Chunk #906 ---
. . . . . .

--- Chunk #907 ---
. 151
    ✓ T wo-Minute Drill  . .

--- Chunk #908 ---
. . . . . . . . . . . . . .

--- Chunk #909 ---
. 157
Q&A   Self Test   . .

--- Chunk #910 ---
. . . . . . . . . . . . . . . . .

--- Chunk #911 ---
. 162
Self Test Answers  . .

--- Chunk #912 ---
. . . . . . . . . . . . . .

--- Chunk #913 ---
. 171
3 Assignments   .............................. 1 8 3
Stack and Heap—Quick Review   . .

--- Chunk #914 ---
. . . . . . . . . . .

--- Chunk #915 ---
. 184
Literals,  Assignments, and Variables 
 (Exam Objectives 1.3 and 7.6)  . .

--- Chunk #916 ---
. . . . . . . . . . .

--- Chunk #917 ---
. 186
Literal Values for All Primitive Types    . .

--- Chunk #918 ---
. . . . . .

--- Chunk #919 ---
. 186
Assignment Operators  . .

--- Chunk #920 ---
. . . . . . . . . . . .

--- Chunk #921 ---
. 190
Exercise 3-1: Casting Primitives   . .

--- Chunk #922 ---
. . . . . . .

--- Chunk #923 ---
. 195
Using a Variable or Array Element That Is Uninitialized 
and Unassigned   . .

--- Chunk #924 ---
. . . . . . . . . . . . .

--- Chunk #925 ---
. 203
Local (Stack,  Automatic) Primitives and Objects    . .

--- Chunk #926 ---
.

--- Chunk #927 ---
. 207
Contents xv
Passing Variables into Methods (Objective 7.3)  . .

--- Chunk #928 ---
. . . . . .

--- Chunk #929 ---
. 213
Passing Object Reference Variables  . .

--- Chunk #930 ---
. . . . . . .

--- Chunk #931 ---
. 213
Does Java Use Pass-By-Value Semantics? .

--- Chunk #932 ---
. . . . . .

--- Chunk #933 ---
. 214
Passing Primitive Variables   . .

--- Chunk #934 ---
. . . . . . . . . .

--- Chunk #935 ---
. 215
Array Declaration, Construction, and Initialization 
 (Exam Objective 1.3)  . .

--- Chunk #936 ---
. . . . . . . . . . . . . . .

--- Chunk #937 ---
. 219
Declaring an Array   . .

--- Chunk #938 ---
. . . . . . . . . . . . .

--- Chunk #939 ---
. 219
Constructing an Array  . .

--- Chunk #940 ---
. . . . . . . . . . . .

--- Chunk #941 ---
. 220
Initializing an Array  . .

--- Chunk #942 ---
. . . . . . . . . . . . .

--- Chunk #943 ---
. 224
Initialization Blocks  . .

--- Chunk #944 ---
. . . . . . . . . . . . .

--- Chunk #945 ---
. 234
Using Wrapper Classes and Boxing (Exam Objective 3.1)  . .

--- Chunk #946 ---
. .

--- Chunk #947 ---
. 237
An Overview of the Wrapper Classes   . .

--- Chunk #948 ---
. . . . . .

--- Chunk #949 ---
. 238
Creating Wrapper Objects   . .

--- Chunk #950 ---
. . . . . . . . . .

--- Chunk #951 ---
. 239
Using Wrapper Conversion Utilities  . .

--- Chunk #952 ---
. . . . . . .

--- Chunk #953 ---
. 240
Autoboxing  . .

--- Chunk #954 ---
. . . . . . . . . . . . . . . .

--- Chunk #955 ---
. 244
Overloading (Exam Objectives 1.5 and 5.4)  . .

--- Chunk #956 ---
. . . . . . .

--- Chunk #957 ---
. 247
Garbage Collection (Exam Objective 7.4)  . .

--- Chunk #958 ---
. . . . . . . .

--- Chunk #959 ---
. 254
Overview of Memory Management and 
Garbage Collection   . .

--- Chunk #960 ---
. . . . . . . . . . . . . . . . .

--- Chunk #961 ---
. 254
Overview of Java's Garbage Collector  . .

--- Chunk #962 ---
. . . . . .

--- Chunk #963 ---
. 255
Writing Code That Explicitly Makes Objects Eligible 
for Collection  . .

--- Chunk #964 ---
. . . . . . . . . . . . . .

--- Chunk #965 ---
. 257
Exercise 3-2: Garbage Collection Experiment . .

--- Chunk #966 ---
. . .

--- Chunk #967 ---
. 262
    ✓ T wo-Minute Drill  . .

--- Chunk #968 ---
. . . . . . . . . . . . . .

--- Chunk #969 ---
. 265
Q&A   Self Test   . .

--- Chunk #970 ---
. . . . . . . . . . . . . . . . .

--- Chunk #971 ---
. 269
Self Test Answers  . .

--- Chunk #972 ---
. . . . . . . . . . . . . .

--- Chunk #973 ---
. 277
4 Operators   ................................ 2 8 7
Java Operators (Exam Objective 7.6)  . .

--- Chunk #974 ---
. . . . . . . . . .

--- Chunk #975 ---
. 288
Assignment Operators  . .

--- Chunk #976 ---
. . . . . . . . . . . .

--- Chunk #977 ---
. 288
Relational Operators    . .

--- Chunk #978 ---
. . . . . . . . . . . .

--- Chunk #979 ---
. 290
instanceof Comparison  . .

--- Chunk #980 ---
. . . . . . . . . . . .

--- Chunk #981 ---
. 295
Arithmetic Operators   . .

--- Chunk #982 ---
. . . . . . . . . . . .

--- Chunk #983 ---
. 298
Conditional Operator  . .

--- Chunk #984 ---
. . . . . . . . . . . .

--- Chunk #985 ---
. 304
Logical Operators    . .

--- Chunk #986 ---
. . . . . . . . . . . . .

--- Chunk #987 ---
. 305
    ✓ T wo-Minute Drill  . .

--- Chunk #988 ---
. . . . . . . . . . . . . .

--- Chunk #989 ---
. 311
Q&A   Self Test   . .

--- Chunk #990 ---
. . . . . . . . . . . . . . . . .

--- Chunk #991 ---
. 313
Self Test Answers  . .

--- Chunk #992 ---
. . . . . . . . . . . . . .

--- Chunk #993 ---
. 319
xvi SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
5 Flow Control, Exceptions, and Assertions   ......... 3 2 7
if and switch Statements (Exam Objective 2.1)  . .

--- Chunk #994 ---
. . . . . .

--- Chunk #995 ---
. 328
if-else Branching  . .

--- Chunk #996 ---
. . . . . . . . . . . . . .

--- Chunk #997 ---
. 329
switch Statements    . .

--- Chunk #998 ---
. . . . . . . . . . . . .

--- Chunk #999 ---
. 334
Exercise 5-1: Creating a switch-case Statement   . .

--- Chunk #1000 ---
.

--- Chunk #1001 ---
. 342
Loops and Iterators (Exam Objective 2.2)  . .

--- Chunk #1002 ---
. . . . . . . .

--- Chunk #1003 ---
. 343
Using while Loops   . .

--- Chunk #1004 ---
. . . . . . . . . . . . .

--- Chunk #1005 ---
. 343
Using do Loops  . .

--- Chunk #1006 ---
. . . . . . . . . . . . . . .

--- Chunk #1007 ---
. 344
Using for Loops   . .

--- Chunk #1008 ---
. . . . . . . . . . . . . .

--- Chunk #1009 ---
. 345
Using break and continue  . .

--- Chunk #1010 ---
. . . . . . . . . . .

--- Chunk #1011 ---
. 352
Unlabeled Statements  . .

--- Chunk #1012 ---
. . . . . . . . . . . .

--- Chunk #1013 ---
. 353
Labeled Statements  . .

--- Chunk #1014 ---
. . . . . . . . . . . . .

--- Chunk #1015 ---
. 354
Exercise 5-2: Creating a Labeled while Loop   . .

--- Chunk #1016 ---
. .

--- Chunk #1017 ---
. 356
Handling Exceptions (Exam Objectives 2.4 and 2.5)  . .

--- Chunk #1018 ---
. . . .

--- Chunk #1019 ---
. 356
Catching an Exception Using try and catch  . .

--- Chunk #1020 ---
. . . .

--- Chunk #1021 ---
. 357
Using finally  . .

--- Chunk #1022 ---
. . . . . . . . . . . . . . . .

--- Chunk #1023 ---
. 359
Propagating Uncaught Exceptions    . .

--- Chunk #1024 ---
. . . . . . .

--- Chunk #1025 ---
. 362
Exercise 5-3: Propagating and Catching 
an Exception   . .

--- Chunk #1026 ---
. . . . . . . . . . . . . .

--- Chunk #1027 ---
. 364
Defining Exceptions  . .

--- Chunk #1028 ---
. . . . . . . . . . . . .

--- Chunk #1029 ---
. 365
Exception Hierarchy  . .

--- Chunk #1030 ---
. . . . . . . . . . . . .

--- Chunk #1031 ---
. 366
Handling an Entire Class Hierarchy of Exceptions   . .

--- Chunk #1032 ---
.

--- Chunk #1033 ---
. 368
Exception Matching  . .

--- Chunk #1034 ---
. . . . . . . . . . . . .

--- Chunk #1035 ---
. 369
Exception Declaration and the Public Interface   . .

--- Chunk #1036 ---
. .

--- Chunk #1037 ---
. 371
Rethrowing the Same Exception  . .

--- Chunk #1038 ---
. . . . . . . .

--- Chunk #1039 ---
. 376
Exercise 5-4: Creating an Exception  . .

--- Chunk #1040 ---
. . . . . .

--- Chunk #1041 ---
. 377
Common Exceptions and Errors(Exam Objective 2.6)  . .

--- Chunk #1042 ---
. . .

--- Chunk #1043 ---
. 378
Working with the Assertion Mechanism (Exam Objective 2.3)  . . . 383
Assertions Overview  . .

--- Chunk #1044 ---
. . . . . . . . . . . . .

--- Chunk #1045 ---
. 384
Enabling Assertions   . .

--- Chunk #1046 ---
. . . . . . . . . . . . .

--- Chunk #1047 ---
. 387
Using Assertions Appropriately   . .

--- Chunk #1048 ---
. . . . . . . .

--- Chunk #1049 ---
. 391
    ✓ T wo-Minute Drill  . .

--- Chunk #1050 ---
. . . . . . . . . . . . . .

--- Chunk #1051 ---
. 397
Q&A   Self Test   . .

--- Chunk #1052 ---
. . . . . . . . . . . . . . . . .

--- Chunk #1053 ---
. 401
Self Test Answers  . .

--- Chunk #1054 ---
. . . . . . . . . . . . . .

--- Chunk #1055 ---
. 411
Contents xvii
6 Strings, I/O, Formatting, and Parsing   ............. 4 2 5
String, StringBuilder, and StringBuffer (Exam Objective 3.1)   . . . 426
The String Class  . .

--- Chunk #1056 ---
. . . . . . . . . . . . . .

--- Chunk #1057 ---
. 426
Important Facts About Strings and Memory    . .

--- Chunk #1058 ---
. . .

--- Chunk #1059 ---
. 433
Important Methods in the String Class  . .

--- Chunk #1060 ---
. . . . . .

--- Chunk #1061 ---
. 434
The StringBuffer and StringBuilder Classes  . .

--- Chunk #1062 ---
. . . .

--- Chunk #1063 ---
. 438
Important Methods in the StringBuffer 
and StringBuilder Classes  . .

--- Chunk #1064 ---
. . . . . . . . . .

--- Chunk #1065 ---
. 440
File Navigation and I/O (Exam Objective 3.2)  . .

--- Chunk #1066 ---
. . . . . .

--- Chunk #1067 ---
. 443
The java.io.Console Class  . .

--- Chunk #1068 ---
. . . . . . . . . . .

--- Chunk #1069 ---
. 457
Serialization (Exam Objective 3.3)   . .

--- Chunk #1070 ---
. . . . . . . . . .

--- Chunk #1071 ---
. 459
Dates, Numbers, and Currency (Exam Objective 3.4)   . .

--- Chunk #1072 ---
. . .

--- Chunk #1073 ---
. 473
Working with Dates, Numbers, and Currencies  . .

--- Chunk #1074 ---
. . .

--- Chunk #1075 ---
. 474
Parsing, Tokenizing, and Formatting (Exam Objective 3.5)   . .

--- Chunk #1076 ---
.

--- Chunk #1077 ---
. 487
A Search Tutorial  . .

--- Chunk #1078 ---
. . . . . . . . . . . . . .

--- Chunk #1079 ---
. 488
Locating Data via Pattern Matching  . .

--- Chunk #1080 ---
. . . . . . .

--- Chunk #1081 ---
. 498
Tokenizing   . .

--- Chunk #1082 ---
. . . . . . . . . . . . . . . .

--- Chunk #1083 ---
. 501
Formatting with printf() and format()  . .

--- Chunk #1084 ---
. . . . . .

--- Chunk #1085 ---
. 506
    ✓ T wo-Minute Drill  . .

--- Chunk #1086 ---
. . . . . . . . . . . . . .

--- Chunk #1087 ---
. 511
Q&A   Self Test   . .

--- Chunk #1088 ---
. . . . . . . . . . . . . . . . .

--- Chunk #1089 ---
. 515
Self Test Answers  . .

--- Chunk #1090 ---
. . . . . . . . . . . . . .

--- Chunk #1091 ---
. 526
7 Generics and Collections   ..................... 5 4 1
Overriding hashCode() and equals() (Objective 6.2)  . .

--- Chunk #1092 ---
. . . .

--- Chunk #1093 ---
. 542
Overriding equals()  . .

--- Chunk #1094 ---
. . . . . . . . . . . . .

--- Chunk #1095 ---
. 544
Overriding hashCode() . .

--- Chunk #1096 ---
. . . . . . . . . . . .

--- Chunk #1097 ---
. 549
Collections (Exam Objective 6.1)  . .

--- Chunk #1098 ---
. . . . . . . . . . .

--- Chunk #1099 ---
. 556
So What Do You Do with a Collection? .

--- Chunk #1100 ---
. . . . . .

--- Chunk #1101 ---
. 556
List Interface   . .

--- Chunk #1102 ---
. . . . . . . . . . . . . . .

--- Chunk #1103 ---
. 561
Set Interface  . .

--- Chunk #1104 ---
. . . . . . . . . . . . . . . .

--- Chunk #1105 ---
. 562
Map Interface  . .

--- Chunk #1106 ---
. . . . . . . . . . . . . . .

--- Chunk #1107 ---
. 563
Queue Interface   . .

--- Chunk #1108 ---
. . . . . . . . . . . . . .

--- Chunk #1109 ---
. 564
Using the Collections Framework (Objectives 6.3 and 6.5)   . .

--- Chunk #1110 ---
.

--- Chunk #1111 ---
. 566
ArrayList Basics   . .

--- Chunk #1112 ---
. . . . . . . . . . . . . .

--- Chunk #1113 ---
. 567
Autoboxing with Collections   . .

--- Chunk #1114 ---
. . . . . . . . .

--- Chunk #1115 ---
. 568
Sorting Collections and Arrays  . .

--- Chunk #1116 ---
. . . . . . . . .

--- Chunk #1117 ---
. 568
Navigating (Searching) TreeSets and TreeMaps   . .

--- Chunk #1118 ---
. .

--- Chunk #1119 ---
. 586
Other Navigation Methods  . .

--- Chunk #1120 ---
. . . . . . . . . .

--- Chunk #1121 ---
. 587
Backed Collections  . .

--- Chunk #1122 ---
. . . . . . . . . . . . .

--- Chunk #1123 ---
. 589
xviii SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
Generic Types (Objectives 6.3 and 6.4)  . .

--- Chunk #1124 ---
. . . . . . . . .

--- Chunk #1125 ---
. 595
Generics and Legacy Code   . .

--- Chunk #1126 ---
. . . . . . . . . .

--- Chunk #1127 ---
. 600
Mixing Generic and Non-generic Collections  . .

--- Chunk #1128 ---
. . .

--- Chunk #1129 ---
. 601
Polymorphism and Generics  . .

--- Chunk #1130 ---
. . . . . . . . . .

--- Chunk #1131 ---
. 607
Generic Methods  . .

--- Chunk #1132 ---
. . . . . . . . . . . . . .

--- Chunk #1133 ---
. 609
Generic Declarations   . .

--- Chunk #1134 ---
. . . . . . . . . . . .

--- Chunk #1135 ---
. 622
    ✓ T wo-Minute Drill  . .

--- Chunk #1136 ---
. . . . . . . . . . . . . .

--- Chunk #1137 ---
. 631
Q&A   Self Test   . .

--- Chunk #1138 ---
. . . . . . . . . . . . . . . . .

--- Chunk #1139 ---
. 636
Self Test Answers   . .

--- Chunk #1140 ---
. . . . . . . . . . . . . .

--- Chunk #1141 ---
. 647
8 Inner Classes   .............................. 6 6 1
Inner Classes  . .

--- Chunk #1142 ---
. . . . . . . . . . . . . . . . . . .

--- Chunk #1143 ---
. 663
Coding a "Regular" Inner Class  . .

--- Chunk #1144 ---
. . . . . . . . .

--- Chunk #1145 ---
. 664
Referencing the Inner or Outer Instance from Within 
the Inner Class  . .

--- Chunk #1146 ---
. . . . . . . . . . . . . .

--- Chunk #1147 ---
. 668
Method-Local Inner Classes  . .

--- Chunk #1148 ---
. . . . . . . . . . . . .

--- Chunk #1149 ---
. 670
What a Method-Local Inner Object Can and Can't Do   . . 671
Anonymous Inner Classes  . .

--- Chunk #1150 ---
. . . . . . . . . . . . . .

--- Chunk #1151 ---
. 673
Plain-Old Anonymous Inner Classes, Flavor One . .

--- Chunk #1152 ---
. . .

--- Chunk #1153 ---
. 673
Plain-Old Anonymous Inner Classes, Flavor T wo  . .

--- Chunk #1154 ---
. .

--- Chunk #1155 ---
. 677
Argument-Defined Anonymous Inner Classes  . .

--- Chunk #1156 ---
. . .

--- Chunk #1157 ---
. 678
Static Nested Classes  . .

--- Chunk #1158 ---
. . . . . . . . . . . . . . . .

--- Chunk #1159 ---
. 680
Instantiating and Using Static Nested Classes  . .

--- Chunk #1160 ---
. . .

--- Chunk #1161 ---
. 681
    ✓ T wo-Minute Drill  . .

--- Chunk #1162 ---
. . . . . . . . . . . . . .

--- Chunk #1163 ---
. 683
Q&A   Self Test   . .

--- Chunk #1164 ---
. . . . . . . . . . . . . . . . .

--- Chunk #1165 ---
. 685
Self Test Answers  . .

--- Chunk #1166 ---
. . . . . . . . . . . . . .

--- Chunk #1167 ---
. 692
9 Threads   .................................. 7 0 1
Defining, Instantiating, and Starting Threads (Objective 4.1)   . . . 702
Defining a Thread   . .

--- Chunk #1168 ---
. . . . . . . . . . . . .

--- Chunk #1169 ---
. 705
Instantiating a Thread  . .

--- Chunk #1170 ---
. . . . . . . . . . . .

--- Chunk #1171 ---
. 706
Starting a Thread  . .

--- Chunk #1172 ---
. . . . . . . . . . . . . .

--- Chunk #1173 ---
. 709
Thread States and Transitions (Objective 4.2)  . .

--- Chunk #1174 ---
. . . . . .

--- Chunk #1175 ---
. 718
Thread States   . .

--- Chunk #1176 ---
. . . . . . . . . . . . . . .

--- Chunk #1177 ---
. 718
Preventing Thread Execution  . .

--- Chunk #1178 ---
. . . . . . . . .

--- Chunk #1179 ---
. 720
Sleeping   . .

--- Chunk #1180 ---
. . . . . . . . . . . . . . . . .

--- Chunk #1181 ---
. 721
Exercise 9-1:  Creating a Thread and 
Putting It to Sleep  . .

--- Chunk #1182 ---
. . . . . . . . . . . . . . . . . .

--- Chunk #1183 ---
. 723
Thread Priorities and yield( )   . .

--- Chunk #1184 ---
. . . . . . . . .

--- Chunk #1185 ---
. 724
Contents xix
Synchronizing Code (Objective 4.3)  . .

--- Chunk #1186 ---
. . . . . . . . . .

--- Chunk #1187 ---
. 728
Synchronization and Locks   . .

--- Chunk #1188 ---
. . . . . . . . . .

--- Chunk #1189 ---
. 735
Exercise 9-2: Synchronizing a Block of Code   . .

--- Chunk #1190 ---
. .

--- Chunk #1191 ---
. 738
Thread Deadlock   . .

--- Chunk #1192 ---
. . . . . . . . . . . . . .

--- Chunk #1193 ---
. 745
Thread Interaction (Objective 4.4)  . .

--- Chunk #1194 ---
. . . . . . . . . . . . . . . .

--- Chunk #1195 ---
. 746
Using notifyAll( ) When Many Threads 
May Be Waiting  . .

--- Chunk #1196 ---
. . . . . . . . . . . . . . . . . . .

--- Chunk #1197 ---
. 752
    ✓ T wo-Minute Drill  . .

--- Chunk #1198 ---
. . . . . . . . . . . . . . . . . . . . .

--- Chunk #1199 ---
. 758
Q&A   Self Test  . .

--- Chunk #1200 ---
. . . . . . . . . . . . . . . . . . . . . . . . . .

--- Chunk #1201 ---
. 761
Self Test Answers  . .

--- Chunk #1202 ---
. . . . . . . . . . . . . . . . . . . .

--- Chunk #1203 ---
. 772
Exercise Answers  . .

--- Chunk #1204 ---
. . . . . . . . . . . . . . . . . . . . .

--- Chunk #1205 ---
. 787
10 Development   .............................. 7 8 9
Using the javac and java Commands 
 (Exam Objectives 7.1, 7.2, and 7.5)   . .

--- Chunk #1206 ---
. . . . . . . . .

--- Chunk #1207 ---
. 790
Compiling with javac   . .

--- Chunk #1208 ---
. . . . . . . . . . . .

--- Chunk #1209 ---
. 790
Launching Applications with java   . .

--- Chunk #1210 ---
. . . . . . .

--- Chunk #1211 ---
. 793
Searching for Other Classes  . .

--- Chunk #1212 ---
. . . . . . . . . .

--- Chunk #1213 ---
. 796
JAR Files (Objective 7.5)  . .

--- Chunk #1214 ---
. . . . . . . . . . . . . .

--- Chunk #1215 ---
. 802
JAR Files and Searching  . .

--- Chunk #1216 ---
. . . . . . . . . . .

--- Chunk #1217 ---
. 803
Using Static Imports (Exam Objective 7.1)   . .

--- Chunk #1218 ---
. . . . . . .

--- Chunk #1219 ---
. 806
Static Imports  . .

--- Chunk #1220 ---
. . . . . . . . . . . . . . .

--- Chunk #1221 ---
. 806
    ✓ T wo-Minute Drill  . .

--- Chunk #1222 ---
. . . . . . . . . . . . . .

--- Chunk #1223 ---
. 809
Q&A   Self Test   . .

--- Chunk #1224 ---
. . . . . . . . . . . . . . . . .

--- Chunk #1225 ---
. 811
Self Test Answers  . .

--- Chunk #1226 ---
. . . . . . . . . . . . . .

--- Chunk #1227 ---
. 820
A About the CD  .............................. 8 3 1
System Requirements  . .

--- Chunk #1228 ---
. . . . . . . . . . . . . . . .

--- Chunk #1229 ---
. 832
Installing and Running Master Exam  . .

--- Chunk #1230 ---
. . . . . . . . . .

--- Chunk #1231 ---
. 832
Master Exam  . .

--- Chunk #1232 ---
. . . . . . . . . . . . . . . .

--- Chunk #1233 ---
. 832
Electronic Book  . .

--- Chunk #1234 ---
. . . . . . . . . . . . . . . . . .

--- Chunk #1235 ---
. 833
Help  . .

--- Chunk #1236 ---
. . . . . . . . . . . . . . . . . . . . . .

--- Chunk #1237 ---
. 833
Removing Installation(s)  . .

--- Chunk #1238 ---
. . . . . . . . . . . . . .

--- Chunk #1239 ---
. 833
Technical Support  . .

--- Chunk #1240 ---
. . . . . . . . . . . . . . . . .

--- Chunk #1241 ---
. 833
LearnKey Technical Support  . .

--- Chunk #1242 ---
. . . . . . . . . .

--- Chunk #1243 ---
.

--- Chunk #1244 ---
833
 Index  ................................... 8 3 5
ACKNOWLEDGMENTS
K
athy and Bert would like to thank the following people:
■ All the incredibly hard-working folks at McGraw-Hill: Tim Green, Jim Kussow, 
Jody McKenzie, Madhu Bhardwaj, and Jennifer Housh for all their help, and 
for being so responsive and patient—well, okay, not all that patient—but so 
professional and the nicest group of people you could hope to work with. ■ To our saviors Solveig Haugland and Midori Batten, for coming to our rescue 
when we were really in a bind! ■ Some of the software professionals and friends who helped us in the early 
days: Tom Bender, Peter Loerincs, Craig Matthews, Dave Gustafson, Leonard 
Coyne, Morgan Porter, and Mike Kavenaugh. ■ The wonderful and talented Certification team at Sun Educational Services, 
primarily the most persistent get-it-done person we know, Evelyn Cartagena. ■ Our great friends and gurus, Bryan Basham, Kathy Collina, and Simon Roberts. ■ To Eden and Skyler, for being horrified that adults—out of school— would 
study this hard for an exam. ■ To the JavaRanch Trail Boss Paul Wheaton, for running the best Java community 
site on the Web, and to all the generous and patient JavaRanch moderators. ■ To all the past and present Sun Ed Java instructors for helping to make 
learning Java a fun experience including (to name only a few): Alan 
Petersen, Jean Tordella, Georgianna Meagher, Anthony Orapallo, Jacqueline 
Jones, James Cubeta, Teri Cubeta, Rob Weingruber, John Nyquist, Asok 
Perumainar, Steve Stelting, Kimberly Bobrow, Keith Ratliff, and the most 
caring and inspiring Java guy on the planet, Jari Paukku. ■ To Darren and Mary, thanks for keeping us sane and for helping us with our 
new furry friends Andi, Kara, Birta, Sola, Draumur, and Tjara. ■ Finally, to Eric and Beth Freeman for your continued inspiration. xx
 
	
xxi
PREFACE
T
his book's primary objective is to help you prepare for and pass Sun Microsystem's SCJP 
certification for Java 6 or Java 5. The Java 6 and Java 5 exams are almost identical in 
scope, and they are both much broader than their predecessor, the Java 1.4 exam. For 
the remainder of this book we'll typically reference the Java 6 exam, but remember that other than 
the addition of the System.Console class and Navigable collections, the Java 5 and Java 6 exams are 
identical in scope. We recommend that you take the Java 6 exam and not the Java 5 exam, but if you 
do decide to take the Java 5 exam, this book is still appropriate. The new exam's objectives touch on 
many of the more commonly used of Java's APIs. The key word here is "touch."  The exam's creators 
intended that passing the exam will demonstrate that the candidate understands the basics of APIs 
such as those for file I/O and regular expressions. This book follows closely both the breadth and the 
depth of the real exam. For instance, after reading this book, you probably won't emerge as a regex 
guru, but if you study the material, and do well on the self tests, you'll have a basic understanding of 
regex, and you'll do well on the exam. After completing this book, you should feel confident that you 
have thoroughly reviewed all of the objectives that Sun has established for the exam. In This Book
This book is organized to optimize your learning of the topics covered by the SCJP
Java 6 exam. Whenever possible, we've organized the chapters to parallel the Sun 
objectives, but sometimes we'll mix up objectives or partially repeat them in order to 
present topics in an order better suited to learning the material. In addition to fully covering the SCJP Java 6 exam, we have also included on the 
CD eight chapters that cover important aspects of Sun's SCJD exam. In Every Chapter
We've created a set of chapter components that call your attention to important 
items, reinforce important points, and provide helpful exam-taking hints. Take a 
look at what you'll find in every chapter:
■ Every chapter begins with the Certification Objectives—what you need to 
know in order to pass the section on the exam dealing with the chapter topic.  
	
xxii SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
The Certification Objective headings identify the objectives within the 
chapter, so you'll always know an objective when you see it! ■ Exam Watch notes call attention to information about, and potential pitfalls 
in, the exam. Since we were on the team that created the exam, we know 
what you're about to go through! ■ On the Job callouts discuss practical aspects of certification topics that might 
not occur on the exam, but that will be useful in the real world. ■ Exercises are interspersed throughout the chapters. They help you master 
skills that are likely to be an area of focus on the exam. Don't just read 
through the exercises; they are hands-on practice that you should be 
comfortable completing. Learning by doing is an effective way to increase 
your competency with a product. ■ From the Classroom sidebars describe the issues that come up most often in 
the training classroom setting. These sidebars give you a valuable perspective 
into certification- and product-related topics. They point out common 
mistakes and address questions that have arisen from classroom discussions. ■ The Certification Summary is a succinct review of the chapter and 
a restatement of salient points regarding the exam. ■ The Two-Minute Drill at the end of every chapter is a checklist of the main 
points of the chapter. It can be used for last-minute review. ■ The Self Test offers questions similar to those found on the certification 
exam, including multiple choice, and pseudo drag-and-drop questions. The 
answers to these questions, as well as explanations of the answers, can be 
found at the end of every chapter. By taking the Self Test after completing 
each chapter, you'll reinforce what you've learned from that chapter, while 
becoming familiar with the structure of the exam questions. ✓
Q&A
INTRODUCTION
Organization
This book is organized in such a way as to serve as an in-depth review for the Sun 
Certified Programmer for both the Java 6 and Java 5 exams, for experienced Java 
professionals and those in the early stages of experience with Java technologies. Each 
chapter covers at least one major aspect of the exam, with an emphasis on the "why" 
as well as the "how to" of programming in the Java language. The CD included with 
the book also includes an in-depth review of the essential ingredients for a successful 
assessment of a project submitted for the Sun Certified Java Developer exam. What This Book Is Not
You will not find a beginner's guide to learning Java in this book. All 800 pages of 
this book are dedicated solely to helping you pass the exams. If you are brand new 
to Java, we suggest you spend a little time learning the basics. You shouldn't start 
with this book until you know how to write, compile, and run simple Java programs. We do not, however, assume any level of prior knowledge of the individual topics 
covered. In other words, for any given topic (driven exclusively by the actual exam 
objectives), we start with the assumption that you are new to that topic. So we 
assume you're new to the individual topics, but we assume that you are not new 
to Java. We also do not pretend to be both preparing you for the exam and simultaneously 
making you a complete Java being. This is a certification exam study guide, and it's 
very clear about its mission. That's not to say that preparing for the exam won't help 
you become a better Java programmer! On the contrary, even the most experienced 
Java developers often claim that having to prepare for the certification exam made 
them far more knowledgeable and well-rounded programmers than they would have 
been without the exam-driven studying. On the CD
For more information on the CD-ROM, please see Appendix A. xxiii
 
	
xxiv SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
Some Pointers
Once you've finished reading this book, set aside some time to do a thorough review. You might want to return to the book several times and make use of all the methods 
it offers for reviewing the material:
 1. Re-read all the T wo-Minute Drills, or have someone quiz you. You also can 
use the drills as a way to do a quick cram before the exam. You might want 
to make some flash cards out of 3 × 5 index cards that have the T wo-Minute 
Drill material on them. 2. Re-read all the Exam Watch notes. Remember that these notes are written by 
authors who helped create the exam. They know what you should expect—
and what you should be on the lookout for.

--- Chunk #1245 ---
3. Re-take the Self Tests. Taking the tests right after you've read the chapter is 
a good idea, because the questions help reinforce what you've just learned. However, it's an even better idea to go back later and do all the questions in 
the book in one sitting. Pretend that you're taking the live exam. (Whenever 
you take the self tests mark your answers on a separate piece of paper. That 
way, you can run through the questions as many times as you need to until 
you feel comfortable with the material.)
 4. Complete the Exercises. The exercises are designed to cover exam topics, and 
there's no better way to get to know this material than by practicing. Be sure 
you understand why you are performing each step in each exercise. If there is 
something you are not clear on, re-read that section in the chapter.

--- Chunk #1246 ---
5. Write lots of Java code. We’ll repeat this advice several times. When we 
wrote this book, we wrote hundreds of small Java programs to help us do our 
research. We have heard from hundreds of candidates who have passed the 
exam, and in almost every case the candidates who scored extremely well on 
the exam wrote lots of code during their studies. Experiment with the code 
samples in the book, create horrendous lists of compiler errors—put away 
your IDE, crank up the command line, and write code! Introduction to the Material in the Book
The Sun Certified Java Programmer (SCJP) exam is considered one of the hardest 
in the IT industry, and we can tell you from experience that a large chunk of exam 
candidates go in to the test unprepared. As programmers, we tend to learn only what we 
need to complete our current project, given the insane deadlines we're usually under. Introduction xxv
But this exam attempts to prove your complete understanding of the Java language, 
not just the parts of it you've become familiar with in your work. Experience alone will rarely get you through this exam with a passing mark, 
because even the things you think you know might work just a little different than 
you imagined. It isn't enough to be able to get your code to work correctly; you must 
understand the core fundamentals in a deep way, and with enough breadth to cover 
virtually anything that could crop up in the course of using the language. The Sun Certified Developer Exam (covered in chapters that are contained on 
the CD) is unique to the IT certification realm, because it actually evaluates your 
skill as a developer rather than simply your knowledge of the language or tools. Becoming a Certified Java Developer is, by definition, a development experience. Who Cares About Certiﬁ cation? Employers do. Headhunters do. Programmers do. Sun's programmer exam has been 
considered the fastest-growing certification in the IT world, and the number of 
candidates taking the exam continues to grow each year. Passing this exam proves 
three important things to a current or prospective employer: you're smart; you know 
how to study and prepare for a challenging test; and, most of all, you know the Java 
language. If an employer has a choice between a candidate who has passed the exam 
and one who hasn't, the employer knows that the certified programmer does not 
have to take time to learn the Java language. But does it mean that you can actually develop software in Java? Not necessarily, 
but it's a good head start. To really demonstrate your ability to develop (as opposed 
to just your knowledge of the language), you should consider pursuing the Developer 
Exam, where you're given an assignment to build a program, start to finish, and 
submit it for an assessor to evaluate and score. Sun's Certification Program
Currently there are eight Java certification exams (although several of them might 
have more than one live version). The Associate exam, the Programmer exam, and 
the Developer exam are all associated with the Java Standard Edition. The Web 
Component exam, the Business Component exam, the Web Services exam, and the 
Enterprise Architect exam are all associated with the Java Enterprise Edition. The 
Mobile Application exam is associated with the Java Micro Edition. xxvi SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
The Associate, Programmer, Web Component, Business Component, Web 
Services, and Mobile Application exams are exclusively multiple-choice and drag-
and-drop exams taken at a testing center, while the Developer and Architect exams 
also involve submitting a project. The Associate Exam (CX-310-019)
Sun Certified Java Associate (SCJA)
The Associate exam is for candidates just entering an application development or a 
software project management career using Java technologies. This exam tests basic 
knowledge of object-oriented concepts, the basics of UML, the basics of the Java 
programming language, and general knowledge of Java Platforms and Technologies. This exam has no prerequisites. The Programmer Exams (CX-310-065)
Sun Certified Java Programmer (SCJP) for Java 6
The Programmer exam is designed to test your knowledge of the Java programming 
language itself. It requires detailed knowledge of language syntax, core concepts, 
and a number of common application programming interfaces (APIs). This exam 
also tests intermediate knowledge of object-oriented design concepts. It does not 
test any issues related to architecture, and it does not ask why one approach is better 
than another, but rather it asks whether the given approach works in a particular 
situation. This exam has no prerequisites. As of May, 2008, two older versions of this 
exam are still available, the 1.4 and the 5.0. The Developer Exam (CX-310-252A, CX-310-027)
Sun Certified Java Developer (SCJD) 
The Developer exam picks up where the Programmer exam leaves off. Passing 
the Programmer exam is required before you can start the Developer exam. The 
Developer exam requires you to develop an actual program and then defend your 
design decisions. It is designed to test your understanding of why certain approaches 
are better than others in certain circumstances, and to prove your ability to follow a 
specification and implement a correct, functioning, and user-friendly program. The Developer exam consists of two pieces: a project assignment and a follow-up 
essay exam. Candidates have an unlimited amount of time to complete the project, 
but once the project is submitted, the candidate then must go to a testing center and 
complete a short follow-up essay exam, designed primarily to validate and verify that 
it was you who designed and built the project. Introduction xxvii
The Web Component Developer Exam (CX-310-083)
Sun Certified Web Component Developer for Java EE Platform (SCWCD)
The web developer exam is for those who are using Java servlet and JSP (Java Server 
Pages) technologies to build Web applications. It's based on the Servlet and JSP 
specifications defined in the Java Enterprise Edition (Java EE). This exam requires 
that the candidate is a Sun Certified Java Programmer. The Business Component Developer Exam (CX-310-091)
Sun Certified Business Component Developer for Java EE Platform (SCBCD)
The business component developer exam is for those candidates who are using Java 
EJB technology to build business-tier applications. The exam is based on the EJB 
specification defined in the Java Enterprise Edition (Java EE). This exam requires 
that the candidate is a Sun Certified Java Programmer. The Web Services Developer Exam (CX-310-220)
Sun Certified Developer for Web Services for Java EE Platform (SCDJWS)
The web services exam is for those candidates who are building applications using 
Java EE and Java Web Services Developer Pack technologies. This exam requires 
that the candidate is a Sun Certified Java Programmer. The Architect Exam (CX-310-052, CX-310-301A, CX-310-062)
Sun Certified Enterprise Architect for J2EE Technology (SCEA)
This certification is for enterprise architects, and thus does not require that the 
candidate pass the Programmer exam. The Architect exam is in three pieces: a 
knowledge-based multiple-choice exam, an architectural design assignment, and 
a follow-up essay exam. You must successfully pass the multiple-choice exam 
before registering and receiving the design assignment. The Mobile Exam (CX-310-110)
Sun Certified Mobile Application Developer for Java ME (SCMAD)
The mobile application developer exam is for candidates creating applications for 
cell phones or other Java enabled devices. The exam covers the Java Technology for 
Wireless Industry (JTWI) specification, the Wireless Messaging API, and Mobile 
Media APIs. This exam requires that the candidate is an SCJP . xxviii SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
T aking the Programmer's Exam
In a perfect world, you would be assessed for your true knowledge of a subject, not 
simply how you respond to a series of test questions. But life isn't perfect, and it just 
isn't practical to evaluate everyone's knowledge on a one-to-one basis. For the majority of its certifications, Sun evaluates candidates using a computer-
based testing service operated by Sylvan Prometric. This service is quite popular in 
the industry, and it is used for a number of vendor certification programs, including 
Novell's CNE and Microsoft's MCSE. Thanks to Sylvan Prometric's large number 
of facilities, exams can be administered worldwide, generally in the same town as a 
prospective candidate. For the most part, Sylvan Prometric exams work similarly from vendor to 
vendor. However, there is an important fact to know about Sun's exams: they use 
the traditional Sylvan Prometric test format, not the newer adaptive format. This 
gives the candidate an advantage, since the traditional format allows answers to be 
reviewed and revised during the test. To discourage simple memorization, Sun exams present a potentially different 
set of questions to different candidates. In the development of the exam, hundreds 
of questions are compiled and refined using beta testers. From this large collection, 
questions are pulled together from each objective and assembled into many different 
versions of the exam. Each Sun exam has a specific number of questions (the Programmer's exam 
contains 72 questions) and test duration (210 minutes for the Programmer's exam) is 
designed to be generous. The time remaining is always displayed in the corner of the 
testing screen, along with the number of remaining questions. If time expires during 
an exam, the test terminates, and incomplete answers are counted as incorrect. Many experienced test takers do not go back and change answers 
unless they have a good reason to do so. Only change an answer when you feel you may 
have misread or misinterpreted the question the ﬁ  rst time. Nervousness may make you 
second-guess every answer and talk yourself out of a correct one. Introduction xxix
When you ﬁ  nd yourself stumped answering multiple-choice questions, 
use your scratch paper to write down the two or three answers you consider the 
strongest, then underline the answer you feel is most likely correct. Here is an example of 
what your scratch paper might look like when you've gone through the test once:
21. B or C
33. A or C
This is extremely helpful when you mark the question and continue on. You can then return to the question and immediately pick up your thought process 
where you left off. Use this technique to avoid having to re-read and re-think questions. You will also need to use your scratch paper during complex, text-based scenario 
questions to create visual images to better understand the question. This technique is 
especially helpful if you are a visual learner. At the end of the exam, your test is immediately graded, and the results 
are displayed on the screen. Scores for each subject area are also provided, but 
the system will not indicate which specific questions were missed. A report 
is automatically printed at the proctor's desk for your files. The test score is 
electronically transmitted back to Sun. Question Format
Sun's Java exams pose questions in either multiple-choice or drag-and-drop formats. Multiple Choice Questions
In earlier versions of the exam, when you encountered a multiple-choice question 
you were not told how many answers were correct, but with each version of the 
exam, the questions have become more difficult, so today each multiple-choice 
question tells you how many answers to choose. The Self Test questions at the end 
of each chapter are closely matched to the format, wording, and difficulty of the real 
exam questions, with two exceptions:
xxx SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
■ Whenever we can, our questions will NOT tell you how many correct 
answers exist (we will say "Choose all that apply"). We do this to help you 
master the material. Some savvy test-takers can eliminate wrong answers 
when the number of correct answers is known. It's also possible, if you know 
how many answers are correct, to choose the most plausible answers. Our job 
is to toughen you up for the real exam! ■ The real exam typically numbers lines of code in a question. Sometimes we do 
not number lines of code—mostly so that we have the space to add comments 
at key places. On the real exam, when a code listing starts with line 1, it 
means that you're looking at an entire source file. If a code listing starts at a 
line number greater than 1, that means you're looking at a partial source file. When looking at a partial source file, assume that the code you can't see is 
correct. (For instance, unless explicitly stated, you can assume that a partial 
source file will have the correct import and package statements.) 
Drag-and-Drop Questions
Although many of the other Sun Java certification exams have been using drag-
and-drop questions for several years, this is the first version of the SCJP exam that 
includes drag-and-drop questions. As we discussed earlier, the exam questions you 
receive are randomized, but you should expect that about 20–25% of the questions 
you encounter will be drag-and-drop style. Drag-and-drop questions typically consist of three components:
■ A scenario A short description of the task you are meant to complete. ■ A partially completed task A code listing, a table, or a directory tree. The 
partially completed task will contain empty slots, which are indicated with 
(typically yellow) boxes. These boxes need to be filled to complete the task. ■ A set of possible "fragment" answers You will click on fragments 
(typically blue boxes) and drag-and-drop them into the correct empty slots. The question's scenario will tell you whether you can reuse fragments. Most drag-and-drop questions will have anywhere from 4 to 10 empty slots to fill, 
and typically a few more fragments than are needed (usually some fragments are left 
unused). Drag-and-drop questions are often the most complex on the exam, and the 
number of possible answer combinations makes them almost impossible to guess. Introduction xxxi
In regards to drag-and-drop questions, there is a huge problem with the 
testing software at many of the Prometric centers world-wide. In general, the testing 
software allows you to review questions you've already answered as often as you'd like. In the case of drag-and-drop questions, however, many candidates have 
reported that if they choose to review a question, the software will erase their previous 
answer! BE CAREFUL! Until this problem is corrected, we recommend that you keep a 
list of which questions are drag and drop, so that you won't review one unintentionally. Another good idea is to write down your drag-and-drop answers so that if one gets 
erased it will be less painful to recreate the answer. This brings us to another issue that some candidates have reported. The 
testing center is supposed to provide you with sufﬁ  cient writing implements so that you 
can work problems out "on paper." In some cases, the centers have provided inadequate 
markers and dry-erase boards which are too small and cumbersome to use effectively. We 
recommend that you call ahead and verify that you will be supplied with actual pencils 
and at least several sheets of blank paper. Tips on T aking the Exam
There are 72 questions on the 310-065 (Java 6) exam. You will need to get at least 
47 of them correct to pass—around 65%. You are given over three hours to complete 
the exam. This information is subject to change. Always check with Sun before 
taking the exam, at www.suned.sun.com. You are allowed to answer questions in any order, and you can go back and check 
your answers after you've gone through the test. There are no penalties for wrong 
answers, so it's better to at least attempt an answer than to not give one at all. A good strategy for taking the exam is to go through once and answer all the 
questions that come to you quickly. You can then go back and do the others. Answering one question might jog your memory for how to answer a previous one. Be very careful on the code examples. Check for syntax errors first: count curly 
braces, semicolons, and parenthesis and then make sure there are as many left ones 
as right ones. Look for capitalization errors and other such syntax problems before 
trying to figure out what the code does. Many of the questions on the exam will hinge on subtleties of syntax. You will 
need to have a thorough knowledge of the Java language in order to succeed. xxxii SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
Tips on Studying for the Exam
First and foremost, give yourself plenty of time to study. Java is a complex 
programming language, and you can't expect to cram what you need to know into 
a single study session. It is a field best learned over time, by studying a subject and 
then applying your knowledge. Build yourself a study schedule and stick to it, but 
be reasonable about the pressure you put on yourself, especially if you're studying in 
addition to your regular duties at work. One easy technique to use in studying for certification exams is the 15-minutes- 
per-day effort. Simply study for a minimum of 15 minutes every day. It is a small but 
significant commitment. If you have a day where you just can't focus, then give up 
at 15 minutes. If you have a day where it flows completely for you, study longer. As 
long as you have more of the "flow days," your chances of succeeding are excellent. We strongly recommend you use flash cards when preparing for the Programmer's 
exam. A flash card is simply a 3 x 5 or 4 x 6 index card with a question on the 
front, and the answer on the back. You construct these cards yourself as you go 
through a chapter, capturing any topic you think might need more memorization 
or practice time. You can drill yourself with them by reading the question, thinking 
through the answer, and then turning the card over to see if you're correct. Or you 
can get another person to help you by holding up the card with the question facing 
you, and then verifying your answer. Most of our students have found these to be 
tremendously helpful, especially because they're so portable that while you're in 
study mode, you can take them everywhere. Best not to use them while driving, 
though, except at red lights. We've taken ours everywhere—the doctor's office, 
restaurants, theaters, you name it. Certification study groups are another excellent resource, and you won't find a 
larger or more willing community than on the JavaRanch.com Big Moose Saloon 
certification forums. If you have a question from this book, or any other mock exam 
question you may have stumbled upon, posting a question in a certification forum 
will get you an answer, in nearly all cases, within a day—usually, within a few hours. You'll find us (the authors) there several times a week, helping those just starting 
out on their exam preparation journey. (You won't actually think of it as anything as 
pleasant-sounding as a "journey" by the time you're ready to take the exam.)
Finally, we recommend that you write a lot of little Java programs! During the 
course of writing this book we wrote hundreds of small programs, and if you listen to 
what the most successful candidates say (you know, those guys who got 98%), they 
almost always report that they wrote a lot of code. Introduction xxxiii
Scheduling Y our Exam
The Sun exams are purchased directly from Sun, but are scheduled through Sylvan 
Prometric. For locations outside the United States, your local number can be found 
on Sylvan's Web site at http://www.2test.com. Sylvan representatives can schedule 
your exam, but they don't have information about the certification programs. Questions about certifications should be directed to Sun's Worldwide Training 
department. These representatives are familiar enough with the exams to find 
them by name, but it's best if you have the exam number handy when you call. You 
wouldn't want to be scheduled and charged for the wrong exam. Exams can be scheduled up to a year in advance, although it's really not necessary. Generally, scheduling a week or two ahead is sufficient to reserve the day and time 
you prefer. When scheduling, operators will search for testing centers in your area. For convenience, they can also tell which testing centers you've used before. When registering for the exam, you will be asked for your ID number. This 
number is used to track your exam results back to Sun. It's important that you use 
the same ID number each time you register, so that Sun can follow your progress. Address information provided when you first register is also used by Sun to ship 
certificates and other related material. In the United States, your Social Security 
Number is commonly used as your ID number. However, Sylvan can assign you a 
unique ID number if you prefer not to use your Social Security Number. Arriving at the Exam
As with any test, you'll be tempted to cram the night before. Resist that temptation. You should know the material by this point, and if you're groggy in the morning, you 
won't remember what you studied anyway. Get a good night's sleep. Arrive early for your exam; it gives you time to relax and review key facts. Take 
the opportunity to review your notes. If you get burned out on studying, you can 
usually start your exam a few minutes early. We don't recommend arriving late. Your 
test could be cancelled, or you might not have enough time to complete the exam. When you arrive at the testing center, you'll need to sign in with the exam 
administrator. In order to sign in, you need to provide two forms of identification. Acceptable forms include government-issued IDs (for example, passport or driver's 
license), credit cards, and company ID badges. One form of ID must include a 
photograph. They just want to be sure that you don't send your brilliant Java guru 
next-door-neighbor-who-you've-paid to take the exam for you. Aside from a brain full of facts, you don't need to bring anything else to the 
exam room. In fact, your brain is about all you're allowed to take into the exam! xxxiv SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
All the tests are closed-book, meaning you don't get to bring any reference materials 
with you. You're also not allowed to take any notes out of the exam room. The test 
administrator will provide you with paper and a pencil. Some testing centers may 
provide a small marker board instead (we recommend that you don't settle for a 
whiteboard). We do recommend that you bring a water bottle. Three hours is a long 
time to keep your brain active, and it functions much better when well hydrated. Leave your pager and telephone in the car, or turn them off. They only add stress 
to the situation, since they are not allowed in the exam room, and can sometimes 
still be heard if they ring outside of the room. Purses, books, and other materials 
must be left with the administrator before entering the exam. Once in the testing room, the exam administrator logs onto your exam, and you 
have to verify that your ID number and the exam number are correct. If this is the 
first time you've taken a Sun test, you can select a brief tutorial of the exam software. Before the test begins, you will be provided with facts about the exam, including the 
duration, the number of questions, and the score required for passing. The odds are 
good that you will be asked to fill out a brief survey before the exam actually begins. This survey will ask you about your level of Java experience. The time you spend on 
the survey is NOT deducted from your actual test time—nor do you get more time 
if you fill out the survey quickly. Also remember that the questions you get on the 
exam will NOT change depending on how you answer the survey questions. Once 
you're done with the survey, the real clock starts ticking and the fun begins. The testing software is Windows-based, but you won't have access to the main 
desktop or any of the accessories. The exam is presented in full screen, with a single 
question per screen. Navigation buttons allow you to move forward and backward 
between questions. In the upper-right corner of the screen, counters show the 
number of questions and time remaining. Most important, there is a Mark check 
box in the upper-left corner of the screen—this will prove to be a critical tool, as 
explained in the next section. T est-T aking T echniques
Without a plan of attack, candidates can become overwhelmed by the exam or 
become side-tracked and run out of time. For the most part, if you are comfortable 
with the material, the allotted time is more than enough to complete the exam. The 
trick is to keep the time from slipping away during any one particular problem. Your obvious goal is to answer the questions correctly and quickly, but other 
factors can distract you. Here are some tips for taking the exam more efficiently. Introduction xxxv
Size Up the Challenge
First, take a quick pass through all the questions in the exam. "Cherry-pick" the easy 
questions, answering them on the spot. Briefly read each question, noticing the type 
of question and the subject. As a guideline, try to spend less than 25 percent of your 
testing time in this pass. This step lets you assess the scope and complexity of the exam, and it helps you 
determine how to pace your time. It also gives you an idea of where to find potential 
answers to some of the questions. Sometimes the wording of one question might 
lend clues or jog your thoughts for another question. If you're not entirely confident in your answer to a question, answer it anyway, 
but check the Mark box to flag it for later review. In the event that you run out of 
time, at least you've provided a "first guess" answer, rather than leaving it blank. Second, go back through the entire test, using the insight you gained from the 
first go-through. For example, if the entire test looks difficult, you'll know better 
than to spend more than a minute or two on each question. Create a pacing with 
small milestones—for example, "I need to answer 10 questions every 25 minutes."
At this stage, it's probably a good idea to skip past the time-consuming questions, 
marking them for the next pass. Try to finish this phase before you're 50–60 percent 
through the testing time. Third, go back through all the questions you marked for review, using the Review 
Marked button in the question review screen. This step includes taking a second 
look at all the questions you were unsure of in previous passes, as well as tackling the 
time-consuming ones you deferred until now. Chisel away at this group of questions 
until you've answered them all. If you're more comfortable with a previously marked question, unmark the 
Review Marked button now. Otherwise, leave it marked. Work your way through 
the time-consuming questions now, especially those requiring manual calculations. Unmark them when you're satisfied with the answer. By the end of this step, you've answered every question in the test, despite having 
reservations about some of your answers. If you run out of time in the next step, at 
least you won't lose points for lack of an answer. You're in great shape if you still 
have 10–20 percent of your time remaining. Review Y our Answers
Now you're cruising!

--- Chunk #1247 ---
You've answered all the questions, and you're ready to do 
a quality check. Take yet another pass (yes, one more) through the entire test 
xxxvi SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
(although you'll probably want to skip a review of the drag-and-drop questions!), 
briefly re-reading each question and your answer. Carefully look over the questions again to check for "trick" questions. Be 
particularly wary of those that include a choice of "Does not compile." Be alert for 
last-minute clues. You're pretty familiar with nearly every question at this point, and 
you may find a few clues that you missed before. The Grand Finale
When you're confident with all your answers, finish the exam by submitting it for 
grading. After what will seem like the longest 10 seconds of your life, the testing 
software will respond with your score. This is usually displayed as a bar graph, 
showing the minimum passing score, your score, and a PASS/FAIL indicator. If you're curious, you can review the statistics of your score at this time. Answers 
to specific questions are not presented; rather, questions are lumped into categories, 
and results are tallied for each category. This detail is also on a report that has been 
automatically printed at the exam administrator's desk. As you leave, you'll need to leave your scratch paper behind or return it to the 
administrator. (Some testing centers track the number of sheets you've been given, 
so be sure to return them all.) In exchange, you'll receive a copy of the test report. This report will be embossed with the testing center's seal, and you should keep 
it in a safe place. Normally, the results are automatically transmitted to Sun, but 
occasionally you might need the paper report to prove that you passed the exam. In a few weeks, Sun will send you a package in the mail containing a nice paper 
certificate, a lapel pin, and a letter. You may also be sent instructions for how to 
obtain artwork for a logo that you can use on personal business cards. Re-T esting
If you don't pass the exam, don't be discouraged. Try to have a good attitude about 
the experience, and get ready to try again. Consider yourself a little more educated. You know the format of the test a little better, and the report shows which areas you 
need to strengthen. If you bounce back quickly, you'll probably remember several of the questions you 
might have missed. This will help you focus your study efforts in the right area. Ultimately, remember that Sun certifications are valuable because they're hard to 
get. After all, if anyone could get one, what value would it have? In the end, it takes 
a good attitude and a lot of studying, but you can do it! 1
Declarations and
Access Control
CERTIFICATION OBJECTIVES
l    Declare Classes & Interfaces
 l     Develop Interfaces & 
        Abstract Classes
 l     Use Primitives,  Arrays, Enums, &
       Legal Identifiers
 
 l   Use Static Methods, JavaBeans 
        Naming, & Var-Args
 ✓   T wo-Minute Drill
        Q&A Self T est
 
	
2 Chapter 1:  Declarations and Access Control
W 
e assume that because you're planning on becoming certified, you already know 
the basics of Java. If you're completely new to the language, this chapter—and the 
rest of the book—will be confusing; so be sure you know at least the basics of the 
language before diving into this book. That said, we're starting with a brief, high-level refresher to 
put you back in the Java mood, in case you've been away for awhile. Java Refresher
A Java program is mostly a collection of objects talking to other objects by invoking 
each other's methods. Every object is of a certain type, and that type is defined by a 
class or an interface. Most Java programs use a collection of objects of many different 
types. ■ Class A template that describes the kinds of state and behavior that objects 
of its type support. ■ Object At runtime, when the Java Virtual Machine (JVM) encounters the 
new keyword, it will use the appropriate class to make an object which is an 
instance of that class. That object will have its own state, and access to all of 
the behaviors defined by its class. ■ State (instance variables) Each object (instance of a class) will have its 
own unique set of instance variables as defined in the class. Collectively, the 
values assigned to an object's instance variables make up the object's state. ■ Behavior (methods) When a programmer creates a class, she creates meth-
ods for that class. Methods are where the class' logic is stored. Methods are 
where the real work gets done. They are where algorithms get executed, and 
data gets manipulated. Identifiers and Keywords
All the Java components we just talked about—classes, variables, and methods—
need names. In Java these names are called identifiers, and, as you might expect, 
there are rules for what constitutes a legal Java identifier. Beyond what's legal, 
Java Refresher 3
though, Java programmers (and Sun) have created conventions for naming methods, 
variables, and classes. Like all programming languages, Java has a set of built-in keywords. These 
keywords must not be used as identifiers. Later in this chapter we'll review the details 
of these naming rules, conventions, and the Java keywords. Inheritance
Central to Java and other object-oriented (OO) languages is the concept of 
inheritance, which allows code defined in one class to be reused in other classes. In 
Java, you can define a general (more abstract) superclass, and then extend it with 
more specific subclasses. The superclass knows nothing of the classes that inherit from 
it, but all of the subclasses that inherit from the superclass must explicitly declare the 
inheritance relationship. A subclass that inherits from a superclass is automatically 
given accessible instance variables and methods defined by the superclass, but is also 
free to override superclass methods to define more specific behavior. For example, a Car superclass class could define general methods common to all 
automobiles, but a Ferrari subclass could override the accelerate() method. Interfaces
A powerful companion to inheritance is the use of interfaces. Interfaces are like a 
100-percent abstract superclass that defines the methods a subclass must support, but 
not how they must be supported. In other words, an Animal interface might declare 
that all Animal implementation classes have an eat() method, but the Animal 
interface doesn't supply any logic for the eat() method. That means it's up to the 
classes that implement the Animal interface to define the actual code for how that 
particular Animal type behaves when its eat() method is invoked. Finding Other Classes
As we'll see later in the book, it's a good idea to make your classes cohesive. That 
means that every class should have a focused set of responsibilities. For instance, 
if you were creating a zoo simulation program, you'd want to represent aardvarks 
with one class, and zoo visitors with a different class. In addition, you might have 
a Zookeeper class, and a Popcorn vendor class. The point is that you don't want a 
class that has both Aardvark and Popcorn behaviors (more on that in Chapter 2). Even a simple Java program uses objects from many different classes: some that 
you created, and some built by others (such as Sun's Java API classes). Java organizes 
classes into packages, and uses import statements to give programmers a consistent 
way to manage naming of, and access to, classes they need. The exam covers a lot of 
concepts related to packages and class access; we'll explore the details in this—and 
later—chapters. CERTIFICATION OBJECTIVE
Identifiers & JavaBeans (Objectives 1.3 and 1.4)
1.3 Develop code that declares, initializes, and uses primitives, arrays, enums, and 
objects as static, instance, and local variables. Also, use legal identifiers for variable names. 1.4 Develop code that declares both static and non-static methods, and—if appropriate—
use method names that adhere to the JavaBeans naming standards. Also develop code that 
declares and uses a variable-length argument list. Remember that when we list one or more Certification Objectives in the book, 
as we just did, it means that the following section covers at least some part of that 
objective. Some objectives will be covered in several different chapters, so you'll see 
the same objective in more than one place in the book. For example, this section 
covers declarations, identifiers, and JavaBeans naming, but using the things you 
declare is covered primarily in later chapters. So, we'll start with Java identifiers. The three aspects of Java identifiers that we 
cover here are
■ Legal Identifiers The rules the compiler uses to determine whether a 
name is legal. ■ Sun's Java Code Conventions Sun's recommendations for naming classes, 
variables, and methods. We typically adhere to these standards throughout 
the book, except when we're trying to show you how a tricky exam question 
might be coded. You won't be asked questions about the Java Code Conven-
tions, but we strongly recommend that programmers use them. ■ JavaBeans Naming Standards The naming requirements of the JavaBeans 
specification. You don't need to study the JavaBeans spec for the exam, 
but you do need to know a few basic JavaBeans naming rules we cover in 
this chapter. 4 Chapter 1:  Declarations and Access Control
Legal Identiﬁ ers
Technically, legal identifiers must be composed of only Unicode characters, 
numbers, currency symbols, and connecting characters (like underscores). The 
exam doesn't dive into the details of which ranges of the Unicode character set are 
considered to qualify as letters and digits. So, for example, you won't need to know 
that Tibetan digits range from \u0420 to \u0f29. Here are the rules you do need 
to know:
■ Identifiers must start with a letter, a currency character ($), or a connecting 
character such as the underscore ( _ ). Identifiers cannot start with a number! ■ After the first character, identifiers can contain any combination of letters, 
currency characters, connecting characters, or numbers. ■ In practice, there is no limit to the number of characters an identifier can 
contain. ■ You can't use a Java keyword as an identifier. Table 1-1 lists all of the Java 
keywords including one new one for 5.0, enum. ■ Identifiers in Java are case-sensitive; foo and FOO are two different identifiers. Examples of legal and illegal identifiers follow, first some legal identifiers:
int _a;  
int $c;  
int ______2_w; 
int _$;  
int this_is_a_very_detailed_name_for_an_identifier;
The following are illegal (it's your job to recognize why):
int :b;
int -d;  
int e#;
int .f;
int 7g;
 Legal Identiﬁ  ers (Exam Objectives 1.3 and 1.4) 5
 abstract  boolean  break  byte  case  catch
 char  class  const  continue  default  do
 double  else  extends  ﬁ  nal  ﬁ  nally  ﬂ  oat
 for goto  if  implements  import  instanceof
 int  interface  long  native  new  package
 private  protected  public  return  short  static
 strictfp  super  switch  synchronized this  throw
 throws  transient  try void  volatile  while
assert enum
Sun's Java Code Conventions
Sun estimates that over the lifetime of a standard piece of code, 20 percent of the 
effort will go into the original creation and testing of the code, and 80 percent 
of the effort will go into the subsequent maintenance and enhancement of the 
code. Agreeing on, and coding to, a set of code standards helps to reduce the effort 
involved in testing, maintaining, and enhancing any piece of code.

--- Chunk #1248 ---
Sun has created 
a set of coding standards for Java, and published those standards in a document 
cleverly titled "Java Code Conventions," which you can find at java.sun.com. It's 
a great document, short and easy to read and we recommend it highly. That said, you'll find that many of the questions in the exam don't follow the 
code conventions, because of the limitations in the test engine that is used to deliver 
the exam internationally. One of the great things about the Sun certifications is that 
the exams are administered uniformly throughout the world. In order to achieve 
that, the code listings that you'll see in the real exam are often quite cramped, 
and do not follow Sun's code standards. In order to toughen you up for the exam, 
we'll often present code listings that have a similarly cramped look and feel, often 
indenting our code only two spaces as opposed to the Sun standard of four. We'll also jam our curly braces together unnaturally, and sometimes put several 
statements on the same line…ouch!

--- Chunk #1249 ---
For example:
 1. class Wombat implements Runnable {
 2. private int i;
 3. public synchronized void run() { 
 4. if (i%5 != 0) { i++; }
 5. for(int x=0; x<5; x++, i++) 
6 Chapter 1:  Declarations and Access Control
 TABLE 1-1   Complete List of Java Keywords  (assert added in 1.4, enum added in 1.5)
 6. { if (x > 1) Thread.yield(); }
 7. System.out.print(i + " ");
 8. }
 9. public static void main(String[] args) {
10. Wombat n = new Wombat();
11. for(int x=100; x>0; --x) { new Thread(n).start(); }
12. } }
Consider yourself forewarned—you'll see lots of code listings, mock questions, and 
real exam questions that are this sick and twisted.

--- Chunk #1250 ---
Nobody wants you to write your 
code like this. Not your employer, not your coworkers, not us, not Sun, and not the 
exam creation team! Code like this was created only so that complex concepts could 
be tested within a universal testing tool. The one standard that is followed as much 
as possible in the real exam are the naming standards. Here are the naming standards 
that Sun recommends, and that we use in the exam and in most of the book:
■ Classes and interfaces The first letter should be capitalized, and if several 
words are linked together to form the name, the first letter of the inner words 
should be uppercase (a format that's sometimes called "camelCase"). For 
classes, the names should typically be nouns. For example: 
  Dog 
  Account
  PrintWriter
 For interfaces, the names should typically be adjectives like
  Runnable
  Serializable
■ Methods The first letter should be lowercase, and then normal camelCase 
rules should be used. In addition, the names should typically be verb-noun 
pairs. For example:
  getBalance
  doCalculation
  setCustomerName
Sun’s Java Code Conventions (Exam Objectives 1.3 and 1.4) 7
■ Variables Like methods, the camelCase format should be used, starting with 
a lowercase letter. Sun recommends short, meaningful names, which sounds 
good to us. Some examples:
  buttonWidth
  accountBalance
  myString
■ Constants Java constants are created by marking variables static and 
final. They should be named using uppercase letters with underscore 
characters as separators:
  MIN_HEIGHT
JavaBeans Standards
The JavaBeans spec is intended to help Java developers create Java components 
that can be easily used by other Java developers in a visual Integrated Development 
Environment (IDE) tool (like Eclipse or NetBeans). As a Java programmer, you 
want to be able to use components from the Java API, but it would be great if you 
could also buy the Java component you want from "Beans 'R Us," that software 
company down the street. And once you've found the components, you'd like to be 
able to access them through a development tool in such a way that you don't have 
to write all your code from scratch. By using naming rules, the JavaBeans spec helps 
guarantee that tools can recognize and use components built by different developers. The JavaBeans API is quite involved, but you'll need to study only a few basics for 
the exam. First, JavaBeans are Java classes that have properties. For our purposes, think of 
properties as private instance variables. Since they're private, the only way 
they can be accessed from outside of their class is through methods in the class. The 
methods that change a property's value are called setter methods, and the methods 
that retrieve a property's value are called getter methods. The JavaBean naming rules 
that you'll need to know for the exam are the following:
JavaBean Property Naming Rules
■ If the property is not a boolean, the getter method's prefix must be get. For 
example, getSize()is a valid JavaBeans getter name for a property named 
"size." Keep in mind that you do not need to have a variable named size 
8 Chapter 1:  Declarations and Access Control
(although some IDEs expect it). The name of the property is inferred from the 
getters and setters, not through any variables in your class. What you return 
from getSize() is up to you. ■ If the property is a boolean, the getter method's prefix is either get or is. For 
example, getStopped() or isStopped() are both valid JavaBeans names for 
a boolean property. ■ The setter method's prefix must be set. For example, setSize() is the valid 
JavaBean name for a property named size. ■ To complete the name of a getter or setter method, change the first letter of 
the property name to uppercase, and then append it to the appropriate prefix 
(get, is, or set). ■ Setter method signatures must be marked public, with a void return type 
and an argument that represents the property type. ■ Getter method signatures must be marked public, take no arguments, and 
have a return type that matches the argument type of the setter method for 
that property. Second, the JavaBean spec supports events, which allow components to notify 
each other when something happens. The event model is often used in GUI 
applications when an event like a mouse click is multicast to many other objects 
that may have things to do when the mouse click occurs. The objects that receive 
the information that an event occurred are called listeners. For the exam, you need to 
know that the methods that are used to add or remove listeners from an event must 
also follow JavaBean naming standards: 
JavaBean Listener Naming Rules
■ Listener method names used to "register" a listener with an event source 
must use the prefix add, followed by the listener type. For example, 
addActionListener() is a valid name for a method that an event source 
will have to allow others to register for Action events. ■ Listener method names used to remove ("unregister") a listener must use 
the prefix remove, followed by the listener type (using the same rules as the 
registration add method). ■ The type of listener to be added or removed must be passed as the argument 
to the method. ■ Listener method names must end with the word "Listener". JavaBeans Standards (Exam Objectives 1.3 and 1.4) 9
Examples of valid JavaBean method signatures are
public void setMyValue(int v)
public int getMyValue()
public boolean isMyStatus()
public void addMyListener(MyListener m)
public void removeMyListener(MyListener m)
Examples of invalid JavaBean method signatures are
void setCustomerName(String s)         // must be public
public void modifyMyValue(int v)       // can't use 'modify'
public void addXListener(MyListener m) // listener type mismatch
CERTIFICATION OBJECTIVE
Declare Classes (Exam Objective 1.1)
1.1 Develop code that declares classes (including abstract and all forms of nested classes), 
interfaces, and enums, and includes the appropriate use of package and import statements 
(including static imports). 10 Chapter 1:  Declarations and Access Control
The objective says you have to know legal identiﬁ  ers only for variable 
names, but the rules are the same for ALL Java components. So remember that a legal 
identiﬁ  er for a variable is also a legal identiﬁ  er for a method or a class. However, you 
need to distinguish between legal identiﬁ  ers and naming conventions, such as the 
JavaBeans standards, that indicate how a Java component should be named. In other 
words, you must be able to recognize that an identiﬁ  er is legal even if it doesn’t conform 
to naming standards. If the exam question is asking about naming conventions—not just 
whether an identiﬁ  er will compile—JavaBeans will be mentioned explicitly. When you write code in Java, you're writing classes or interfaces. Within those 
classes, as you know, are variables and methods (plus a few other things). How you 
declare your classes, methods, and variables dramatically affects your code's behavior. For example, a public method can be accessed from code running anywhere in your 
application. Mark that method private, though, and it vanishes from everyone's 
radar (except the class in which it was declared). For this objective, we'll study 
the ways in which you can declare and modify (or not) a class. You'll find that we 
cover modifiers in an extreme level of detail, and though we know you're already 
familiar with them, we're starting from the very beginning. Most Java programmers 
think they know how all the modifiers work, but on closer study often find out that 
they don't (at least not to the degree needed for the exam). Subtle distinctions 
are everywhere, so you need to be absolutely certain you're completely solid on 
everything in this section's objectives before taking the exam. Source File Declaration Rules
Before we dig into class declarations, let's do a quick review of the rules associated 
with declaring classes, import statements, and package statements in a source file:
■ There can be only one public class per source code file. ■ Comments can appear at the beginning or end of any line in the source code 
file; they are independent of any of the positioning rules discussed here. ■ If there is a public class in a file, the name of the file must match the name 
of the public class. For example, a class declared as public class Dog { } 
must be in a source code file named Dog.java. ■ If the class is part of a package, the package statement must be the first line 
in the source code file, before any import statements that may be present. ■ If there are import statements, they must go between the package statement 
(if there is one) and the class declaration. If there isn't a package statement, 
then the import statement(s) must be the first line(s) in the source code file. If there are no package or import statements, the class declaration must be 
the first line in the source code file. ■ import and package statements apply to all classes within a source code file. In other words, there's no way to declare multiple classes in a file and have 
them in different packages, or use different imports. ■ A file can have more than one nonpublic class. Source File Declaration Rules (Exam Objective 1.1) 11
■ Files with no public classes can have a name that does not match any of the 
classes in the file. In Chapter 10 we'll go into a lot more detail about the rules involved with 
declaring and using imports, packages, and a feature new to Java 5, static imports. Class Declarations and Modiﬁ ers
Although nested (often called inner) classes are on the exam, we'll save nested class 
declarations for Chapter 8. You're going to love that chapter.

--- Chunk #1251 ---
No, really.

--- Chunk #1252 ---
Seriously. The following code is a bare-bones class declaration:
class MyClass { }
This code compiles just fine, but you can also add modifiers before the class 
declaration. Modifiers fall into two categories:
■ Access modifiers: public, protected, private. ■ Non-access modifiers (including strictfp, final, and abstract). We'll look at access modifiers first, so you'll learn how to restrict or allow access 
to a class you create. Access control in Java is a little tricky because there are four 
access controls (levels of access) but only three access modifiers. The fourth access 
control level (called default or package access) is what you get when you don't use 
any of the three access modifiers. In other words, every class, method, and instance 
variable you declare has an access control, whether you explicitly type one or not. Although all four access controls (which means all three modifiers) work for most 
method and variable declarations, a class can be declared with only public or 
default access; the other two access control levels don't make sense for a class, as 
you'll see. Java is a package-centric language; the developers assumed that for good 
organization and name scoping, you would put all your classes into packages. They were right, and you should. Imagine this nightmare: Three different 
programmers, in the same company but working on different parts of a 
project, write a class named Utilities. If those three Utilities classes have 
12 Chapter 1:  Declarations and Access Control
not been declared in any explicit package, and are in the classpath, you won't 
have any way to tell the compiler or JVM which of the three you're trying 
to reference. Sun recommends that developers use reverse domain names, 
appended with division and/or project names. For example, if your domain 
name is geeksanonymous.com, and you're working on the client code for 
the TwelvePointOSteps program, you would name your package something 
like com.geeksanonymous.steps.client. That would essentially change the 
name of your class to com.geeksanonymous.steps.client.Utilities. You 
might still have name collisions within your company, if you don't come up 
with your own naming schemes, but you're guaranteed not to collide with 
classes developed outside your company (assuming they follow Sun's naming 
convention, and if they don't, well, Really Bad Things could happen). Class Access
What does it mean to access a class? When we say code from one class (class A) has 
access to another class (class B), it means class A can do one of three things:
■ Create an instance of class B. ■ Extend class B (in other words, become a subclass of class B). ■ Access certain methods and variables within class B, depending on the access 
control of those methods and variables. In effect, access means visibility. If class A can't see class B, the access level of the 
methods and variables within class B won't matter; class A won't have any way to 
access those methods and variables. Default Access    A class with default access has no modifier preceding it in the 
declaration! It's the access control you get when you don't type a modifier in the 
class declaration. Think of default access as package-level access, because a class with 
default access can be seen only by classes within the same package. For example, if 
class A and class B are in different packages, and class A has default access, class B 
won't be able to create an instance of class A, or even declare a variable or return 
type of class A. In fact, class B has to pretend that class A doesn't even exist, or the 
compiler will complain. Look at the following source file:
Class Declarations and Modiﬁ  ers (Exam Objective 1.1) 13
package cert;
class Beverage { }
Now look at the second source file:
package exam.stuff;
import cert.Beverage;
class Tea extends Beverage { }
As you can see, the superclass (Beverage) is in a different package from the 
subclass (Tea). The import statement at the top of the Tea file is trying (fingers 
crossed) to import the Beverage class. The Beverage file compiles fine, but when we 
try to compile the Tea file we get something like:
Can't access class cert.Beverage. Class or interface must be 
public, in same package, or an accessible member class. import cert.Beverage;
Tea won't compile because its superclass, Beverage, has default access and is in 
a different package. You can do one of two things to make this work. You could put 
both classes in the same package, or you could declare Beverage as public, as the next 
section describes. When you see a question with complex logic, be sure to look at the access 
modifiers first. That way, if you spot an access violation (for example, a class in 
package A trying to access a default class in package B), you'll know the code won't 
compile so you don't have to bother working through the logic. It's not as if you 
don't have anything better to do with your time while taking the exam. Just choose 
the "Compilation fails" answer and zoom on to the next question. Public Access    A class declaration with the public keyword gives all classes 
from all packages access to the public class. In other words, all classes in the Java 
Universe (JU) have access to a public class. Don't forget, though, that if a public 
class you're trying to use is in a different package from the class you're writing, you'll 
still need to import the public class. In the example from the preceding section, we may not want to place the subclass 
in the same package as the superclass. To make the code work, we need to add the 
keyword public in front of the superclass (Beverage) declaration, as follows:
14 Chapter 1:  Declarations and Access Control
Class Declarations and Modiﬁ  ers (Exam Objective 1.1) 15
package cert;
public class Beverage { }
This changes the Beverage class so it will be visible to all classes in all packages. The class can now be instantiated from all other classes, and any class is now free to 
subclass (extend from) it—unless, that is, the class is also marked with the nonaccess 
modifier final. Read on. Other (Nonaccess) Class Modifiers
You can modify a class declaration using the keyword final, abstract, or 
strictfp. These modifiers are in addition to whatever access control is on the class, 
so you could, for example, declare a class as both public and final. But you can't 
always mix nonaccess modifiers. You're free to use strictfp in combination with 
final,  for example, but you must never, ever, ever mark a class as both final and 
abstract. You'll see why in the next two sections. You won't need to know how strictfp works, so we're focusing only on 
modifying a class as final or abstract. For the exam, you need to know only that 
strictfp is a keyword and can be used to modify a class or a method, but never a 
variable. Marking a class as strictfp means that any method code in the class will 
conform to the IEEE 754 standard rules for floating points. Without that modifier, 
floating points used in the methods might behave in a platform-dependent way. If 
you don't declare a class as strictfp, you can still get strictfp behavior on a 
method-by-method basis, by declaring a method as strictfp. If you don't know the 
IEEE 754 standard, now's not the time to learn it. You have, as we say, bigger fish to 
fry. Final Classes    When used in a class declaration, the final keyword means 
the class can't be subclassed. In other words, no other class can ever extend (inherit 
from) a final class, and any attempts to do so will give you a compiler error. So why would you ever mark a class final? After all, doesn't that violate the 
whole object-oriented (OO) notion of inheritance? You should make a final class 
only if you need an absolute guarantee that none of the methods in that class will 
ever be overridden. If you're deeply dependent on the implementations of certain 
methods, then using final gives you the security that nobody can change the 
implementation out from under you. You'll notice many classes in the Java core libraries are final. For example, the 
String class cannot be subclassed. Imagine the havoc if you couldn't guarantee how 
a String object would work on any given system your application is running on! If 
programmers were free to extend the String class (and thus substitute their new 
String subclass instances where java.lang.String instances are expected), 
civilization—as we know it—could collapse. So use final for safety, but only when 
you're certain that your final class has indeed said all that ever needs to be said 
in its methods. Marking a class final means, in essence, your class can't ever be 
improved upon, or even specialized, by another programmer. A benefit of having nonfinal classes is this scenario: Imagine you find a problem 
with a method in a class you're using, but you don't have the source code. So you 
can't modify the source to improve the method, but you can extend the class and 
override the method in your new subclass, and substitute the subclass everywhere 
the original superclass is expected. If the class is final, though, then you're stuck. Let's modify our Beverage example by placing the keyword final in the 
declaration:
package cert;
public final class Beverage {
  public void importantMethod() { }
}
Now, if we try to compile the Tea subclass:
package exam.stuff;
import cert.Beverage;
class Tea extends Beverage { }
We get an error something like
Can't subclass final classes: class 
cert.Beverage class Tea extends Beverage{
1 error
In practice, you'll almost never make a final class. A final class obliterates a key 
benefit of OO—extensibility. So unless you have a serious safety or security issue, 
assume that some day another programmer will need to extend your class. If you 
don't, the next programmer forced to maintain your code will hunt you down and 
<insert really scary thing>. Abstract Classes    An abstract class can never be instantiated. Its sole 
purpose, mission in life, raison d'être, is to be extended (subclassed). (Note, how-
ever, that you can compile and execute an abstract class, as long as you don't try 
16 Chapter 1:  Declarations and Access Control
Class Declarations and Modiﬁ  ers (Exam Objective 1.1) 17
to make an instance of it.) Why make a class if you can't make objects out of it? Because the class might be just too, well, abstract. For example, imagine you have 
a class Car that has generic methods common to all vehicles. But you don't want 
anyone actually creating a generic, abstract Car object. How would they initialize its 
state? What color would it be? How many seats? Horsepower? All-wheel drive? Or 
more importantly, how would it behave?

--- Chunk #1253 ---
In other words, how would the methods be 
implemented? No, you need programmers to instantiate actual car types such as BMWBoxster 
and SubaruOutback. We'll bet the Boxster owner will tell you his car does things 
the Subaru can do "only in its dreams." Take a look at the following abstract class:
abstract class Car {
   private double price;
   private String model;
   private String year;
   public abstract void goFast();
   public abstract void goUpHill(); 
   public abstract void impressNeighbors();
   // Additional, important, and serious code goes here
}
The preceding code will compile fine. However, if you try to instantiate a Car in 
another body of code, you'll get a compiler error something like this:
AnotherClass.java:7: class Car is an abstract 
class. It can't be instantiated. Car x = new Car();
1 error
Notice that the methods marked abstract end in a semicolon rather than 
curly braces. Look for questions with a method declaration that ends with a semicolon, rather 
than curly braces. If the method is in a class—as opposed to an interface—then both 
the method and the class must be marked abstract. You might get a question that 
asks how you could fix a code sample that includes a method ending in a semicolon, 
but without an abstract modifier on the class or method. In that case, you could 
either mark the method and class abstract, or change the semicolon to code (like a 
curly brace pair). Remember, if you change a method from abstract to nonabstract, 
don't forget to change the semicolon at the end of the method declaration into a 
curly brace pair! We'll look at abstract methods in more detail later in this objective, but always 
remember that if even a single method is abstract, the whole class must be 
declared abstract. One abstract method spoils the whole bunch. You can, however, 
put nonabstract methods in an abstract class. For example, you might have 
methods with implementations that shouldn't change from Car type to Car type, 
such as getColor() or setPrice(). By putting nonabstract methods in an abstract 
class, you give all concrete subclasses (concrete just means not abstract) inherited 
method implementations. The good news there is that concrete subclasses get to 
inherit functionality, and need to implement only the methods that define subclass-
specific behavior. (By the way, if you think we misused raison d'être earlier, don't send an e-mail. We'd like to see you work it into a programmer certification book.)
Coding with abstract class types (including interfaces, discussed later in this 
chapter) lets you take advantage of polymorphism, and gives you the greatest degree 
of flexibility and extensibility. You'll learn more about polymorphism in Chapter 2. You can't mark a class as both abstract and final. They have nearly opposite 
meanings. An abstract class must be subclassed, whereas a final class must not be 
subclassed. If you see this combination of abstract and final modifiers, used for a 
class or method declaration, the code will not compile. EXERCISE 1-1
Creating an Abstract Superclass and Concrete Subclass
The following exercise will test your knowledge of public, default, final, and 
abstract classes. Create an abstract superclass named Fruit and a concrete 
subclass named Apple. The superclass should belong to a package called food and 
the subclass can belong to the default package (meaning it isn't put into a package 
explicitly). Make the superclass public and give the subclass default access. 1. Create the superclass as follows:
   package food;
   public abstract class Fruit{ /* any code you want */}
2. Create the subclass in a separate file as follows:
   import food.Fruit;
   class Apple extends Fruit{ /* any code you want */}
18 Chapter 1:  Declarations and Access Control
3. Create a directory called food off the directory in your class path setting. 4. Attempt to compile the two files. If you want to use the Apple class, make 
           sure you place the Fruit.class file in the food subdirectory. CERTIFICATION OBJECTIVE
Declare Interfaces (Exam Objectives 1.1 and 1.2)
1.1 Develop code that declares classes (including abstract and all forms of nested classes), 
interfaces, and enums, and includes the appropriate use of package and import statements 
(including static imports). 1.2 Develop code that declares an interface. Develop code that implements or extends one 
or more interfaces. Develop code that declares an abstract class. Develop code that extends 
an abstract class. Declaring an Interface
When you create an interface, you're defining a contract for what a class can do, 
without saying anything about how the class will do it. An interface is a contract. You could write an interface Bounceable, for example, that says in effect, "This is 
the Bounceable interface. Any class type that implements this interface must agree 
to write the code for the bounce() and setBounceFactor() methods." 
By defining an interface for Bounceable, any class that wants to be treated as a 
Bounceable thing can simply implement the Bounceable interface and provide 
code for the interface's two methods. Interfaces can be implemented by any class, from any inheritance tree. This 
lets you take radically different classes and give them a common characteristic. For example, you might want both a Ball and a Tire to have bounce behavior, but 
Ball and Tire don't share any inheritance relationship; Ball extends Toy while Tire 
extends only java.lang.Object. But by making both Ball and Tire implement 
Bounceable, you're saying that Ball and Tire can be treated as, "Things that 
can bounce," which in Java translates to "Things on which you can invoke the 
Declaring an Interface (Exam Objectives 1.1 and 1.2) 19
bounce() and setBounceFactor() methods." Figure 1-1 illustrates the relationship 
between interfaces and classes. FIGURE 1-1  
The Relationship 
between interfaces 
and classes
Think of an interface as a 100-percent abstract class. Like an abstract class, 
an interface defines abstract methods that take the following form:
abstract void bounce();  // Ends with a semicolon rather than 
                         // curly braces
But while an abstract class can define both abstract and non-abstract 
methods, an interface can have only abstract methods. Another way interfaces 
differ from abstract classes is that interfaces have very little flexibility in how the 
methods and variables defined in the interface are declared. These rules are strict:
■ All interface methods are implicitly public and abstract. In other words, 
you do not need to actually type the public or abstract modifiers in the 
method declaration, but the method is still always public and abstract. ■ All variables defined in an interface must be public, static, and final—
in other words, interfaces can declare only constants, not instance variables. 20 Chapter 1:  Declarations and Access Control
interface Bounceable
What you
declare. What the 
compiler
sees. What the 
implementing
class must do. (All interface
methods must
be implemented,
and must be
marked public.)
void bounce( );
void setBounceFactor(int bf);
interface Bounceable
Class Tire implements Bounceable
public void bounce( ){...}
public void setBounceFactor(int bf){ }
public abstract void bounce( );
public abstract void setBounceFactor(int bf);
■ Interface methods must not be static. ■ Because interface methods are abstract, they cannot be marked final, 
strictfp, or native. (More on these modifiers later.)
■ An interface can extend one or more other interfaces. ■ An interface cannot extend anything but another interface. ■ An interface cannot implement another interface or class. ■ An interface must be declared with the keyword interface. ■ Interface types can be used polymorphically (see Chapter 2 for more details). The following is a legal interface declaration:
public abstract interface Rollable { }
Typing in the abstract modifier is considered redundant; interfaces are 
implicitly abstract whether you type abstract or not. You just need to know that 
both of these declarations are legal, and functionally identical:
public abstract interface Rollable { }
public interface Rollable { }
The public modifier is required if you want the interface to have public rather 
than default access. We've looked at the interface declaration but now we'll look closely at the 
methods within an interface:
public interface Bounceable {
    public abstract void bounce();
    public abstract void setBounceFactor(int bf);
}
Typing in the public and abstract modifiers on the methods is redundant, 
though, since all interface methods are implicitly public and abstract. Given 
that rule, you can see that the following code is exactly equivalent to the 
preceding interface:
public interface Bounceable {
      void bounce();                 // No modifiers
      void setBounceFactor(int bf);  // No modifiers
}
Declaring an Interface (Exam Objectives 1.1 and 1.2)  21
You must remember that all interface methods are public and abstract regardless 
of what you see in the interface definition. Look for interface methods declared with any combination of public, abstract, 
or no modifiers. For example, the following five method declarations, if declared 
within their own interfaces, are legal and identical! void bounce();
public void bounce();
abstract void bounce();
public abstract void bounce();
abstract public void bounce();
The following interface method declarations won't compile:
final void bounce();    // final and abstract can never be used
                        // together, and abstract is implied 
static void bounce();   // interfaces define instance methods
private void bounce();  // interface methods are always public
protected void bounce();    // (same as above)
Declaring Interface Constants
You're allowed to put constants in an interface. By doing so, you guarantee that any 
class implementing the interface will have access to the same constant. By placing the constants right in the interface, any class that implements the 
interface has direct access to the constants, just as if the class had inherited them. You need to remember one key rule for interface constants. They must always be
public static final
So that sounds simple, right? After all, interface constants are no different from 
any other publicly accessible constants, so they obviously must be declared public, 
static, and final. But before you breeze past the rest of this discussion, think 
about the implications: Because interface constants are defined in an interface, 
they don't have to be declared as public, static, or final. They must be 
public, static, and final, but you don't have to actually declare them that way. Just 
as interface methods are always public and abstract whether you say so in the code 
or not, any variable defined in an interface must be—and implicitly is—a public 
22 Chapter 1:  Declarations and Access Control
constant. See if you can spot the problem with the following code (assume two 
separate files):
interface Foo {
  int BAR = 42;
  void go();
}
class Zap implements Foo {
  public void go() {
     BAR = 27;
  }
}
You can't change the value of a constant! Once the value has been assigned, the 
value can never be modified. The assignment happens in the interface itself (where 
the constant is declared), so the implementing class can access it and use it, but as a 
read-only value. So the BAR = 27 assignment will not compile. Declaring Interface Constants (Exam Objectives 1.1 and 1.2) 23
Look for interface deﬁ  nitions that deﬁ  ne constants, but without 
explicitly using the required modiﬁ  ers. For example, the following are all identical:
public int x = 1;        // Looks non-static and non-final, 
                         // but isn't! int x = 1;               // Looks default, non-final, 
                         // non-static, but isn't! static int x = 1;        // Doesn't show final or public
final int x = 1;         // Doesn't show static or public
public static int x = 1;        // Doesn't show final
public final int x = 1;         // Doesn't show static
static final int x = 1          // Doesn't show public
public static final int x = 1;  // what you get implicitly
Any combination of the required (but implicit) modiﬁ  ers is legal, as is 
using no modiﬁ  ers at all! On the exam, you can expect to see questions you won’t be 
able to answer correctly unless you know, for example, that an interface variable is ﬁ  nal 
and can never be given a value by the implementing (or any other) class. CERTIFICATION OBJECTIVE
Declare Class Members (Objectives 1.3 and 1.4)
1.3 Develop code that declares, initializes, and uses primitives, arrays, enums, and 
objects as static, instance, and local variables. Also, use legal identifiers for variable 
names. 1.4 Develop code that declares both static and non-static methods, and—if 
appropriate—use method names that adhere to the JavaBeans naming standards. Also 
develop code that declares and uses a variable-length argument list. We've looked at what it means to use a modifier in a class declaration, and now 
we'll look at what it means to modify a method or variable declaration. Methods and instance (nonlocal) variables are collectively known as members. You can modify a member with both access and nonaccess modifiers, and you have 
more modifiers to choose from (and combine) than when you're declaring a class. Access Modiﬁ ers
Because method and variable members are usually given access control in exactly 
the same way, we'll cover both in this section. Whereas a class can use just two of the four access control levels (default or 
public), members can use all four:
■ public
■ protected
■ default
■ private
Default protection is what you get when you don't type an access modifier in the 
member declaration. The default and protected access control types have almost 
identical behavior, except for one difference that will be mentioned later. It's crucial that you know access control inside and out for the exam. There will 
be quite a few questions with access control playing a role. Some questions test 
24 Chapter 1:  Declarations and Access Control
several concepts of access control at the same time, so not knowing one small part of 
access control could blow an entire question. What does it mean for code in one class to have access to a member of another 
class? For now, ignore any differences between methods and variables. If class A has 
access to a member of class B, it means that class B's member is visible to class A. When a class does not have access to another member, the compiler will slap you for 
trying to access something that you're not even supposed to know exists! You need to understand two different access issues:
■ Whether method code in one class can access a member of another class
■ Whether a subclass can inherit a member of its superclass
The first type of access is when a method in one class tries to access a method or a 
variable of another class, using the dot operator (.) to invoke a method or retrieve a 
variable. For example:
class Zoo {
  public String coolMethod() {
    return "Wow  baby";
  }
}
class Moo {
  public void useAZoo() {
    Zoo z = new Zoo(); 
    // If the preceding line compiles Moo has access 
    // to the Zoo class
    // But... does it have access to the coolMethod()? System.out.println("A Zoo says, " + z.coolMethod());
    // The preceding line works because Moo can access the
    // public method
  }
}
The second type of access revolves around which, if any, members of a superclass 
a subclass can access through inheritance. We're not looking at whether the subclass 
can, say, invoke a method on an instance of the superclass (which would just be an 
example of the first type of access). Instead, we're looking at whether the subclass 
inherits a member of its superclass. Remember, if a subclass inherits a member, it's 
exactly as if the subclass actually declared the member itself. In other words, if a 
subclass inherits a member, the subclass has the member. Access Modiﬁ  ers (Exam Objectives 1.3 and 1.4) 25
class Zoo {
  public String coolMethod() {
    return "Wow  baby";
 }
}
class Moo extends Zoo {
  public void useMyCoolMethod() {
    // Does an instance of Moo inherit the coolMethod()? System.out.println("Moo says, " + this.coolMethod()); 
    // The preceding line works because Moo can inherit the   
    // public method
    // Can an instance of Moo invoke coolMethod() on an
    // instance of Zoo? Zoo z = new Zoo();
    System.out.println("Zoo says, " + z.coolMethod());
    // coolMethod() is public, so Moo can invoke it on a Zoo
    //reference    
  }
}
Figure 1-2 compares a class inheriting a member of another class, and accessing a 
member of another class using a reference of an instance of that class. Much of access control (both types) centers on whether the two classes involved 
are in the same or different packages. Don't forget, though, if class A itself can't be 
accessed by class B, then no members within class A can be accessed by class B. You need to know the effect of different combinations of class and member access 
(such as a default class with a public variable). To figure this out, first look at the 
access level of the class. If the class itself will not be visible to another class, then 
none of the members will be either, even if the member is declared public. Once 
you've confirmed that the class is visible, then it makes sense to look at access levels 
on individual members. Public Members    
When a method or variable member is declared public, it means all other classes, 
regardless of the package they belong to, can access the member (assuming the class 
itself is visible). 26 Chapter 1:  Declarations and Access Control
  FIGURE 1-2    Comparison of inheritance vs. dot operator for member access. Access Modiﬁ  ers (Exam Objectives 1.3 and 1.4) 27
SportsCar
Convertible
Driver
doThings( ){
doDriverStuff( ){
SportsCar car = new SportsCar( );
Convertible con = new Convertible( );
SportsCar sc = new SportsCar( );
sc.goFast( );
car.goFast( );
con.goFast( );
}
doMore( ){
goFast( );
}
}
superclass
subclass
Three ways to access a method:
Invoking a method declared in the same class
Invoking a method using a reference of the class
Invoking an inherited method
D
R
R
R
D
R
I
I
 goFast( )
doStuff( ){
goFast( );
}
{ }
28 Chapter 1:  Declarations and Access Control
Look at the following source file: 
package book;
import cert.*;  // Import all classes in the cert package
class Goo {
  public static void main(String[] args) {
    Sludge o = new Sludge();
    o.testIt();
  }
}
Now look at the second file:
package cert;
public class Sludge {
  public void testIt() { System.out.println("sludge"); }
}
As you can see, Goo and Sludge are in different packages. However, Goo can 
invoke the method in Sludge without problems because both the Sludge class and its 
testIt() method are marked public. For a subclass, if a member of its superclass is declared public, the subclass 
inherits that member regardless of whether both classes are in the same package:
package cert;
public class Roo {
  public String doRooThings() {
    // imagine the fun code that goes here 
    return "fun";
  }
}
The Roo class declares the doRooThings() member as public. So if we make 
a subclass of Roo, any code in that Roo subclass can call its own inherited 
doRooThings() method. package notcert;   //Not the package Roo is in
import cert.Roo;
class Cloo extends Roo {
  public void testCloo() {
    System.out.println(doRooThings());
  }
}
Notice in the preceding code that the doRooThings() method is invoked 
without having to preface it with a reference. Remember, if you see a method 
invoked (or a variable accessed) without the dot operator (.), it means the method 
or variable belongs to the class where you see that code. It also means that the 
method or variable is implicitly being accessed using the this reference. So in the 
preceding code, the call to doRooThings() in the Cloo class could also have been 
written as this.doRooThings(). The reference this always refers to the currently 
executing object—in other words, the object running the code where you see the 
this reference. Because the this reference is implicit, you don't need to preface your 
member access code with it, but it won't hurt. Some programmers include it to make 
the code easier to read for new (or non) Java programmers. Besides being able to invoke the doRooThings() method on itself, code from 
some other class can call doRooThings() on a Cloo instance, as in the following:
class Toon {
  public static void main(String[] args) {
    Cloo c = new Cloo();
    System.out.println(c.doRooThings()); //No problem; method
                                         // is public
  }
}      
Private Members    
Members marked private can't be accessed by code in any class other than the 
class in which the private member was declared. Let's make a small change to the 
Roo class from an earlier example. package cert;
public class Roo {
  private String doRooThings() {
    // imagine the fun code that goes here, but only the Roo
    // class knows 
    return "fun";
  }
}
The doRooThings() method is now private, so no other class can use it. If we 
try to invoke the method from any other class, we'll run into trouble:
 Access Modiﬁ  ers (Exam Objectives 1.3 and 1.4) 29
30 Chapter 1:  Declarations and Access Control
package notcert;
import cert.Roo;
class  UseARoo {
  public void testIt() {
    Roo r = new Roo(); //So far so good; class Roo is public
    System.out.println(r.doRooThings()); //Compiler error! }
}
If we try to compile UseARoo, we get a compiler error something like this:
cannot find symbol
symbol  : method doRooThings()
It's as if the method doRooThings() doesn't exist, and as far as any code outside 
of the Roo class is concerned, it's true. A private member is invisible to any code 
outside the member's own class. What about a subclass that tries to inherit a private member of its superclass? When a member is declared private, a subclass can't inherit it. For the exam, you 
need to recognize that a subclass can't see, use, or even think about the private 
members of its superclass. You can, however, declare a matching method in the 
subclass. But regardless of how it looks, it is not an overriding method! It is simply a 
method that happens to have the same name as a private method (which you're not 
supposed to know about) in the superclass. The rules of overriding do not apply, so 
you can make this newly-declared-but-just-happens-to-match method declare new 
exceptions, or change the return type, or anything else you want to do with it. package cert;
public class Roo {
   private String doRooThings() {
    // imagine the fun code that goes here, but no other class
    // will know 
    return "fun";
   }
}
The doRooThings() method is now off limits to all subclasses, even those in the 
same package as the superclass:
package cert;             //Cloo and Roo are in the same package 
class  Cloo extends Roo {  //Still OK, superclass Roo is public
  public void testCloo() {
    System.out.println(doRooThings()); //Compiler error! }
}
If we try to compile the subclass Cloo, the compiler is delighted to spit out an 
error something like this:
%javac Cloo.java
Cloo.java:4: Undefined method: doRooThings()
      System.out.println(doRooThings());
1 error
Although you're allowed to mark instance variables as public, in practice it's 
nearly always best to keep all variables private or protected. If variables 
need to be changed, set, or read, programmers should use public accessor 
methods, so that code in any other class has to ask to get or set a variable (by 
going through a method), rather than access it directly. JavaBean-compliant 
accessor methods take the form get<propertyName> or, for booleans, 
is<propertyName> and set<propertyName>, and provide a place to check 
and/or validate before returning or modifying a value. Without this protection, the weight variable of a Cat object, for example, 
could be set to a negative number if the offending code goes straight to 
the public variable as in someCat.weight = -20. But an accessor method, 
setWeight(int wt), could check for an inappropriate number. (OK, wild 
speculation, but we're guessing a negative weight might be inappropriate for 
a cat. Or not.) Chapter 2 will discuss this data protection (encapsulation) in 
more detail. Can a private method be overridden by a subclass? That's an interesting 
question, but the answer is technically no. Since the subclass, as we've seen, cannot 
inherit a private method, it therefore cannot override the method—overriding 
depends on inheritance. We'll cover the implications of this in more detail a little 
later in this section as well as in Chapter 2, but for now just remember that a 
method marked private cannot be overridden. Figure 1-3 illustrates the effects of 
the public and private modifiers on classes from the same or different packages. Access Modiﬁ  ers (Exam Objectives 1.3 and 1.4) 31
32 Chapter 1:  Declarations and Access Control
  FIGURE 1-3  
Effects of public and 
private access
Protected and Default Members    
The protected and default access control levels are almost identical, but with one 
critical difference. A default member may be accessed only if the class accessing the 
member belongs to the same package, whereas a protected member can be accessed 
(through inheritance) by a subclass even if the subclass is in a different package. SportsCar
Convertible
Driver
doThings( ){
doDriverStuff( ){
SportsCar car = new SportsCar( );
Convertible con = new Convertible( );
SportsCar sc = new SportsCar( );
sc.goFast( );
car.goFast( );
con.goFast( );
}
doMore( ){
goFast( );
}
}
superclass
The effect of private access control
subclass
Three ways to access a method:
Invoking a method declared in the same class
Invoking a method using a reference of the class
Invoking an inherited method
D
R
R
R
D
R
I
I
goFast( )
private
doStuff( ){
goFast( );
}
{ }. . . Take a look at the following two classes:
package certification;
public class OtherClass {
  void testIt() {   // No modifier means method has default
                    // access
    System.out.println("OtherClass");
  }
}
In another source code file you have the following:
package somethingElse;
import certification.OtherClass;
class AccessClass {
  static public void main(String[] args) {
    OtherClass o = new OtherClass();
    o.testIt();
  }
}
As you can see, the testIt() method in the first file has default (think: package-
level) access. Notice also that class OtherClass is in a different package from the 
AccessClass. Will AccessClass be able to use the method testIt()? Will it cause a 
compiler error? Will Daniel ever marry Francesca? Stay tuned.

--- Chunk #1254 ---
No method matching testIt() found in class 
certification.OtherClass. o.testIt();
From the preceding results, you can see that AccessClass can't use the OtherClass 
method testIt() because testIt() has default access, and AccessClass is not 
in the same package as OtherClass. So AccessClass can't see it, the compiler 
complains, and we have no idea who Daniel and Francesca are. Default and protected behavior differ only when we talk about subclasses. If the 
protected keyword is used to define a member, any subclass of the class declaring 
the member can access it through inheritance. It doesn't matter if the superclass and 
subclass are in different packages, the protected superclass member is still visible to 
the subclass (although visible only in a very specific way as we'll see a little later). This is in contrast to the default behavior, which doesn't allow a subclass to access a 
superclass member unless the subclass is in the same package as the superclass. Access Modiﬁ  ers (Exam Objectives 1.3 and 1.4) 33
34 Chapter 1:  Declarations and Access Control
Whereas default access doesn't extend any special consideration to subclasses 
(you're either in the package or you're not), the protected modifier respects the 
parent-child relationship, even when the child class moves away (and joins a 
new package). So, when you think of default access, think package restriction. No 
exceptions. But when you think protected, think package + kids. A class with a 
protected member is marking that member as having package-level access for all 
classes, but with a special exception for subclasses outside the package. But what does it mean for a subclass-outside-the-package to have access to a 
superclass (parent) member? It means the subclass inherits the member. It does not, 
however, mean the subclass-outside-the-package can access the member using a 
reference to an instance of the superclass. In other words, protected = inheritance. Protected does not mean that the subclass can treat the protected superclass member 
as though it were public. So if the subclass-outside-the-package gets a reference to 
the superclass (by, for example, creating an instance of the superclass somewhere 
in the subclass' code), the subclass cannot use the dot operator on the superclass 
reference to access the protected member. To a subclass-outside-the-package, a 
protected member might as well be default (or even private), when the subclass is 
using a reference to the superclass. The subclass can see the protected member 
only through inheritance. Are you confused?

--- Chunk #1255 ---
So are we. Hang in there and it will all become clear with the 
next batch of code examples. (And don't worry; we're not actually confused. We're 
just trying to make you feel better if you are. You know, like it's OK for you to feel as 
though nothing makes sense, and that it isn't your fault.

--- Chunk #1256 ---
Or is it? <insert evil laugh>)
Protected Details    
Let's take a look at a protected instance variable (remember, an instance variable 
is a member) of a superclass. package certification;
public class Parent {
   protected int x = 9; // protected access
}
The preceding code declares the variable x as protected. This makes the 
variable accessible to all other classes inside the certification package, as well as 
inheritable by any subclasses outside the package. Now let's create a subclass in a 
different package, and attempt to use the variable x (that the subclass inherits):
package other; // Different package
import certification.Parent;
class Child extends Parent {
   public void testIt() {
      System.out.println("x is " + x); // No problem; Child
                                       // inherits x
   }
}
The preceding code compiles fine. Notice, though, that the Child class is 
accessing the protected variable through inheritance. Remember, any time we talk 
about a subclass having access to a superclass member, we could be talking about 
the subclass inheriting the member, not simply accessing the member through a 
reference to an instance of the superclass (the way any other nonsubclass would 
access it). Watch what happens if the subclass Child (outside the superclass' 
package) tries to access a protected variable using a Parent class reference. package other; 
import certification.Parent;
class Child extends Parent {
   public void testIt() {
      System.out.println("x is " + x); // No problem; Child
                                       // inherits x
      Parent p = new Parent(); // Can we access x using the
                               // p reference? System.out.println("X in parent is " + p.x); // Compiler
                                                   // error! }
}
The compiler is more than happy to show us the problem:
%javac -d . other/Child.java
other/Child.java:9: x has protected access in certification.Par-
ent
System.out.println("X in parent is " + p.x);
                                        ^
1 error
So far we've established that a protected member has essentially package-level or 
default access to all classes except for subclasses. We've seen that subclasses outside 
the package can inherit a protected member. Finally, we've seen that subclasses 
Access Modiﬁ  ers (Objectives 1.3 and 1.4) 35
36 Chapter 1:  Declarations and Access Control
outside the package can't use a superclass reference to access a protected member. For a subclass outside the package, the protected member can be accessed only 
through inheritance. But there's still one more issue we haven't looked at...what does a protected 
member look like to other classes trying to use the subclass-outside-the-package to 
get to the subclass' inherited protected superclass member? For example, using our 
previous Parent/Child classes, what happens if some other class—Neighbor, say—in 
the same package as the Child (subclass), has a reference to a Child instance and 
wants to access the member variable x ? In other words, how does that protected 
member behave once the subclass has inherited it? Does it maintain its protected 
status, such that classes in the Child's package can see it? No! Once the subclass-outside-the-package inherits the protected member, 
that member (as inherited by the subclass) becomes private to any code outside 
the subclass, with the exception of subclasses of the subclass. So if class Neighbor 
instantiates a Child object, then even if class Neighbor is in the same package as 
class Child, class Neighbor won't have access to the Child's inherited (but protected) 
variable x. Figure 1-4 illustrates the effect of protected access on classes and subclasses 
in the same or different packages. Whew! That wraps up protected, the most misunderstood modifier in Java. Again, it's used only in very special cases, but you can count on it showing up on 
the exam. Now that we've covered the protected modifier, we'll switch to default 
member access, a piece of cake compared to protected. Default Details    
Let's start with the default behavior of a member in a superclass. We'll modify the 
Parent's member x to make it default. package certification;
public class Parent {
  int x = 9; // No access modifier, means default
             // (package) access
}
Notice we didn't place an access modifier in front of the variable x. Remember 
that if you don't type an access modifier before a class or member declaration, the 
access control is default, which means package level. We'll now attempt to access 
the default member from the Child class that we saw earlier. FIGURE 1-4     
Effects of 
protected 
access
When we compile the child file, we get an error something like this:
Child.java:4: Undefined variable: x
      System.out.println("Variable x is " + x);
1 error
Access Modiﬁ  ers (Exam Objectives 1.3 and 1.4) 37
If goFast( ) is default If goFast( )is protected
SportsCar
Convertible
Driver
Package A
goFast( ){ }
goFast( ){ } doThings
SportsCar
sc.goFastgoFast( );
Where goFast
is Declared in the
same class. Invoking goFast( ) 
class in which goFast( )
}
doStuff( ){ doMore( ){
}
goFast( );
Invoking the
goFast( )
method
Inherited
 from
a superclass. D
RI
SportsCar
Convertible
Package A
goFast( ){ }
D
Driver Convertible Convertible
Package B
Key:
Package B Package B
RR I R IR
DR I
Driver
RR
Driver
RR
SportsCar
Package A
goFast( ){ }
D
SportsCar
Package A
protected goFast( ){ }
D
RI
R R
sc = new SportsCar( );
( ){
( );
}
was declared. u
sing a Reference to the
38 Chapter 1:  Declarations and Access Control
The compiler gives the same error as when a member is declared as private. The 
subclass Child (in a different package from the superclass Parent) can't see or use the 
default superclass member x ! Now, what about default access for two classes in the 
same package? package certification;
public class Parent{
  int x = 9; // default access
}
And in the second class you have the following:
package certification;
class Child extends Parent{
  static public void main(String[] args) {
    Child sc = new Child();
    sc.testIt();
  }
  public void testIt() {
    System.out.println("Variable x is " + x); // No problem;
  }
}
The preceding source file compiles fine, and the class Child runs and displays the 
value of x. Just remember that default members are visible to subclasses only if those 
subclasses are in the same package as the superclass. Local Variables and Access Modifiers
Can access modifiers be applied to local variables? NO! There is never a case where an access modifier can be applied to a local variable, 
so watch out for code like the following:
class Foo {
  void doStuff() {
    private int x = 7;
    this.doMore(x);
  }
}
You can be certain that any local variable declared with an access modifier will 
not compile. In fact, there is only one modifier that can ever be applied to local 
variables—final. That about does it for our discussion on member access modifiers. Table 1-2 
shows all the combinations of access and visibility; you really should spend some 
time with it. Next, we're going to dig into the other (nonaccess) modifiers that you 
can apply to member declarations. Nonaccess Member Modiﬁ ers
We've discussed member access, which refers to whether code from one class can 
invoke a method (or access an instance variable) from another class. That still 
leaves a boatload of other modifiers you can use on member declarations. T wo 
you're already familiar with—final and abstract—because we applied them to 
class declarations earlier in this chapter. But we still have to take a quick look at 
transient, synchronized, native, strictfp, and then a long look at the Big 
One—static. We'll look first at modifiers applied to methods, followed by a look at modifiers 
applied to instance variables. We'll wrap up this section with a look at how static 
works when applied to variables and methods. Nonaccess Member Modiﬁ  ers (Exam Objectives 1.3 and 1.4) 39
 
Visibility Public Protected Default Private
From the same class Yes Yes Yes Yes
From any class in the same 
package
Yes Yes Yes No
From a subclass in the same 
package
Yes Yes Yes No
From a subclass outside the 
same package
Yes Yes, through 
inheritance
No No
From any non-subclass class 
outside the package
Yes No No No
 TABLE 1-2   Determining Access to Class Members
40 Chapter 1:  Declarations and Access Control
Final Methods    
The final keyword prevents a method from being overridden in a subclass, and is 
often used to enforce the API functionality of a method. For example, the Thread 
class has a method called isAlive() that checks whether a thread is still active. If 
you extend the Thread class, though, there is really no way that you can correctly 
implement this method yourself (it uses native code, for one thing), so the designers 
have made it final. Just as you can't subclass the String class (because we need to 
be able to trust in the behavior of a String object), you can't override many of the 
methods in the core class libraries. This can't-be-overridden restriction provides for 
safety and security, but you should use it with great caution. Preventing a subclass 
from overriding a method stifles many of the benefits of OO including extensibility 
through polymorphism. A typical final method declaration looks like this:
class SuperClass{
  public final void showSample() {
    System.out.println("One thing.");
  }
}
It's legal to extend SuperClass, since the class isn't marked final, but we can't 
override the final method showSample(), as the following code attempts to do:
class SubClass extends SuperClass{
  public void showSample() { // Try to override the final 
                             // superclass method
    System.out.println("Another thing.");
  }
}
Attempting to compile the preceding code gives us something like this:
%javac FinalTest.java
FinalTest.java:5: The method void showSample() declared in class 
SubClass cannot override the final method of the same signature 
declared in class SuperClass. Final methods cannot be overridden. public void showSample() { }
1 error
Final Arguments    
Method arguments are the variable declarations that appear in between the paren-
theses in a method declaration. A typical method declaration with multiple argu-
ments looks like this:
public Record getRecord(int fileNumber, int recNumber) {}
Method arguments are essentially the same as local variables. In the preceding 
example, the variables fileNumber and recNumber will both follow all the rules 
applied to local variables. This means they can also have the modifier final:
public Record getRecord(int fileNumber, final int recordNumber) {}
In this example, the variable recNumber is declared as final, which of course 
means it can't be modified within the method. In this case, "modified" means 
reassigning a new value to the variable. In other words, a final argument must keep 
the same value that the parameter had when it was passed into the method. Abstract Methods    
An abstract method is a method that's been declared (as abstract) but not 
implemented. In other words, the method contains no functional code. And if you 
recall from the earlier section "Abstract Classes," an abstract method declaration 
doesn't even have curly braces for where the implementation code goes, but instead 
closes with a semicolon. In other words, it has no method body. You mark a method 
abstract when you want to force subclasses to provide the implementation. For 
example, if you write an abstract class Car with a method goUpHill(), you might 
want to force each subtype of Car to define its own goUpHill() behavior, specific to 
that particular type of car. public abstract void showSample();
Notice that the abstract method ends with a semicolon instead of curly braces. It is illegal to have even a single abstract method in a class that is not explicitly 
declared abstract! Look at the following illegal class:
public class IllegalClass{
  public abstract void doIt();
}
Nonaccess Member Modiﬁ  ers (Exam Objectives 1.3 and 1.4) 41
42 Chapter 1:  Declarations and Access Control
The preceding class will produce the following error if you try to compile it:
IllegalClass.java:1: class IllegalClass must be declared 
abstract. It does not define void doIt() from class IllegalClass. public class IllegalClass{
1 error
You can, however, have an abstract class with no abstract methods. The following 
example will compile fine:
public abstract class LegalClass{
   void goodMethod() {
      // lots of real implementation code here
   }
 } 
In the preceding example, goodMethod() is not abstract. Three different clues 
tell you it's not an abstract method:
■ The method is not marked abstract. ■ The method declaration includes curly braces, as opposed to ending in a 
semicolon. In other words, the method has a method body. ■ The method provides actual implementation code. Any class that extends an abstract class must implement all abstract methods 
of the superclass, unless the subclass is also abstract. The rule is this:
The first concrete subclass of an abstract class must implement all abstract
    methods of the superclass. Concrete just means nonabstract, so if you have an abstract class extending 
another abstract class, the abstract subclass doesn't need to provide implementations 
for the inherited abstract methods. Sooner or later, though, somebody's going to 
make a nonabstract subclass (in other words, a class that can be instantiated), 
and that subclass will have to implement all the abstract methods from up the 
inheritance tree. The following example demonstrates an inheritance tree with two 
abstract classes and one concrete class:
public abstract class Vehicle {
  private String type;
  public abstract void goUpHill();  // Abstract method
  public String getType() {         // Non-abstract method
    return type;
  }    
}
public abstract class Car extends Vehicle {
  public abstract void goUpHill();  // Still abstract
  public void doCarThings() {
    // special car code goes here
  }
}
public class Mini extends Car {
  public void goUpHill() {
    // Mini-specific going uphill code
  }
}
So how many methods does class Mini have? Three. It inherits both the 
getType() and doCarThings() methods, because they're public and concrete 
(nonabstract). But because goUpHill() is abstract in the superclass Vehicle, 
and is never implemented in the Car class (so it remains abstract), it means 
class Mini—as the first concrete class below Vehicle—must implement the 
goUpHill() method. In other words, class Mini can't pass the buck (of abstract 
method implementation) to the next class down the inheritance tree, but class Car 
can, since Car, like Vehicle, is abstract. Figure 1-5 illustrates the effects of the 
abstract modifier on concrete and abstract subclasses. Nonaccess Member Modiﬁ  ers (Exam Objectives 1.3 and 1.4) 43
44 Chapter 1:  Declarations and Access Control
  FIGURE 1-5    The effects of the abstract modifier on concrete and abstract subclasses
Look for concrete classes that don't provide method implementations for 
abstract methods of the superclass. The following code won't compile:
public abstract class A {
  abstract void foo();
}
class B extends A {
  void foo(int I) { }
}
Class B won't compile because it doesn't implement the inherited abstract 
method foo(). Although the foo(int I) method in class B might appear to be 
abstract Car
startEngine( )
SportsCar
startEngine( )//optional
goForward( )//Required
reverse( )//Required
turn(int whichWay)//Required
Abstract methods must be implemented by a 
non-abstract subclass. If the subclass is abstract,
it is not required to implement the abstract
methods, but it is allowed to implement any
or all of the superclass abstract methods. The
AcmeRover class is non-abstract,  so it must
implement the abstract method declared in its
superclass, SUV, and it must also implement
turn( ), which was not implemented by SUV. stop( )
abstract goForward( )
abstract reverse( )
abstract turn(int whichWay)
abstract SUV
enable4wd( )
AcmeRover
enable4wd( )//optional
goOffRoad( )//Required
turn(int whichWay)//Required
goForward( )
reverse( )
abstract goOffRoad( )
//turn( )not implemented
an implementation of the superclass' abstract method, it is simply an overloaded 
method (a method using the same identifier, but different arguments), so it doesn't 
fulfill the requirements for implementing the superclass' abstract method. We'll 
look at the differences between overloading and overriding in detail in Chapter 2. A method can never, ever, ever be marked as both abstract and final, or both 
abstract and private. Think about it—abstract methods must be implemented 
(which essentially means overridden by a subclass) whereas final and private 
methods cannot ever be overridden by a subclass. Or to phrase it another way, an 
abstract designation means the superclass doesn't know anything about how 
the subclasses should behave in that method, whereas a final designation means 
the superclass knows everything about how all subclasses (however far down the 
inheritance tree they may be) should behave in that method. The abstract and 
final modifiers are virtually opposites. Because private methods cannot even be 
seen by a subclass (let alone inherited), they too cannot be overridden, so they too 
cannot be marked abstract. Finally, you need to know that the abstract modifier can never be combined 
with the static modifier. We'll cover static methods later in this objective, but 
for now just remember that the following would be illegal:
abstract static void doStuff();
And it would give you an error that should be familiar by now:
MyClass.java:2: illegal combination of modifiers: abstract and 
static
  abstract static void doStuff();
Synchronized Methods    
The synchronized keyword indicates that a method can be accessed by only one 
thread at a time. We'll discuss this nearly to death in Chapter 9, but for now all 
we're concerned with is knowing that the synchronized modifier can be applied 
only to methods—not variables, not classes, just methods. A typical synchronized 
declaration looks like this:
public synchronized Record retrieveUserInfo(int id) { }
You should also know that the synchronized modifier can be matched with any 
of the four access control levels (which means it can be paired with any of the three 
access modifier keywords). Nonaccess Member Modiﬁ  ers (Exam Objectives 1.3 and 1.4) 45
46 Chapter 1:  Declarations and Access Control
Native Methods    
The native modifier indicates that a method is implemented in platform-depen-
dent code, often in C. You don't need to know how to use native methods for the 
exam, other than knowing that native is a modifier (thus a reserved keyword) and 
that native can be applied only to methods—not classes, not variables, just methods. Note that a native method's body must be a semicolon (;) (like abstract methods), 
indicating that the implementation is omitted. Strictfp Methods    
We looked earlier at using strictfp as a class modifier, but even if you don't de-
clare a class as strictfp, you can still declare an individual method as strictfp. Remember, strictfp forces floating points (and any floating-point operations) to 
adhere to the IEEE 754 standard. With strictfp, you can predict how your floating 
points will behave regardless of the underlying platform the JVM is running on. The 
downside is that if the underlying platform is capable of supporting greater precision, a 
strictfp method won't be able to take advantage of it. You'll want to study the IEEE 754 if you need something to help you fall asleep. For the exam, however, you don't need to know anything about strictfp other 
than what it's used for, that it can modify a class or method declaration, and that a 
variable can never be declared strictfp. Methods with Variable Argument Lists (var-args)
As of 5.0, Java allows you to create methods that can take a variable number of 
arguments. Depending on where you look, you might hear this capability referred to 
as "variable-length argument lists," "variable arguments," "var-args," "varargs," or our 
personal favorite (from the department of obfuscation), "variable arity parameter." 
They're all the same thing, and we'll use the term "var-args" from here on out. As a bit of background, we'd like to clarify how we're going to use the terms 
"argument" and "parameter" throughout this book. ■ arguments The things you specify between the parentheses when you're 
invoking a method: 
   doStuff("a", 2);  // invoking doStuff, so a & 2 are arguments
■ parameters The things in the method's signature that indicate what the 
method must receive when it's invoked:
    void doStuff(String s, int a) { } // we're expecting two
                                   // parameters: String and int
We'll cover using var-arg methods more in the next few chapters, for now let's 
review the declaration rules for var-args:
■ Var-arg type When you declare a var-arg parameter, you must specify the 
type of the argument(s) this parameter of your method can receive. (This can 
be a primitive type or an object type.)
■ Basic syntax To declare a method using a var-arg parameter, you follow the 
type with an ellipsis (...), a space, and then the name of the array that will 
hold the parameters received. ■  Other parameters It's legal to have other parameters in a method that uses 
a var-arg. ■  Var-args limits The var-arg must be the last parameter in the method's 
signature, and you can have only one var-arg in a method. Let's look at some legal and illegal var-arg declarations:
Legal:
void doStuff(int... x) { }  // expects from 0 to many ints
                            // as parameters
void doStuff2(char c, int... x)  { }  // expects first a char,
                                      // then 0 to many ints
void doStuff3(Animal... animal) { }   // 0 to many Animals
Illegal:
void doStuff4(int x...) { }             // bad syntax
void doStuff5(int... x, char... y) { }  // too many var-args
void doStuff6(String... s, byte b) { }  // var-arg must be last
Constructor Declarations
In Java, objects are constructed. Every time you make a new object, at least one 
constructor is invoked. Every class has a constructor, although if you don't create 
one explicitly, the compiler will build one for you. There are tons of rules concerning 
Constructor Declarations (Exam Objectives 1.3 and 1.4) 47
48 Chapter 1:  Declarations and Access Control
constructors, and we're saving our detailed discussion for Chapter 2. For now, let's 
focus on the basic declaration rules. Here's a simple example:
class Foo {
  protected Foo() { }          // this is Foo's constructor
  protected void Foo() { }     // this is a badly named,
                               // but legal, method
}
The first thing to notice is that constructors look an awful lot like methods. A 
key difference is that a constructor can't ever, ever, ever, have a return type…ever! Constructor declarations can however have all of the normal access modifiers, and 
they can take arguments (including var-args), just like methods. The other BIG 
RULE, to understand about constructors is that they must have the same name as 
the class in which they are declared. Constructors can't be marked static (they 
are after all associated with object instantiation), they can't be marked final 
or abstract (because they can't be overridden). Here are some legal and illegal 
constructor declarations:
class Foo2 {
  // legal constructors
  Foo2() { }
  private Foo2(byte b) { }
  Foo2(int x) { }
  Foo2(int x, int... y) { }
  // illegal constructors
  void Foo2() { }            // it's a method, not a constructor
  Foo() { }                  // not a method or a constructor
  Foo2(short s);             // looks like an abstract method
  static Foo2(float f) { }   // can't be static
  final Foo2(long x) { }     // can't be final
  abstract Foo2(char c) { }  // can't be abstract
  Foo2(int... x, int t) { }  // bad var-arg syntax
 }
Variable Declarations
There are two types of variables in Java:
■ Primitives A primitive can be one of eight types: char, boolean, byte, 
short, int, long, double, or float. Once a primitive has been declared, its 
primitive type can never change, although in most cases its value can change. ■ Reference variables A reference variable is used to refer to (or access) an 
object. A reference variable is declared to be of a specific type and that type 
can never be changed. A reference variable can be used to refer to any object 
of the declared type, or of a subtype of the declared type (a compatible type). We'll talk a lot more about using a reference variable to refer to a subtype in 
Chapter 2, when we discuss polymorphism. Declaring Primitives and Primitive Ranges
Primitive variables can be declared as class variables (statics), instance variables, 
method parameters, or local variables. You can declare one or more primitives, of the 
same primitive type, in a single line. In Chapter 3 we will discuss the various ways 
in which they can be initialized, but for now we'll leave you with a few examples of 
primitive variable declarations:
byte b;
boolean myBooleanPrimitive;
int x, y, z;                  // declare three int primitives
On previous versions of the exam you needed to know how to calculate ranges 
for all the Java primitives. For the current exam, you can skip some of that detail, 
but it's still important to understand that for the integer types the sequence from 
small to big is byte, short, int, long, and that doubles are bigger than floats. You will also need to know that the number types (both integer and floating-
point types) are all signed, and how that affects their ranges. First, let's review the 
concepts. All six number types in Java are made up of a certain number of 8-bit bytes, and 
are signed, meaning they can be negative or positive. The leftmost bit (the most 
significant digit) is used to represent the sign, where a 1 means negative and 0 means 
positive, as shown in Figure 1-6. The rest of the bits represent the value, using two's 
complement notation. Variable Declarations (Exam Objectives 1.3 and 1.4) 49
50 Chapter 1:  Declarations and Access Control
  FIGURE 1-6     The Sign bit for a byte
Table 1-3 shows the primitive types with their sizes and ranges. Figure 1-6 shows 
that with a byte, for example, there are 256 possible numbers (or 28). Half of these 
are negative, and half -1 are positive. The positive range is one less than the 
negative range because the number zero is stored as a positive binary number. We 
use the formula -2(bits-1) to calculate the negative range, and we use 2(bits-1)–1 for the 
positive range. Again, if you know the first two columns of this table, you'll be in 
good shape for the exam. T ype Bits Bytes Minimum Range Maximum Range
byte 81 -27 27-1
short 16 2 -215 215-1
int 32 4 -231 231-1
long 64 8 -263 263-1
float 32 4 n/a n/a
double 64 8 n/a n/a
 TABLE 1-3    Ranges of Numeric Primitives
byte
sign bit:  0 = positive
       I = negative
byte: 7 bits can represent 27 or
128 different values:
0 thru 127 -or- –128 thru –1
short: 15 bits can represent
215 or 32768 values:
0 thru 32767 -or- –32768 thru –1
value bits:00100110
1111101000000111short
sign bit value bits
The range for floating-point numbers is complicated to determine, but luckily you 
don't need to know these for the exam (although you are expected to know that a 
double holds 64 bits and a float 32). For boolean types there is not a range; a boolean can be only true or false. If 
someone asks you for the bit depth of a boolean, look them straight in the eye and 
say, "That's virtual-machine dependent." They'll be impressed. The char type (a character) contains a single, 16-bit Unicode character. Although the extended ASCII set known as ISO Latin-1 needs only 8 bits (256 
different characters), a larger range is needed to represent characters found in 
languages other than English. Unicode characters are actually represented by 
unsigned 16-bit integers, which means 216 possible values, ranging from 0 to 65535 
(216)-1. You'll learn in Chapter 3 that because a char is really an integer type, it 
can be assigned to any number type large enough to hold 65535 (which means 
anything larger than a short. Although both chars and shorts are 16-bit types, 
remember that a short uses 1 bit to represent the sign, so fewer positive numbers are 
acceptable in a short). Declaring Reference Variables
Reference variables can be declared as static variables, instance variables, method 
parameters, or local variables. You can declare one or more reference variables, 
of the same type, in a single line. In Chapter 3 we will discuss the various ways in 
which they can be initialized, but for now we'll leave you with a few examples of 
reference variable declarations:
Object o;
Dog myNewDogReferenceVariable;
String s1, s2, s3;               // declare three String vars. Instance Variables
Instance variables are defined inside the class, but outside of any method, and 
are only initialized when the class is instantiated. Instance variables are the fields 
that belong to each unique object. For example, the following code defines fields 
(instance variables) for the name, title, and manager for employee objects:
class Employee {
  //  define fields (instance variables) for employee instances
  private String name;
  private String title,
Variable Declarations (Exam Objectives 1.3 and 1.4)  51
52 Chapter 1:  Declarations and Access Control
  private String manager;
  // other code goes here including access methods for private
  // fields
}
The preceding Employee class says that each employee instance will know its 
own name, title, and manager. In other words, each instance can have its own 
unique values for those three fields. If you see the term "field," "instance variable," 
"property," or "attribute," they mean virtually the same thing. (There actually 
are subtle but occasionally important distinctions between the terms, but those 
distinctions aren't used on the exam.) 
For the exam, you need to know that instance variables
■ Can use any of the four access levels (which means they can be marked with 
any of the three access modifiers)
■ Can be marked final
■ Can be marked transient
■ Cannot be marked abstract
■ Cannot be marked synchronized
■ Cannot be marked strictfp
■ Cannot be marked native
■ Cannot be marked static, because then they'd become class variables. We've already covered the effects of applying access control to instance variables 
(it works the same way as it does for member methods). A little later in this chapter 
we'll look at what it means to apply the final or transient modifier to an 
instance variable. First, though, we'll take a quick look at the difference between 
instance and local variables. Figure 1-7 compares the way in which modifiers can be 
applied to methods vs. variables. FIGURE 1-7    Comparison of modifiers on variables vs. methods
Local (Automatic/Stack/Method) Variables
Local variables are variables declared within a method. That means the variable is 
not just initialized within the method, but also declared within the method. Just 
as the local variable starts its life inside the method, it's also destroyed when the 
method has completed. Local variables are always on the stack, not the heap. (We'll 
talk more about the stack and the heap in Chapter 3). Although the value of the 
variable might be passed into, say, another method that then stores the value in an 
instance variable, the variable itself lives only within the scope of the method. Just don't forget that while the local variable is on the stack, if the variable is an 
object reference, the object itself will still be created on the heap. There is no such 
thing as a stack object, only a stack variable. You'll often hear programmers use 
the phrase, "local object," but what they really mean is, "locally declared reference 
variable." So if you hear a programmer use that expression, you'll know that he's just 
too lazy to phrase it in a technically precise way. You can tell him we said that—
unless he knows where we live. Local variable declarations can't use most of the modifiers that can be applied 
to instance variables, such as public (or the other access modifiers), transient, 
volatile, abstract, or static, but as we saw earlier, local variables can be 
marked final. And as you'll learn in Chapter 3 (but here's a preview), before a 
local variable can be used, it must be initialized with a value. For instance:
Variable Declarations (Exam Objectives 1.3 and 1.4)  53
final final 
public
protected
private
static
transient
volatile
final 
public
protected
private
static
abstract
synchronized
strictfp
native
Local
Variables
Variables
(non-local) Methods
54 Chapter 1:  Declarations and Access Control
class TestServer {
  public void logIn() {
    int count = 10;
  }
}
Typically, you'll initialize a local variable in the same line in which you declare 
it, although you might still need to reinitialize it later in the method. The key is 
to remember that a local variable must be initialized before you try to use it. The 
compiler will reject any code that tries to use a local variable that hasn't been 
assigned a value, because—unlike instance variables—local variables don't get 
default values. A local variable can't be referenced in any code outside the method in which 
it's declared. In the preceding code example, it would be impossible to refer to the 
variable count anywhere else in the class except within the scope of the method 
logIn(). Again, that's not to say that the value of count can't be passed out of the 
method to take on a new life. But the variable holding that value, count, can't be 
accessed once the method is complete, as the following illegal code demonstrates:
class TestServer {
  public void logIn() {
    int count = 10;
  }
  public void doSomething(int i) {
    count = i;  // Won't compile! Can't access count outside
                // method logIn()
  }
}
It is possible to declare a local variable with the same name as an instance 
variable. It's known as shadowing, as the following code demonstrates:
class TestServer {
   int count = 9;  // Declare an instance variable named count
   public void logIn() {
      int count = 10;  // Declare a local variable named count
      System.out.println("local variable count is " + count);
   }
   public void count() {
      System.out.println("instance variable count is " + count);
   }
   public static void main(String[] args) {
      new TestServer().logIn();
      new TestServer().count();
   }
}
The preceding code produces the following output:
local variable count is 10
instance variable count is 9
Why on earth (or the planet of your choice) would you want to do that? Normally, you won't. But one of the more common reasons is to name a parameter 
with the same name as the instance variable to which the parameter will be 
assigned. The following (wrong) code is trying to set an instance variable's value using a 
parameter:
class Foo {
   int size = 27;
   public void setSize(int size) {
      size = size;  // ??? which size equals which size??? }
} 
So you've decided that—for overall readability—you want to give the parameter 
the same name as the instance variable its value is destined for, but how do you 
resolve the naming collision? Use the keyword this. The keyword this always, 
always, always refers to the object currently running. The following code shows this 
in action:
class Foo {
   int size = 27;
   public void setSize(int size) {
      this.size = size;  // this.size means the current object's
                         // instance variable, size. The size
          // on the right is the parameter
   }
} 
Array Declarations
In Java, arrays are objects that store multiple variables of the same type, or variables 
that are all subclasses of the same type. Arrays can hold either primitives or object 
Variable Declarations (Exam Objectives 1.3 and 1.4)  55
56 Chapter 1:  Declarations and Access Control
references, but the array itself will always be an object on the heap, even if the array 
is declared to hold primitive elements. In other words, there is no such thing as a 
primitive array, but you can make an array of primitives. For the exam, you need to know three things: 
■ How to make an array reference variable (declare) 
■ How to make an array object (construct) 
■ How to populate the array with elements (initialize) 
For this objective, you only need to know how to declare an array, we'll cover 
constructing and initializing arrays in Chapter 3. Arrays are efficient, but many times you'll want to use one of the Collection 
types from java.util (including HashMap, ArrayList, and TreeSet). Collection 
classes offer more flexible ways to access an object (for insertion, deletion, 
reading, and so on) and unlike arrays, can expand or contract dynamically 
as you add or remove elements. There's a Collection type for a wide range of 
needs. Do you need a fast sort? A group of objects with no duplicates? A way 
to access a name-value pair? Chapter 7 covers them in more detail. Arrays are declared by stating the type of elements the array will hold (an 
object or a primitive), followed by square brackets to either side of the identifier. Declaring an Array of Primitives
int[] key;  // Square brackets before name (recommended)
int key []; // Square brackets after name (legal but less 
            // readable)
Declaring an Array of Object References
Thread[] threads;  // Recommended
Thread threads []; // Legal but less readable
When declaring an array reference, you should always put the array brackets 
immediately after the declared type, rather than after the identifier (variable 
name). That way, anyone reading the code can easily tell that, for example, 
key is a reference to an int array object, and not an int primitive. We can also declare multidimensional arrays, which are in fact arrays of arrays. This can be done in the following manner:
String[][][] occupantName;
String[] managerName [];
The first example is a three-dimensional array (an array of arrays of arrays) and 
the second is a two-dimensional array. Notice in the second example we have one 
square bracket before the variable name and one after. This is perfectly legal to the 
compiler, proving once again that just because it's legal doesn't mean it's right. In Chapter 3, we'll spend a lot of time discussing arrays, how to initialize and use 
them, and how to deal with multi-dimensional arrays…stay tuned! Final Variables
Declaring a variable with the final keyword makes it impossible to reinitialize that 
variable once it has been initialized with an explicit value (notice we said explicit 
rather than default). For primitives, this means that once the variable is assigned a 
value, the value can't be altered. For example, if you assign 10 to the int variable 
x, then x is going to stay 10, forever. So that's straightforward for primitives, but 
what does it mean to have a final object reference variable? A reference variable 
marked final can't ever be reassigned to refer to a different object. The data within 
the object can be modified, but the reference variable cannot be changed. In other 
words, a final reference still allows you to modify the state of the object it refers 
Variable Declarations (Exam Objectives 1.3 and 1.4)  57
It is never legal to include the size of the array in your declaration. Yes, we know you can do that in some other languages, which is why you might see a 
question or two that include code similar to the following: 
int[5] scores;
The preceding code won’t compile. Remember, the JVM doesn’t allocate space until 
you actually instantiate the array object. That’s when size matters. 58 Chapter 1:  Declarations and Access Control
to, but you can't modify the reference variable to make it refer to a different object. Burn this in: there are no final objects, only final references. We'll explain this in 
more detail in Chapter 3. We've now covered how the final modifier can be applied to classes, methods, 
and variables. Figure 1-8 highlights the key points and differences of the various 
applications of final. FIGURE 1- 8    Effect of final on variables, methods, and classes
final
class
final class Foo
class Bar extends Foo
class Baz
final void go( )
final void go( )
class Roo
final int size = 42;
void changeSize( ){
size = 16;
}
class Bat extends Baz
final
method
final
variable
final method 
cannot be
overridden by
a subclass
final variable cannot be
assigned a new value, once
the initial method is made
(the initial assignment of a
value must happe
n before
the constructor completes). final class 
cannot be
subclassed
Transient Variables
 If you mark an instance variable as transient, you're telling the JVM to skip 
(ignore) this variable when you attempt to serialize the object containing it. Serialization is one of the coolest features of Java; it lets you save (sometimes called 
"flatten") an object by writing its state (in other words, the value of its instance 
variables) to a special type of I/O stream. With serialization you can save an object 
to a file, or even ship it over a wire for reinflating (deserializing) at the other end, in 
another JVM. Serialization has been added to the exam as of Java 5, and we'll cover 
it in great detail in Chapter 6. Volatile Variables
The volatile modifier tells the JVM that a thread accessing the variable must 
always reconcile its own private copy of the variable with the master copy in 
memory. Say what? Don't worry about it. For the exam, all you need to know about 
volatile is that, as with transient, it can be applied only to instance variables. Make no mistake, the idea of multiple threads accessing an instance variable is scary 
stuff, and very important for any Java programmer to understand. But as you'll see in 
Chapter 9, you'll probably use synchronization, rather than the volatile modifier, 
to make your data thread-safe. The volatile modifier may also be applied to project managers  : )
Static Variables and Methods 
The static modifier is used to create variables and methods that will exist 
independently of any instances created for the class. All static members exist 
before you ever make a new instance of a class, and there will be only one copy of 
a static member regardless of the number of instances of that class. In other words, 
all instances of a given class share the same value for any given static variable. We'll cover static members in great detail in the next chapter. Things you can mark as static:
■ Methods
■ Variables
■ A class nested within another class, but not within a method (more on this in 
Chapter 8). ■ Initialization blocks
Variable Declarations (Exam Objectives 1.3 and 1.4)  59
60 Chapter 1:  Declarations and Access Control
Things you can't mark as static:
■ Constructors (makes no sense; a constructor is used only to create instances)
■ Classes (unless they are nested)
■ Interfaces
■ Method local inner classes (we'll explore this in Chapter 8)
■ Inner class methods and instance variables
■ Local variables
Declaring Enums
As of 5.0, Java lets you restrict a variable to having one of only a few pre-defined 
values—in other words, one value from an enumerated list. (The items in the 
enumerated list are called, surprisingly, enums.)
Using enums can help reduce the bugs in your code. For instance, in your coffee 
shop application you might want to restrict your size selections to BIG, HUGE, 
and OVERWHELMING. If you let an order for a LARGE or a GRANDE slip in, it 
might cause an error. Enums to the rescue. With the following simple declaration, 
you can guarantee that the compiler will stop you from assigning anything to a 
CoffeeSize except BIG, HUGE, or OVERWHELMING:
enum CoffeeSize { BIG, HUGE, OVERWHELMING };
From then on, the only way to get a CoffeeSize will be with a statement something 
like this:
CoffeeSize cs = CoffeeSize.BIG;
It's not required that enum constants be in all caps, but borrowing from the Sun 
code convention that constants are named in caps, it's a good idea. The basic components of an enum are its constants (i.e., BIG, HUGE, and
OVERWHELMING), although in a minute you'll see that there can be a lot more 
to an enum. Enums can be declared as their own separate class, or as a class member, 
however they must not be declared within a method! Declaring an enum outside a class:
enum CoffeeSize { BIG, HUGE, OVERWHELMING }  // this cannot be
                                         // private or protected
class Coffee {
   CoffeeSize size;  
}
public class CoffeeTest1 {   
   public static void main(String[] args) {
      Coffee drink = new Coffee();
      drink.size = CoffeeSize.BIG;        // enum outside class
   }
}
The preceding code can be part of a single file. (Remember, the file must be named 
CoffeeTest1.java because that's the name of the public class in the file.) The 
key point to remember is that an enum that isn't enclosed in a class can be declared 
with only the public or default modifier, just like a non-inner class. Here's an 
example of declaring an enum inside a class:
class Coffee2 {
  enum CoffeeSize {BIG, HUGE, OVERWHELMING }
  CoffeeSize size;
}
public class CoffeeTest2 {
  public static void main(String[] args) {
    Coffee2 drink = new Coffee2();
    drink.size = Coffee2.CoffeeSize.BIG;   // enclosing class
             // name required
  }
}
The key points to take away from these examples are that enums can be declared 
as their own class, or enclosed in another class, and that the syntax for accessing 
an enum's members depends on where the enum was declared. Declaring Enums (Exam Objectives 1.3 and 1.4)   61
62 Chapter 1:  Declarations and Access Control
The following is NOT legal:
public class CoffeeTest1 {
  public static void main(String[] args) {
    enum CoffeeSize { BIG, HUGE, OVERWHELMING } // WRONG! Cannot
                                                // declare enums 
                                                // in methods
    Coffee drink = new Coffee();
    drink.size = CoffeeSize.BIG;
  }
} 
To make it more confusing for you, the Java language designers made it optional to 
put a semicolon at the end of the enum declaration (when no other declarations for 
this enum follow):
public class CoffeeTest1 {
  enum CoffeeSize { BIG, HUGE, OVERWHELMING }; // <--semicolon
                                             // is optional here
  public static void main(String[] args) {
    Coffee drink = new Coffee();
    drink.size = CoffeeSize.BIG;
  }
}
So what gets created when you make an enum? The most important thing to 
remember is that enums are not Strings or ints! Each of the enumerated CoffeeSize 
types are actually instances of CoffeeSize. In other words, BIG is of type CoffeeSize. Think of an enum as a kind of class, that looks something (but not exactly) like this:
// conceptual example of how you can think
// about enums
class CoffeeSize {
    public static final CoffeeSize BIG = 
                             new CoffeeSize("BIG", 0);
    public static final CoffeeSize HUGE = 
                             new CoffeeSize("HUGE", 1);
    public static final CoffeeSize OVERWHELMING = 
                             new CoffeeSize("OVERWHELMING", 2);
    
public CoffeeSize(String enumName, int index) {
       // stuff here
    }
   public static void main(String[] args) {
     System.out.println(CoffeeSize.BIG);
   }
}
Notice how each of the enumerated values, BIG, HUGE, and OVERWHELMING, 
are instances of type CoffeeSize. They're represented as static and final, which in 
the Java world, is thought of as a constant. Also notice that each enum value knows 
its index or position…in other words, the order in which enum values are declared 
matters. You can think of the CoffeeSize enums as existing in an array of type 
CoffeeSize, and as you'll see in a later chapter, you can iterate through the values of 
an enum by invoking the values() method on any enum type. (Don't worry about 
that in this chapter.)
Declaring Constructors, Methods, and Variables in an enum
Because an enum really is a special kind of class, you can do more than just list the 
enumerated constant values. You can add constructors, instance variables, methods, 
and something really strange known as a constant specific class body. To understand 
why you might need more in your enum, think about this scenario: imagine you 
want to know the actual size, in ounces, that map to each of the three CoffeeSize 
constants. For example, you want to know that BIG is 8 ounces, HUGE is 10 
ounces, and OVERWHELMING is a whopping 16 ounces. You could make some kind of a lookup table, using some other data structure, 
but that would be a poor design and hard to maintain. The simplest way is to treat 
your enum values (BIG, HUGE, and OVERWHELMING), as objects that can each 
have their own instance variables. Then you can assign those values at the time the 
enums are initialized, by passing a value to the enum constructor. This takes a little 
explaining, but first look at the following code:
enum CoffeeSize { 
    // 8, 10 & 16 are passed to the constructor
    BIG(8), HUGE(10), OVERWHELMING(16);  
    CoffeeSize(int ounces) { // constructor
      this.ounces = ounces;  
    }
    private int ounces;      // an instance variable
    public int getOunces() {
Declaring Enums (Exam Objectives 1.3 and 1.4)   63
64 Chapter 1:  Declarations and Access Control
      return ounces;
    }
}
class Coffee {
   CoffeeSize size;    // each instance of Coffee has an enum
   public static void main(String[] args) {
      Coffee drink1 = new Coffee();
      drink1.size = CoffeeSize.BIG;
      Coffee drink2 = new Coffee();
      drink2.size = CoffeeSize.OVERWHELMING;
      System.out.println(drink1.size.getOunces()); // prints 8
      for(CoffeeSize cs: CoffeeSize.values())
         System.out.println(cs + " " + cs.getOunces());
   }
}
Which produces:
  8
  BIG 8
  HUGE 10
  OVERWHELMING 16
Note: Every enum has a static method, values(), that returns an array of the enum's 
values in the order they're declared. The key points to remember about enum constructors are
■ You can NEVER invoke an enum constructor directly. The enum constructor 
is invoked automatically, with the arguments you define after the constant 
value. For example, BIG(8) invokes the CoffeeSize constructor that takes 
an int, passing the int literal 8 to the constructor. (Behind the scenes, of 
course, you can imagine that BIG is also passed to the constructor, but we 
don't have to know—or care—about the details.)
■ You can define more than one argument to the constructor, and you can 
overload the enum constructors, just as you can overload a normal class 
constructor. We discuss constructors in much more detail in Chapter 2. To 
initialize a CoffeeType with both the number of ounces and, say, a lid type, 
you'd pass two arguments to the constructor as BIG(8, "A"), which means 
you have a constructor in CoffeeSize that takes both an int and a String. And finally, you can define something really strange in an enum that looks like an 
anonymous inner class (which we talk about in Chapter 8). It's known as a constant 
specific class body, and you use it when you need a particular constant to override a 
method defined in the enum. Imagine this scenario: you want enums to have two methods—one for ounces 
and one for lid code (a String). Now imagine that most coffee sizes use the same 
lid code, "B", but the OVERWHELMING size uses type "A". You can define a 
getLidCode() method in the CoffeeSize enum that returns "B", but then you need 
a way to override it for OVERWHELMING. You don't want to do some hard-to-
maintain if/then code in the getLidCode() method, so the best approach might 
be to somehow have the OVERWHELMING constant override the getLidCode() 
method. This looks strange, but you need to understand the basic declaration rules:
enum CoffeeSize { 
     BIG(8), 
     HUGE(10), 
     OVERWHELMING(16) {    // start a code block that defines
                           // the "body" for this constant
       public String getLidCode() {   // override the method 
                                      // defined in CoffeeSize
         return "A";
       }
     };    // the semicolon is REQUIRED when more code follows
     CoffeeSize(int ounces) {
       this.ounces = ounces;
     }
    private int ounces;
    public int getOunces() {
      return ounces;
    }
    public String getLidCode() {  // this method is overridden 
                                 // by the OVERWHELMING constant
      return "B";   // the default value we want to return for
                    // CoffeeSize constants
    }
}
Declaring Enums (Exam Objectives 1.3 and 1.4)   65
66 Chapter 1:  Declarations and Access Control
CERTIFICATION SUMMARY
After absorbing the material in this chapter, you should be familiar with some of the 
nuances of the Java language. You may also be experiencing confusion around why 
you ever wanted to take this exam in the first place.

--- Chunk #1257 ---
That's normal at this point. If 
you hear yourself saying, "What was I thinking?" just lie down until it passes. We 
would like to tell you that it gets easier…that this was the toughest chapter and it's 
all downhill from here…
Let's briefly review what you'll need to know for the exam. There will be many questions dealing with keywords indirectly, so be sure you can 
identify which are keywords and which aren't. Although naming conventions like the use of camelCase won't be on the exam 
directly, you will need to understand the basics of JavaBeans naming, which uses 
camelCase. You need to understand the rules associated with creating legal identifiers, and 
the rules associated with source code declarations, including the use of package and 
import statements. You now have a good understanding of access control as it relates to classes, 
methods, and variables. You've looked at how access modifiers (public, protected, 
and private) define the access control of a class or member. You learned that abstract classes can contain both abstract and nonabstract 
methods, but that if even a single method is marked abstract, the class must 
be marked abstract. Don't forget that a concrete (nonabstract) subclass of an 
abstract class must provide implementations for all the abstract methods of the 
superclass, but that an abstract class does not have to implement the abstract 
methods from its superclass. An abstract subclass can "pass the buck" to the first 
concrete subclass. We covered interface implementation. Remember that interfaces can extend 
another interface (even multiple interfaces), and that any class that implements an 
interface must implement all methods from all the interfaces in the inheritance tree 
of the interface the class is implementing. You've also looked at the other modifiers including static, final, abstract, 
synchronized, and so on. You've learned how some modifiers can never be 
combined in a declaration, such as mixing abstract with either final or private. Keep in mind that there are no final objects in Java. A reference variable 
marked final can never be changed, but the object it refers to can be modified. You've seen that final applied to methods means a subclass can't override them, 
and when applied to a class, the final class can't be subclassed. Remember that as of Java 5, methods can be declared with a var-arg parameter 
(which can take from zero to many arguments of the declared type), but that you can 
have only one var-arg per method, and it must be the method's last parameter. Make sure you're familiar with the relative sizes of the numeric primitives. Remember that while the values of non-final variables can change, a reference 
variable's type can never change. You also learned that arrays are objects that contain many variables of the same 
type. Arrays can also contain other arrays. Remember what you've learned about static variables and methods, especially 
that static members are per-class as opposed to per-instance. Don't forget that 
a static method can't directly access an instance variable from the class it's in, 
because it doesn't have an explicit reference to any particular instance of the class. Finally, we covered a feature new to Java 5, enums. An enum is a much safer and 
more flexible way to implement constants than was possible in earlier versions of 
Java. Because they are a special kind of class, enums can be declared very simply, 
or they can be quite complex—including such attributes as methods, variables, 
constructors, and a special type of inner class called a constant specific class body. Before you hurl yourself at the practice test, spend some time with the following 
optimistically named "T wo-Minute Drill." Come back to this particular drill often, 
as you work through this book and especially when you're doing that last-minute 
cramming. Because—and here's the advice you wished your mother had given you 
before you left for college—it's not what you know, it's when you know it. For the exam, knowing what you can't do with the Java language is just as 
important as knowing what you can do. Give the sample questions a try! They're 
very similar to the difficulty and structure of the real exam questions, and should 
be an eye opener for how difficult the exam can be. Don't worry if you get a lot of 
them wrong. If you find a topic that you are weak in, spend more time reviewing and 
studying. Many programmers need two or three serious passes through a chapter (or 
an individual objective) before they can answer the questions confidently. Certiﬁ  cation Summary 67
68 Chapter 1:  Declarations and Access Control
✓
TWO-MINUTE DRILL
Remember that in this chapter, when we talk about classes, we're referring to 
non-inner classes, or top-level classes. We'll devote all of Chapter 8 to inner classes. Identifiers (Objective 1.3)
❑ Identifiers can begin with a letter, an underscore, or a currency character. ❑ After the first character, identifiers can also include digits. ❑ Identifiers can be of any length. ❑ JavaBeans methods must be named using camelCase, and depending on the 
method's purpose, must start with set, get, is, add, or remove. Declaration Rules (Objective 1.1)
❑  A source code file can have only one public class. ❑ If the source file contains a public class, the filename must match the
public class name. ❑  A file can have only one package statement, but multiple imports. ❑ The package statement (if any) must be the first (non-comment) line in a 
source file. ❑ The import statements (if any) must come after the package and before 
 the class declaration. ❑ If there is no package statement, import statements must be the first (non-
comment) statements in the source file. ❑ package and import statements apply to all classes in the file. ❑  A file can have more than one nonpublic class. ❑ Files with no public classes have no naming restrictions. Class Access Modifiers (Objective 1.1)
❑ There are three access modifiers: public, protected, and private. ❑ There are four access levels: public, protected, default, and private. ❑ Classes can have only public or default access. ❑  A class with default access can be seen only by classes within the same package. ❑  A class with public access can be seen by all classes from all packages. ❑ Class visibility revolves around whether code in one class can
 ❑   Create an instance of another class
 ❑   Extend (or subclass), another class
 ❑   Access methods and variables of another class
Class Modifiers (Nonaccess) (Objective 1.2)
❑ Classes can also be modified with final, abstract, or strictfp. ❑  A class cannot be both final and abstract. ❑  A final class cannot be subclassed. ❑ An abstract class cannot be instantiated. ❑  A single abstract method in a class means the whole class must be abstract. ❑ An abstract class can have both abstract and nonabstract methods. ❑ The first concrete class to extend an abstract class must implement all of its
 abstract methods. Interface Implementation (Objective 1.2)
❑ Interfaces are contracts for what a class can do, but they say nothing about 
the way in which the class must do it. ❑ Interfaces can be implemented by any class, from any inheritance tree. ❑ An interface is like a 100-percent abstract class, and is implicitly abstract 
whether you type the abstract modifier in the declaration or not. ❑ An interface can have only abstract methods, no concrete methods allowed. ❑ Interface methods are by default public and abstract—explicit declaration 
of these modifiers is optional. ❑ Interfaces can have constants, which are always implicitly public, 
static, and final. ❑ Interface constant declarations of public, static, and final are optional 
in any combination. ❑  A legal nonabstract implementing class has the following properties:
 ❑    It provides concrete implementations for the interface's methods. ❑    It must follow all legal override rules for the methods it implements. ❑    It must not declare any new checked exceptions for an 
      implementation method. T wo-Minute Drill 69
70 Chapter 1:  Declarations and Access Control
 ❑    It must not declare any checked exceptions that are broader than
      the exceptions declared in the interface method. ❑    It may declare runtime exceptions on any interface method 
      implementation regardless of the interface declaration. ❑    It must maintain the exact signature (allowing for covariant returns) 
      and return type of the methods it implements (but does not have to 
      declare the exceptions of the interface). ❑  A class implementing an interface can itself be abstract. ❑ An abstract implementing class does not have to implement the interface 
methods (but the first concrete subclass must). ❑  A class can extend only one class (no multiple inheritance), but it can 
implement many interfaces. ❑ Interfaces can extend one or more other interfaces. ❑ Interfaces cannot extend a class, or implement a class or interface. ❑ When taking the exam, verify that interface and class declarations are legal 
before verifying other code logic. Member Access Modifiers (Objectives 1.3 and 1.4)
❑ Methods and instance (nonlocal) variables are known as "members."
❑ Members can use all four access levels: public, protected, default, private. ❑ Member access comes in two forms:
 ❑    Code in one class can access a member of another class. ❑    A subclass can inherit a member of its superclass. ❑ If a class cannot be accessed, its members cannot be accessed. ❑ Determine class visibility before determining member visibility. ❑ public members can be accessed by all other classes, even in other packages. ❑ If a superclass member is public, the subclass inherits it—regardless of package. ❑ Members accessed without the dot operator (.) must belong to the same class. ❑ this. always refers to the currently executing object. ❑ this.aMethod() is the same as just invoking aMethod(). ❑ private members can be accessed only by code in the same class. ❑ private members are not visible to subclasses, so private members can-
not be inherited. ❑ Default and protected members differ only when subclasses are involved:
 ❑   Default members can be accessed only by classes in the same package. ❑    protected members can be accessed by other classes in the same 
      package, plus subclasses regardless of package. ❑    protected = package plus kids (kids meaning subclasses). ❑    For subclasses outside the package, the protected member can be 
      accessed only through inheritance; a subclass outside the package cannot
      access a protected member by using a reference to a superclass instance 
      (in other words, inheritance is the only mechanism for a subclass
      outside the package to access a protected member of its superclass). ❑    A protected member inherited by a subclass from another package is 
      not accessible to any other class in the subclass package, except for the 
      subclass' own subclasses. Local Variables (Objective 1.3)
❑ Local (method, automatic, or stack) variable declarations cannot have 
access modifiers. ❑ final is the only modifier available to local variables. ❑ Local variables don't get default values, so they must be initialized before use. Other Modifiers—Members (Objective 1.3)
❑ final methods cannot be overridden in a subclass. ❑ abstract methods are declared, with a signature, a return type, and 
an optional throws clause, but are not implemented. ❑ abstract methods end in a semicolon—no curly braces. ❑ Three ways to spot a non-abstract method:
 ❑    The method is not marked abstract. ❑    The method has curly braces. ❑    The method has code between the curly braces. ❑ The first nonabstract (concrete) class to extend an abstract class must 
implement all of the abstract class' abstract methods. ❑ The synchronized modifier applies only to methods and code blocks. ❑ synchronized methods can have any access control and can also be 
marked final. T wo-Minute Drill 71
72 Chapter 1:  Declarations and Access Control
❑ abstract methods must be implemented by a subclass, so they must be 
inheritable. For that reason:
 ❑    abstract methods cannot be private. ❑    abstract methods cannot be final. ❑ The native modifier applies only to methods. ❑ The strictfp modifier applies only to classes and methods. Methods with var-args (Objective 1.4)
❑ As of Java 5, methods can declare a parameter that accepts from zero to 
many arguments, a so-called var-arg method. ❑ A var-arg parameter is declared with the syntax type... name; for instance: 
doStuff(int... x) { }
❑ A var-arg method can have only one var-arg parameter. ❑ In methods with normal parameters and a var-arg, the var-arg must come last. Variable Declarations (Objective 1.3)
❑ Instance variables can
  ❑  Have any access control
  ❑  Be marked final or transient
❑ Instance variables can't be abstract, synchronized, native, or strictfp. ❑ It is legal to declare a local variable with the same name as an instance 
variable; this is called "shadowing."
❑ final variables have the following properties:
 ❑    final variables cannot be reinitialized once assigned a value. ❑    final reference variables cannot refer to a different object once the
      object has been assigned to the final variable. ❑    final reference variables must be initialized before the constructor 
      completes. ❑ There is no such thing as a final object. An object reference marked final 
does not mean the object itself is immutable. ❑ The transient modifier applies only to instance variables. ❑ The volatile modifier applies only to instance variables. Array Declarations (Objective 1.3)
❑ Arrays can hold primitives or objects, but the array itself is always an object. ❑ When you declare an array, the brackets can be to the left or right of the 
variable name. ❑ It is never legal to include the size of an array in the declaration. ❑ An array of objects can hold any object that passes the IS-A (or instanceof) 
test for the declared type of the array. For example, if Horse extends Animal, 
then a Horse object can go into an Animal array. Static Variables and Methods (Objective 1.4)
❑ They are not tied to any particular instance of a class. ❑ No classes instances are needed in order to use static members of the class. ❑ There is only one copy of a static variable / class and all instances share it. ❑ static methods do not have direct access to non-static members. Enums (Objective 1.3)
❑ An enum specifies a list of constant values assigned to a type. ❑ An enum is NOT a String or an int; an enum constant's type is the enum 
type. For example, SUMMER and FALL are of the enum type Season. ❑ An enum can be declared outside or inside a class, but NOT in a method. ❑ An enum declared outside a class must NOT be marked static, final, 
abstract, protected, or private. ❑ Enums can contain constructors, methods, variables, and constant class bodies. ❑ enum constants can send arguments to the enum constructor, using the 
syntax BIG(8), where the int literal 8 is passed to the enum constructor. ❑ enum constructors can have arguments, and can be overloaded. ❑ enum constructors can NEVER be invoked directly in code. They are always 
called automatically when an enum is initialized. ❑ The semicolon at the end of an enum declaration is optional. These are legal:
 enum Foo { ONE, TWO, THREE}
enum Foo { ONE, TWO, THREE};
❑ MyEnum.values() returns an array of MyEnum's values. T wo-Minute Drill 73
SELF TEST
The following questions will help you measure your understanding of the material presented in this 
chapter.

--- Chunk #1258 ---
Read all of the choices carefully, as there may be more than one correct answer.

--- Chunk #1259 ---
Choose all 
correct answers for each question. Stay focused. If you have a rough time with these at first, don't beat yourself up. Be positive. Repeat nice 
affirmations to yourself like, "I am smart enough to understand enums"  and "OK, so that other guy 
knows enums better than I do, but I bet he can't <insert something you are good at> like me."
 1. Which is true?

--- Chunk #1260 ---
(Choose all that apply.)
  A. "X extends Y" is correct if and only if X is a class and Y is an interface
  B. "X extends Y" is correct if  and only if X is an interface and Y is a class
  C. "X extends Y" is correct if X and Y are either both classes or both interfaces
  D. "X extends Y" is correct for all combinations of X and Y being classes and/or interfaces
 2. Which method names follow the JavaBeans standard? (Choose all that apply.)
  A. addSize
  B. getCust
  C.

--- Chunk #1261 ---
deleteRep
  D. isColorado
  E. putDimensions
 3. Given:
1. class Voop {
2. public static void main(String [] args) {
3. doStuff(1);
4. doStuff(1,2);
5. }
6. // insert code here
7. }
  Which, inserted independently at line 6, will compile? (Choose all that apply.)
  A. static void doStuff(int... doArgs) { } 
  B. static void doStuff(int[] doArgs) { }
  C. static void doStuff(int doArgs...) { }
  D. static void doStuff(int... doArgs, int y) { }
  E. static void doStuff(int x, int... doArgs) { }
74 Chapter 1:  Declarations and Access Control
 4. Given:
 1. enum Animals {
 2. DOG("woof"), CAT("meow"), FISH("burble");
 3. String sound;
 4. Animals(String s) { sound = s; }
 5. }
 6. class TestEnum {
 7. static Animals a;
 8. public static void main(String[] args) {
 9. System.out.println(a.DOG.sound + " " + a.FISH.sound);
10. }
11.

--- Chunk #1262 ---
}
  What is the result? A. woof burble
  B. Multiple compilation errors
  C. Compilation fails due to an error on line 2
  D. Compilation fails due to an error on line 3
  E. Compilation fails due to an error on line 4
  F. Compilation fails due to an error on line 9
 5. Given two files:
 1. package pkgA;
 2. public class Foo {
 3. int a = 5;
 4. protected int b = 6;
 5. public int c = 7;
 6. }
 3. package pkgB;
 4. import pkgA.*;
 5. public class Baz {
 6. public static void main(String[] args) {
 7. Foo f = new Foo();
 8. System.out.print(" " + f.a);
 9. System.out.print(" " + f.b);
10. System.out.println(" " + f.c);
11. }
12. }
Self T est 75
76 Chapter 1:  Declarations and Access Control
  What is the result? (Choose all that apply.)
  A. 5 6 7
  B. 5 followed by an exception
  C. Compilation fails with an error on line 7
  D. Compilation fails with an error on line 8
  E. Compilation fails with an error on line 9
  F. Compilation fails with an error on line 10
 6. Given:
 1. public class Electronic implements Device 
          { public void doIt() { } }
 2. 3. abstract class Phone1 extends Electronic { }
 4. 5. abstract class Phone2 extends Electronic 
      { public void doIt(int x) { } }
 6. 7. class Phone3 extends Electronic implements Device 
      { public void doStuff() { } }
 8. 9. interface Device { public void doIt(); }
  What is the result? (Choose all that apply.)
  A. Compilation succeeds
  B. Compilation fails with an error on line 1
  C. Compilation fails with an error on line 3
  D. Compilation fails with an error on line 5
  E. Compilation fails with an error on line 7
  F. Compilation fails with an error on line 9
 7. Given:
 4. class Announce {
 5. public static void main(String[] args) {
 6. for(int __x = 0; __x < 3; __x++) ;
 7. int #lb = 7;                          
Self T est 77
 8. long [] x [5];                       
 9. Boolean []ba[];
10. enum Traffic { RED, YELLOW, GREEN }; 
11. }
12.

--- Chunk #1263 ---
}
  What is the result? (Choose all that apply.)
  A. Compilation succeeds
  B. Compilation fails with an error on line 6
  C. Compilation fails with an error on line 7
  D. Compilation fails with an error on line 8
  E. Compilation fails with an error on line 9
  F. Compilation fails with an error on line 10
 8. Given:
 3. public class TestDays {
 4. public enum Days { MON, TUE, WED };
 5. public static void main(String[] args) {
 6. for(Days d : Days.values() )
 7. ;
 8. Days [] d2 = Days.values();
 9. System.out.println(d2[2]);
10. }
11.

--- Chunk #1264 ---
}
  What is the result? (Choose all that apply.)
  A. TUE
  B. WED
  C. The output is unpredictable
  D. Compilation fails due to an error on line 4
  E. Compilation fails due to an error on line 6
  F. Compilation fails due to an error on line 8
  G. Compilation fails due to an error on line 9
78 Chapter 1:  Declarations and Access Control
 9. Given:
 4. public class Frodo extends Hobbit {
 5. public static void main(String[] args) {
 6. Short myGold = 7;
 7. System.out.println(countGold(myGold, 6));
 8. }
 9.

--- Chunk #1265 ---
}
10. class Hobbit {
11. int countGold(int x, int y) { return x + y; }
12. }
  What is the result?

--- Chunk #1266 ---
A.

--- Chunk #1267 ---
13
  B. Compilation fails due to multiple errors
  C. Compilation fails due to an error on line 6
  D. Compilation fails due to an error on line 7
  E. Compilation fails due to an error on line 11
SELF TEST ANSWERS
 1. Which is true?

--- Chunk #1268 ---
(Choose all that apply.)
  A. "X extends Y" is correct if and only if X is a class and Y is an interface
  B. "X extends Y" is correct if  and only if X is an interface and Y is a class
  C. "X extends Y" is correct if X and Y are either both classes or both interfaces
  D. "X extends Y" is correct for all combinations of X and Y being classes and/or interfaces
  Answer:
  ® ✓    C is correct. ® ˚  A is incorrect because classes implement interfaces, they don't extend them. B is incorrect 
because interfaces only "inherit from" other interfaces. D is incorrect based on the 
preceding rules. (Objective 1.2)
 2. Which method names follow the JavaBeans standard? (Choose all that apply.)
  A. addSize
  B. getCust
  C.

--- Chunk #1269 ---
deleteRep
  D. isColorado
  E. putDimensions
  Answer:
  ® ✓    B and D use the valid prefixes 'get' and 'is'. ® ˚     A is incorrect because ' add' can be used only with Listener methods. C and E  are 
incorrect because ' delete' and 'put' are not standard JavaBeans name prefixes. (Objective 1.4)
 3.

--- Chunk #1270 ---
Given:
1. class Voop {
2. public static void main(String[] args) {
3. doStuff(1);
4. doStuff(1,2);
5. }
6. // insert code here
7. }
Self T est Answers 79
80 Chapter 1:  Declarations and Access Control
  Which, inserted independently at line 6, will compile? (Choose all that apply.)
  A. static void doStuff(int... doArgs) { } 
  B. static void doStuff(int[] doArgs) { }
  C. static void doStuff(int doArgs...) { }
  D. static void doStuff(int... doArgs, int y) { }
  E. static void doStuff(int x, int... doArgs) { }
  Answer:
  ® ✓    A and E use valid var-args syntax. ® ˚     B and C are invalid var-arg syntax, and D is invalid because the var-arg must be the last 
of a method's arguments. (Objective 1.4)
 4.

--- Chunk #1271 ---
Given:
 1. enum Animals {
 2. DOG("woof"), CAT("meow"), FISH("burble");
 3. String sound;
 4. Animals(String s) { sound = s; }
 5. }
 6. class TestEnum {
 7. static Animals a;
 8. public static void main(String [] args) {
 9. System.out.println(a.DOG.sound + " " + a.FISH.sound);
10. }
11.

--- Chunk #1272 ---
}
  What is the result? A. woof burble
  B. Multiple compilation errors
  C. Compilation fails due to an error on line 2
  D. Compilation fails due to an error on line 3
  E. Compilation fails due to an error on line 4
  F. Compilation fails due to an error on line 9
  Answer:
  ® ✓    A is correct; enums can have constructors and variables. ® ˚    B, C, D, E, and F are incorrect; these lines all use correct syntax. (Objective 1.3)
 5.

--- Chunk #1273 ---
Given two files:
 1. package pkgA;
 2. public class Foo {
 3. int a = 5;
 4. protected int b = 6;
 5. public int c = 7;
 6. }
 
 3. package pkgB;
 4. import pkgA.*;
 5. public class Baz {
 6. public static void main(String[] args) {
 7. Foo f = new Foo();
 8. System.out.print(" " + f.a);
 9. System.out.print(" " + f.b);
10. System.out.print(" " + f.c);
11. }
12.

--- Chunk #1274 ---
}
  What is the result? (Choose all that apply.)
  A. 5 6 7
  B. 5 followed by an exception
  C. Compilation fails with an error on line 7
  D. Compilation fails with an error on line 8
  E. Compilation fails with an error on line 9
  F. Compilation fails with an error on line 10
  Answer:
  ® ✓     D and E are correct. Variable a has default access, so it cannot be accessed from outside the 
package. Variable b has protected access in pkgA. ® ˚    A, B, C, and F are incorrect based on the above information. (Objective 1.1)
 6.

--- Chunk #1275 ---
Given:
 1. public class Electronic implements Device 
          { public void doIt() { } }
 2. 3. abstract class Phone1 extends Electronic { }
 4. 5. abstract class Phone2 extends Electronic 
      { public void doIt(int x) { } }
 6. Self T est Answers 81
82 Chapter 1:  Declarations and Access Control
 7. class Phone3 extends Electronic implements Device 
      { public void doStuff() { } }
 8. 9. interface Device { public void doIt(); }
  What is the result? (Choose all that apply.)
  A. Compilation succeeds
  B. Compilation fails with an error on line 1
  C. Compilation fails with an error on line 3
  D. Compilation fails with an error on line 5
  E. Compilation fails with an error on line 7
  F. Compilation fails with an error on line 9
  Answer:
  ® ✓     A is correct; all of these are legal declarations. ® ˚    B, C, D, E, and F are incorrect based on the above information. (Objective 1.2)
 7.

--- Chunk #1276 ---
Given:
 4. class Announce {
 5. public static void main(String[] args) {
 6. for(int __x = 0; __x < 3; __x++) ;
 7. int #lb = 7;                          
 8. long [] x [5];                       
 9. Boolean []ba[];
10. enum Traffic { RED, YELLOW, GREEN }; 
11. }
12.

--- Chunk #1277 ---
}
  What is the result? (Choose all that apply.)
  A. Compilation succeeds
  B. Compilation fails with an error on line 6
  C. Compilation fails with an error on line 7
  D. Compilation fails with an error on line 8
  E. Compilation fails with an error on line 9
  F. Compilation fails with an error on line 10
Self T est Answers 83
  Answer:
  ® ✓     C, D, and F are correct. Variable names cannot begin with a #, an array declaration can’t 
include a size without an instantiation, and enums can’t be declared within a method. ® ˚    A, B, and E are incorrect based on the above information. (Objective 1.3)
 8.

--- Chunk #1278 ---
Given:
 3. public class TestDays {
 4. public enum Days { MON, TUE, WED };
 5. public static void main(String[] args) {
 6. for(Days d : Days.values() )
 7. ;
 8. Days [] d2 = Days.values();
 9. System.out.println(d2[2]);
10. }
11.

--- Chunk #1279 ---
}
  What is the result? (Choose all that apply.)
  A. TUE
  B. WED
  C. The output is unpredictable
  D. Compilation fails due to an error on line 4
  E. Compilation fails due to an error on line 6
  F. Compilation fails due to an error on line 8
  G. Compilation fails due to an error on line 9
  Answer:
  ® ✓     B is correct. Every enum comes with a static values() method that returns an array 
of the enum's values, in the order in which they are declared in the enum. ® ˚    A, C, D, E, F, and G are incorrect based on the above information. (Objective 1.3)
 9.

--- Chunk #1280 ---
Given:
 4. public class Frodo extends Hobbit {
 5. public static void main(String[] args) {
 6. Short myGold = 7;
 7. System.out.println(countGold(myGold, 6));
 8. }
 9.

--- Chunk #1281 ---
}
10. class Hobbit {
11. int countGold(int x, int y) { return x + y; }
12. }
84 Chapter 1:  Declarations and Access Control
  What is the result? A.

--- Chunk #1282 ---
13
  B. Compilation fails due to multiple errors
  C. Compilation fails due to an error on line 6
  D. Compilation fails due to an error on line 7
  E. Compilation fails due to an error on line 11
  Answer:
  ® ✓     D is correct. The Short myGold is autoboxed correctly, but the countGold() method 
cannot be invoked from a static context. ® ˚    A, B, C, and E are incorrect based on the above information. (Objective 1.4)
2
Object
Orientation
CERTIFICATION OBJECTIVES
 l    Declare Interfaces
 l     Declare, Initialize, and Use
       Class Members
 l     Use Overloading and Overriding
l    Develop Constructors
 l     Describe Encapsulation, Coupling,
       and Cohesion
l    Use Polymorphism
 l    Relate Modifiers and Inheritance 
 l    Use Superclass Constructors and
        Overloaded Constructors
 
 l    Use IS-A and HAS-A Relationships
 ✓   T wo-Minute Drill
        Q&A Self T est
 
	
86 Chapter 2:  Object Orientation
B
eing an SCJP 6 means you must be at one with the object-oriented aspects of Java. Y ou 
must dream of inheritance hierarchies, the power of polymorphism must flow through 
you, cohesion and loose coupling must become second nature to you, and composition 
must be your bread and butter. This chapter will prepare you for all of the object-oriented 
objectives and questions you'll encounter on the exam. We have heard of many experienced Java 
programmers who haven't really become fluent with the object-oriented tools that Java provides, 
so we'll start at the beginning. CERTIFICATION OBJECTIVE
Encapsulation (Exam Objective 5.1)
5.1 Develop code that implements tight encapsulation, loose coupling, and high cohesion 
in classes, and describe the benefits. Imagine you wrote the code for a class, and another dozen programmers from 
your company all wrote programs that used your class. Now imagine that later on, 
you didn't like the way the class behaved, because some of its instance variables 
were being set (by the other programmers from within their code) to values you 
hadn't anticipated. Their code brought out errors in your code. (Relax, this is just 
hypothetical.) Well, it is a Java program, so you should be able just to ship out a 
newer version of the class, which they could replace in their programs without 
changing any of their own code. This scenario highlights two of the promises/benefits of Object Orientation (OO): 
flexibility and maintainability. But those benefits don't come automatically.

--- Chunk #1283 ---
You 
have to do something. You have to write your classes and code in a way that supports 
flexibility and maintainability. So what if Java supports OO? It can't design your 
code for you. For example, imagine if you made your class with public instance 
variables, and those other programmers were setting the instance variables directly, 
as the following code demonstrates:
public class BadOO {
   public int size;
Encapsulation (Exam Objective 5.1) 87
   public int weight;
   ... }
public class ExploitBadOO {
   public static void main (String [] args) {
      BadOO b = new BadOO();
      b.size = -5; // Legal but bad!! }
}
And now you're in trouble. How are you going to change the class in a way that 
lets you handle the issues that come up when somebody changes the size variable 
to a value that causes problems? Your only choice is to go back in and write method 
code for adjusting size (a setSize(int a) method, for example), and then 
protect the size variable with, say, a private access modifier. But as soon as you 
make that change to your code, you break everyone else's! The ability to make changes in your implementation code without breaking the 
code of others who use your code is a key benefit of encapsulation. You want to 
hide implementation details behind a public programming interface. By interface, 
we mean the set of accessible methods your code makes available for other code to 
call—in other words, your code's API. By hiding implementation details, you can 
rework your method code (perhaps also altering the way variables are used by your 
class) without forcing a change in the code that calls your changed method. If you want maintainability, flexibility, and extensibility (and of course, you do), 
your design must include encapsulation. How do you do that? ■ Keep instance variables protected (with an access modifier, often private). ■ Make public accessor methods, and force calling code to use those methods 
rather than directly accessing the instance variable. ■ For the methods, use the JavaBeans naming convention of 
set<someProperty> and get<someProperty>. Figure 2-1 illustrates the idea that encapsulation forces callers of our code to go 
through methods rather than accessing variables directly. FIGURE 2-1  
The nature of 
encapsulation
We call the access methods getters and setters although some prefer the fancier 
terms accessors and mutators. (Personally, we don't like the word "mutate".) 
Regardless of what you call them, they're methods that other programmers must go 
through in order to access your instance variables. They look simple, and you've 
probably been using them forever:
public class Box {
   // protect the instance variable; only an instance 
   // of Box can access it
   private int size;
   // Provide public getters and setters
   public int getSize() {
      return size;
88 Chapter 2:  Object Orientation
Class A
B b = new B();
getSize()
setSize()
getName()
setName()
getColor()
setColor()
int x = b.getSize();
b.setSize(34);
b.setName("Fred");
b.setColor(blue);
String s = b.getName();
Color c = b.getColor();
Class B
size
name
color
Class A cannot access Class B instance variable data 
without going through getter and setter methods. Data is
marked private; only the accessor methods are public. privatepubl ic
   }
   public void setSize(int newSize) {
      size = newSize;
   }
}
Wait a minute...how useful is the previous code? It doesn't even do any validation 
or processing. What benefit can there be from having getters and setters that add 
no additional functionality? The point is, you can change your mind later, and add 
more code to your methods without breaking your API. Even if today you don't 
think you really need validation or processing of the data, good OO design dictates 
that you plan for the future. To be safe, force calling code to go through your 
methods rather than going directly to instance variables. Always. Then you're free to 
rework your method implementations later, without risking the wrath of those dozen 
programmers who know where you live. Encapsulation (Exam Objective 5.1) 89
Look out for code that appears to be asking about the behavior of a 
method, when the problem is actually a lack of encapsulation. Look at the following 
example, and see if you can ﬁ  gure out what’s going on:
class Foo {
   public int left = 9;
   public int right = 3;
   public void setLeft(int leftNum) {
      left = leftNum;
      right = leftNum/3;
   }
   // lots of complex test code here
}
Now consider this question: Is the value of right always going to be one-
third the value of left? It looks like it will, until you realize that users of the Foo class 
don’t need to use the setLeft() method! They can simply go straight to the instance 
variables and change them to any arbitrary int value. CERTIFICATION OBJECTIVE
Inheritance, Is-A, Has-A (Exam Objective 5.5)
5.5 Develop code that implements "is-a" and/or "has-a" relationships. Inheritance is everywhere in Java. It's safe to say that it's almost (almost?) 
impossible to write even the tiniest Java program without using inheritance. In order 
to explore this topic we're going to use the instanceof operator, which we'll discuss 
in more detail in Chapter 4. For now, just remember that instanceof returns true 
if the reference variable being tested is of the type being compared to. This code:
class Test {
  public static void main(String [] args) {
    Test t1 = new Test();
    Test t2 = new Test();
    if (!t1.equals(t2))
      System.out.println("they're not equal");
    if (t1 instanceof Object)
      System.out.println("t1's an Object");
  }
}
Produces the output:
they're not equal
t1's an Object
Where did that equals method come from? The reference variable t1 is of type 
Test, and there's no equals method in the Test class. Or is there? The second if 
test asks whether t1 is an instance of class Object, and because it is (more on that 
soon), the if test succeeds. Hold on…how can t1 be an instance of type Object, we just said it was of type 
Test? I'm sure you're way ahead of us here, but it turns out that every class in Java is 
a subclass of class Object, (except of course class Object itself). In other words, every 
class you'll ever use or ever write will inherit from class Object. You'll always have 
an equals method, a clone method, notify, wait, and others, available to use. Whenever you create a class, you automatically inherit all of class Object's methods. 90 Chapter 2:  Object Orientation
Why? Let's look at that equals method for instance. Java's creators correctly 
assumed that it would be very common for Java programmers to want to compare 
instances of their classes to check for equality. If class Object didn't have an equals 
method, you'd have to write one yourself; you and every other Java programmer. That one equals method has been inherited billions of times. (To be fair, equals 
has also been overridden billions of times, but we're getting ahead of ourselves.)
For the exam you'll need to know that you can create inheritance relationships 
in Java by extending a class. It's also important to understand that the two most 
common reasons to use inheritance are
■ To promote code reuse 
■ To use polymorphism
Let's start with reuse. A common design approach is to create a fairly generic 
version of a class with the intention of creating more specialized subclasses that 
inherit from it. For example:
class GameShape {
   public void displayShape() {
     System.out.println("displaying shape");
   }
   // more code
}
class PlayerPiece extends GameShape {
   public void movePiece() {
     System.out.println("moving game piece");
   }
   // more code
}
public class TestShapes {
   public static void main (String[] args) {
      PlayerPiece shape = new PlayerPiece();
      shape.displayShape();
      shape.movePiece();
   }
}
Inheritance, Is-A, Has-A (Exam Objective 5.5) 91
Outputs:
displaying shape
moving game piece
Notice that the PlayingPiece class inherits the generic display() method 
from the less-specialized class GameShape, and also adds its own method, 
movePiece(). Code reuse through inheritance means that methods with generic 
functionality (like display())—that could apply to a wide range of different kinds 
of shapes in a game—don't have to be reimplemented. That means all specialized 
subclasses of GameShape are guaranteed to have the capabilities of the more generic 
superclass. You don't want to have to rewrite the display() code in each of your 
specialized components of an online game. But you knew that.

--- Chunk #1284 ---
You've experienced the pain of duplicate code when you make 
a change in one place and have to track down all the other places where that same 
(or very similar) code exists. The second (and related) use of inheritance is to allow your classes to be accessed 
polymorphically—a capability provided by interfaces as well, but we'll get to that 
in a minute. Let's say that you have a GameLauncher class that wants to loop 
through a list of different kinds of GameShape objects, and invoke display() on 
each of them. At the time you write this class, you don't know every possible kind 
of GameShape subclass that anyone else will ever write. And you sure don't want 
to have to redo your code just because somebody decided to build a Dice shape six 
months later. The beautiful thing about polymorphism ("many forms") is that you can treat any 
subclass of GameShape as a GameShape. In other words, you can write code in your 
GameLauncher class that says, "I don't care what kind of object you are as long as 
you inherit from (extend) GameShape. And as far as I'm concerned, if you extend 
GameShape then you've definitely got a display() method, so I know I can call it."
Imagine we now have two specialized subclasses that extend the more generic 
GameShape class, PlayerPiece and TilePiece:
class GameShape {
   public void displayShape() {
     System.out.println("displaying shape");
   }
   // more code
}
92 Chapter 2:  Object Orientation
class PlayerPiece extends GameShape {
   public void movePiece() {
     System.out.println("moving game piece");
   }
   // more code
}
class TilePiece extends GameShape {
    public void getAdjacent() {
      System.out.println("getting adjacent tiles");
    }
    // more code
}
Now imagine a test class has a method with a declared argument type of  
GameShape, that means it can take any kind of GameShape. In other words, 
any subclass of GameShape can be passed to a method with an argument of type 
GameShape. This code
public class TestShapes {
   public static void main (String[] args) {
      PlayerPiece player = new PlayerPiece();
      TilePiece tile = new TilePiece();
      doShapes(player);
      doShapes(tile);
   }
   public static void doShapes(GameShape shape) {
     shape.displayShape();
   }
}
Outputs:
displaying shape
displaying shape
The key point is that the doShapes() method is declared with a GameShape 
argument but can be passed any subtype (in this example, a subclass) of GameShape. The method can then invoke any method of GameShape, without any concern 
for the actual runtime class type of the object passed to the method. There are 
Inheritance, Is-A, Has-A (Exam Objective 5.5) 93
implications, though. The doShapes() method knows only that the objects are 
a type of GameShape, since that's how the parameter is declared. And using a 
reference variable declared as type GameShape—regardless of whether the variable 
is a method parameter, local variable, or instance variable—means that only the 
methods of GameShape can be invoked on it. The methods you can call on a 
reference are totally dependent on the declared type of the variable, no matter what 
the actual object is, that the reference is referring to. That means you can't use a 
GameShape variable to call, say, the getAdjacent() method even if the object 
passed in is of type TilePiece. (We'll see this again when we look at interfaces.)
IS-A and HAS-A Relationships
For the exam you need to be able to look at code and determine whether the code 
demonstrates an IS-A or HAS-A relationship. The rules are simple, so this should be 
one of the few areas where answering the questions correctly is almost a no-brainer. IS-A
In OO, the concept of IS-A is based on class inheritance or interface 
implementation. IS-A is a way of saying, "this thing is a type of that thing." For 
example, a Mustang is a type of horse, so in OO terms we can say, "Mustang IS-A 
Horse." Subaru IS-A Car. Broccoli IS-A Vegetable (not a very fun one, but it still 
counts). You express the IS-A relationship in Java through the keywords extends 
(for class inheritance) and implements (for interface implementation). public class Car {
  // Cool Car code goes here
}
public class Subaru extends Car {
   // Important Subaru-specific stuff goes here
   // Don't forget Subaru inherits accessible Car members which
   // can include both methods and variables. }
A Car is a type of Vehicle, so the inheritance tree might start from the Vehicle 
class as follows:
public class Vehicle { ... }
public class Car extends Vehicle { ... }
public class Subaru extends Car { ... }
94 Chapter 2:  Object Orientation
In OO terms, you can say the following:
Vehicle is the superclass of Car. Car is the subclass of Vehicle. Car is the superclass of Subaru. Subaru is the subclass of Vehicle. Car inherits from Vehicle. Subaru inherits from both Vehicle and Car. Subaru is derived from Car. Car is derived from Vehicle. Subaru is derived from Vehicle. Subaru is a subtype of both Vehicle and Car. Returning to our IS-A relationship, the following statements are true:
"Car extends Vehicle" means "Car IS-A Vehicle."
"Subaru extends Car" means "Subaru IS-A Car."
And we can also say:
"Subaru IS-A Vehicle" because a class is said to be "a type of" anything further up 
in its inheritance tree. If the expression (Foo instanceof Bar) is true, then class 
Foo IS-A Bar, even if Foo doesn't directly extend Bar, but instead extends some 
other class that is a subclass of Bar. Figure 2-2 illustrates the inheritance tree for 
Vehicle, Car, and Subaru. The arrows move from the subclass to the superclass. In other words, a class' arrow points toward the class from which it extends. FIGURE 2-2  
Inheritance tree
for Vehicle, Car,
Subaru
IS-A (Exam Objective 5.5) 95
Vehicle
Car extends Vehicle
Subaru extends Car
HAS-A
HAS-A relationships are based on usage, rather than inheritance. In other words, 
class A HAS-A B if code in class A has a reference to an instance of class B. For 
example, you can say the following,
A Horse IS-A Animal. A Horse HAS-A Halter. The code might look like this:
public class Animal { }
public class Horse extends Animal {
   private Halter myHalter;
}
In the preceding code, the Horse class has an instance variable of type Halter, so 
you can say that "Horse HAS-A Halter." In other words, Horse has a reference to a 
Halter. Horse code can use that Halter reference to invoke methods on the Halter, 
and get Halter behavior without having Halter-related code (methods) in the Horse 
class itself. Figure 2-3 illustrates the HAS-A relationship between Horse and Halter. FIGURE 2-3  
HAS-A
relationship
between Horse
and Halter
HAS-A relationships allow you to design classes that follow good OO practices 
by not having monolithic classes that do a gazillion different things. Classes (and 
their resulting objects) should be specialists. As our friend Andrew says, "specialized 
classes can actually help reduce bugs." The more specialized the class, the more 
likely it is that you can reuse the class in other applications. If you put all the 
Halter-related code directly into the Horse class, you'll end up duplicating code 
in the Cow class, UnpaidIntern class, and any other class that might need Halter 
behavior. By keeping the Halter code in a separate, specialized Halter class, you 
have the chance to reuse the Halter class in multiple applications. 96 Chapter 2:  Object Orientation
Horse
Halter halt
tie(Rope r)t ie(Rope r)
Halter
Horse class has a Halter, because Horse 
declares an instance variable of type Halter. When code invokes tie() on a Horse instance,
the Horse invokes tie() on the Horse
object’s Halter instance variable. HAS-A (Exam Objective 5.5) 97
Object-Oriented Design
IS-A and HAS-A relationships and 
encapsulation are just the tip of the iceberg 
when it comes to object-oriented design. Many books and graduate theses have been 
dedicated to this topic.

--- Chunk #1285 ---
The reason for the 
emphasis on proper design is simple: money. The cost to deliver a software application has 
been estimated to be as much as ten times more 
expensive for poorly designed programs. Having 
seen the ramifications of poor designs, I can 
assure you that this estimate is not far-fetched. Even the best object-oriented designers 
make mistakes. It is difficult to visualize the 
relationships between hundreds, or even 
thousands, of classes. When mistakes are 
discovered during the implementation (code 
writing) phase of a project, the amount of code 
that has to be rewritten can sometimes cause 
programming teams to start over from scratch. The software industry has evolved to aid the 
designer. Visual object modeling languages, like 
the Unified Modeling Language (UML), allow 
designers to design and easily modify classes 
without having to write code first,
because object-oriented components 
are represented graphically. This allows 
the designer to create a map of the class 
relationships and helps them recognize errors 
before coding begins. Another innovation 
in object-oriented design is design patterns. Designers noticed that many object-oriented 
designs apply consistently from project to 
project, and that it was useful to apply the same 
designs because it reduced the potential to 
introduce new design errors. Object-oriented 
designers then started to share these designs 
with each other. Now, there are many catalogs 
of these design patterns both on the Internet 
and in book form. Although passing the Java certification exam 
does not require you to understand object-
oriented design this thoroughly, hopefully 
this background information will help you 
better appreciate why the test writers chose to 
include encapsulation, and IS-A, and HAS-A 
relationships on the exam. —Jonathan Meeks, Sun Certified Java Programmer
FROM THE CLASSROOM
98 Chapter 2:  Object Orientation
Users of the Horse class (that is, code that calls methods on a Horse instance), 
think that the Horse class has Halter behavior. The Horse class might have a 
tie(LeadRope rope) method, for example. Users of the Horse class should never 
have to know that when they invoke the tie() method, the Horse object turns 
around and delegates the call to its Halter class by invoking myHalter.tie(rope). The scenario just described might look like this:
public class Horse extends Animal {
   private Halter myHalter = new Halter();
   public void tie(LeadRope rope) {
      myHalter.tie(rope);  // Delegate tie behavior to the
                           // Halter object 
   }
}
public class Halter {
   public void tie(LeadRope aRope) {
      // Do the actual tie work here
   }
}
In OO, we don't want callers to worry about which class or which object 
is actually doing the real work. To make that happen, the Horse class hides 
implementation details from Horse users. Horse users ask the Horse object to 
do things (in this case, tie itself up), and the Horse will either do it or, as in this 
example, ask something else to do it. To the caller, though, it always appears that 
the Horse object takes care of itself. Users of a Horse should not even need to know 
that there is such a thing as a Halter class. CERTIFICATION OBJECTIVE
Polymorphism (Exam Objective 5.2)
5.2 Given a scenario, develop code that demonstrates the use of polymorphism. Further, 
determine when casting will be necessary and recognize compiler vs. runtime errors related 
to object reference casting. Polymorphism (Exam Objective 5.2) 99
Remember, any Java object that can pass more than one IS-A test can be 
considered polymorphic. Other than objects of type Object, all Java objects are 
polymorphic in that they pass the IS-A test for their own type and for class Object. Remember that the only way to access an object is through a reference variable, 
and there are a few key things to remember about references:
■ A reference variable can be of only one type, and once declared, that type 
can never be changed (although the object it references can change). ■ A reference is a variable, so it can be reassigned to other objects, (unless the 
reference is declared final). ■ A reference variable's type determines the methods that can be invoked on 
the object the variable is referencing. ■ A reference variable can refer to any object of the same type as the declared 
reference, or—this is the big one—it can refer to any subtype of the 
declared type! ■ A reference variable can be declared as a class type or an interface type. If 
the variable is declared as an interface type, it can reference any object of any 
class that implements the interface. Earlier we created a GameShape class that was extended by two other classes, 
PlayerPiece and TilePiece. Now imagine you want to animate some of the 
shapes on the game board. But not all shapes can be animatable, so what do you do 
with class inheritance? Could we create a class with an animate() method, and have only some of 
the GameShape subclasses inherit from that class? If we can, then we could have 
PlayerPiece, for example, extend both the GameShape class and Animatable class, 
while the TilePiece would extend only GameShape. But no, this won't work! Java 
supports only single inheritance! That means a class can have only one immediate 
superclass. In other words, if PlayerPiece is a class, there is no way to say 
something like this:
class PlayerPiece extends GameShape, Animatable { // NO! // more code
}
A class cannot extend more than one class. That means one parent per class. A 
class can have multiple ancestors, however, since class B could extend class A, and 
class C could extend class B, and so on. So any given class might have multiple 
classes up its inheritance tree, but that's not the same as saying a class directly 
extends two classes. Some languages (like C++) allow a class to extend more than one other class. This capability is known as "multiple inheritance." The reason that Java's 
creators chose not to allow multiple inheritance is that it can become quite 
messy. In a nutshell, the problem is that if a class extended two other classes, 
and both superclasses had, say, a doStuff() method, which version of doStuff() 
would the subclass inherit? This issue can lead to a scenario known as the 
"Deadly Diamond of Death," because of the shape of the class diagram that 
can be created in a multiple inheritance design. The diamond is formed when 
classes B and C both extend A, and both B and C inherit a method from A. If 
class D extends both B and C, and both B and C have overridden the method 
in A, class D has, in theory, inherited two different implementations of the 
same method. Drawn as a class diagram, the shape of the four classes looks 
like a diamond. So if that doesn't work, what else could you do? You could simply put the 
animate() code in GameShape, and then disable the method in classes that can't be 
animated. But that's a bad design choice for many reasons, including it's more error-
prone, it makes the GameShape class less cohesive (more on cohesion in a minute), 
and it means the GameShape API "advertises" that all shapes can be animated, when 
in fact that's not true since only some of the GameShape subclasses will be able to 
successfully run the animate() method. So what else could you do? You already know the answer—create an Animatable 
interface, and have only the GameShape subclasses that can be animated implement 
that interface. Here's the interface:
public interface Animatable {
   public void animate();
}
And here's the modified PlayerPiece class that implements the interface:
100 Chapter 2:  Object Orientation
Polymorphism (Exam Objective 5.2) 101
class PlayerPiece extends GameShape implements Animatable {
   public void movePiece() {
     System.out.println("moving game piece");
   }
   public void animate() {
     System.out.println("animating...");
   }
   // more code
}
So now we have a PlayerPiece that passes the IS-A test for both the 
GameShape class and the Animatable interface. That means a PlayerPiece can be 
treated polymorphically as one of four things at any given time, depending on the 
declared type of the reference variable:
■ An Object (since any object inherits from Object)
■  A GameShape (since PlayerPiece extends GameShape)
■  A PlayerPiece (since that's what it really is)
■ An Animatable (since PlayerPiece implements Animatable)
The following are all legal declarations. Look closely:
      PlayerPiece player = new PlayerPiece();
      Object o = player;
      GameShape shape = player;
      Animatable mover = player;
There's only one object here—an instance of type PlayerPiece—but there 
are four different types of reference variables, all referring to that one object on 
the heap. Pop quiz: which of the preceding reference variables can invoke the 
displayShape() method? Hint: only two of the four declarations can be used to 
invoke the displayShape() method. Remember that method invocations allowed by the compiler are based solely on 
the declared type of the reference, regardless of the object type. So looking at the 
four reference types again—Object, GameShape, PlayerPiece, and Animatable—
which of these four types know about the displayShape() method? You guessed it—both the GameShape class and the PlayerPiece class are known 
(by the compiler) to have a displayShape() method, so either of those reference types 
can be used to invoke displayShape(). Remember that to the compiler, a 
PlayerPiece IS-A GameShape, so the compiler says, "I see that the declared 
type is PlayerPiece, and since PlayerPiece extends GameShape, that means 
PlayerPiece inherited the displayShape() method. Therefore, PlayerPiece 
can be used to invoke the displayShape() method."
Which methods can be invoked when the PlayerPiece object is being referred 
to using a reference declared as type Animatable? Only the animate() method. Of course the cool thing here is that any class from any inheritance tree can also 
implement Animatable, so that means if you have a method with an argument 
declared as type Animatable, you can pass in PlayerPiece objects, SpinningLogo 
objects, and anything else that's an instance of a class that implements Animatable. And you can use that parameter (of type Animatable) to invoke the animate() 
method, but not the displayShape() method (which it might not even have), or 
anything other than what is known to the compiler based on the reference type. The 
compiler always knows, though, that you can invoke the methods of class Object on 
any object, so those are safe to call regardless of the reference—class or interface—
used to refer to the object. We've left out one big part of all this, which is that even though the compiler 
only knows about the declared reference type, the Java Virtual Machine (JVM) 
at runtime knows what the object really is. And that means that even if the 
PlayerPiece object's displayShape() method is called using a GameShape 
reference variable, if the PlayerPiece overrides the displayShape() method, the 
JVM will invoke the PlayerPiece version! The JVM looks at the real object at the 
other end of the reference, "sees" that it has overridden the method of the declared 
reference variable type, and invokes the method of the object's actual class. But one 
other thing to keep in mind:
Polymorphic method invocations apply only to instance methods. You can 
always refer to an object with a more general reference variable type (a su-
perclass or interface), but at runtime, the ONLY things that are dynamically 
selected based on the actual object (rather than the reference type) are instance 
methods. Not static methods. Not variables. Only overridden instance meth-
ods are dynamically invoked based on the real object's type. Since this definition depends on a clear understanding of overriding, and the 
distinction between static methods and instance methods, we'll cover those next. 102 Chapter 2:  Object Orientation
CERTIFICATION OBJECTIVE
Overriding / Overloading 
(Exam Objectives 1.5 and 5.4)
1.5 Given a code example, determine if a method is correctly overriding or overloading 
another method, and identify legal return values (including covariant returns), for the 
method. 5.4 Given a scenario, develop code that declares and/or invokes overridden or overloaded 
methods and code that declares and/or invokes superclass, overridden, or overloaded 
constructors. Overridden Methods
Any time you have a class that inherits a method from a superclass, you have the 
opportunity to override the method (unless, as you learned earlier, the method is 
marked final). The key benefit of overriding is the ability to define behavior that's 
specific to a particular subclass type. The following example demonstrates a Horse 
subclass of Animal overriding the Animal version of the eat() method:
public class Animal {
   public void eat() {
      System.out.println("Generic Animal Eating Generically");
   }
}
class Horse extends Animal {
   public void eat() {
       System.out.println("Horse eating hay, oats, "
                           + "and horse treats");
   }
}
For abstract methods you inherit from a superclass, you have no choice. You must 
implement the method in the subclass unless the subclass is also abstract. Abstract 
methods must be implemented by the concrete subclass, but this is a lot like saying 
that the concrete subclass overrides the abstract methods of the superclass. So you 
could think of abstract methods as methods you're forced to override. Overridden Methods (Exam Objectives 1.5 and 5.4) 103
The Animal class creator might have decided that for the purposes of 
polymorphism, all Animal subtypes should have an eat() method defined in a 
unique, specific way. Polymorphically, when someone has an Animal reference that 
refers not to an Animal instance, but to an Animal subclass instance, the caller 
should be able to invoke eat() on the Animal reference, but the actual runtime 
object (say, a Horse instance) will run its own specific eat() method. Marking the 
eat() method abstract is the Animal programmer's way of saying to all subclass 
developers, "It doesn't make any sense for your new subtype to use a generic eat() 
method, so you have to come up with your own eat() method implementation!" 
A (non-abstract), example of using polymorphism looks like this:
public class TestAnimals {
  public static void main (String [] args) {
    Animal a = new Animal();
    Animal b = new Horse();  //Animal ref, but a Horse object
    a.eat(); // Runs the Animal version of eat()
    b.eat(); // Runs the Horse version of eat()
  }
}
class Animal {
  public void eat() {
    System.out.println("Generic Animal Eating Generically");
  }
}
class Horse extends Animal {
  public void eat() {
    System.out.println("Horse eating hay, oats, "
                       + "and horse treats");
   }
   public void buck() { }
}
In the preceding code, the test class uses an Animal reference to invoke a method 
on a Horse object. Remember, the compiler will allow only methods in class Animal 
to be invoked when using a reference to an Animal. The following would not be 
legal given the preceding code:
Animal c = new Horse();
c.buck();  // Can't invoke buck(); 
           // Animal class doesn't have that method
104 Chapter 2:  Object Orientation
To reiterate, the compiler looks only at the reference type, not the instance 
type. Polymorphism lets you use a more abstract supertype (including an interface) 
reference to refer to one of its subtypes (including interface implementers). The overriding method cannot have a more restrictive access modifier than the 
method being overridden (for example, you can't override a method marked public 
and make it protected). Think about it: if the Animal class advertises a public 
eat() method and someone has an Animal reference (in other words, a reference 
declared as type Animal), that someone will assume it's safe to call eat() on the 
Animal reference regardless of the actual instance that the Animal reference is 
referring to. If a subclass were allowed to sneak in and change the access modifier on 
the overriding method, then suddenly at runtime—when the JVM invokes the true 
object's (Horse) version of the method rather than the reference type's (Animal) 
version—the program would die a horrible death. (Not to mention the emotional 
distress for the one who was betrayed by the rogue subclass.) Let's modify the 
polymorphic example we saw earlier in this section:
public class TestAnimals {
  public static void main (String [] args) {
    Animal a = new Animal();
    Animal b = new Horse();  //Animal ref, but a Horse object
    a.eat(); // Runs the Animal version of eat()
    b.eat(); // Runs the Horse version of eat()
  }
}
class Animal {
  public void eat() {
    System.out.println("Generic Animal Eating Generically");
  }
}
class Horse extends Animal {
  private void eat() {  // whoa! - it's private! System.out.println("Horse eating hay, oats, "
                       + "and horse treats");
  }
}
If this code compiled (which it doesn't), the following would fail at runtime:
Animal b = new Horse();  // Animal ref, but a Horse
                         // object , so far so good
b.eat();                 // Meltdown at runtime! Overridden Methods (Exam Objectives 1.5 and 5.4) 105
The variable b is of type Animal, which has a public eat() method. But 
remember that at runtime, Java uses virtual method invocation to dynamically 
select the actual version of the method that will run, based on the actual instance. An Animal reference can always refer to a Horse instance, because Horse IS-A(n) 
Animal. What makes that superclass reference to a subclass instance possible is 
that the subclass is guaranteed to be able to do everything the superclass can do. Whether the Horse instance overrides the inherited methods of Animal or simply 
inherits them, anyone with an Animal reference to a Horse instance is free to call all 
accessible Animal methods. For that reason, an overriding method must fulfill the 
contract of the superclass. The rules for overriding a method are as follows:
■ The argument list must exactly match that of the overridden method. If they 
don't match, you can end up with an overloaded method you didn't intend. ■ The return type must be the same as, or a subtype of, the return type declared 
in the original overridden method in the superclass. (More on this in a few 
pages when we discuss covariant returns.)
■ The access level can't be more restrictive than the overridden method's. ■ The access level CAN be less restrictive than that of the overridden method. ■ Instance methods can be overridden only if they are inherited by the subclass. A subclass within the same package as the instance's superclass can override 
any superclass method that is not marked private or final. A subclass in a 
different package can override only those non-final methods marked pub-
lic or protected (since protected methods are inherited by the subclass). ■ The overriding method CAN throw any unchecked (runtime) exception, 
regardless of whether the overridden method declares the exception. (More 
in Chapter 5.)
■ The overriding method must NOT throw checked exceptions that are new 
or broader than those declared by the overridden method. For example, a 
method that declares a FileNotFoundException cannot be overridden by a 
method that declares a SQLException, Exception, or any other non-runtime 
exception unless it's a subclass of FileNotFoundException. ■ The overriding method can throw narrower or fewer exceptions. Just because 
an overridden method "takes risks" doesn't mean that the overriding subclass' 
exception takes the same risks. Bottom line: an overriding method doesn't 
106 Chapter 2:  Object Orientation
have to declare any exceptions that it will never throw, regardless of what the 
overridden method declares. ■ You cannot override a method marked final. ■ You cannot override a method marked static. We'll look at an example in a 
few pages when we discuss static methods in more detail. ■ If a method can't be inherited, you cannot override it. Remember that 
overriding implies that you're reimplementing a method you inherited! For 
example, the following code is not legal, and even if you added an eat() 
method to Horse, it wouldn't be an override of Animal's eat() method. public class TestAnimals {
   public static void main (String [] args) {
      Horse h =  new Horse();
      h.eat(); // Not legal because Horse didn't inherit eat()
   }
}
class Animal {
   private void eat() {
      System.out.println("Generic Animal Eating Generically");
   }
}
class Horse extends Animal { }
Invoking a Superclass Version of an Overridden Method
Often, you'll want to take advantage of some of the code in the superclass version of 
a method, yet still override it to provide some additional specific behavior. It's like 
saying, "Run the superclass version of the method, then come back down here and 
finish with my subclass additional method code." (Note that there's no requirement 
that the superclass version run before the subclass code.) It's easy to do in code using 
the keyword super as follows:
public class Animal {
   public void eat() { }
   public void printYourself() { 
      // Useful printing code goes here
   }
}
class Horse extends Animal {
   public void printYourself() {
      // Take advantage of Animal code, then add some more
Overridden Methods (Exam Objectives 1.5 and 5.4) 107
      super.printYourself();  // Invoke the superclass
                              // (Animal) code
                              // Then do Horse-specific 
                              // print work here
   }
}
Note: Using super to invoke an overridden method only applies to instance 
methods. (Remember, static methods can't be overridden.)
108 Chapter 2:  Object Orientation
If a method is overridden but you use a polymorphic (supertype) 
reference to refer to the subtype object with the overriding method, the compiler 
assumes you’re calling the supertype version of the method. If the supertype version 
declares a checked exception, but the overriding subtype method does not, the compiler 
still thinks you are calling a method that declares an exception (more in Chapter 5). Let’s take a look at an example:
class Animal {
  public void eat() throws Exception {
    // throws an Exception
  }
}
class Dog2 extends Animal {
  public void eat() { /* no Exceptions */}
  public static void main(String [] args) {
    Animal a = new Dog2();
    Dog2 d = new Dog2();
    d.eat();           // ok
    a.eat();           // compiler error - 
                       // unreported exception
  }
}
This code will not compile because of the Exception declared on the 
Animal eat() method. This happens even though, at runtime, the eat() method used 
would be the Dog version, which does not declare the exception. Examples of Legal and Illegal Method Overrides
Let's take a look at overriding the eat() method of Animal:
public class Animal {
   public void eat() { }
}
Table 2-1 lists examples of illegal overrides of the Animal eat() method, given 
the preceding version of the Animal class. Overloaded Methods
You're wondering what overloaded methods are doing in an OO chapter, but we've 
included them here since one of the things newer Java developers are most confused 
about are all of the subtle differences between overloaded and overridden methods. Overloaded methods let you reuse the same method name in a class, but with 
different arguments (and optionally, a different return type). Overloading a method 
often means you're being a little nicer to those who call your methods, because your 
code takes on the burden of coping with different argument types rather than forcing 
the caller to do conversions prior to invoking your method. The rules are simple:
■ Overloaded methods MUST change the argument list. ■ Overloaded methods CAN change the return type. ■ Overloaded methods CAN change the access modifier. ■ Overloaded methods CAN declare new or broader checked exceptions. Overloaded Methods (Exam Objectives 1.5 and 5.4) 109
Illegal Override Code Problem with the Code
private void eat() { } Access modifier is more restrictive
public void eat() throws 
IOException { }
Declares a checked exception not defined by superclass 
version
public void eat(String food) { } A legal overload, not an override, because the argument list 
changed
public String eat() { } Not an override because of the return type, not an overload 
either because there’s no change in the argument list
 TABLE 2-1    Examples of Illegal Overrides
■  A method can be overloaded in the same class or in a subclass. In other words, 
if class A defines a doStuff(int i) method, the subclass B could define a 
doStuff(String s) method without overriding the superclass version that 
takes an int. So two methods with the same name but in different classes 
can still be considered overloaded, if the subclass inherits one version of the 
method and then declares another overloaded version in its class definition. Legal Overloads
Let's look at a method we want to overload:
public void changeSize(int size, String name, float pattern) { }    
The following methods are legal overloads of the changeSize() method:  
   
public void changeSize(int size, String name) { }
public int changeSize(int size, float pattern) { }
public void changeSize(float pattern, String name)
                       throws IOException { }
110 Chapter 2:  Object Orientation
Be careful to recognize when a method is overloaded rather than 
overridden. You might see a method that appears to be violating a rule for overriding, but 
that is actually a legal overload, as follows:
public class Foo {
   public void doStuff(int y, String s) { }
   public void moreThings(int x) { }
}
class Bar extends Foo {
   public void doStuff(int y, long s) throws IOException { }
}
It's tempting to see the IOException as the problem, because the 
overridden doStuff() method doesn’t declare an exception, and IOException is checked 
by the compiler. But the doStuff() method is not overridden! Subclass Bar overloads the 
doStuff() method, by varying the argument list, so the IOException is ﬁ ne. Invoking Overloaded Methods
Note that there's a lot more to this discussion on how the compiler knows which 
method to invoke, but the rest is covered in Chapter 3 when we look at boxing and 
var-args—both of which have a huge impact on overloading. (You still have to pay 
attention to the part covered here, though.)
When a method is invoked, more than one method of the same name might exist 
for the object type you're invoking a method on. For example, the Horse class might 
have three methods with the same name but with different argument lists, which 
means the method is overloaded. Deciding which of the matching methods to invoke is based on the arguments. If 
you invoke the method with a String argument, the overloaded version that takes 
a String is called. If you invoke a method of the same name but pass it a float, the 
overloaded version that takes a float will run. If you invoke the method of the 
same name but pass it a Foo object, and there isn't an overloaded version that takes 
a Foo, then the compiler will complain that it can't find a match. The following are 
examples of invoking overloaded methods:
class Adder {
  public int addThem(int x, int y) {
    return x + y;
  }
  // Overload the addThem method to add doubles instead of ints
  public double addThem(double x, double y) {
    return x + y;
  }
}
// From another class, invoke the addThem() method
public class TestAdder {
  public static void main (String [] args) {
    Adder a = new Adder();
    int b = 27;
    int c = 3;
    int result = a.addThem(b,c); // Which addThem is invoked? double doubleResult = a.addThem(22.5,9.3); // Which addThem? }
}
In the preceding TestAdder code, the first call to a.addThem(b,c) passes two 
ints to the method, so the first version of addThem()—the overloaded version 
Overloaded Methods (Exam Objectives 1.5 and 5.4) 111
that takes two int arguments—is called. The second call to a.addThem(22.5, 
9.3) passes two doubles to the method, so the second version of addThem()—the 
overloaded version that takes two double arguments—is called. Invoking overloaded methods that take object references rather than primitives is 
a little more interesting. Say you have an overloaded method such that one version 
takes an Animal and one takes a Horse (subclass of Animal). If you pass a Horse 
object in the method invocation, you'll invoke the overloaded version that takes a 
Horse. Or so it looks at first glance:
class Animal { }
class Horse extends Animal { }
class UseAnimals {
   public void doStuff(Animal a) {
      System.out.println("In the Animal version");
   }
   public void doStuff(Horse h) {
      System.out.println("In the Horse version");
   }
   public static void main (String [] args) {
      UseAnimals ua = new UseAnimals();
      Animal animalObj = new Animal();
      Horse horseObj = new Horse();
      ua.doStuff(animalObj);
      ua.doStuff(horseObj);
   }
}
The output is what you expect:
in the Animal version
in the Horse version
But what if you use an Animal reference to a Horse object? Animal animalRefToHorse = new Horse();
 ua.doStuff(animalRefToHorse);
Which of the overloaded versions is invoked? You might want to say, "The one 
that takes a Horse, since it's a Horse object at runtime that's being passed to the 
method." But that's not how it works. The preceding code would actually print:
in the Animal version
112 Chapter 2:  Object Orientation
Even though the actual object at runtime is a Horse and not an Animal, the 
choice of which overloaded method to call (in other words, the signature of the 
method) is NOT dynamically decided at runtime. Just remember, the reference 
type (not the object type) determines which overloaded method is invoked! To 
summarize, which overridden version of the method to call (in other words, from 
which class in the inheritance tree) is decided at runtime based on object type, but 
which overloaded version of the method to call is based on the reference type of 
the argument passed at compile time. If you invoke a method passing it an Animal 
reference to a Horse object, the compiler knows only about the Animal, so it 
chooses the overloaded version of the method that takes an Animal. It does not 
matter that at runtime there's actually a Horse being passed. Polymorphism in Overloaded and Overridden Methods
How does polymorphism work with overloaded methods? From what we just looked 
at, it doesn't appear that polymorphism matters when a method is overloaded. If 
you pass an Animal reference, the overloaded method that takes an Animal will be 
invoked, even if the actual object passed is a Horse. Once the Horse masquerading 
as Animal gets in to the method, however, the Horse object is still a Horse despite 
being passed into a method expecting an Animal. So it's true that polymorphism 
doesn't determine which overloaded version is called; polymorphism does come into 
play when the decision is about which overridden version of a method is called. But 
sometimes, a method is both overloaded and overridden. Imagine the Animal and 
Horse classes look like this:
public class Animal {
   public void eat() {
      System.out.println("Generic Animal Eating Generically");
   }
}
public class Horse extends Animal {
   public void eat() {
       System.out.println("Horse eating hay ");
   }
   public void eat(String s) {
      System.out.println("Horse eating " + s);
   }
}
Notice that the Horse class has both overloaded and overridden the eat() 
method. Table 2-2 shows which version of the three eat() methods will run 
depending on how they are invoked. Overloaded Methods (Exam Objectives 1.5 and 5.4) 113
114 Chapter 2:  Object Orientation
  Method Invocation Code Result
 Animal a = new Animal();
 a.eat(); Generic Animal Eating Generically
 Horse h = new Horse();
 h.eat();Horse eating hay
 Animal ah = new Horse();
 ah.eat();
Horse eating hay
Polymorphism works—the actual object type (Horse), not the 
reference type (Animal), is used to determine which eat() is called. Horse he = new Horse();
 he.eat("Apples");
Horse eating Apples
The overloaded eat(String s) method is invoked. Animal a2 = new Animal();
 a2.eat("treats");
Compiler error! Compiler sees that Animal class doesn't have an 
eat() method that takes a String. Animal ah2 = new Horse();
ah2.eat("Carrots");
Compiler error! Compiler still looks only at the reference, and sees 
that Animal doesn’t have an eat() method that takes a String. Compiler doesn’t care that the actual object might be a Horse at 
runtime. TABLE 2-2    Examples of Illegal Overrides
Don’t be fooled by a method that’s overloaded but not overridden by a 
subclass. It’s perfectly legal to do the following:
public class Foo {
   void doStuff() { }
}
class Bar extends Foo {
   void doStuff(String s) { }
}
The Bar class has two doStuff() methods: the no-arg version it inherits 
from Foo (and does not override), and the overloaded doStuff(String s) deﬁ  ned in the 
Bar class. Code with a reference to a Foo can invoke only the no-arg version, but code 
with a reference to a Bar can invoke either of the overloaded versions. Table 2-3 summarizes the difference between overloaded and overridden methods. The current objective (5.4) covers both method and constructor overloading, but 
we'll cover constructor overloading in the next section, where we'll also cover the 
other constructor-related topics that are on the exam. Figure 2-4 illustrates the way 
overloaded and overridden methods appear in class relationships. FIGURE 2-4  
Overloaded
and overridden
methods
in class
relationships
Overloaded Methods (Exam Objectives 1.5 and 5.4) 115
Overloaded Method Overridden Method
Argument(s) Must change. Must not change.

--- Chunk #1286 ---
Return type Can change. Can’t change except for 
covariant returns. Exceptions Can change. Can reduce or eliminate. Must not throw new 
or broader checked 
exceptions. Access Can change. Must not make more 
restrictive (can be less 
restrictive). Invocation Reference type determines which overloaded version (based 
on declared argument types) is selected. Happens at compile 
time. The actual method that’s invoked is still a virtual method 
invocation that happens at runtime, but the compiler will 
already know the signature of the method to be invoked. So at 
runtime, the argument match will already have been nailed 
down, just not the class in which the method lives. Object type (in other 
words, the type of the 
actual instance on the 
heap) determines which 
method is selected. Happens at runtime. TABLE 2-3    Differences Between Overloaded and Overridden Methods
Overriding
Tree
showLeaves()
Oak
showLeaves()
Oak
setFeatures(String name, int leafSize)
setFeatures(int leafSize)
Tree
setFeatures(String name)
Overloading
CERTIFICATION OBJECTIVE
Reference Variable Casting (Objective 5.2)
5.2 Given a scenario, develop code that demonstrates the use of polymorphism. Further, 
determine when casting will be necessary and recognize compiler vs. runtime errors related 
to object reference casting. We've seen how it's both possible and common to use generic reference variable 
types to refer to more specific object types. It's at the heart of polymorphism. For 
example, this line of code should be second nature by now:
Animal animal = new Dog();
But what happens when you want to use that animal reference variable to invoke  
a method that only class Dog has? You know it's referring to a Dog, and you want to 
do a Dog-specific thing? In the following code, we've got an array of Animals, and 
whenever we find a Dog in the array, we want to do a special Dog thing. Let's agree 
for now that all of this code is OK, except that we're not sure about the line of code 
that invokes the playDead method. class Animal {
  void makeNoise() {System.out.println("generic noise"); }
}
class Dog extends Animal {
  void makeNoise() {System.out.println("bark"); }
  void playDead() { System.out.println("roll over"); }    
}
class CastTest2 {
  public static void main(String [] args) {
    Animal [] a = {new Animal(), new Dog(), new Animal() };
    for(Animal animal : a) {
      animal.makeNoise();
      if(animal instanceof Dog) {
        animal.playDead();       // try to do a Dog behavior ? }
    }
  }
}
116 Chapter 2:  Object Orientation
When we try to compile this code, the compiler says something like this:
cannot find symbol
The compiler is saying, "Hey, class Animal doesn't have a playDead() method". Let's modify the if code block:
      if(animal instanceof Dog) {
        Dog d = (Dog) animal;      // casting the ref. var. d.playDead(); 
      }
The new and improved code block contains a cast, which in this case is 
sometimes called a downcast, because we're casting down the inheritance tree to a 
more specific class. Now, the compiler is happy. Before we try to invoke playDead, 
we cast the animal variable to type Dog. What we're saying to the compiler is, "We 
know it's really referring to a Dog object, so it's okay to make a new Dog reference 
variable to refer to that object." In this case we're safe because before we ever try the 
cast, we do an instanceof test to make sure. It's important to know that the compiler is forced to trust us when we do a 
downcast, even when we screw up:
class Animal { }
class Dog extends Animal { }
class DogTest {
  public static void main(String [] args) {
    Animal animal = new Animal();
    Dog d = (Dog) animal;          // compiles but fails later
  }
}
It can be maddening! This code compiles! When we try to run it, we'll get an 
exception something like this:
java.lang.ClassCastException
Why can't we trust the compiler to help us out here? Can't it see that animal 
is of type Animal? All the compiler can do is verify that the two types are in the 
same inheritance tree, so that depending on whatever code might have come before 
the downcast, it's possible that animal is of type Dog. The compiler must allow 
Reference Variable Casting (Objective 5.2) 117
things that might possibly work at runtime. However, if the compiler knows with 
certainty that the cast could not possibly work, compilation will fail. The following 
replacement code block will NOT compile: 
Animal animal = new Animal();
Dog d = (Dog) animal;
String s = (String) animal;  // animal can't EVER be a String
In this case, you'll get an error something like this:
inconvertible types
Unlike downcasting, upcasting (casting up the inheritance tree to a more general 
type) works implicitly (i.e., you don't have to type in the cast) because when you 
upcast you're implicitly restricting the number of methods you can invoke, as 
opposed to downcasting, which implies that later on, you might want to invoke a 
more specific method. For instance:
class Animal { }
class Dog extends Animal { }
class DogTest {
  public static void main(String [] args) {
    Dog d = new Dog();
    Animal a1 = d;           // upcast ok with no explicit cast
    Animal a2 = (Animal) d;  // upcast ok with an explicit cast
  }
}
Both of the previous upcasts will compile and run without exception, because a 
Dog IS-A Animal, which means that anything an Animal can do, a Dog can do. A 
Dog can do more, of course, but the point is—anyone with an Animal reference can 
safely call Animal methods on a Dog instance. The Animal methods may have been 
overridden in the Dog class, but all we care about now is that a Dog can always do 
at least everything an Animal can do. The compiler and JVM know it too, so the 
implicit upcast is always legal for assigning an object of a subtype to a reference of 
one of its supertype classes (or interfaces). If Dog implements Pet, and Pet defines 
beFriendly(), then a Dog can be implicitly cast to a Pet, but the only Dog method 
you can invoke then is beFriendly(), which Dog was forced to implement because 
Dog implements the Pet interface. 118 Chapter 2:  Object Orientation
One more thing…if Dog implements Pet, then if Beagle extends Dog, but 
Beagle does not declare that it implements Pet, Beagle is still a Pet! Beagle is a Pet 
simply because it extends Dog, and Dog's already taken care of the Pet parts of itself, 
and all its children. The Beagle class can always override any methods it inherits 
from Dog, including methods that Dog implemented to fulfill its interface contract. And just one more thing…if Beagle does declare it implements Pet, just so that 
others looking at the Beagle class API can easily see that Beagle IS-A Pet, without 
having to look at Beagle's superclasses, Beagle still doesn't need to implement the 
beFriendly() method if the Dog class (Beagle's superclass) has already taken care of 
that. In other words, if Beagle IS-A Dog, and Dog IS-A Pet, then Beagle IS-A Pet, 
and has already met its Pet obligations for implementing the beFriendly() method 
since it inherits the beFriendly() method. The compiler is smart enough to say, "I 
know Beagle already IS a Dog,  but it's OK to make it more obvious." 
So don't be fooled by code that shows a concrete class that declares that it 
implements an interface, but doesn't implement the methods of the interface. Before 
you can tell whether the code is legal, you must know what the superclasses of this 
implementing class have declared. If any superclass in its inheritance tree has already 
provided concrete (i.e., non-abstract) method implementations, then, regardless 
of whether the superclass declares that it implements the interface, the subclass is 
under no obligation to re-implement (override) those methods. Reference Variable Casting (Objective 5.2) 119
The exam creators will tell you that they’re forced to jam tons of code 
into little spaces "because of the exam engine."  While that’s partially true, they ALSO 
like to obfuscate. The following code:
Animal a = new Dog();
Dog d = (Dog) a;
d.doDogStuff();
Can be replaced with this easy-to-read bit of fun:
Animal a = new Dog();
((Dog)a).doDogStuff();
In this case the compiler needs all of those parentheses, otherwise it 
thinks it’s been handed an incomplete statement. CERTIFICATION OBJECTIVE
Implementing an Interface (Exam Objective 1.2)
1.2 Develop code that declares an interface... When you implement an interface, you're agreeing to adhere to the contract defined 
in the interface. That means you're agreeing to provide legal implementations 
for every method defined in the interface, and that anyone who knows what the 
interface methods look like (not how they're implemented, but how they can be 
called and what they return) can rest assured that they can invoke those methods on 
an instance of your implementing class. For example, if you create a class that implements the Runnable interface (so 
that your code can be executed by a specific thread), you must provide the public 
void run() method. Otherwise, the poor thread could be told to go execute your 
Runnable object's code and—surprise surprise—the thread then discovers the object 
has no run() method! (At which point, the thread would blow up and the JVM 
would crash in a spectacular yet horrible explosion.) Thankfully, Java prevents this 
meltdown from occurring by running a compiler check on any class that claims 
to implement an interface. If the class says it's implementing an interface, it darn 
well better have an implementation for each method in the interface (with a few 
exceptions we'll look at in a moment). Assuming an interface, Bounceable, with two methods: bounce(), and 
setBounceFactor(), the following class will compile:
public class Ball implements Bounceable {  // Keyword 
                                           // 'implements'
   public void bounce() { }
   public void setBounceFactor(int bf) { }
}
OK, we know what you're thinking: "This has got to be the worst implementation 
class in the history of implementation classes." It compiles, though. And runs.

--- Chunk #1287 ---
The 
interface contract guarantees that a class will have the method (in other words, 
others can call the method subject to access control), but it never guaranteed a 
good implementation—or even any actual implementation code in the body of the 
method. The compiler will never say to you, "Um, excuse me, but did you really 
120 Chapter 2:  Object Orientation
mean to put nothing between those curly braces? HELLO. This is a method after all, 
so shouldn't it do something?" 
Implementation classes must adhere to the same rules for method implementation 
as a class extending an abstract class. In order to be a legal implementation class, a 
nonabstract implementation class must do the following:
■ Provide concrete (nonabstract) implementations for all methods from the 
declared interface. ■ Follow all the rules for legal overrides. ■ Declare no checked exceptions on implementation methods other than 
those declared by the interface method, or subclasses of those declared by  
the interface method. ■ Maintain the signature of the interface method, and maintain the same 
return type (or a subtype). (But it does not have to declare the exceptions 
declared in the interface method declaration.)
But wait, there's more! An implementation class can itself be abstract! For 
example, the following is legal for a class Ball implementing Bounceable:
abstract class Ball implements Bounceable { }
Notice anything missing? We never provided the implementation methods. And that's OK. If the implementation class is abstract, it can simply pass the 
buck to its first concrete subclass. For example, if class BeachBall extends Ball, and 
BeachBall is not abstract, then BeachBall will have to provide all the methods 
from Bounceable:
class BeachBall extends Ball {  
  // Even though we don't say it in the class declaration above, 
  // BeachBall implements Bounceable, since BeachBall's abstract
  // superclass (Ball) implements Bounceable
   public void bounce() {
      // interesting BeachBall-specific bounce code
   }
   public void setBounceFactor(int bf) { 
      // clever BeachBall-specific code for setting 
      // a bounce factor
   }
Implementing an Interface (Exam Objective 1.2) 121
   // if class Ball defined any abstract methods, 
   // they'll have to be 
   // implemented here as well. }
Look for classes that claim to implement an interface but don't provide the 
correct method implementations. Unless the implementing class is abstract, the 
implementing class must provide implementations for all methods defined in the 
interface. T wo more rules you need to know and then we can put this topic to sleep (or put 
you to sleep; we always get those two confused):
1. A class can implement more than one interface. It's perfectly legal to say, for 
example, the following:
public class Ball implements Bounceable, Serializable, Runnable 
{ ... }
You can extend only one class, but implement many interfaces. But remember 
that subclassing defines who and what you are, whereas implementing defines a role 
you can play or a hat you can wear, despite how different you might be from some 
other class implementing the same interface (but from a different inheritance tree). For example, a Person extends HumanBeing (although for some, that's debatable). But a Person may also implement Programmer, Snowboarder, Employee, Parent, or 
PersonCrazyEnoughToTakeThisExam. 2. An interface can itself extend another interface, but never implement 
anything. The following code is perfectly legal:
public interface Bounceable extends Moveable { }   // ok! What does that mean? The first concrete (nonabstract) implementation class of 
Bounceable must implement all the methods of Bounceable, plus all the methods 
of Moveable! The subinterface, as we call it, simply adds more requirements to the 
contract of the superinterface. You'll see this concept applied in many areas of Java, 
especially J2EE where you'll often have to build your own interface that extends one 
of the J2EE interfaces. 122 Chapter 2:  Object Orientation
Hold on though, because here's where it gets strange. An interface can extend 
more than one interface! Think about that for a moment. You know that when we're 
talking about classes, the following is illegal:
public class Programmer extends Employee, Geek { } // Illegal! As we mentioned earlier, a class is not allowed to extend multiple classes in Java. An interface, however, is free to extend multiple interfaces. interface Bounceable extends Moveable, Spherical {   // ok! void bounce();
   void setBounceFactor(int bf);
}
interface Moveable {
   void moveIt();
}
interface Spherical {
   void doSphericalThing();
}
In the next example, Ball is required to implement Bounceable, plus all methods 
from the interfaces that Bounceable extends (including any interfaces those 
interfaces extend, and so on until you reach the top of the stack—or is it the bottom 
of the stack?). So Ball would need to look like the following:
class Ball implements Bounceable {
                              
   public void bounce() { }   // Implement Bounceable's methods
   public void setBounceFactor(int bf) { }
   public void moveIt() { }    // Implement Moveable's method 
  
   public void doSphericalThing() { }   // Implement Spherical
}
If class Ball fails to implement any of the methods from Bounceable, Moveable, or 
Spherical, the compiler will jump up and down wildly, red in the face, until it does. Unless, that is, class Ball is marked abstract. In that case, Ball could choose to 
implement any, all, or none of the methods from any of the interfaces, thus leaving 
the rest of the implementations to a concrete subclass of Ball, as follows:
Implementing an Interface (Exam Objective 1.2) 123
abstract class Ball implements Bounceable {
   public void bounce() { ... }  // Define bounce behavior
   public void setBounceFactor(int bf) { ... }
   // Don't implement the rest; leave it for a subclass
}
class SoccerBall extends Ball {  // class SoccerBall must 
             // implement the interface methods that Ball didn't
   public void moveIt() { ... }
   public void doSphericalThing() { ... }
   // SoccerBall can choose to override the Bounceable methods 
   // implemented by Ball
   public void bounce() { ... }
}
Figure 2-5 compares concrete and abstract examples of extends and implements, 
for both classes and interfaces. 124 Chapter 2:  Object Orientation
 FIGURE 2-5   Comparing concrete and abstract examples of extends and implements
Because BeachBall is the first concrete class to implement Bounceable, 
it must provide implementations for all methods of Bounceable, except
those defined in the abstract class Ball. Because Ball did not provide
implementations of Bounceable methods, BeachBall was required to
implement all of them. interface Bounceable
void bounce( );
void setBounceFactor(int bf);
class Tire implements Bounceable
abstract Ball implements Bounceable
class BeachBall extends Ball
public void bounce( ){ }
public void setBounceFactor (int bf){ }
/*beSpherical is not abstract
so BeachBall is not
required to implement it.*/
/*no methods of
Bounceable are
implemented
in Ball  */
void beSpherical( ){}
public void bounce( ){ }
public void setBounceFactor (int bf){ }
Implementing an Interface (Exam Objective 1.2) 125
Look for illegal uses of extends and implements. The following shows 
examples of legal and illegal class and interface declarations:
class Foo { }                      // OK
class Bar implements Foo  { }      // No! Can't implement a class 
interface Baz { }                  // OK
interface Fi { }                   // OK
interface Fee implements Baz { }   // No! Interface can't 
                                   // implement an interface
interface Zee implements Foo { }   // No! Interface can't 
                                   // implement a class
interface Zoo extends Foo { }      // No! Interface can't 
                                   // extend a class
interface Boo extends Fi { }       // OK. Interface can extend 
                                   // an interface
class Toon extends Foo, Button { } // No! Class can't extend 
                                   // multiple classes
class Zoom implements Fi, Baz { }  // OK. class can implement 
                                   // multiple interfaces
interface Vroom extends Fi, Baz { }  // OK. interface can extend
                                     // multiple interfaces
class Yow extends Foo implements Fi { } // OK. Class can do both
                                        // (extends must be 1st) 
Burn these in, and watch for abuses in the questions you get on the 
exam. Regardless of what the question appears to be testing, the real problem might be 
the class or interface declaration. Before you get caught up in, say, tracing a complex 
threading ﬂ  ow, check to see if the code will even compile. (Just that tip alone may 
be worth your putting us in your will!) (You’ll be impressed by the effort the exam 
developers put into distracting you from the real problem.) (How did people manage to 
write anything before parentheses were invented?) 
CERTIFICATION OBJECTIVE
Legal Return T ypes (Exam Objective 1.5)
1.5 Given a code example, determine if a method is correctly overriding or overloading 
another method, and identify legal return values (including covariant returns), for the 
method. This objective covers two aspects of return types: what you can declare as a 
return type, and what you can actually return as a value. What you can and cannot 
declare is pretty straightforward, but it all depends on whether you're overriding an 
inherited method or simply declaring a new method (which includes overloaded 
methods). We'll take just a quick look at the difference between return type 
rules for overloaded and overriding methods, because we've already covered that 
in this chapter. We'll cover a small bit of new ground, though, when we look at 
polymorphic return types and the rules for what is and is not legal to actually return. Return T ype Declarations
This section looks at what you're allowed to declare as a return type, which 
depends primarily on whether you are overriding, overloading, or declaring a 
new method. Return T ypes on Overloaded Methods
Remember that method overloading is not much more than name reuse. The 
overloaded method is a completely different method from any other method of 
the same name. So if you inherit a method but overload it in a subclass, you're not 
subject to the restrictions of overriding, which means you can declare any return 
type you like. What you can't do is change only the return type. To overload a 
method, remember, you must change the argument list. The following code shows an 
overloaded method:
public class Foo{
   void go() { }
}
public class Bar extends Foo {
   String go(int x) {
126 Chapter 2:  Object Orientation
     return null;
   }
}
Notice that the Bar version of the method uses a different return type. That's 
perfectly fine. As long as you've changed the argument list, you're overloading the 
method, so the return type doesn't have to match that of the superclass version. What you're NOT allowed to do is this:
public class Foo{
   void go() { }
}
public class Bar extends Foo {
   String go() { // Not legal! Can't change only the return type
      return null; 
   } 
}
Overriding and Return T ypes, and Covariant Returns
When a subclass wants to change the method implementation of an inherited 
method (an override), the subclass must define a method that matches the inherited 
version exactly. Or, as of Java 5, you're allowed to change the return type in the 
overriding method as long as the new return type is a subtype of the declared return 
type of the overridden (superclass) method. Let's look at a covariant return in action:
class Alpha {
  Alpha doStuff(char c) {
    return new Alpha();
  }
}
class Beta extends Alpha {
  Beta doStuff(char c) {     // legal override in Java 1.5
    return new Beta();
  }
}
As of Java 5, this code will compile. If you were to attempt to compile this code 
with a 1.4 compiler or with the source flag as follows:
Return Type Declarations (Exam Objective 1.5) 127
javac -source 1.4 Beta.java
you would get a compiler error something like this:
attempting to use incompatible return type
(We'll talk more about compiler flags in Chapter 10.)
Other rules apply to overriding, including those for access modifiers and declared 
exceptions, but those rules aren't relevant to the return type discussion. For the exam, be sure you know that overloaded methods can change the return 
type, but overriding methods can do so only within the bounds of covariant returns. Just that knowledge alone will help you through a wide range of exam questions. Returning a Value
You have to remember only six rules for returning a value:
 1. You can return null in a method with an object reference return type. public Button doStuff() {
         return null;
       }
2. An array is a perfectly legal return type. public String[] go() {
     return new String[] {"Fred", "Barney", "Wilma"};
  }
3. In a method with a primitive return type, you can return any value or 
variable that can be implicitly converted to the declared return type. public int foo() {
         char c = 'c';
         return c;  // char is compatible with int
       }
128 Chapter 2:  Object Orientation
4. In a method with a primitive return type, you can return any value or 
 variable that can be explicitly cast to the declared return type. public int foo () {
     float f = 32.5f;
     return (int) f;
   }
5. You must not return anything from a method with a void return type. public void bar() {
     return "this is it";  // Not legal!! }
6. In a method with an object reference return type, you can return any 
 object type that can be implicitly cast to the declared return type. public Animal getAnimal() {
     return new Horse();  // Assume Horse extends Animal
   } 
   public Object getObject() {
     int[] nums = {1,2,3};
     return nums;  // Return an int array,
                 // which is still an object
   }
   public interface Chewable { }
   public class Gum implements Chewable { }
   public class TestChewable {
       // Method with an interface return type
       public Chewable getChewable() {
         return new Gum();  // Return interface implementer   
      }
   }
Returning a Value (Exam Objective 1.5) 129
CERTIFICATION OBJECTIVE
Constructors and Instantiation 
(Exam Objectives 1.6, 5.3, and 5.4)
1.6 Given a set of classes and superclasses, develop constructors for one or more of the 
classes. Given a class declaration, determine if a default constructor will be created, and 
if so, determine the behavior of that constructor. Given a nested or nonnested class listing, 
write code to instantiate the class. 5.3 Explain the effect of modifiers on inheritance with respect to constructors, instance or 
static variables, and instance or static methods. 5.4 Given a scenario, develop code that declares and/or invokes overridden or overloaded 
methods and code that declares and/or invokes superclass, overridden, or overloaded 
constructors. 130 Chapter 2:  Object Orientation
 Watch for methods that declare an abstract class or interface return 
type, and know that any object that passes the IS-A test (in other words, would test true 
using the instanceof operator) can be returned from that method— for example:
public abstract class Animal { }
public class Bear extends Animal { }
public class Test {
   public Animal go() {
      return new Bear();  // OK, Bear "is-a" Animal
   }
}
This code will compile, the return value is a subtype. Objects are constructed. You can't make a new object without invoking a 
constructor. In fact, you can't make a new object without invoking not just the 
constructor of the object's actual class type, but also the constructor of each of its 
superclasses! Constructors are the code that runs whenever you use the keyword 
new. OK, to be a bit more accurate, there can also be initialization blocks that run 
when you say new, but we're going to cover them (init blocks), and their static 
initialization counterparts, in the next chapter. We've got plenty to talk about 
here—we'll look at how constructors are coded, who codes them, and how they work 
at runtime. So grab your hardhat and a hammer, and let's do some object building. Constructor Basics
Every class, including abstract classes, MUST have a constructor. Burn that into your 
brain. But just because a class must have one, doesn't mean the programmer has to 
type it. A constructor looks like this:
class Foo {
   Foo() { } // The constructor for the Foo class
}
Notice what's missing? There's no return type! T wo key points to remember about 
constructors are that they have no return type and their names must exactly match 
the class name. Typically, constructors are used to initialize instance variable state, as 
follows:
class Foo {
   int size;
   String name;
   Foo(String name, int size) {
      this.name = name;
      this.size = size;
   }
}
In the preceding code example, the Foo class does not have a no-arg constructor. That means the following will fail to compile:
Foo f = new Foo();  // Won't compile, no matching constructor
but the following will compile:
Constructors and Instantiation (Exam Objectives 1.6, 5.3, and 5.4) 131
Foo f = new Foo("Fred", 43);  // No problem. Arguments match 
                              // the Foo constructor. So it's very common (and desirable) for a class to have a no-arg constructor, 
regardless of how many other overloaded constructors are in the class (yes, 
constructors can be overloaded). You can't always make that work for your classes; 
occasionally you have a class where it makes no sense to create an instance without 
supplying information to the constructor. A java.awt.Color object, for example, 
can't be created by calling a no-arg constructor, because that would be like saying to 
the JVM, "Make me a new Color object, and I really don't care what color it is...you 
pick."  Do you seriously want the JVM making your style decisions? Constructor Chaining
We know that constructors are invoked at runtime when you say new on some class 
type as follows:
Horse h = new Horse();
But what really happens when you say new Horse() ? (Assume Horse extends Animal and Animal extends Object.)
1. Horse constructor is invoked. Every constructor invokes the constructor 
of its superclass with an (implicit) call to super(), unless the constructor 
invokes an overloaded constructor of the same class (more on that in a 
minute). 2. Animal constructor is invoked (Animal is the superclass of Horse). 3. Object constructor is invoked (Object is the ultimate superclass of all 
classes, so class Animal extends Object even though you don't actually 
type "extends Object" into the Animal class declaration. It's implicit.) At 
this point we're on the top of the stack. 4. Object instance variables are given their explicit values. By explicit values, 
we mean values that are assigned at the time the variables are declared, 
like "int x = 27", where "27" is the explicit value (as opposed to the 
default value) of the instance variable. 5. Object constructor completes. 6. Animal instance variables are given their explicit values (if any). 7. Animal constructor completes. 132 Chapter 2:  Object Orientation
8. Horse instance variables are given their explicit values (if any). 9. Horse constructor completes. Figure 2-6 shows how constructors work on the call stack. FIGURE 2-6  
Constructors on
the call stack
Rules for Constructors
The following list summarizes the rules you'll need to know for the exam (and to 
understand the rest of this section). You MUST remember these, so be sure to study 
them more than once. ■ Constructors can use any access modifier, including private. (A private 
constructor means only code within the class itself can instantiate an object 
of that type, so if the private constructor class wants to allow an instance 
of the class to be used, the class must provide a static method or variable that 
allows access to an instance created from within the class.)
■ The constructor name must match the name of the class. ■ Constructors must not have a return type. ■ It's legal (but stupid) to have a method with the same name as the class, 
but that doesn't make it a constructor. If you see a return type, it's a method 
rather than a constructor. In fact, you could have both a method and a 
constructor with the same name—the name of the class—in the same class, 
and that's not a problem for Java. Be careful not to mistake a method for a 
constructor—be sure to look for a return type. ■ If you don't type a constructor into your class code, a default constructor will 
be automatically generated by the compiler. ■ The default constructor is ALWAYS a no-arg constructor. ■ If you want a no-arg constructor and you've typed any other constructor(s) 
into your class code, the compiler won't provide the no-arg constructor (or 
4. 3.

--- Chunk #1288 ---
2.

--- Chunk #1289 ---
1. Object()
Animal()calls super()
Horse()calls super()
main()calls new Horse()
Constructors and Instantiation (Exam Objectives 1.6, 5.3, and 5.4) 133
any other constructor) for you. In other words, if you've typed in a construc-
tor with arguments, you won't have a no-arg constructor unless you type it in 
yourself! ■ Every constructor has, as its first statement, either a call to an overloaded 
constructor (this()) or a call to the superclass constructor (super()), although 
remember that this call can be inserted by the compiler. ■ If you do type in a constructor (as opposed to relying on the compiler-gener-
ated default constructor), and you do not type in the call to super() or a call 
to this(), the compiler will insert a no-arg call to super() for you, as the very 
first statement in the constructor. ■  A call to super() can be either a no-arg call or can include arguments passed 
to the super constructor. ■  A no-arg constructor is not necessarily the default (i.e., compiler-supplied) 
constructor, although the default constructor is always a no-arg constructor. The default constructor is the one the compiler provides! While the default 
constructor is always a no-arg constructor, you're free to put in your own no-
arg constructor. ■ You cannot make a call to an instance method, or access an instance variable, 
until after the super constructor runs. ■ Only static variables and methods can be accessed as part of the call to su-
per() or this(). (Example: super(Animal.NAME) is OK, because NAME is 
declared as a static variable.)
■ Abstract classes have constructors, and those constructors are always called 
when a concrete subclass is instantiated. ■ Interfaces do not have constructors. Interfaces are not part of an object's 
inheritance tree. ■ The only way a constructor can be invoked is from within another construc-
tor. In other words, you can't write code that actually calls a constructor as 
follows:
    class Horse {
      Horse() { } // constructor
      void doStuff() {
        Horse();  // calling the constructor - illegal! } 
    }
134 Chapter 2:  Object Orientation
Determine Whether a Default Constructor Will Be Created
The following example shows a Horse class with two constructors:
class Horse {
   Horse() { }
   Horse(String name) { }
 }
Will the compiler put in a default constructor for the class above? No! How about for the following variation of the class? class Horse {
   Horse(String name) { }
}
Now will the compiler insert a default constructor? No! What about this class? class Horse { }
Now we're talking. The compiler will generate a default constructor for the 
preceding class, because the class doesn't have any constructors defined. OK, what about this class? class Horse { 
   void Horse() { }
}
It might look like the compiler won't create one, since there already is a constructor 
in the Horse class. Or is there? Take another look at the preceding Horse class. What's wrong with the Horse() constructor? It isn't a constructor at all! It's 
simply a method that happens to have the same name as the class. Remember, the 
return type is a dead giveaway that we're looking at a method, and not a constructor. How do you know for sure whether a default constructor will be created? Because you didn't write any constructors in your class. Determine Whether a Default Constructor Will Be Created (Exam Objectives 1.6, 5.3, and 5.4) 135
How do you know what the default constructor will look like? Because... ■ The default constructor has the same access modifier as the class. ■ The default constructor has no arguments. ■ The default constructor includes a no-arg call to the super constructor 
(super()). Table 2-4 shows what the compiler will (or won't) generate for your class. What happens if the super constructor has arguments? Constructors can have arguments just as methods can, and if you try to invoke 
a method that takes, say, an int, but you don't pass anything to the method, the 
compiler will complain as follows:
class Bar {
    void takeInt(int x) { }
}
class UseBar {
   public static void main (String [] args) {
     Bar b = new Bar();
     b.takeInt();  // Try to invoke a no-arg takeInt() method
   }
}
The compiler will complain that you can't invoke takeInt() without passing an 
int. Of course, the compiler enjoys the occasional riddle, so the message it spits out 
on some versions of the JVM (your mileage may vary) is less than obvious:
UseBar.java:7: takeInt(int) in Bar cannot be applied to ()
     b.takeInt();
      ^
But you get the idea. The bottom line is that there must be a match for the 
method. And by match, we mean that the argument types must be able to accept 
the values or variables you're passing, and in the order you're passing them. Which 
brings us back to constructors (and here you were thinking we'd never get there), 
which work exactly the same way. 136 Chapter 2:  Object Orientation
So if your super constructor (that is, the constructor of your immediate 
superclass/parent) has arguments, you must type in the call to super(), supplying 
the appropriate arguments. Crucial point: if your superclass does not have a no-arg 
Determine Whether a Default Constructor Will Be Created (Exam Objectives 1.6, 5.3, and 5.4) 137
Class Code (What Y ou T ype) Compiler Generated Constructor Code (in Bold)
class Foo { } class Foo {
  Foo() {
    super();
  }
}
class Foo { 
  Foo() { } 
}
class Foo {
  Foo() {
    super();
  }
}
public class Foo { } public class Foo {
  public Foo() {
    super();
  }
}
class Foo { 
  Foo(String s) { }
}
class Foo {
  Foo(String s) {
    super();
  }
}
class Foo { 
  Foo(String s) {
    super();
  }
}
Nothing, compiler doesn’t need to insert 
anything. class Foo { 
  void Foo() { }
}
class Foo {
  void Foo() { }
  Foo() {
    super();
  }
}
(void Foo() is a method, not a constructor.)
 TABLE 2-4    Compiler-Generated Constructor Code
constructor, you must type a constructor in your class (the subclass) because you 
need a place to put in the call to super with the appropriate arguments. The following is an example of the problem:
class Animal {
   Animal(String name) { }
}
class Horse extends Animal {
   Horse() {
      super();  // Problem! }
}
And once again the compiler treats us with the stunningly lucid:
Horse.java:7: cannot resolve symbol
symbol  : constructor Animal  ()
location: class Animal
      super();  // Problem! ^
If you're lucky (and it's a full moon), your compiler might be a little more explicit. But again, the problem is that there just isn't a match for what we're trying to invoke 
with super()—an Animal constructor with no arguments. Another way to put this is that if your superclass does not have a no-arg 
constructor, then in your subclass you will not be able to use the default constructor 
supplied by the compiler. It's that simple. Because the compiler can only put in a call 
to a no-arg super(), you won't even be able to compile something like this:
class Clothing {
   Clothing(String s) { }
}
class TShirt extends Clothing { }
Trying to compile this code gives us exactly the same error we got when we put 
a constructor in the subclass with a call to the no-arg version of super():
Clothing.java:4: cannot resolve symbol
symbol  : constructor Clothing  ()
location: class Clothing
138 Chapter 2:  Object Orientation
class TShirt extends Clothing { }
^
In fact, the preceding Clothing and TShirt code is implicitly the same as the 
following code, where we've supplied a constructor for TShirt that's identical to the 
default constructor supplied by the compiler:
class Clothing {
   Clothing(String s) { }
}
class TShirt extends Clothing { 
                  // Constructor identical to compiler-supplied
                  // default constructor
   TShirt() {
      super(); // Won't work! }      // Invokes a no-arg Clothing() constructor,
}        // but there isn't one! One last point on the whole default constructor thing (and it's probably 
very obvious, but we have to say it or we'll feel guilty for years), constructors 
are never inherited. They aren't methods. They can't be overridden (because 
they aren't methods and only instance methods can be overridden). So the type 
of constructor(s) your superclass has in no way determines the type of default 
constructor you'll get. Some folks mistakenly believe that the default constructor 
somehow matches the super constructor, either by the arguments the default 
constructor will have (remember, the default constructor is always a no-arg), or by 
the arguments used in the compiler-supplied call to super(). So, although constructors can't be overridden, you've already seen that they can 
be overloaded, and typically are. Overloaded Constructors
Overloading a constructor means typing in multiple versions of the constructor, each 
having a different argument list, like the following examples:
class Foo {
   Foo() { }
   Foo(String s) { }
}
Overloaded Constructors (Exam Objectives 1.6, 5.3, and 5.4) 139
The preceding Foo class has two overloaded constructors, one that takes a string, 
and one with no arguments. Because there's no code in the no-arg version, it's 
actually identical to the default constructor the compiler supplies, but remember—
since there's already a constructor in this class (the one that takes a string), the 
compiler won't supply a default constructor. If you want a no-arg constructor to 
overload the with-args version you already have, you're going to have to type it 
yourself, just as in the Foo example. Overloading a constructor is typically used to provide alternate ways for clients 
to instantiate objects of your class. For example, if a client knows the animal name, 
they can pass that to an Animal constructor that takes a string. But if they don't 
know the name, the client can call the no-arg constructor and that constructor can 
supply a default name. Here's what it looks like:
  1. public class Animal {
  2. String name;
  3. Animal(String name) {
  4. this.name = name;
  5. }
  6. 7. Animal() {
  8. this(makeRandomName());
  9. }
 10. 11. static String makeRandomName() {
 12. int x = (int) (Math.random() * 5);
 13. String name = new String[] {"Fluffy", "Fido",
                                      "Rover", "Spike",
                                      "Gigi"}[x];
 14. return name;
 15.

--- Chunk #1290 ---
}
 16.

--- Chunk #1291 ---
17. public static void main (String [] args) {
 18. Animal a = new Animal();
 19. System.out.println(a.name);
 20. Animal b = new Animal("Zeus");
 21. System.out.println(b.name);
 22. }  
 23. }
Running the code four times produces this output:
140 Chapter 2:  Object Orientation
% java Animal 
Gigi  
Zeus
% java Animal
Fluffy
Zeus
% java Animal
Rover
Zeus
% java Animal
Fluffy
Zeus
There's a lot going on in the preceding code. Figure 2-7 shows the call stack for 
constructor invocations when a constructor is overloaded. Take a look at the call 
stack, and then let's walk through the code straight from the top. FIGURE 2-7 
Overloaded 
constructors on 
the call stack
■ Line 2 Declare a String instance variable name. ■ Lines 3–5 Constructor that takes a String, and assigns it to instance vari-
able name. ■ Line 7 Here's where it gets fun. Assume every animal needs a name, but 
the client (calling code) might not always know what the name should be, 
so you'll assign a random name. The no-arg constructor generates a name by 
invoking the makeRandomName() method. ■ Line 8 The no-arg constructor invokes its own overloaded constructor 
that takes a String, in effect calling it the same way it would be called if 
Overloaded Constructors (Exam Objectives 1.6, 5.3, and 5.4) 141
4. 3.

--- Chunk #1292 ---
2.

--- Chunk #1293 ---
1. Object()
Animal(String s)calls super()
Animal()calls this(randomlyChosenNameString)
main()calls new Animal()
client code were doing a new to instantiate an object, passing it a String for 
the name. The overloaded invocation uses the keyword this, but uses it as 
though it were a method name, this(). So line 8 is simply calling the con-
structor on line 3, passing it a randomly selected String rather than a client-
code chosen name. ■ Line 11 Notice that the makeRandomName() method is marked static! That's because you cannot invoke an instance (in other words, nonstatic) 
method (or access an instance variable) until after the super constructor has 
run. And since the super constructor will be invoked from the constructor on 
line 3, rather than from the one on line 7, line 8 can use only a static method 
to generate the name. If we wanted all animals not specifically named by the 
caller to have the same default name, say, "Fred," then line 8 could have read
this("Fred");  rather than calling a method that returns a string with the 
randomly chosen name. ■ Line 12 This doesn't have anything to do with constructors, but since we're 
all here to learn...it generates a random integer between 0 and 4. ■ Line 13 Weird syntax, we know. We're creating a new String object (just a 
single String instance), but we want the string to be selected randomly from 
a list. Except we don't have the list, so we need to make it. So in that one 
line of code we
1. Declare a String variable, name. 2. Create a String array (anonymously—we don't assign the array itself to 
anything). 3. Retrieve the string at index [x] (x being the random number generated
on line 12) of the newly created String array. 4. Assign the string retrieved from the array to the declared instance vari-
able name. We could have made it much easier to read if we'd just written
 
 String[] nameList = {"Fluffy", "Fido", "Rover", "Spike",
                     "Gigi"};
 String name = nameList[x];
 
 But where's the fun in that? Throwing in unusual syntax (especially for code 
wholly unrelated to the real question) is in the spirit of the exam. Don't be 
142 Chapter 2:  Object Orientation
startled! (OK, be startled, but then just say to yourself, "Whoa" and get on 
with it.) 
■ Line 18  We're invoking the no-arg version of the constructor (causing a 
random name from the list to be passed to the other constructor). ■ Line 20 We're invoking the overloaded constructor that takes a string 
representing the name. The key point to get from this code example is in line 8. Rather than calling 
super(), we're calling this(), and this() always means a call to another 
constructor in the same class. OK, fine, but what happens after the call to this()? Sooner or later the super() constructor gets called, right? Yes indeed. A call to 
this() just means you're delaying the inevitable. Some constructor, somewhere, 
must make the call to super(). Key Rule: The first line in a constructor must be a call to super() or a call to 
this(). No exceptions. If you have neither of those calls in your constructor, the compiler 
will insert the no-arg call to super(). In other words, if constructor A() has a call 
to this(), the compiler knows that constructor A() will not be the one to invoke 
super(). The preceding rule means a constructor can never have both a call to super() 
and a call to this(). Because each of those calls must be the first statement in a 
constructor, you can't legally use both in the same constructor. That also means the 
compiler will not put a call to super() in any constructor that has a call to this(). Thought question: What do you think will happen if you try to compile the 
following code? class A {
   A() {
     this("foo");
   }
   A(String s) {
      this();
   }
}
Your compiler may not actually catch the problem (it varies depending on your 
compiler, but most won't catch the problem). It assumes you know what you're 
Overloaded Constructors (Exam Objectives 1.6, 5.3, and 5.4) 143
doing. Can you spot the flaw? Given that a super constructor must always be called, 
where would the call to super() go? Remember, the compiler won't put in a default 
constructor if you've already got one or more constructors in your class. And when 
the compiler doesn't put in a default constructor, it still inserts a call to super() in 
any constructor that doesn't explicitly have a call to the super constructor—unless, 
that is, the constructor already has a call to this(). So in the preceding code, where 
can super() go? The only two constructors in the class both have calls to this(), and 
in fact you'll get exactly what you'd get if you typed the following method code:
public void go() {
   doStuff();
}
public void doStuff() {
   go();
}
Now can you see the problem? Of course you can. The stack explodes! It gets 
higher and higher and higher until it just bursts open and method code goes spilling 
out, oozing out of the JVM right onto the floor. T wo overloaded constructors both 
calling this() are two constructors calling each other. Over and over and over, 
resulting in
% java A
Exception in thread "main" java.lang.StackOverflowError
The benefit of having overloaded constructors is that you offer flexible ways to 
instantiate objects from your class. The benefit of having one constructor invoke 
another overloaded constructor is to avoid code duplication. In the Animal 
example, there wasn't any code other than setting the name, but imagine if after line 
4 there was still more work to be done in the constructor. By putting all the other 
constructor work in just one constructor, and then having the other constructors 
invoke it, you don't have to write and maintain multiple versions of that other 
important constructor code. Basically, each of the other not-the-real-one overloaded 
constructors will call another overloaded constructor, passing it whatever data it 
needs (data the client code didn't supply). Constructors and instantiation become even more exciting (just when you 
thought it was safe), when you get to inner classes, but we know you can stand to 
144 Chapter 2:  Object Orientation
have only so much fun in one chapter, so we're holding the rest of the discussion on 
instantiating inner classes until Chapter 8. CERTIFICATION OBJECTIVE
Statics (Exam Objective 1.3) 
1.3 Develop code that declares, initializes, and uses primitives, arrays, enums, and 
objects as static, instance, and local variables. Also, use legal identifiers for variable names. Static Variables and Methods
The static modifier has such a profound impact on the behavior of a method or 
variable that we're treating it as a concept entirely separate from the other modifiers. To understand the way a static member works, we'll look first at a reason for using 
one. Imagine you've got a utility class with a method that always runs the same 
way; its sole function is to return, say, a random number. It wouldn't matter which 
instance of the class performed the method—it would always behave exactly the 
same way. In other words, the method's behavior has no dependency on the state 
(instance variable values) of an object. So why, then, do you need an object when 
the method will never be instance-specific? Why not just ask the class itself to run 
the method? Let's imagine another scenario: Suppose you want to keep a running count of 
all instances instantiated from a particular class. Where do you actually keep that 
variable? It won't work to keep it as an instance variable within the class whose 
instances you're tracking, because the count will just be initialized back to a default 
value with each new instance. The answer to both the utility-method-always-runs-
the-same scenario and the keep-a-running-total-of-instances scenario is to use the 
static modifier. Variables and methods marked static belong to the class, rather 
than to any particular instance. In fact, you can use a static method or variable 
without having any instances of that class at all. You need only have the class 
available to be able to invoke a static method or access a static variable. static 
variables, too, can be accessed without having an instance of a class. But if there are 
instances, a static variable of a class will be shared by all instances of that class; 
there is only one copy. The following code declares and uses a static counter variable:
Static Variables and Methods (Exam Objective 1.3) 145
class Frog {
   static int frogCount = 0;  // Declare and initialize 
                              // static variable
   public Frog() {
      frogCount += 1;  // Modify the value in the constructor
   }
   public static void main (String [] args) {
      new Frog();
      new Frog();
      new Frog();
      System.out.println("Frog count is now " + frogCount);
   }
}
In the preceding code, the static frogCount variable is set to zero when the Frog 
class is first loaded by the JVM, before any Frog instances are created! (By the way, 
you don't actually need to initialize a static variable to zero; static variables get the 
same default values instance variables get.) Whenever a Frog instance is created, 
the Frog constructor runs and increments the static frogCount variable. When this 
code executes, three Frog instances are created in main(), and the result is
Frog count is now 3
Now imagine what would happen if frogCount were an instance variable (in 
other words, nonstatic):
class Frog {
   int frogCount = 0;  // Declare and initialize 
                       // instance variable
   public Frog() {
      frogCount += 1;  // Modify the value in the constructor
   }
   public static void main (String [] args) {
      new Frog();
      new Frog();
      new Frog();
      System.out.println("Frog count is now " + frogCount);
   }
}
When this code executes, it should still create three Frog instances in main(), 
but the result is...a compiler error! We can't get this code to compile, let alone run. 146 Chapter 2:  Object Orientation
Frog.java:11: nonstatic variable frogCount cannot be referenced
from a static context
    System.out.println("Frog count is " + frogCount);
                                          ^
    1 error
The JVM doesn't know which Frog object's frogCount you're trying to access. The problem is that main() is itself a static method, and thus isn't running 
against any particular instance of the class, rather just on the class itself. A static 
method can't access a nonstatic (instance) variable, because there is no instance! That's not to say there aren't instances of the class alive on the heap, but rather that 
even if there are, the static method doesn't know anything about them. The same 
applies to instance methods; a static method can't directly invoke a nonstatic 
method. Think static = class, nonstatic = instance. Making the method called by the 
JVM (main()) a static method means the JVM doesn't have to create an instance 
of your class just to start running code. Static Variables and Methods (Exam Objective 1.3) 147
One of the mistakes most often made by new Java programmers is 
attempting to access an instance variable (which means nonstatic variable) from the 
static main() method (which doesn’t know anything about any instances, so it can’t 
access the variable). The following code is an example of illegal access of a nonstatic 
variable from a static method:
class Foo {
    int x = 3;
    public static void main (String [] args) {
       System.out.println("x is " + x);
    }
}
Understand that this code will never compile, because you can’t access 
a nonstatic (instance) variable from a static method. Just think of the compiler saying, 
“Hey, I have no idea which Foo object’s x variable you’re trying to print!” Remember, it’s 
the class running the main() method, not an instance of the class. Accessing Static Methods and Variables
Since you don't need to have an instance in order to invoke a static method or 
access a static variable, then how do you invoke or use a static member? What's the 
syntax? We know that with a regular old instance method, you use the dot operator 
on a reference to an instance:
class Frog {
   int frogSize = 0;
   public int getFrogSize() {
      return frogSize;
   }
   public Frog(int s) {
      frogSize = s;
   }
   public static void main (String [] args) {
148 Chapter 2:  Object Orientation
 (continued) Of course, the tricky part for the exam is that the question 
won’t look as obvious as the preceding code. The problem you’re being tested for— 
accessing a nonstatic variable from a static method—will be buried in code that might 
appear to be testing something else. For example, the preceding code would be more 
likely to appear as
class Foo {
    int x = 3;
    float y = 4.3f;
    public static void main (String [] args) {
       for (int z = x; z < ++x; z--, y = y + z)
          // complicated looping and branching code
    }
}
So while you’re trying to follow the logic, the real issue is that x and y 
can’t be used within main(), because x and y are instance, not static, variables! The same 
applies for accessing nonstatic methods from a static method. The rule is, a static method 
of a class can’t access a nonstatic (instance) method or variable of its own class. Frog f = new Frog(25);
      System.out.println(f.getFrogSize()); // Access instance
                                           // method using f
   }
}
In the preceding code, we instantiate a Frog, assign it to the reference variable 
f, and then use that f reference to invoke a method on the Frog instance we just 
created. In other words, the getFrogSize() method is being invoked on a specific 
Frog object on the heap. But this approach (using a reference to an object) isn't appropriate for accessing a 
static method, because there might not be any instances of the class at all! So, the 
way we access a static method (or static variable) is to use the dot operator on 
the class name, as opposed to using it on a reference to an instance, as follows:
class Frog {
   static int frogCount = 0;  // Declare and initialize 
                              // static variable
   public Frog() {
      frogCount += 1;  // Modify the value in the constructor
   }
}
class TestFrog {
   public static void main (String [] args) {
     new Frog();
     new Frog();
     new Frog();
     System.out.print("frogCount:"+Frog.frogCount); //Access 
                                              // static variable  
   }
}
But just to make it really confusing, the Java language also allows you to use an 
object reference variable to access a static member:
Frog f = new Frog();
int frogs = f.frogCount; // Access static variable 
                         // FrogCount using f
Static Variables and Methods (Exam Objective 1.3) 149
In the preceding code, we instantiate a Frog, assign the new Frog object to the 
reference variable f, and then use the f reference to invoke a static method! But 
even though we are using a specific Frog instance to access the static method, 
the rules haven't changed. This is merely a syntax trick to let you use an object 
reference variable (but not the object it refers to) to get to a static method or 
variable, but the static member is still unaware of the particular instance used 
to invoke the static member. In the Frog example, the compiler knows that the 
reference variable f is of type Frog, and so the Frog class static method is run with 
no awareness or concern for the Frog instance at the other end of the f reference. In 
other words, the compiler cares only that reference variable f is declared as type Frog. Figure 2-8 illustrates the effects of the static modifier on methods and variables. FIGURE 2-8 
The effects of 
static on methods 
and variables
150 Chapter 2:  Object Orientation
class Foo
class Bar
class Baz
static int count;
static void woo( ){ }
static void doMore( ){
woo( );
int x = count;
}
void go ( );
static void doMore( ){
go( );
}
int size = 42;
static void doMore( ){
int x = size;
}
static method cannot
access an instance
(non-static) variable
static method cannot
access a non-static 
method
static method
can access a static
method or variable
Finally, remember that static methods can't be overridden! This doesn't mean they 
can't be redefined in a subclass, but redefining and overriding aren't the same thing. Let's take a look at an example of a redefined (remember, not overridden), static 
method:
class Animal { 
  static void doStuff() { 
    System.out.print("a "); 
  } 
}
class Dog extends Animal {
  static void doStuff() {         // it's a redefinition,
                                  // not an override
    System.out.print("d ");  
  }
  public static void main(String [] args) {
    Animal [] a = {new Animal(), new Dog(), new Animal()};
    for(int x = 0; x < a.length; x++)
      a[x].doStuff();               // invoke the static method
  }
}
Running this code produces the output:
a a a
Remember, the syntax a[x].doStuff() is just a shortcut (the syntax trick)…the 
compiler is going to substitute something like Animal.doStuff() instead. Notice 
that we didn't use the Java 1.5 enhanced for loop here (covered in Chapter 5), even 
though we could have.

--- Chunk #1294 ---
Expect to see a mix of both Java 1.4 and Java 5 coding styles 
and practices on the exam. CERTIFICATION OBJECTIVE
Coupling and Cohesion  (Exam Objective 5.1)
5.1 Develop code that implements tight encapsulation, loose coupling, and high cohesion 
in classes, and describe the benefits. Coupling and Cohesion (Exam Objective 5.1) 151
We're going to admit it up front. The Sun exam's definitions for cohesion and 
coupling are somewhat subjective, so what we discuss in this chapter is from the 
perspective of the exam, and by no means The One True Word on these two OO 
design principles. It may not be exactly the way that you've learned it, but it's what 
you need to understand to answer the questions. You'll have very few questions 
about coupling and cohesion on the real exam. These two topics, coupling and cohesion, have to do with the quality of an OO 
design. In general, good OO design calls for loose coupling and shuns tight coupling, 
and good OO design calls for high cohesion, and shuns low cohesion. As with most 
OO design discussions, the goals for an application are
■ Ease of creation
■ Ease of maintenance
■ Ease of enhancement
Coupling
Let's start by making an attempt at a definition of coupling. Coupling is the degree 
to which one class knows about another class. If the only knowledge that class A 
has about class B, is what class B has exposed through its interface, then class A and 
class B are said to be loosely coupled…that's a good thing. If, on the other hand, 
class A relies on parts of class B that are not part of class B's interface, then the 
coupling between the classes is tighter…not a good thing. In other words, if A knows 
more than it should about the way in which B was implemented, then A and B are 
tightly coupled. Using this second scenario, imagine what happens when class B is enhanced. It's 
quite possible that the developer enhancing class B has no knowledge of class A, 
why would she? Class B's developer ought to feel that any enhancements that don't 
break the class's interface should be safe, so she might change some noninterface 
part of the class, which then causes class A to break. At the far end of the coupling spectrum is the horrible situation in which class A 
knows non-API stuff about class B, and class B knows non-API stuff about class A… 
this is REALLY BAD. If either class is ever changed, there's a chance that the other 
class will break. Let's look at an obvious example of tight coupling, which has been 
enabled by poor encapsulation:
class DoTaxes {
  float rate;
152 Chapter 2:  Object Orientation
  float doColorado() {
    SalesTaxRates str = new SalesTaxRates();
    rate = str.salesRate;     // ouch
                              // this should be a method call:
            // rate = str.getSalesRate("CO");
    // do stuff with rate
  }
}
class SalesTaxRates {
  public float salesRate;            // should be private
  public float adjustedSalesRate;    // should be private
  public float getSalesRate(String region) {
    salesRate = new DoTaxes().doColorado();    // ouch again! // do region-based calculations
    return adjustedSalesRate;
  }
}
All nontrivial OO applications are a mix of many classes and interfaces working 
together. Ideally, all interactions between objects in an OO system should use the 
APIs, in other words, the contracts, of the objects' respective classes. Theoretically, 
if all of the classes in an application have well-designed APIs, then it should be 
possible for all interclass interactions to use those APIs exclusively. As we discussed 
earlier in this chapter, an aspect of good class and API design is that classes should 
be well encapsulated. The bottom line is that coupling is a somewhat subjective concept. Because of 
this, the exam will test you on really obvious examples of tight coupling; you won't 
be asked to make subtle judgment calls. Cohesion
While coupling has to do with how classes interact with each other, cohesion is all 
about how a single class is designed. The term cohesion is used to indicate the degree 
to which a class has a single, well-focused purpose. Keep in mind that cohesion is a 
subjective concept. The more focused a class is, the higher its cohesiveness—a good 
thing. The key benefit of high cohesion is that such classes are typically much easier 
to maintain (and less frequently changed) than classes with low cohesion. Another 
benefit of high cohesion is that classes with a well-focused purpose tend to be more 
reusable than other classes. Let's take a look at a pseudo-code example:
Coupling and Cohesion (Exam Objective 5.1) 153
class BudgetReport {
  void connectToRDBMS(){ }
  void generateBudgetReport() { }
  void saveToFile() { }
  void print() { }
}
Now imagine your manager comes along and says, "Hey you know that 
accounting application we're working on? The clients just decided that they're also 
going to want to generate a revenue projection report, oh and they want to do some 
inventory reporting also. They do like our reporting features however, so make sure 
that all of these reports will let them choose a database, choose a printer, and save 
generated reports to data files..."  Ouch! Rather than putting all the printing code into one report class, we probably would 
have been better off with the following design right from the start:
class BudgetReport {
  Options getReportingOptions() { }
  void generateBudgetReport(Options o) { }
}
class ConnectToRDBMS {
  DBconnection getRDBMS() { }
}
class PrintStuff {
  PrintOptions getPrintOptions() { }
}
class FileSaver {
  SaveOptions getFileSaveOptions() { }
}
This design is much more cohesive. Instead of one class that does everything, 
we've broken the system into four main classes, each with a very specific, or cohesive, 
role. Because we've built these specialized, reusable classes, it'll be much easier 
to write a new report, since we've already got the database connection class, the 
printing class, and the file saver class, and that means they can be reused by other 
classes that might want to print a report. 154 Chapter 2:  Object Orientation
CERTIFICATION SUMMARY
We started the chapter by discussing the importance of encapsulation in good OO 
design, and then we talked about how good encapsulation is implemented: with 
private instance variables and public getters and setters. Next, we covered the importance of inheritance; so that you can grasp overriding, 
overloading, polymorphism, reference casting, return types, and constructors. We covered IS-A and HAS-A. IS-A is implemented using inheritance, and 
HAS-A is implemented by using instance variables that refer to other objects. Polymorphism was next. Although a reference variable's type can't be changed, it 
can be used to refer to an object whose type is a subtype of its own. We learned how 
to determine what methods are invocable for a given reference variable. We looked at the difference between overridden and overloaded methods, 
learning that an overridden method occurs when a subclass inherits a method from 
a superclass, and then reimplements the method to add more specialized behavior. We learned that, at runtime, the JVM will invoke the subclass version on an 
instance of a subclass, and the superclass version on an instance of the superclass. Abstract methods must be "overridden" (technically, abstract methods must be 
implemented, as opposed to overridden, since there really isn't anything to override. We saw that overriding methods must declare the same argument list and 
return type (or, as of Java 5, they can return a subtype of the declared return type 
of the superclass overridden method), and that the access modifier can't be more 
restrictive. The overriding method also can't throw any new or broader checked 
exceptions that weren't declared in the overridden method. You also learned that 
the overridden method can be invoked using the syntax super.doSomething();. Overloaded methods let you reuse the same method name in a class, but with 
different arguments (and, optionally, a different return type). Whereas overriding 
methods must not change the argument list, overloaded methods must. But unlike 
overriding methods, overloaded methods are free to vary the return type, access 
modifier, and declared exceptions any way they like. We learned the mechanics of casting (mostly downcasting), reference variables, 
when it's necessary, and how to use the instanceof operator. Implementing interfaces came next. An interface describes a contract that the 
implementing class must follow. The rules for implementing an interface are similar 
to those for extending an abstract class. Also remember that a class can implement 
more than one interface, and that interfaces can extend another interface. We also looked at method return types, and saw that you can declare any return 
type you like (assuming you have access to a class for an object reference return 
Certiﬁ  cation Summary 155
type), unless you're overriding a method. Barring a covariant return, an overriding 
method must have the same return type as the overridden method of the superclass. We saw that while overriding methods must not change the return type, overloaded 
methods can (as long as they also change the argument list). Finally, you learned that it is legal to return any value or variable that can be 
implicitly converted to the declared return type. So, for example, a short can be 
returned when the return type is declared as an int. And (assuming Horse extends 
Animal), a Horse reference can be returned when the return type is declared 
an Animal. We covered constructors in detail, learning that if you don't provide a constructor 
for your class, the compiler will insert one. The compiler-generated constructor is 
called the default constructor, and it is always a no-arg constructor with a no-arg call 
to super(). The default constructor will never be generated if there is even a single 
constructor in your class (regardless of the arguments of that constructor), so if you 
need more than one constructor in your class and you want a no-arg constructor, 
you'll have to write it yourself. We also saw that constructors are not inherited, and 
that you can be confused by a method that has the same name as the class (which 
is legal). The return type is the giveaway that a method is not a constructor, since 
constructors do not have return types. We saw how all of the constructors in an object's inheritance tree will always be 
invoked when the object is instantiated using new. We also saw that constructors 
can be overloaded, which means defining constructors with different argument 
lists. A constructor can invoke another constructor of the same class using the 
keyword this(), as though the constructor were a method named this(). We saw 
that every constructor must have either this() or super() as the first statement 
(although the compiler can insert it for you). We looked at static methods and variables. Static members are tied to the 
class, not an instance, so there is only one copy of any static member. A common 
mistake is to attempt to reference an instance variable from a static method. Use 
the class name with the dot operator to access static members. We discussed the OO concepts of coupling and cohesion. Loose coupling is the 
desirable state of two or more classes that interact with each other only through 
their respective API's. Tight coupling is the undesirable state of two or more 
classes that know inside details about another class, details not revealed in the 
class's API. High cohesion is the desirable state of a single class whose purpose and 
responsibilities are limited and well-focused. And once again, you learned that the exam includes tricky questions designed 
largely to test your ability to recognize just how tricky the questions can be. 156 Chapter 2:  Object Orientation
TWO-MINUTE DRILL
Here are some of the key points from each certification objective in this chapter. Encapsulation, IS-A, HAS-A (Objective 5.1)
❑ Encapsulation helps hide implementation behind an interface (or API). ❑ Encapsulated code has two features:
 ❑   Instance variables are kept protected (usually with the private modifier). ❑   Getter and setter methods provide access to instance variables. ❑ IS-A refers to inheritance or implementation. ❑ IS-A is expressed with the keyword extends. ❑ IS-A, "inherits from," and "is a subtype of " are all equivalent expressions. ❑ HAS-A means an instance of one class "has a" reference to an instance of 
another class or another instance of the same class. Inheritance (Objective 5.5)
❑ Inheritance allows a class to be a subclass of a superclass, and thereby 
inherit public and protected variables and methods of the superclass. ❑ Inheritance is a key concept that underlies IS-A, polymorphism, overriding, 
overloading, and casting. ❑ All classes (except class Object), are subclasses of type Object, and therefore 
they inherit Object's methods. Polymorphism (Objective 5.2)
❑ Polymorphism means "many forms."
❑ A reference variable is always of a single, unchangeable type, but it can refer 
to a subtype object. ❑ A single object can be referred to by reference variables of many different 
types —as long as they are the same type or a supertype of the object. ❑ The reference variable's type (not the object's type), determines which 
methods can be called! ❑ Polymorphic method invocations apply only to overridden instance methods. T wo-Minute Drill 157
✓
Overriding and Overloading (Objectives 1.5 and 5.4)
❑ Methods can be overridden or overloaded; constructors can be overloaded 
but not overridden. ❑ Abstract methods must be overridden by the first concrete (non-abstract) 
subclass. ❑ With respect to the method it overrides, the overriding method
 ❑    Must have the same argument list. ❑    Must have the same return type, except that as of  Java 5, the return type
      can be a subclass—this is known as a covariant return. ❑    Must not have a more restrictive access modifier. ❑    May have a less restrictive access modifier. ❑    Must not throw new or broader checked exceptions. ❑    May throw fewer or narrower checked exceptions, or any 
      unchecked exception. ❑ final methods cannot be overridden. ❑ Only inherited methods may be overridden, and remember that private 
methods are not inherited. ❑  A subclass uses super.overriddenMethodName() to call the superclass 
version of an overridden method. ❑ Overloading means reusing a method name, but with different arguments. ❑ Overloaded methods
 ❑    Must have different argument lists
 ❑    May have different return types, if argument lists are also different
 ❑    May have different access modifiers
 ❑    May throw different exceptions
❑ Methods from a superclass can be overloaded in a subclass. ❑ Polymorphism applies to overriding, not to overloading. ❑ Object type (not the reference variable's type), determines which overridden 
method is used at runtime. ❑ Reference type determines which overloaded method will be used at 
compile time. 158 Chapter 2:  Object Orientation
Reference Variable Casting (Objective 5.2)
❑ There are two types of reference variable casting: downcasting and upcasting. ❑ Downcasting: If you have a reference variable that refers to a subtype object, 
you can assign it to a reference variable of the subtype. You must make an 
explicit cast to do this, and the result is that you can access the subtype's 
members with this new reference variable. ❑ Upcasting: You can assign a reference variable to a supertype reference vari-
able explicitly or implicitly. This is an inherently safe operation because the 
assignment restricts the access capabilities of the new variable. Implementing an Interface (Objective 1.2)
❑ When you implement an interface, you are fulfilling its contract. ❑ You implement an interface by properly and concretely overriding all of the 
methods defined by the interface. ❑ A single class can implement many interfaces. Return T ypes (Objective 1.5)
❑ Overloaded methods can change return types; overridden methods cannot, 
except in the case of covariant returns. ❑ Object reference return types can accept null as a return value. ❑ An array is a legal return type, both to declare and return as a value. ❑ For methods with primitive return types, any value that can be implicitly 
converted to the return type can be returned. ❑ Nothing can be returned from a void, but you can return nothing. You're 
allowed to simply say return, in any method with a void return type, to bust 
out of a method early. But you can't return nothing from a method with a 
non-void return type. ❑ Methods with an object reference return type, can return a subtype. ❑ Methods with an interface return type, can return any implementer. Constructors and Instantiation (Objectives 1.6 and 5.4)
❑   A constructor is always invoked when a new object is created. T wo-Minute Drill 159
❑   Each superclass in an object's inheritance tree will have a constructor called. ❑ Every class, even an abstract class, has at least one constructor. ❑ Constructors must have the same name as the class. ❑ Constructors don't have a return type. If you see code with a return type, it's a 
method with the same name as the class, it's not a constructor. ❑ Typical constructor execution occurs as follows:
 ❑    The constructor calls its superclass constructor, which calls its superclass 
      constructor, and so on all the way up to the Object constructor. ❑    The Object constructor executes and then returns to the calling 
      constructor, which runs to completion and then returns to its calling
      constructor, and so on back down to the completion of the constructor of
      the actual instance being created. ❑ Constructors can use any access modifier (even private!). ❑ The compiler will create a default constructor if you don't create any construc-
tors in your class. ❑ The default constructor is a no-arg constructor with a no-arg call to super(). ❑ The first statement of every constructor must be a call to either this() (an 
overloaded constructor) or super(). ❑ The compiler will add a call to super() unless you have already put in a call 
to this() or super(). ❑ Instance members are accessible only after the super constructor runs. ❑ Abstract classes have constructors that are called when a concrete 
subclass is instantiated. ❑ Interfaces do not have constructors. ❑ If your superclass does not have a no-arg constructor, you must create a con-
structor and insert a call to super() with arguments matching those 
of the superclass constructor. ❑ Constructors are never inherited, thus they cannot be overridden. ❑  A constructor can be directly invoked only by another constructor (using 
a call to super() or this()). ❑ Issues with calls to this()
 ❑    May appear only as the first statement in a constructor. ❑    The argument list determines which overloaded constructor is called. 160 Chapter 2:  Object Orientation
 ❑    Constructors can call constructors can call constructors, and so on, but
      sooner or later one of them better call super() or the stack will explode. ❑    Calls to this() and super() cannot be in the same constructor. You can 
      have one or the other, but never both. Statics  (Objective 1.3)
❑ Use static methods to implement behaviors that are not affected by the 
state of any instances. ❑ Use static variables to hold data that is class specific as opposed to instance 
specific—there will be only one copy of a static variable. ❑ All static members belong to the class, not to any instance. ❑ A static method can't access an instance variable directly. ❑ Use the dot operator to access static members, but remember that using a 
reference variable with the dot operator is really a syntax trick, and the com-
piler will substitute the class name for the reference variable, for instance:
           d.doStuff();
       becomes:
           Dog.doStuff();
❑ static methods can't be overridden, but they can be redefined. Coupling and Cohesion (Objective 5.1)
❑ Coupling refers to the degree to which one class knows about or uses mem-
bers of another class. ❑ Loose coupling is the desirable state of having classes that are well encapsu-
lated, minimize references to each other, and limit the breadth of API usage. ❑ Tight coupling is the undesirable state of having classes that break the rules of 
loose coupling. ❑ Cohesion refers to the degree in which a class has a single, well-defined role 
or responsibility. ❑ High cohesion is the desirable state of a class whose members support a 
single, well-focused role or responsibility. ❑ Low cohesion is the undesirable state of a class whose members support mul-
tiple, unfocused roles or responsibilities. T wo-Minute Drill 161
SELF TEST
 1. Given:
public abstract interface Frobnicate { public void twiddle(String s); }
  Which is a correct class? (Choose all that apply.)
  A . public abstract class Frob implements Frobnicate { 
      public abstract void twiddle(String s) { }
    }
  B . public abstract class Frob implements Frobnicate { }
  C . public class Frob extends Frobnicate {
      public void twiddle(Integer i) { }
    }
  D . public class Frob implements Frobnicate {
      public void twiddle(Integer i) { }
    }
  E . public class Frob implements Frobnicate {
      public void twiddle(String i) { }
      public void twiddle(Integer s) { }
    }
 2. Given:
class Top {
  public Top(String s) { System.out.print("B"); }
}
public class Bottom2 extends Top {
  public Bottom2(String s) { System.out.print("D"); }
  public static void main(String [] args) {
    new Bottom2("C");
    System.out.println(" ");
  }
}
  What is the result? A.

--- Chunk #1295 ---
BD 
  B. DB 
  C. BDC
  D. DBC
  E. Compilation fails
162 Chapter 2:  Object Orientation
 3. Given:
class Clidder {
  private final void flipper() { System.out.println("Clidder"); }
}
public class Clidlet extends Clidder {
  public final void flipper() { System.out.println("Clidlet");  }
  public static void main(String [] args) { 
    new Clidlet().flipper(); 
  }
}
  What is the result? A.

--- Chunk #1296 ---
Clidlet
  B. Clidder 
  C. Clidder
Clidlet
  D. Clidlet
Clidder 
  E. Compilation fails
 4. Using the fragments below, complete the following code so it compiles. Note, you may not have to fill all of the slots. Code:
class AgedP {
  __________  __________  __________  __________  __________
  public AgedP(int x) {
    __________  __________  __________  __________  __________
  }
}
public class Kinder extends AgedP {
  __________  __________  __________  _________  ________  __________
  public Kinder(int x) {
    __________  __________  __________  __________  __________ ();
  }
}
Self T est 163
164 Chapter 2:  Object Orientation
Fragments: Use the following fragments zero or more times:
AgedP super this
(){}
;
 5. Which statement(s) are true?

--- Chunk #1297 ---
(Choose all that apply.)
  A. Cohesion is the OO principle most closely associated with hiding implementation details 
  B. Cohesion is the OO principle most closely associated with making sure that classes know 
about other classes only through their APIs
  C. Cohesion is the OO principle most closely associated with making sure that a class is 
designed with a single, well-focused purpose
   D. Cohesion is the OO principle most closely associated with allowing a single object to be 
seen as having many types 
 6. Given the following,
 1.

--- Chunk #1298 ---
class X { void do1() { } }
 2. class Y extends X { void do2() { } }
 3. 4. class Chrome {
 5. public static void main(String [] args) {
 6. X x1 = new X();
 7. X x2 = new Y();
 8. Y y1 = new Y();
 9. // insert code here
10. } }   
  Which, inserted at line 9, will compile? (Choose all that apply.)
  A. x2.do2(); 
  B. (Y)x2.do2(); 
  C. ((Y)x2).do2();
   D. None of the above statements will compile 
 7. Given:
 1. ClassA has a ClassD
 2. Methods in ClassA use public methods in ClassB
 3. Methods in ClassC use public methods in ClassA
 4. Methods in ClassA use public variables in ClassB
  Which is most likely true? (Choose the most likely.)
   A. ClassD has low cohesion
  B. ClassA has weak encapsulation
  C. ClassB has weak encapsulation
  D. ClassB has strong encapsulation
  E. ClassC is tightly coupled to ClassA
 8. Given:
 3. class Dog {
 4. public void bark() { System.out.print("woof "); }
 5. }
 6. class Hound extends Dog {
 7. public void sniff() { System.out.print("sniff "); }
 8. public void bark() { System.out.print("howl "); }
 9. }
10. public class DogShow {
11. public static void main(String[] args) { new DogShow().go(); }
12. void go() {
13. new Hound().bark();
14. ((Dog) new Hound()).bark();
15. ((Dog) new Hound()).sniff();
16. }
17. }
  What is the result? (Choose all that apply.)
  A. howl howl sniff
  B. howl woof sniff
  C. howl howl followed by an exception
  D. howl woof followed by an exception
  E. Compilation fails with an error at line 14
  F. Compilation fails with an error at line 15
Self T est 165
166 Chapter 2:  Object Orientation
 9. Given:
 3. public class Redwood extends Tree {
 4. public static void main(String[] args) {
 5. new Redwood().go();
 6. }
 7. void go() { 
 8. go2(new Tree(), new Redwood()); 
 9. go2((Redwood) new Tree(), new Redwood());
10. }
11. void go2(Tree t1, Redwood r1) {
12. Redwood r2 = (Redwood)t1;
13. Tree t2 = (Tree)r1;
14. }
15. }
16. class Tree { }
  What is the result? (Choose all that apply.)
  A. An exception is thrown at runtime
  B. The code compiles and runs with no output
  C. Compilation fails with an error at line 8
  D. Compilation fails with an error at line 9
  E. Compilation fails with an error at line 12
  F. Compilation fails with an error at line 13
 10. Given:
 3. public class Tenor extends Singer { 
 4. public static String sing() { return "fa"; }
 5. public static void main(String[] args) {
 6. Tenor t = new Tenor();
 7. Singer s = new Tenor();
 8. System.out.println(t.sing() + " " + s.sing());
 9. }
10. }
11. class Singer { public static String sing() { return "la"; } }
  What is the result? A.

--- Chunk #1299 ---
fa fa
  B. fa la
  C. la la
  D. Compilation fails
  E. An exception is thrown at runtime
 11. Given:
 3. class Alpha {
 4. static String s = " ";
 5. protected Alpha() { s += "alpha "; }
 6. }
 7. class SubAlpha extends Alpha {
 8. private SubAlpha() { s += "sub "; }
 9. }
10. public class SubSubAlpha extends Alpha {
11. private SubSubAlpha() { s += "subsub "; }
12. public static void main(String[] args) {
13. new SubSubAlpha();
14. System.out.println(s);
15. }
16. }
  What is the result? A. subsub
  B. sub subsub
  C. alpha subsub
  D. alpha sub subsub
  E. Compilation fails
  F. An exception is thrown at runtime
 12. Given:
 3. class Building {
 4. Building() {  System.out.print("b ");  }
 5. Building(String name) {  
 6. this();   System.out.print("bn " + name); 
 7. }
 8.

--- Chunk #1300 ---
}
 9. public class House extends Building {
10. House() {  System.out.print("h ");  }
11. House(String name) { 
12. this();   System.out.print("hn " + name);
13. }
14. public static void main(String[] args) { new House("x "); }
15. }
Self T est 167
168 Chapter 2:  Object Orientation
  What is the result? A.

--- Chunk #1301 ---
h hn x
  B. hn x h
  C. b h hn x
  D. b hn x h
  E. bn x h hn x
  F. b bn x h hn x
  G. bn x b h hn x
  H. Compilation fails
 13. Given:
 3. class Mammal {
 4. String name = "furry ";
 5. String makeNoise() { return "generic noise"; }
 6. }
 7. class Zebra extends Mammal {
 8. String name = "stripes ";
 9. String makeNoise() { return "bray"; }
10. }
11. public class ZooKeeper {
12. public static void main(String[] args) { new ZooKeeper().go(); }
13. void go() {
14. Mammal m = new Zebra();
15. System.out.println(m.name + m.makeNoise());
16. }
17. }
  What is the result? A. furry bray
  B. stripes bray
  C. furry generic noise
  D. stripes generic noise
  E. Compilation fails
  F. An exception is thrown at runtime
Self T est 169
 14. You’re designing a new online board game in which Floozels are a type of Jammers, Jammers can 
have Quizels, Quizels are a type of Klakker, and Floozels can have several Floozets. Which of the 
following fragments represent this design? (Choose all that apply.)
  A. import java.util.*; 
       interface Klakker { }
       class Jammer { Set<Quizel> q; }
       class Quizel implements Klakker { }
       public class Floozel extends Jammer { List<Floozet> f; }
       interface Floozet { }
  B. import java.util.*;     
       class Klakker { Set<Quizel> q; }
       class Quizel extends Klakker { }
       class Jammer { List<Floozel> f; }
       class Floozet extends Floozel { }
       public class Floozel { Set<Klakker> k; }
  C. import java.util.*;      
       class Floozet { }
       class Quizel implements Klakker { }
       class Jammer { List<Quizel> q; }
       interface Klakker { }
       class Floozel extends Jammer { List<Floozet> f; }
  D. import java.util.*;      
       interface Jammer extends Quizel { }  
       interface Klakker { }
       interface Quizel extends Klakker { }
       interface Floozel extends Jammer, Floozet { }
       interface Floozet { }
 15. Given:
 3. class A { }
 4. class B extends A { }
 5. public class ComingThru {
 6. static String s = "-";
 7. public static void main(String[] args) {
 8. A[] aa = new A[2];
 9. B[] ba = new B[2];
10. sifter(aa);
11. sifter(ba);
12. sifter(7);
13. System.out.println(s);
14. }
170 Chapter 2:  Object Orientation
15. static void sifter(A[]... a2)    { s += "1"; }
16. static void sifter(B[]... b1)    { s += "2"; }
17. static void sifter(B[] b1)       { s += "3"; }
18. static void sifter(Object o)     { s += "4"; }
19. }
  What is the result?

--- Chunk #1302 ---
A. -124
  B. -134
  C. -424
  D. -434
  E. -444
  F. Compilation fails
SELF TEST ANSWERS
 1. Given:
public abstract interface Frobnicate { public void twiddle(String s); }
        Which is a correct class? (Choose all that apply.)
  A . public abstract class Frob implements Frobnicate { 
      public abstract void twiddle(String s) { }
    }
  B . public abstract class Frob implements Frobnicate { }
  C . public class Frob extends Frobnicate {
      public void twiddle(Integer i) { }
    }
  D . public class Frob implements Frobnicate {
      public void twiddle(Integer i) { }
    }
  E . public class Frob implements Frobnicate {
      public void twiddle(String i) { }
      public void twiddle(Integer s) { }
    }
Answer: 
  ® ✓  B is correct, an abstract class need not implement any or all of an interface’s methods. E is correct, the class implements the interface method and additionally overloads the  
twiddle() method. ® ˚   A is incorrect because abstract methods have no body. C is incorrect because classes 
                implement interfaces they don’t extend them. D is incorrect because overloading a 
                method is not implementing it. (Objective 5.4)
 2. Given:
class Top {
  public Top(String s) { System.out.print("B"); }
}
public class Bottom2 extends Top {
  public Bottom2(String s) { System.out.print("D"); }
  public static void main(String [] args) {
    new Bottom2("C");
    System.out.println(" ");
} }
Self T est Answers 171
172 Chapter 2:  Object Orientation
       What is the result? A.

--- Chunk #1303 ---
BD 
  B. DB 
  C. BDC
  D. DBC
  E. Compilation fails
Answer: 
  ® ✓  E is correct. The implied super() call in Bottom2’s constructor cannot be satisfied because 
there isn’t a no-arg constructor in Top. A default, no-arg constructor is generated by the 
compiler only if the class has no constructor defined explicitly. ® ˚   A, B, C, and D are incorrect based on the above. (Objective 1.6)
 3. Given:
class Clidder {
  private final void flipper() { System.out.println("Clidder"); }
}
public class Clidlet extends Clidder {
  public final void flipper() { System.out.println("Clidlet");  }
  public static void main(String [] args) { 
    new Clidlet().flipper(); 
} }
  What is the result? A.

--- Chunk #1304 ---
Clidlet 
  B. Clidder 
  C. Clidder
Clidlet
  D. Clidlet
Clidder 
  E. Compilation fails
Answer: 
  ® ✓  A is correct. Although a final method cannot be overridden, in this case, the method 
is private, and therefore hidden. The effect is that a new, accessible, method flipper is 
created. Therefore, no polymorphism occurs in this example, the method invoked is simply 
that of the child class, and no error occurs. ® ˚   B, C, D, and E are incorrect based on the preceding. (Objective 5.3)
 4. Using the fragments below, complete the following code so it compiles.

--- Chunk #1305 ---
Note, you may not have to fill all of the slots. Code:
class AgedP {
  __________  __________  __________  __________  __________
  public AgedP(int x) {
    __________  __________  __________  __________  __________
  }
}
public class Kinder extends AgedP {
  __________  __________  __________  _________  ________  __________
  public Kinder(int x) {
    __________  __________  __________  __________  __________ ();
  }
}
Fragments: Use the following fragments zero or more times:
AgedP super this
(){}
;
Answer:
class AgedP {
  AgedP() {}
  public AgedP(int x) {
  }
}
public class Kinder extends AgedP {
  public Kinder(int x) {
    super();
  }
}
        As there is no droppable tile for the variable x and the parentheses (in the Kinder constructor), 
are already in place and empty, there is no way to construct a call to the superclass constructor 
Self T est Answers 173
174 Chapter 2:  Object Orientation
that takes an argument. Therefore, the only remaining possibility is to create a call to the no-
argument superclass constructor.

--- Chunk #1306 ---
This is done as: super();. The line cannot be left blank, as 
the parentheses are already in place. Further, since the superclass constructor called is the no-
argument version, this constructor must be created. It will not be created by the compiler 
because there is another constructor already present. (Objective 5.4)
 5 Which statement(s) are true?

--- Chunk #1307 ---
(Choose all that apply.)
  A. Cohesion is the OO principle most closely associated with hiding implementation details 
  B. Cohesion is the OO principle most closely associated with making sure that classes know 
about other classes only through their APIs
  C. Cohesion is the OO principle most closely associated with making sure that a class is 
designed with a single, well-focused purpose
   D. Cohesion is the OO principle most closely associated with allowing a single object to be 
seen as having many types 
Answer:
  ® ✓ Answer C is correct. ® ˚  A refers to encapsulation, B refers to coupling, and D refers to polymorphism. (Objective 5.1)
 6 .

--- Chunk #1308 ---
Given the following,
 1. class X { void do1() { } }
 2. class Y extends X { void do2() { } }
 3. 4. class Chrome {
 5. public static void main(String [] args) {
 6. X x1 = new X();
 7. X x2 = new Y();
 8. Y y1 = new Y();
 9. // insert code here
10. }
11. }   
  Which, inserted at line 9, will compile? (Choose all that apply.)
  A. x2.do2(); 
  B. (Y)x2.do2(); 
  C. ((Y)x2).do2();
   D. None of the above statements will compile
Answer:
  ® ✓   C is correct. Before you can invoke Y’s do2 method you have to cast x2 to be of type Y. Statement B looks like a proper cast but without the second set of parentheses, the 
compiler thinks it’s an incomplete statement. ® ˚   A, B and D are incorrect based on the preceding. (Objective 5.2)
 7 .

--- Chunk #1309 ---
Given:
 1. ClassA has a ClassD
 2. Methods in ClassA use public methods in ClassB
 3. Methods in ClassC use public methods in ClassA
 4. Methods in ClassA use public variables in ClassB
  Which is most likely true? (Choose the most likely.)
  A. ClassD has low cohesion
  B. ClassA has weak encapsulation
  C. ClassB has weak encapsulation
  D. ClassB has strong encapsulation
  E. ClassC is tightly coupled to ClassA
Answer:
  ® ✓   C is correct. Generally speaking, public variables are a sign of weak encapsulation. ® ˚   A, B, D, and E are incorrect, because based on the information given, none of these 
statements can be supported. (Objective 5.1)
 8 .

--- Chunk #1310 ---
Given:
 3. class Dog {
 4. public void bark() { System.out.print("woof "); }
 5. }
 6. class Hound extends Dog {
 7. public void sniff() { System.out.print("sniff "); }
Self T est Answers 175
176 Chapter 2:  Object Orientation
 8. public void bark() { System.out.print("howl "); }
 9. }
10. public class DogShow {
11. public static void main(String[] args) { new DogShow().go(); }
12. void go() {
13. new Hound().bark();
14. ((Dog) new Hound()).bark();
15. ((Dog) new Hound()).sniff();
16. }
17. }
  What is the result? (Choose all that apply.)
  A. howl howl sniff
  B. howl woof sniff
  C. howl howl followed by an exception
  D. howl woof followed by an exception
  E. Compilation fails with an error at line 14
  F. Compilation fails with an error at line 15
Answer:
  ® ✓   F is correct. Class Dog doesn’t have a sniff method. ® ˚   A, B, C, D, and E are incorrect based on the above information. (Objective 5.2)
 9 .

--- Chunk #1311 ---
Given:
 3. public class Redwood extends Tree {
 4. public static void main(String[] args) {
 5. new Redwood().go();
 6. }
 7. void go() { 
 8. go2(new Tree(), new Redwood()); 
 9. go2((Redwood) new Tree(), new Redwood());
10. }
11. void go2(Tree t1, Redwood r1) {
12. Redwood r2 = (Redwood)t1;
13. Tree t2 = (Tree)r1;
14. }
15. }
16. class Tree { }
  What is the result? (Choose all that apply.)
  A. An exception is thrown at runtime
  B. The code compiles and runs with no output
  C. Compilation fails with an error at line 8
  D. Compilation fails with an error at line 9
  E. Compilation fails with an error at line 12
  F. Compilation fails with an error at line 13
Answer:
  ® ✓   A is correct, a ClassCastException will be thrown when the code attempts to downcast a 
Tree to a Redwood. ® ˚   B, C, D, E, and F are incorrect based on the above information. (Objective 5.2)
 10.

--- Chunk #1312 ---
Given:
 3. public class Tenor extends Singer { 
 4. public static String sing() { return "fa"; }
 5. public static void main(String[] args) {
 6. Tenor t = new Tenor();
 7. Singer s = new Tenor();
 8. System.out.println(t.sing() + " " + s.sing());
 9. }
10. }
11. class Singer { public static String sing() { return "la"; } }
  What is the result? A.

--- Chunk #1313 ---
fa fa
  B. fa la
  C. la la
  D. Compilation fails
  E. An exception is thrown at runtime
Answer:
  ® ✓   B is correct. The code is correct, but polymorphism doesn’t apply to static methods. ® ˚   A, C, D, and E are incorrect based on the above information. (Objective 5.2)
Self T est Answers 177
178 Chapter 2:  Object Orientation
 11. Given:
 3.

--- Chunk #1314 ---
class Alpha {
 4. static String s = " ";
 5. protected Alpha() { s += "alpha "; }
 6. }
 7. class SubAlpha extends Alpha {
 8. private SubAlpha() { s += "sub "; }
 9. }
10. public class SubSubAlpha extends Alpha {
11. private SubSubAlpha() { s += "subsub "; }
12. public static void main(String[] args) {
13. new SubSubAlpha();
14. System.out.println(s);
15. }
16. }
  What is the result? A. subsub
  B. sub subsub
  C. alpha subsub
  D. alpha sub subsub
  E. Compilation fails
  F. An exception is thrown at runtime
Answer:
  ® ✓   C is correct. Watch out, SubSubAlpha extends Alpha! Since the code doesn’t attempt 
to make a SubAlpha, the private constructor in SubAlpha is okay. ® ˚   A, B, D, E, and F are incorrect based on the above information. (Objective 5.3)
 12.

--- Chunk #1315 ---
Given:
 3. class Building {
 4. Building() {  System.out.print("b ");  }
 5. Building(String name) {  
 6. this();   System.out.print("bn " + name); 
 7. }
 8.

--- Chunk #1316 ---
}
 9. public class House extends Building {
10. House() {  System.out.print("h ");  }
11. House(String name) { 
12. this();   System.out.print("hn " + name);
13. }
14. public static void main(String[] args) { new House("x "); }
15. }
  What is the result?

--- Chunk #1317 ---
A. h hn x
  B. hn x h
  C. b h hn x
  D. b hn x h
  E. bn x h hn x
  F. b bn x h hn x
  G. bn x b h hn x
  H. Compilation fails
Answer:
  ® ✓   C is correct. Remember that constructors call their superclass constructors, which execute 
first, and that constructors can be overloaded. ® ˚   A, B, D, E, F, G, and H are incorrect based on the above information. (Objectives 1.6, 5.4)
 13.

--- Chunk #1318 ---
Given:
 3. class Mammal {
 4. String name = "furry ";
 5. String makeNoise() { return "generic noise"; }
 6. }
 7. class Zebra extends Mammal {
 8. String name = "stripes ";
 9. String makeNoise() { return "bray"; }
10. }
11. public class ZooKeeper {
12. public static void main(String[] args) { new ZooKeeper().go(); }
13. void go() {
14. Mammal m = new Zebra();
15. System.out.println(m.name + m.makeNoise());
16. }
17. }
Self T est Answers 179
180 Chapter 2:  Object Orientation
  What is the result? A.

--- Chunk #1319 ---
furry bray
  B. stripes bray
  C. furry generic noise
  D. stripes generic noise
  E. Compilation fails
  F. An exception is thrown at runtime
Answer:
  ® ✓   A is correct. Polymorphism is only for instance methods. ® ˚   B, C, D, E, and F are incorrect based on the above information.

--- Chunk #1320 ---
(Objectives 1.5, 5.4)
 14. You’re designing a new online board game in which Floozels are a type of Jammers, Jammers can 
have Quizels, Quizels are a type of Klakker, and Floozels can have several Floozets. Which of the 
following fragments represent this design? (Choose all that apply.)
  A. import java.util.*; 
       interface Klakker { }
       class Jammer { Set<Quizel> q; }
       class Quizel implements Klakker { }
       public class Floozel extends Jammer { List<Floozet> f; }
       interface Floozet { }
  B. import java.util.*;     
       class Klakker { Set<Quizel> q; }
       class Quizel extends Klakker { }
       class Jammer { List<Floozel> f; }
       class Floozet extends Floozel { }
       public class Floozel { Set<Klakker> k; }
  C. import java.util.*;      
       class Floozet { }
       class Quizel implements Klakker { }
       class Jammer { List<Quizel> q; }
       interface Klakker { }
       class Floozel extends Jammer { List<Floozet> f; }
  D. import java.util.*;      
       interface Jammer extends Quizel { }  
       interface Klakker { }
       interface Quizel extends Klakker { }
       interface Floozel extends Jammer, Floozet { }
       interface Floozet { }
Self T est Answers 181
Answer:
  ® ✓   A and C are correct. The phrase "type of" indicates an "is-a" relationship (extends or 
implements), and the phrase “have” is of course a "has-a" relationship (usually instance 
variables). ® ˚   B and D are incorrect based on the above information. (Objective 5.5)
 15.

--- Chunk #1321 ---
Given:
 3. class A { }
 4. class B extends A { }
 5. public class ComingThru {
 6. static String s = "-";
 7. public static void main(String[] args) {
 8. A[] aa = new A[2];
 9. B[] ba = new B[2];
10. sifter(aa);
11. sifter(ba);
12. sifter(7);
13. System.out.println(s);
14. }
15. static void sifter(A[]... a2)    { s += "1"; }
16. static void sifter(B[]... b1)    { s += "2"; }
17. static void sifter(B[] b1)       { s += "3"; }
18. static void sifter(Object o)     { s += "4"; }
19. }
  What is the result?

--- Chunk #1322 ---
A. -124
  B. -134
  C. -424
  D. -434
  E. -444
  F. Compilation fails
Answer:
  ® ✓   D is correct. In general, overloaded var-args methods are chosen last. Remember that arrays 
are objects. Finally, an int can be boxed to an Integer and then "widened" to an Object. ® ˚   A, B, C, E, and F are incorrect based on the above information. (Objective 1.5)
			

3
Assignments
CERTIFICATION OBJECTIVES
l    Use Class Members
 l     Develop Wrapper Code & 
        Autoboxing Code
 l     Determine the Effects of Passing
       Variables into Methods
 
 l    Recognize when Objects Become 
          Eligible for Garbage Collection
 ✓     T wo-Minute Drill
          Q&A  Self T est
 
	
184 Chapter 3:  Assignments
Stack and Heap—Quick Review
For most people, understanding the basics of the stack and the heap makes it 
far easier to understand topics like argument passing, polymorphism, threads, 
exceptions, and garbage collection. In this section, we'll stick to an overview, but 
we'll expand these topics several more times throughout the book. For the most part, the various pieces (methods, variables, and objects) of Java 
programs live in one of two places in memory: the stack or the heap. For now, we're 
going to worry about only three types of things: instance variables, local variables, 
and objects:
■ Instance variables and objects live on the heap. ■ Local variables live on the stack. Let's take a look at a Java program, and how its various pieces are created and 
map into the stack and the heap:
 1. class Collar { }
 2.

--- Chunk #1323 ---
3. class Dog {
 4. Collar c;         // instance variable
 5. String name;      // instance variable
 6. 7. public static void main(String [] args) {
 8. 9. Dog d;                         // local variable: d
10. d = new Dog();
11. d.go(d);
12. }
13. void go(Dog dog) {               // local variable: dog
14. c = new Collar();              
15. dog.setName("Aiko");
16. }
17. void setName(String dogName) {   // local var: dogName
18. name = dogName;
19. // do more stuff
20.

--- Chunk #1324 ---
}
21. }
Figure 3-1 shows the state of the stack and the heap once the program reaches 
line 19. Following are some key points:
Instance
variables:
- name
- c
Collar object
Dog object
String object
"Aiko"
The Heap
setName() dogName
go()  dog
main()  d
method               local 
                          variables
           The Stack
Stack and Heap—Quick Review 185
 
■ Line 7— main() is placed on the stack. ■ Line 9—reference variable d is created on the stack, but there's no Dog 
object yet. ■ Line 10—a new Dog object is created and is assigned to the d reference 
variable. ■ Line 11—a copy of the reference variable d is passed to the go() method. ■ Line 13—the go() method is placed on the stack, with the dog parameter as 
a local variable. ■ Line 14—a new Collar object is created on the heap, and assigned to Dog's 
instance variable. ■ Line 17— setName() is added to the stack, with the dogName parameter as 
its local variable. ■  Line 18—the name instance variable now also refers to the String object. ■ Notice that two different local variables refer to the same Dog object. ■ Notice that one local variable and one instance variable both refer to the 
same String Aiko. ■ After Line 19 completes, setName() completes and is removed from the 
stack. At this point the local variable dogName disappears too, although the 
String object it referred to is still on the heap. FIGURE 3-1 
Overview of the 
Stack and the 
Heap
186 Chapter 3:  Assignments
CERTIFICATION OBJECTIVE
Literals,  Assignments, and Variables 
(Exam Objectives 1.3 and 7.6)
1.3 Develop code that declares, initializes, and uses primitives, arrays, enums, and 
objects as static, instance, and local variables. Also, use legal identifiers for variable names. 7.6 Write code that correctly applies the appropriate operators including assignment 
operators (limited to: =, +=, -=)... Literal Values for All Primitive T ypes  
A primitive literal is merely a source code representation of the primitive data 
types—in other words, an integer, floating-point number, boolean, or character that 
you type in while writing code. The following are examples of primitive literals:
'b'          // char literal
42           // int literal
false        // boolean literal
2546789.343  // double literal
Integer Literals
There are three ways to represent integer numbers in the Java language: decimal 
(base 10), octal (base 8), and hexadecimal (base 16). Most exam questions 
with integer literals use decimal representations, but the few that use octal or 
hexadecimal are worth studying for. Even though the odds that you'll ever actually 
use octal in the real world are astronomically tiny, they were included in the exam 
just for fun. Decimal Literals    Decimal integers need no explanation; you've been using 
them since grade one or earlier. Chances are you don't keep your checkbook in 
hex. (If you do, there's a Geeks Anonymous [GA] group ready to help.) In the Java 
language, they are represented as is, with no prefix of any kind, as follows:
int length = 343;
Octal Literals    Octal integers use only the digits 0 to 7. In Java, you represent 
an integer in octal form by placing a zero in front of the number, as follows:
class Octal {
  public static void main(String [] args) {
    int six = 06;     // Equal to decimal 6
    int seven = 07;   // Equal to decimal 7
    int eight = 010;  // Equal to decimal 8
    int nine = 011;   // Equal to decimal 9
    System.out.println("Octal 010 = " + eight);
  }
}
Notice that when we get past seven and are out of digits to use (we are allowed 
only the digits 0 through 7 for octal numbers), we revert back to zero, and one is 
added to the beginning of the number. You can have up to 21 digits in an octal 
number, not including the leading zero. If we run the preceding program, it displays 
the following:
Octal 010 = 8
Hexadecimal Literals    Hexadecimal (hex for short) numbers are constructed 
using 16 distinct symbols. Because we never invented single digit symbols for the 
numbers 10 through 15, we use alphabetic characters to represent these digits. Counting from 0 through 15 in hex looks like this:
0 1 2 3 4 5 6 7 8 9 a b c d e f
Java will accept capital or lowercase letters for the extra digits (one of the few 
places Java is not case-sensitive!). You are allowed up to 16 digits in a hexadecimal 
number, not including the prefix 0x or the optional suffix extension L, which will be 
explained later. All of the following hexadecimal assignments are legal:
class HexTest {
  public static void main (String [] args) {
    int x = 0X0001;
    int y = 0x7fffffff;
    int z = 0xDeadCafe;
    System.out.println("x = " + x + " y = " + y + " z = " + z);
  }
}
Literal  Values for All Primitive Types (Exam Objectives 1.3 and 7.6) 187
188 Chapter 3:  Assignments
Running HexTest produces the following output:
x = 1 y = 2147483647 z = -559035650
Don't be misled by changes in case for a hexadecimal digit or the 'x' preceding it. 0XCAFE and 0xcafe are both legal and have the same value. All three integer literals (octal, decimal, and hexadecimal) are defined as int by 
default, but they may also be specified as long by placing a suffix of L or l after the 
number:
long jo = 110599L;
long so = 0xFFFFl;  // Note the lowercase 'l'
Floating-Point Literals
Floating-point numbers are defined as a number, a decimal symbol, and more 
numbers representing the fraction. double d = 11301874.9881024;
In the preceding example, the number 11301874.9881024 is the literal value. Floating-point literals are defined as double (64 bits) by default, so if you want to 
assign a floating-point literal to a variable of type float (32 bits), you must attach the 
suffix F or f to the number. If you don't, the compiler will complain about a possible 
loss of precision, because you're trying to fit a number into a (potentially) less precise 
"container." The F suffix gives you a way to tell the compiler, "Hey, I know what I'm 
doing, and I'll take the risk, thank you very much." 
float f = 23.467890;         // Compiler error, possible loss 
                             // of precision
float g = 49837849.029847F;  // OK; has the suffix "F"
You may also optionally attach a D or d to double literals, but it is not necessary 
because this is the default behavior. double d = 110599.995011D; // Optional, not required
double  g = 987.897;       // No 'D' suffix, but OK because the 
                           // literal is a double by default
Look for numeric literals that include a comma, for example,
int x = 25,343;  // Won't compile because of the comma
Boolean Literals
Boolean literals are the source code representation for boolean values. A boolean 
value can only be defined as true or false. Although in C (and some other 
languages) it is common to use numbers to represent true or false, this will not 
work in Java. Again, repeat after me, "Java is not C++."
boolean t = true;  // Legal
boolean  f = 0;    // Compiler error! Be on the lookout for questions that use numbers where booleans are required. You might see an if test that uses a number, as in the following:
int x = 1;  if (x) {  } // Compiler error! Character Literals
A char literal is represented by a single character in single quotes. char a = 'a';
char b = '@';
You can also type in the Unicode value of the character, using the Unicode 
notation of prefixing the value with \u as follows:
char letterN = '\u004E'; // The letter 'N'
Remember, characters are just 16-bit unsigned integers under the hood. That 
means you can assign a number literal, assuming it will fit into the unsigned 16-bit 
range (65535 or less). For example, the following are all legal:
char a = 0x892;        // hexadecimal literal
char b = 982;          // int literal
char c = (char)70000;  // The cast is required; 70000 is 
                       // out of char range
Literal  Values for All Primitive Types (Exam Objectives 1.3 and 7.6) 189
190 Chapter 3:  Assignments
char d = (char) -98;   // Ridiculous, but legal
And the following are not legal and produce compiler errors:
char e = -29;   // Possible loss of precision; needs a cast
char f = 70000  // Possible loss of precision; needs a cast
You can also use an escape code if you want to represent a character that can't be 
typed in as a literal, including the characters for linefeed, newline, horizontal tab, 
backspace, and single quotes. char c = '\"';    // A double quote
char d = '\n';    // A newline
Literal Values for Strings
A string literal is a source code representation of a value of a String object. For 
example, the following is an example of two ways to represent a string literal:
String s = "Bill Joy";
System.out.println("Bill" + " Joy");
Although strings are not primitives, they're included in this section because they 
can be represented as literals—in other words, typed directly into code. The only 
other nonprimitive type that has a literal representation is an array, which we'll look 
at later in the chapter. Thread t = ??? // what literal value could possibly go here? Assignment Operators
Assigning a value to a variable seems straightforward enough; you simply assign 
the stuff on the right side of the = to the variable on the left. Well, sure, but don't 
expect to be tested on something like this:
x = 6;
No, you won't be tested on the no-brainer (technical term) assignments. You will, however, be tested on the trickier assignments involving complex 
expressions and casting. W e'll look at both primitive and reference variable 
assignments. But before we begin, let's back up and peek inside a variable. What is a 
variable? How are the variable and its value related? Variables are just bit holders, with a designated type. You can have an int holder, 
a double holder, a Button holder, and even a String[] holder. Within that holder is 
a bunch of bits representing the value. For primitives, the bits represent a numeric 
value (although we don't know what that bit pattern looks like for boolean, luckily, 
we don't care). A byte with a value of 6, for example, means that the bit pattern in 
the variable (the byte holder) is 00000110, representing the 8 bits. So the value of a primitive variable is clear, but what's inside an object holder? If you say,
Button b = new Button();
what's inside the Button holder b? Is it the Button object? No! A variable referring 
to an object is just that—a reference variable. A reference variable bit holder 
contains bits representing a way to get to the object. We don't know what the format 
is. The way in which object references are stored is virtual-machine specific (it's 
a pointer to something, we just don't know what that something really is). All 
we can say for sure is that the variable's value is not the object, but rather a value 
representing a specific object on the heap. Or null. If the reference variable has not 
been assigned a value, or has been explicitly assigned a value of null, the variable 
holds bits representing—you guessed it—null. You can read
Button b = null;
as "The Button variable b is not referring to any object." 
So now that we know a variable is just a little box o' bits, we can get on with the 
work of changing those bits. We'll look first at assigning values to primitives, and 
finish with assignments to reference variables. Primitive Assignments
The equal (=) sign is used for assigning a value to a variable, and it's cleverly named 
the assignment operator. There are actually 12 assignment operators, but only the 
five most commonly used are on the exam, and they are covered in Chapter 4. You can assign a primitive variable using a literal or the result of an expression. Assignment Operators (Exam Objectives 1.3 and 7.6) 191
192 Chapter 3:  Assignments
Take a look at the following:
int x = 7;     // literal assignment
int y = x + 2; // assignment with an expression 
               // (including a literal)
int z = x * y; // assignment with an expression
The most important point to remember is that a literal integer (such as 7) is 
always implicitly an int. Thinking back to Chapter 1, you'll recall that an int is 
a 32-bit value. No big deal if you're assigning a value to an int or a long variable, 
but what if you're assigning to a byte variable? After all, a byte-sized holder can't 
hold as many bits as an int-sized holder. Here's where it gets weird. The following is 
legal,
byte b = 27;
but only because the compiler automatically narrows the literal value to a byte. In 
other words, the compiler puts in the cast. The preceding code is identical to the 
following:
byte b = (byte) 27; // Explicitly cast the int literal to a byte
It looks as though the compiler gives you a break, and lets you take a shortcut with 
assignments to integer variables smaller than an int. (Everything we're saying about 
byte applies equally to char and short, both of which are smaller than an int.) 
We're not actually at the weird part yet, by the way. We know that a literal integer is always an int, but more importantly, the result 
of an expression involving anything int-sized or smaller is always an int. In other 
words, add two bytes together and you'll get an int—even if those two bytes are 
tiny. Multiply an int and a short and you'll get an int. Divide a short by a byte 
and you'll get…an int. OK, now we're at the weird part. Check this out:
byte a = 3;     // No problem, 3 fits in a byte
byte b = 8;     // No problem, 8 fits in a byte
byte c = b + c; // Should be no problem, sum of the two bytes
                // fits in a byte
The last line won't compile! You'll get an error something like this:
TestBytes.java:5: possible loss of precision
found   : int
required: byte
    byte c = a + b;
               ^
We tried to assign the sum of two bytes to a byte variable, the result of which 
(11) was definitely small enough to fit into a byte, but the compiler didn't care. It 
knew the rule about int-or-smaller expressions always resulting in an int. It would 
have compiled if we'd done the explicit cast:
byte c = (byte) (a + b);
Primitive Casting
Casting lets you convert primitive values from one type to another. We mentioned 
primitive casting in the previous section, but now we're going to take a deeper look. (Object casting was covered in Chapter 2.)
Casts can be implicit or explicit. An implicit cast means you don't have to write 
code for the cast; the conversion happens automatically. Typically, an implicit 
cast happens when you're doing a widening conversion. In other words, putting a 
smaller thing (say, a byte) into a bigger container (like an int). Remember those 
"possible loss of precision" compiler errors we saw in the assignments 
section? Those happened when we tried to put a larger thing (say, a long) into a 
smaller container (like a short). The large-value-into-small-container conversion 
is referred to as narrowing and requires an explicit cast, where you tell the compiler 
that you're aware of the danger and accept full responsibility. First we'll look at an 
implicit cast:
int a = 100;
long b = a; // Implicit cast, an int value always fits in a long
An explicit casts looks like this:
float a = 100.001f;
int b = (int)a; // Explicit cast, the float could lose info
Integer values may be assigned to a double variable without explicit casting, 
because any integer value can fit in a 64-bit double. The following line 
demonstrates this:
Assignment Operators (Exam Objectives 1.3 and 7.6) 193
194 Chapter 3:  Assignments
double d = 100L; // Implicit cast
In the preceding statement, a double is initialized with a long value (as denoted by 
the L after the numeric value). No cast is needed in this case because a double can 
hold every piece of information that a long can store. If, however, we want to assign 
a double value to an integer type, we're attempting a narrowing conversion and the 
compiler knows it:
class Casting {
  public static void main(String [] args) {
    int x = 3957.229; // illegal
  }
}
If we try to compile the preceding code, we get an error something like:
%javac Casting.java
Casting.java:3: Incompatible type for declaration. Explicit cast 
needed to convert double to int. int x = 3957.229; // illegal
1 error
In the preceding code, a floating-point value is being assigned to an integer variable. Because an integer is not capable of storing decimal places, an error occurs. To make 
this work, we'll cast the floating-point number into an int:
class Casting {
  public static void main(String [] args) {
    int x = (int)3957.229; // legal cast
    System.out.println("int x = " + x);
  }
}
When you cast a floating-point number to an integer type, the value loses all the 
digits after the decimal. The preceding code will produce the following output:
int x = 3957
We can also cast a larger number type, such as a long, into a smaller number type, 
such as a byte. Look at the following:
Assignment Operators (Exam Objectives 1.3 and 7.6) 195
class Casting {
  public static void main(String [] args) {
    long l = 56L;
    byte b = (byte)l;
    System.out.println("The byte is " + b);
  }
}
The preceding code will compile and run fine. But what happens if the long value is 
larger than 127 (the largest number a byte can store)? Let's modify the code:
class Casting {
  public static void main(String [] args) {
    long l = 130L;
    byte b = (byte)l;
    System.out.println("The byte is " + b);
  }
}
The code compiles fine, and when we run it we get the following:
%java Casting
The byte is -126
You don't get a runtime error, even when the value being narrowed is too large 
for the type. The bits to the left of the lower 8 just…go away. If the leftmost bit (the 
sign bit) in the byte (or any integer primitive) now happens to be a 1, the primitive 
will have a negative value. EXERCISE 3-1
Casting Primitives
Create a float number type of any value, and assign it to a short using casting. 1. Declare a float variable: float f = 234.56F;
  2. Assign the float to a short: short s = (short)f;
196 Chapter 3:  Assignments
Assigning Floating-Point Numbers    Floating-point numbers have 
slightly different assignment behavior than integer types. First, you must know that 
every floating-point literal is implicitly a double (64 bits), not a float. So the 
literal 32.3, for example, is considered a double. If you try to assign a double to a 
float, the compiler knows you don't have enough room in a 32-bit float container 
to hold the precision of a 64-bit double, and it lets you know. The following code 
looks good, but won't compile:
float f = 32.3;
You can see that 32.3 should fit just fine into a float-sized variable, but the 
compiler won't allow it. In order to assign a floating-point literal to a float 
variable, you must either cast the value or append an f to the end of the literal. The 
following assignments will compile:
float f = (float) 32.3;
float g = 32.3f; 
float h = 32.3F;
Assigning a Literal That Is T oo Large for the Variable   We'll also get 
a compiler error if we try to assign a literal value that the compiler knows is too big 
to fit into the variable. byte a = 128; // byte can only hold up to 127
The preceding code gives us an error something like
TestBytes.java:5: possible loss of precision
found   : int
required: byte 
byte a = 128;
We can fix it with a cast:
byte a = (byte) 128;
But then what's the result? When you narrow a primitive, Java simply truncates 
the higher-order bits that won't fit. In other words, it loses all the bits to the left of 
the bits you're narrowing to. Let's take a look at what happens in the preceding code. There, 128 is the bit 
pattern 10000000. It takes a full 8 bits to represent 128. But because the literal 128 
is an int, we actually get 32 bits, with the 128 living in the right-most (lower-order) 
8 bits. So a literal 128 is actually
00000000000000000000000010000000
Take our word for it; there are 32 bits there. To narrow the 32 bits representing 128, Java simply lops off the leftmost (higher-
order) 24 bits. We're left with just the 10000000. But remember that a byte is 
signed, with the leftmost bit representing the sign (and not part of the value of the 
variable). So we end up with a negative number (the 1 that used to represent 128 
now represents the negative sign bit). Remember, to find out the value of a negative 
number using two's complement notation, you flip all of the bits and then add 1. Flipping the 8 bits gives us 01111111, and adding 1 to that gives us 10000000, or 
back to 128! And when we apply the sign bit, we end up with –128. You must use an explicit cast to assign 128 to a byte, and the assignment leaves 
you with the value –128. A cast is nothing more than your way of saying to the 
compiler, "Trust me. I'm a professional. I take full responsibility for anything weird 
that happens when those top bits are chopped off."
That brings us to the compound assignment operators. The following will compile,
byte b = 3;
b += 7;        // No problem - adds 7 to b (result is 10)
and is equivalent to
byte b = 3;
b = (byte) (b + 7);  // Won't compile without the 
                     // cast, since b + 7 results in an int
The compound assignment operator += lets you add to the value of b, without 
putting in an explicit cast. In fact, +=, -=, *=, and /= will all put in an implicit cast. Assignment Operators (Exam Objectives 1.3 and 7.6) 197
Assigning One Primitive Variable to Another Primitive Variable
When you assign one primitive variable to another, the contents of the right-hand 
variable are copied. For example,
int a = 6;
int b = a;
This code can be read as, "Assign the bit pattern for the number 6 to the int 
variable a. Then copy the bit pattern in a, and place the copy into variable b."
So, both variables now hold a bit pattern for 6, but the two variables have no 
other relationship. We used the variable a only to copy its contents. At this point, 
a and b have identical contents (in other words, identical values), but if we change 
the contents of either a or b, the other variable won't be affected. Take a look at the following example:
class ValueTest {
   public static void main (String [] args) {
      int a = 10;  // Assign a value to a
      System.out.println("a = " + a);
      int b = a;
      b = 30;
      System.out.println("a = " + a + " after change to b");
   }
}
The output from this program is
%java ValueTest
a = 10
a = 10 after change to b
Notice the value of a stayed at 10. The key point to remember is that even after 
you assign a to b, a and b are not referring to the same place in memory. The a and b 
variables do not share a single value; they have identical copies. Reference Variable Assignments
You can assign a newly created object to an object reference variable as follows:
Button b = new Button(); 
198 Chapter 3:  Assignments
The preceding line does three key things:
■ Makes a reference variable named b, of type Button
■ Creates a new Button object on the heap
■ Assigns the newly created Button object to the reference variable b
You can also assign null to an object reference variable, which simply means the 
variable is not referring to any object:
Button c = null;
The preceding line creates space for the Button reference variable (the bit holder 
for a reference value), but doesn't create an actual Button object. As we discussed in the last chapter, you can also use a reference variable to refer 
to any object that is a subclass of the declared reference variable type, as follows:
public class Foo {
   public void doFooStuff() { }
}
public class Bar extends Foo { 
   public void doBarStuff() { }
}
class Test {
   public static void main (String [] args) {
      Foo reallyABar = new Bar();  // Legal because Bar is a 
                                   // subclass of Foo
      Bar reallyAFoo = new Foo();  // Illegal! Foo is not a 
                                   // subclass of Bar
   }
}
The rule is that you can assign a subclass of the declared type, but not a superclass 
of the declared type. Remember, a Bar object is guaranteed to be able to do anything 
a Foo can do, so anyone with a Foo reference can invoke Foo methods even though 
the object is actually a Bar. In the preceding code, we see that Foo has a method doFooStuff() that 
someone with a Foo reference might try to invoke. If the object referenced by 
the Foo variable is really a Foo, no problem. But it's also no problem if the object 
is a Bar, since Bar inherited the doFooStuff() method. You can't make it work 
Assignment Operators (Exam Objectives 1.3 and 7.6) 199
in reverse, however. If somebody has a Bar reference, they're going to invoke 
doBarStuff(), but if the object is a Foo, it won't know how to respond. Variable Scope
Once you've declared and initialized a variable, a natural question is "How long will 
this variable be around?" This is a question regarding the scope of variables. And not 
only is scope an important thing to understand in general, it also plays a big part in 
the exam. Let's start by looking at a class file: 
class Layout {                      // class
  static int s = 343;       // static variable
  int x;                            // instance variable
  { x = 7; int x2 = 5; }            // initialization block
  Layout() { x += 8; int x3 = 6;}   // constructor
  void doStuff() {                  // method
    int y = 0;                      // local variable
    for(int z = 0; z < 4; z++) {    // 'for' code block
      y += z + x;
    } 
  }
}
As with variables in all Java programs, the variables in this program (s, x, x2, x3, 
y, and z) all have a scope:
■ s is a static variable. ■ x is an instance variable. ■ y is a local variable (sometimes called a "method local" variable). ■ z is a block variable. ■ x2 is an init block variable, a flavor of local variable. ■ x3 is a constructor variable, a flavor of local variable. For the purposes of discussing the scope of variables, we can say that there are four 
basic scopes:
200 Chapter 3:  Assignments
■ Static variables have the longest scope; they are created when the class is 
loaded, and they survive as long as the class stays loaded in the Java Virtual 
Machine (JVM). ■ Instance variables are the next most long-lived; they are created when a new 
instance is created, and they live until the instance is removed. ■ Local variables are next; they live as long as their method remains on the 
stack. As we'll soon see, however, local variables can be alive, and still be 
"out of scope". ■ Block variables live only as long as the code block is executing. Scoping errors come in many sizes and shapes. One common mistake happens 
when a variable is shadowed and two scopes overlap. We'll take a detailed look at 
shadowing in a few pages. The most common reason for scoping errors is when 
you attempt to access a variable that is not in scope. Let's look at three common 
examples of this type of error:
■ Attempting to access an instance variable from a static context (typically 
from main() ). class ScopeErrors {
     int x = 5;
     public static void main(String[] args) {
       x++;   // won't compile, x is an 'instance' variable
     }
   }
■ Attempting to access a local variable from a nested method. When a method, say go(), invokes another method, say go2(), go2() won't 
have access to go()'s local variables. While go2() is executing, go()'s local 
variables are still alive, but they are out of scope. When go2() completes, it 
is removed from the stack, and go() resumes execution. At this point, all of 
go()'s previously declared variables are back in scope. For example:
   class ScopeErrors {
     public static void main(String [] args) {
       ScopeErrors s = new ScopeErrors();
       s.go();
     }
     void go() {
       int y = 5;
Assignment Operators (Exam Objectives 1.3 and 7.6) 201
       go2();
       y++;        // once go2() completes, y is back in scope
     }
     void go2() {
       y++;        // won't compile, y is local to go()
     }
   }
■ Attempting to use a block variable after the code block has completed. It's very common to declare and use a variable within a code block, but be 
careful not to try to use the variable once the block has completed:
   void go3() {
     for(int z = 0; z < 5; z++) {
       boolean test = false;
       if(z == 3) {
         test = true;
         break;
       }
     }
     System.out.print(test);   // 'test' is an ex-variable, 
                               // it has ceased to be... }
In the last two examples, the compiler will say something like this:
  cannot find symbol
This is the compiler's way of saying, "That variable you just tried to use? Well, it 
might have been valid in the distant past (like one line of code ago), but this is 
Internet time baby, I have no memory of such a variable."
202 Chapter 3:  Assignments
Pay extra attention to code block scoping errors. You might see them in 
switches, try-catches, for, do, and while loops. Using a Variable or Array Element That Is Uninitialized 
and Unassigned 
Java gives us the option of initializing a declared variable or leaving it 
uninitialized. When we attempt to use the uninitialized variable, we can get 
different behavior depending on what type of variable or array we are dealing 
with (primitives or objects). The behavior also depends on the level (scope) at 
which we are declaring our variable. An instance variable is declared within the 
class but outside any method or constructor, whereas a local variable is declared 
within a method (or in the argument list of the method). Local variables are sometimes called stack, temporary, automatic, or method 
variables, but the rules for these variables are the same regardless of what you 
call them. Although you can leave a local variable uninitialized, the compiler 
complains if you try to use a local variable before initializing it with a value, as 
we shall see. Primitive and Object T ype Instance Variables
Instance variables (also called member variables) are variables defined at the 
class level. That means the variable declaration is not made within a method, 
constructor, or any other initializer block. Instance variables are initialized to a 
default value each time a new instance is created, although they may be given 
an explicit value after the object's super-constructors have completed. Table 3-1 
lists the default values for primitive and object types. Using a Variable or Array Element That Is Uninitialized and Unassigned (Exam Objectives 1.3 & 7.6) 203
 
Variable T ype Default Value
Object reference null  (not referencing any object)
byte, short, int, long 0
float, double 0.0
boolean false
char '\u0000'
 TABLE 3-1    Default Values for Primitives and Reference Types
Primitive Instance Variables
In the following example, the integer year is defined as a class member because it is 
within the initial curly braces of the class and not within a method's curly braces:
public class BirthDate {
  int year;                                 // Instance variable
  public static void main(String [] args) {
    BirthDate bd = new BirthDate();
    bd.showYear();
  }
  public void showYear() {
    System.out.println("The year is " + year);
  }
}
When the program is started, it gives the variable year a value of zero, the default 
value for primitive number instance variables. It's a good idea to initialize all your variables, even if you're assigning them 
with the default value. Your code will be easier to read; programmers who 
have to maintain your code (after you win the lottery and move to Tahiti) will 
be grateful. Object Reference Instance Variables
When compared with uninitialized primitive variables, object references that aren't 
initialized are a completely different story. Let's look at the following code:
public class Book {
  private String title;          // instance reference variable
  public String getTitle() {
    return title;
  }
  public static void main(String [] args) {
    Book b = new Book();
    System.out.println("The title is " + b.getTitle());
  }
}
204 Chapter 3:  Assignments
Using a Variable or Array Element That Is Uninitialized and Unassigned (Exam Objectives 1.3 & 7.6) 205
This code will compile fine. When we run it, the output is
The title is null
The title variable has not been explicitly initialized with a String assignment, 
so the instance variable value is null. Remember that null is not the same as an 
empty String (""). A null value means the reference variable is not referring to any 
object on the heap. The following modification to the Book code runs into trouble:
public class Book {
  private String title;          // instance reference variable
  public String getTitle() {
    return title;
  }
  public static void main(String [] args) {
    Book b = new Book();
    String s = b.getTitle();     // Compiles and runs
    String t = s.toLowerCase();  // Runtime Exception! }
}
When we try to run the Book class, the JVM will produce something like this:
Exception in thread "main" java.lang.NullPointerException
     at Book.main(Book.java:9)
We get this error because the reference variable title does not point (refer) to 
an object. We can check to see whether an object has been instantiated by using the 
keyword null, as the following revised code shows:
public class Book {
  private String title;          // instance reference variable
  public String getTitle() {
    return title;
  }
  public static void main(String [] args) {
    Book b = new Book();
    String s = b.getTitle(); // Compiles and runs
    if (s != null) {
      String t = s.toLowerCase();
    }
  }
}
The preceding code checks to make sure the object referenced by the variable s is 
not null before trying to use it. Watch out for scenarios on the exam where you 
might have to trace back through the code to find out whether an object reference 
will have a value of null. In the preceding code, for example, you look at the 
instance variable declaration for title, see that there's no explicit initialization, 
recognize that the title variable will be given the default value of null, and then 
realize that the variable s will also have a value of null. Remember, the value of s is 
a copy of the value of title (as returned by the getTitle() method), so if title is a 
null reference, s will be too. Array Instance Variables
Later in this chapter we'll be taking a very detailed look at declaring, constructing, 
and initializing arrays and multidimensional arrays. For now, we're just going to look 
at the rule for an array element's default values. An array is an object; thus, an array instance variable that's declared but not 
explicitly initialized will have a value of null, just as any other object reference 
instance variable. But…if the array is initialized, what happens to the elements 
contained in the array? All array elements are given their default values—the same 
default values that elements of that type get when they're instance variables. The bottom line: Array elements are always, always, always given default values, 
regardless of where the array itself is declared or instantiated. If we initialize an array, object reference elements will equal null if they are not 
initialized individually with values. If primitives are contained in an array, they will 
be given their respective default values. For example, in the following code, the 
array year will contain 100 integers that all equal zero by default:
public class BirthDays {
  static int [] year = new int[100];
  public static void main(String [] args) {
    for(int i=0;i<100;i++)
      System.out.println("year[" + i + "] = " + year[i]);
  }
}
When the preceding code runs, the output indicates that all 100 integers in the 
array equal zero. 206 Chapter 3:  Assignments
Local (Stack,  Automatic) Primitives and Objects (Exam Objectives 1.3 and 7.6) 207
Local (Stack,  Automatic) Primitives and Objects 
Local variables are defined within a method, and they include a method's parameters. Local Primitives
In the following time travel simulator, the integer year is defined as an automatic 
variable because it is within the curly braces of a method. public class TimeTravel {
  public static void main(String [] args) {
    int year = 2050;
    System.out.println("The year is " + year);
  }
}
Local variables, including primitives, always, always, always must be initialized 
before you attempt to use them (though not necessarily on the same line of code). Java does not give local variables a default value; you must explicitly initialize them 
with a value, as in the preceding example. If you try to use an uninitialized primitive 
in your code, you'll get a compiler error:
public class TimeTravel {
  public static void main(String [] args) {
    int year; // Local variable (declared but not initialized)
    System.out.println("The year is " + year); // Compiler error
  }
}
“Automatic” is just another term for “local variable.” It does not mean 
the automatic variable is automatically assigned a value! The opposite is true. An 
automatic variable must be assigned a value in the code, or the compiler will complain. Compiling produces output something like this:
%javac TimeTravel.java
TimeTravel.java:4: Variable year may not have been initialized. System.out.println("The year is " + year);
1 error
To correct our code, we must give the integer year a value. In this updated 
example, we declare it on a separate line, which is perfectly valid:
public class TimeTravel {
  public static void main(String [] args) {
    int year;      // Declared but not initialized
    int day;       // Declared but not initialized
    System.out.println("You step into the portal.");
    year = 2050;   // Initialize (assign an explicit value)
    System.out.println("Welcome to the year " + year);
  }
}
Notice in the preceding example we declared an integer called day that never 
gets initialized, yet the code compiles and runs fine. Legally, you can declare a local 
variable without initializing it as long as you don't use the variable, but let's face it, if 
you declared it, you probably had a reason (although we have heard of programmers 
declaring random local variables just for sport, to see if they can figure out how and 
why they're being used). The compiler can't always tell whether a local variable has been initialized 
before use. For example, if you initialize within a logically conditional block 
(in other words, a code block that may not run, such as an if block or for 
loop without a literal value of true or false in the test), the compiler knows 
that the initialization might not happen, and can produce an error. The 
following code upsets the compiler:
public class TestLocal {
  public static void main(String [] args) {
    int x;
    if (args[0] != null) { // assume you know this will 
                           // always be true
208 Chapter 3:  Assignments
      x = 7;               // compiler can't tell that this 
                           // statement will run
    }
    int y = x;             // the compiler will choke here
  }
}
The compiler will produce an error something like this:
TestLocal.java:9: variable x might not have been initialized
Because of the compiler-can't-tell-for-certain problem, you will sometimes 
need to initialize your variable outside the conditional block, just to make the 
compiler happy. You know why that's important if you've seen the bumper 
sticker, "When the compiler's not happy, ain't nobody happy."
Local Object References
Objects references, too, behave differently when declared within a method rather 
than as instance variables. With instance variable object references, you can get 
away with leaving an object reference uninitialized, as long as the code checks to 
make sure the reference isn't null before using it. Remember, to the compiler, null 
is a value. You can't use the dot operator on a null reference, because there is no 
object at the other end of it, but a null reference is not the same as an uninitialized 
reference. Locally declared references can't get away with checking for null before 
use, unless you explicitly initialize the local variable to null. The compiler will 
complain about the following code:
import java.util.Date;
public class TimeTravel {
  public static void main(String [] args) {
    Date date;
    if (date == null)
      System.out.println("date is null");
  }
}
Compiling the code results in an error similar to the following:
Local (Stack, Automatic) Primitives and Objects (Exam Objectives 1.3 & 7.6) 209
%javac TimeTravel.java
TimeTravel.java:5: Variable date may not have been initialized. if (date == null)
1 error
Instance variable references are always given a default value of null, until 
explicitly initialized to something else. But local references are not given a default 
value; in other words, they aren't null. If you don't initialize a local reference variable, 
then by default, its value is…well that's the whole point—it doesn't have any value 
at all! So we'll make this simple: Just set the darn thing to null explicitly, until 
you're ready to initialize it to something else. The following local variable will 
compile properly:
Date date = null; // Explicitly set the local reference 
                  // variable to null
Local Arrays
Just like any other object reference, array references declared within a method must 
be assigned a value before use. That just means you must declare and construct the 
array. You do not, however, need to explicitly initialize the elements of an array. We've said it before, but it's important enough to repeat: array elements are given 
their default values (0, false, null, '\u0000', etc.) regardless of whether the array 
is declared as an instance or local variable. The array object itself, however, will not 
be initialized if it's declared locally. In other words, you must explicitly initialize an 
array reference if it's declared and used within a method, but at the moment you 
construct an array object, all of its elements are assigned their default values. Assigning One Reference Variable to Another
With primitive variables, an assignment of one variable to another means the 
contents (bit pattern) of one variable are copied into another. Object reference 
variables work exactly the same way. The contents of a reference variable are a bit 
pattern, so if you assign reference variable a to reference variable b, the bit pattern 
in a is copied and the new copy is placed into b. (Some people have created a game 
around counting how many times we use the word copy in this chapter…this copy 
concept is a biggie!) If we assign an existing instance of an object to a new reference 
variable, then two reference variables will hold the same bit pattern—a bit pattern 
referring to a specific object on the heap. Look at the following code:
210 Chapter 3:  Assignments
import java.awt.Dimension;
class ReferenceTest {
  public static void main (String [] args) {
    Dimension a = new Dimension(5,10);
    System.out.println("a.height = " + a.height);
    Dimension b = a;
    b.height = 30;
    System.out.println("a.height = " + a.height + 
                       " after change to b");
  }
}
In the preceding example, a Dimension object a is declared and initialized with 
a width of 5 and a height of 10. Next, Dimension b is declared, and assigned the 
value of a. At this point, both variables (a and b) hold identical values, because 
the contents of a were copied into b. There is still only one Dimension object—the 
one that both a and b refer to. Finally, the height property is changed using the b 
reference. Now think for a minute: is this going to change the height property of a as 
well? Let's see what the output will be:
%java ReferenceTest
a.height = 10
a.height = 30 after change to b
From this output, we can conclude that both variables refer to the same instance 
of the Dimension object. When we made a change to b, the height property was also 
changed for a. One exception to the way object references are assigned is String. In Java, String 
objects are given special treatment. For one thing, String objects are immutable; you 
can't change the value of a String object (lots more on this concept in Chapter 6). But it sure looks as though you can. Examine the following code:
class StringTest {
  public static void main(String [] args) {
    String x = "Java";  // Assign a value to x
    String y = x;       // Now y and x refer to the same 
                        // String object
    System.out.println("y string = " + y);
    x = x + " Bean";    // Now modify the object using 
                        // the x reference
Local (Stack, Automatic) Primitives and Objects (Exam Objectives 1.3 and 7.6) 211
    System.out.println("y string = " + y);
  }
}
You might think String y will contain the characters Java Bean after the 
variable x is changed, because Strings are objects. Let's see what the output is:
%java StringTest
y string = Java
y string = Java
As you can see, even though y is a reference variable to the same object that x 
refers to, when we change x, it doesn't change y! For any other object type, where 
two references refer to the same object, if either reference is used to modify the 
object, both references will see the change because there is still only a single object. But any time we make any changes at all to a String, the VM will update the reference 
variable to refer to a different object. The different object might be a new object, or it 
might not, but it will definitely be a different object. The reason we can't say for sure 
whether a new object is created is because of the String constant pool, which we'll 
cover in Chapter 6. You need to understand what happens when you use a String reference variable to 
modify a string:
■  A new string is created (or a matching String is found in the String pool), 
leaving the original String object untouched. ■ The reference used to modify the String (or rather, make a new String by 
modifying a copy of the original) is then assigned the brand new String object. So when you say
1. String s = "Fred";
2. String t = s;     // Now t and s refer to the same 
                     // String object
3. t.toUpperCase();  // Invoke a String method that changes 
                     // the String 
you haven't changed the original String object created on line 1. When line 2 
completes, both t and s reference the same String object. But when line 3 runs, 
rather than modifying the object referred to by t (which is the one and only String 
212 Chapter 3:  Assignments
object up to this point), a brand new String object is created. And then abandoned. Because the new String isn't assigned to a String variable, the newly created String 
(which holds the string "FRED") is toast. So while two String objects were created 
in the preceding code, only one is actually referenced, and both t and s refer to 
it. The behavior of Strings is extremely important in the exam, so we'll cover it in 
much more detail in Chapter 6. CERTIFICATION OBJECTIVE
Passing Variables into Methods (Objective 7.3)
7.3 Determine the effect upon object references and primitive values when they are passed 
into methods that perform assignments or other modifying operations on the parameters. Methods can be declared to take primitives and/or object references. You need to 
know how (or if) the caller's variable can be affected by the called method. The 
difference between object reference and primitive variables, when passed into 
methods, is huge and important. To understand this section, you'll need to be 
comfortable with the assignments section covered in the first part of this chapter. Passing Object Reference Variables
When you pass an object variable into a method, you must keep in mind that you're 
passing the object reference, and not the actual object itself. Remember that a 
reference variable holds bits that represent (to the underlying VM) a way to get to 
a specific object in memory (on the heap). More importantly, you must remember 
that you aren't even passing the actual reference variable, but rather a copy of the 
reference variable. A copy of a variable means you get a copy of the bits in that 
variable, so when you pass a reference variable, you're passing a copy of the bits 
representing how to get to a specific object. In other words, both the caller and the 
called method will now have identical copies of the reference, and thus both will 
refer to the same exact (not a copy) object on the heap. For this example, we'll use the Dimension class from the java.awt package:
 1. import java.awt.Dimension;
 2. class ReferenceTest {
Passing Object Reference Variables (Exam Objective 7.3) 213
 3. public static void main (String [] args) {
 4. Dimension d = new Dimension(5,10);
 5. ReferenceTest rt = new ReferenceTest();
 6. System.out.println("Before modify() d.height = " 
                           + d.height);
 7. rt.modify(d);
 8. System.out.println("After modify() d.height = " 
                           + d.height);
 9. }
10. void modify(Dimension dim) {
11. dim.height = dim.height + 1;
12. System.out.println("dim = " + dim.height);
13. }
14. }
When we run this class, we can see that the modify() method was indeed able to 
modify the original (and only) Dimension object created on line 4. C:\Java Projects\Reference>java ReferenceTest
Before modify() d.height = 10
dim = 11
After modify() d.height = 11
Notice when the Dimension object on line 4 is passed to the modify() method, 
any changes to the object that occur inside the method are being made to the object 
whose reference was passed. In the preceding example, reference variables d and dim 
both point to the same object. Does Java Use Pass-By-Value Semantics? If Java passes objects by passing the reference variable instead, does that mean Java 
uses pass-by-reference for objects? Not exactly, although you'll often hear and read 
that it does. Java is actually pass-by-value for all variables running within a single 
VM. Pass-by-value means pass-by-variable-value. And that means, pass-by-copy-of-
the-variable! (There's that word copy again!)
It makes no difference if you're passing primitive or reference variables, you are 
always passing a copy of the bits in the variable. So for a primitive variable, you're 
passing a copy of the bits representing the value. For example, if you pass an int 
variable with the value of 3, you're passing a copy of the bits representing 3. The 
called method then gets its own copy of the value, to do with it what it likes. 214 Chapter 3:  Assignments
And if you're passing an object reference variable, you're passing a copy of the 
bits representing the reference to an object. The called method then gets its own 
copy of the reference variable, to do with it what it likes. But because two identical 
reference variables refer to the exact same object, if the called method modifies the 
object (by invoking setter methods, for example), the caller will see that the object 
the caller's original variable refers to has also been changed. In the next section, 
we'll look at how the picture changes when we're talking about primitives. The bottom line on pass-by-value: the called method can't change the caller's 
variable, although for object reference variables, the called method can change the 
object the variable referred to. What's the difference between changing the variable 
and changing the object? For object references, it means the called method can't 
reassign the caller's original reference variable and make it refer to a different object, 
or null. For example, in the following code fragment,
void bar() {
   Foo f = new Foo();
   doStuff(f);
}
void doStuff(Foo g) {
   g.setName("Boo");
   g = new Foo();
}
reassigning g does not reassign f! At the end of the bar() method, two Foo objects 
have been created, one referenced by the local variable f and one referenced by 
the local (argument) variable g. Because the doStuff() method has a copy of the 
reference variable, it has a way to get to the original Foo object, for instance to call 
the setName() method. But, the doStuff() method does not have a way to get to 
the f reference variable. So doStuff() can change values within the object f refers 
to, but doStuff() can't change the actual contents (bit pattern) of f. In other 
words, doStuff() can change the state of the object that f refers to, but it can't 
make f refer to a different object! Passing Primitive Variables
Let's look at what happens when a primitive variable is passed to a method:
class ReferenceTest {
  public static void main (String [] args) {
Passing Primitive Variables (Exam Objective 7.3) 215
    int a = 1;
    ReferenceTest rt = new ReferenceTest();
    System.out.println("Before modify() a = " + a);
    rt.modify(a);
    System.out.println("After modify() a = " + a);
  }
  void modify(int number) {
    number = number + 1;
    System.out.println("number = " + number);
  }
}
In this simple program, the variable a is passed to a method called modify(), 
which increments the variable by 1. The resulting output looks like this:
Before modify() a = 1
number = 2
After modify() a = 1
Notice that a did not change after it was passed to the method. Remember, it was 
a copy of a that was passed to the method. When a primitive variable is passed to a 
method, it is passed by value, which means pass-by-copy-of-the-bits-in-the-variable. 216 Chapter 3:  Assignments
The Shadowy World of Variables
Just when you think you’ve got it all figured 
out, you see a piece of code with variables 
not behaving the way you think they should. You might have stumbled into code with a 
shadowed variable. You can shadow a variable 
in several ways. We’ll look at the one most 
likely to trip you up: hiding an instance 
variable by shadowing it with a local variable. Shadowing involves redeclaring a variable 
that’s already been declared somewhere else. The effect of shadowing is to hide the 
previously declared variable in such a way 
that it may look as though you’re using the 
hidden variable, but you’re actually using the 
shadowing variable. You might find reasons to 
shadow a variable intentionally, but typically 
it happens by accident and causes hard-to-
find bugs. On the exam, you can expect to see 
questions where shadowing plays a role. FROM THE CLASSROOM
Passing Primitive Variables (Exam Objective 7.3) 217
FROM THE CLASSROOM
    You can shadow an instance variable by declaring a local variable of the same name, either 
directly or as part of an argument:
  class Foo {
    static int size = 7;
    static void changeIt(int size) {
      size = size + 200; 
      System.out.println("size in changeIt is " + size);
    }
    public static void main (String [] args) {
      Foo f = new Foo();
      System.out.println("size = " + size);
      changeIt(size);
      System.out.println("size after changeIt is " + size);
    }
  }
    The preceding code appears to change the size instance variable in the changeIt() method, 
but because changeIt() has a parameter named size, the local size variable is modified while 
the instance variable size is untouched. Running class Foo prints
  %java Foo
  size = 7
  size in changeIt is 207
  size after changeIt is 7
    Things become more interesting when the shadowed variable is an object reference, rather than 
a primitive:
  class Bar {
    int barNum = 28; 
  }  
218 Chapter 3:  Assignments
  class Foo { 
    Bar myBar = new Bar();
    void changeIt(Bar myBar) {
      myBar.barNum = 99;
      System.out.println("myBar.barNum in changeIt is " + myBar.barNum);
      myBar = new Bar();
      myBar.barNum = 420;
      System.out.println("myBar.barNum in changeIt is now " + myBar.barNum);
    }
    public static void main (String [] args) {
      Foo f = new Foo();
      System.out.println("f.myBar.barNum is " + f.myBar.barNum);
      f.changeIt(f.myBar);
      System.out.println("f.myBar.barNum after changeIt is " 
                         + f.myBar.barNum);
    }
  }
    The preceding code prints out this:
  f.myBar.barNum is 28
  myBar.barNum in changeIt is 99
  myBar.barNum in changeIt is now 420
  f.myBar.barNum after changeIt is 99
    You can see that the shadowing variable (the local parameter myBar in changeIt()) can still 
affect the myBar instance variable, because the myBar parameter receives a reference to the same 
Bar object. But when the local myBar is reassigned a new Bar object, which we then modify by 
changing its barNum value, Foo’s original myBar instance variable is untouched. FROM THE CLASSROOM
CERTIFICATION OBJECTIVE
Array Declaration, Construction, and Initialization
(Exam Objective 1.3)
1.3 Develop code that declares, initializes, and uses primitives, arrays, enums, and 
objects as static, instance, and local variables. Also, use legal identifiers for variable names. Arrays are objects in Java that store multiple variables of the same type. Arrays can 
hold either primitives or object references, but the array itself will always be an 
object on the heap, even if the array is declared to hold primitive elements. In other 
words, there is no such thing as a primitive array, but you can make an array 
of primitives. For this objective, you need to know three things: 
■ How to make an array reference variable (declare) 
■ How to make an array object (construct) 
■ How to populate the array with elements (initialize) 
There are several different ways to do each of those, and you need to know about 
all of them for the exam. Arrays are efficient, but most of the time you'll want to use one of the 
Collection types from java.util (including HashMap, ArrayList, TreeSet). Collection classes offer more flexible ways to access an object (for insertion, 
deletion, and so on) and unlike arrays, can expand or contract dynamically 
as you add or remove elements (they're really managed arrays, since they use 
arrays behind the scenes). There's a Collection type for a wide range of needs. Do you need a fast sort? A group of objects with no duplicates? A way to 
access a name/value pair? A linked list? Chapter 7 covers them in more detail. Declaring an Array
Arrays are declared by stating the type of element the array will hold, which can 
be an object or a primitive, followed by square brackets to the left or right of 
the identifier. Declaring an Array (Exam Objective 1.3) 219
Declaring an array of primitives:
int[] key;  // brackets before name (recommended)
int key []; // brackets after name (legal but less readable)
            // spaces between the name and [] legal, but bad
Declaring an array of object references:
Thread[] threads;  // Recommended
Thread threads[];  // Legal but less readable
When declaring an array reference, you should always put the array brackets 
immediately after the declared type, rather than after the identifier (variable 
name). That way, anyone reading the code can easily tell that, for example, key is a 
reference to an int array object, and not an int primitive. We can also declare multidimensional arrays, which are in fact arrays of arrays. This can be done in the following manner:
String[][][] occupantName;  // recommended
String[] ManagerName [];    // yucky, but legal
The first example is a three-dimensional array (an array of arrays of arrays) and 
the second is a two-dimensional array. Notice in the second example we have one 
square bracket before the variable name and one after. This is perfectly legal to the 
compiler, proving once again that just because it's legal doesn't mean it's right. It is never legal to include the size of the array in your declaration. Yes, we know 
you can do that in some other languages, which is why you might see a question or 
two that include code similar to the following: 
int[5] scores;
The preceding code won't make it past the compiler. Remember, the JVM 
doesn't allocate space until you actually instantiate the array object. That's when size 
matters. Constructing an Array
Constructing an array means creating the array object on the heap (where all objects 
live)—i.e., doing a new on the array type. To create an array object, Java must know 
220 Chapter 3:  Assignments
how much space to allocate on the heap, so you must specify the size of the array at 
creation time. The size of the array is the number of elements the array will hold. Constructing One-Dimensional Arrays
The most straightforward way to construct an array is to use the keyword new 
followed by the array type, with a bracket specifying how many elements of that type 
the array will hold. The following is an example of constructing an array of type int:
int[] testScores;        // Declares the array of ints
testScores = new int[4]; // constructs an array and assigns it 
                         // to the testScores variable
The preceding code puts one new object on the heap—an array object holding four 
elements—with each element containing an int with a default value of 0. Think of 
this code as saying to the compiler, "Create an array object that will hold four ints, 
and assign it to the reference variable named testScores. Also, go ahead and set 
each int element to zero. Thanks." (The compiler appreciates good manners.) 
Figure 3-2 shows the testScores array on the heap, after construction. You can also declare and construct an array in one statement as follows:
int[] testScores = new int[4];
This single statement produces the same result as the two previous statements. Arrays of object types can be constructed in the same way:
Thread[] threads = new Thread[5];
Constructing an Array (Exam Objective 1.3) 221
 FIGURE 3-2 
A one-dimensional 
array on the Heap
testScores
0000
0123
int[ ]array
reference
variable
int[ ]array object
The heap
Values
Indices
222 Chapter 3:  Assignments
Remember that—despite how the code appears—the Thread constructor is not 
being invoked. We're not creating a Thread instance, but rather a single Thread 
array object. After the preceding statement, there are still no actual Thread objects! Remember, arrays must always be given a size at the time they are constructed. The JVM needs the size to allocate the appropriate space on the heap for the new 
array object. It is never legal, for example, to do the following:
int[] carList = new int[]; // Will not compile; needs a size
So don't do it, and if you see it on the test, run screaming toward the nearest 
answer marked "Compilation fails."
In addition to being constructed with new, arrays can also be created using a kind 
of syntax shorthand that creates the array while simultaneously initializing the array 
elements to values supplied in code (as opposed to default values). We'll look at 
that in the next section. For now, understand that because of these syntax shortcuts, 
objects can still be created even without you ever using or seeing the keyword new. Think carefully about how many objects are on the heap after a code 
statement or block executes. The exam will expect you to know, for example, that the 
preceding code produces just one object (the array assigned to the reference variable 
named threads). The single object referenced by threads holds ﬁ ve Thread reference 
variables, but no Thread objects have been created or assigned to those references. You may see the words "construct", "create", and "instantiate" used 
interchangeably. They all mean, “An object is built on the heap.”  This also implies that 
the object’s constructor runs, as a result of the construct/create/instantiate code. You can 
say with certainty, for example, that any code that uses the keyword new, will (if it runs 
successfully) cause the class constructor and all superclass constructors to run. int[ ]array object
int[ ][ ] (2-D array)
reference variable
int[ ][ ] myArray = new int[3][ ];
myArray[0] = new int[2];
myArray[0][0] = 6;
myArray[0][1] = 7;
myArray[1] = new int[3];
myArray[1][0] = 9;
myArray[1][1] = 8;
myArray[1][2] = 5;
Picture demonstrates the result of the following code:
myArray
null
2-D int[ ][ ]array object
int[ ]array object
myArray[0]
myArray[1]
The heap
Constructing Multidimensional Arrays
Multidimensional arrays, remember, are simply arrays of arrays. So a two-
dimensional array of type int is really an object of type int array (int []), with 
each element in that array holding a reference to another int array. The second 
dimension holds the actual int primitives. The following code declares and 
constructs a two-dimensional array of type int:
int[][] myArray = new int[3][];
Notice that only the first brackets are given a size. That's acceptable in Java, since 
the JVM needs to know only the size of the object assigned to the variable myArray. Figure 3-3 shows how a two-dimensional int array works on the heap. Constructing an Array (Exam Objective 1.3) 223
 FIGURE 3-3 
A two-dimensional 
array on the Heap
Initializing an Array
Initializing an array means putting things into it. The "things" in the array are the 
array's elements, and they're either primitive values (2, x, false, and so on), or 
objects referred to by the reference variables in the array. If you have an array of 
objects (as opposed to primitives), the array doesn't actually hold the objects, just as 
any other nonprimitive variable never actually holds the object, but instead holds 
a reference to the object. But we talk about arrays as, for example, "an array of five 
strings," even though what we really mean is, "an array of five references to String 
objects." Then the big question becomes whether or not those references are actually 
pointing (oops, this is Java, we mean referring) to real String objects, or are simply 
null. Remember, a reference that has not had an object assigned to it is a null 
reference. And if you try to actually use that null reference by, say, applying the dot 
operator to invoke a method on it, you'll get the infamous NullPointerException. The individual elements in the array can be accessed with an index number. The 
index number always begins with zero, so for an array of ten objects the index numbers 
will run from 0 through 9. Suppose we create an array of three Animals as follows:
Animal [] pets = new Animal[3];
We have one array object on the heap, with three null references of type Animal, 
but we don't have any Animal objects. The next step is to create some Animal 
objects and assign them to index positions in the array referenced by pets:
pets[0] = new Animal();
pets[1] = new Animal();
pets[2] = new Animal();
This code puts three new Animal objects on the heap and assigns them to the 
three index positions (elements) in the pets array. 224 Chapter 3:  Assignments
Look for code that tries to access an out-of-range array index. For 
example, if an array has three elements, trying to access the [3] element will raise an 
ArrayIndexOutOfBoundsException, because in an array of three elements, the 
legal index values are 0, 1, and 2. You also might see an attempt to use a negative number 
as an array index. The following are examples of legal and illegal array access attempts. Be sure to recognize that these cause runtime exceptions and not compiler errors! A two-dimensional array (an array of arrays) can be initialized as follows:
int[][] scores = new int[3][]; 
// Declare and create an array holding three references 
// to int arrays
scores[0] = new int[4]; 
// the first element in the scores array is an int array 
// of four int elements 
scores[1] = new int[6];
// the second element in the scores array is an int array 
// of six int elements 
scores[2] = new int[1];
// the third element in the scores array is an int array 
// of one int element
Initializing Elements in a Loop
Array objects have a single public variable, length that gives you the number of 
elements in the array. The last index value, then, is always one less than the length. For example, if the length of an array is 4, the index values are from 0 through 3. Often, you'll see array elements initialized in a loop as follows:
Initializing an Array (Exam Objective 1.3) 225
Nearly all of the exam questions list both runtime exception and compiler 
error as possible answers. int[] x = new int[5];
x[4] = 2; // OK, the last element is at index 4
x[5] = 3;  // Runtime  exception. There is no element at index 
5! int[] z = new int[2];
int y = -3;
z[y] = 4; // Runtime exception. y is a negative number
These can be hard to spot in a complex loop, but that’s where you’re 
most likely to see array index problems in exam questions. 226 Chapter 3:  Assignments
  Dog[] myDogs = new Dog[6]; // creates an array of 6 
                             // Dog references 
for(int x = 0; x < myDogs.length; x++) {
    myDogs[x] = new Dog(); // assign a new Dog to the 
                           // index position x
} 
The length variable tells us how many elements the array holds, but it does not 
tell us whether those elements have been initialized. Declaring, Constructing, and Initializing on One Line
You can use two different array-specific syntax shortcuts to both initialize (put 
explicit values into an array's elements) and construct (instantiate the array object 
itself) in a single statement. The first is used to declare, create, and initialize in one 
statement as follows:
1. int x = 9;
2. int[] dots = {6,x,8};
Line 2 in the preceding code does four things: 
■ Declares an int array reference variable named dots. ■ Creates an int array with a length of three (three elements). ■ Populates the array's elements with the values 6, 9, and 8. ■ Assigns the new array object to the reference variable dots. The size (length of the array) is determined by the number of comma-separated 
items between the curly braces. The code is functionally equivalent to the following 
longer code:
int[] dots;
dots = new int[3];
int x = 9;
dots[0] = 6;
dots[1] = x;
dots[2] = 8;
puppy
myDogs
Dog puppy = new Dog (”Frodo”);
Dog[ ] myDogs = {puppy, new Dog(”Clover”), new Dog(”Aiko”)};
012
Frodo Clover
Aiko
Dog object Dog object
Dog object
Dog reference
variable
Dog[ ]array
reference variable
Four objects are created:
1 Dog object referenced by puppy and by myDogs[0]
1 Dog[ ] array referenced by myDogs
2 Dog object referenced by myDogs[1]and myDogs[2]
Picture demonstrates the result of the following code:
Dog[ ]array object
The heap
This begs the question, "Why would anyone use the longer way?" One reason 
come to mind. You might not know—at the time you create the array—the values 
that will be assigned to the array's elements. This array shortcut alone (combined 
with the stimulating prose) is worth the price of this book. With object references rather than primitives, it works exactly the same way:
Dog puppy = new Dog("Frodo");
Dog[] myDogs = {puppy, new Dog("Clover"), new Dog("Aiko")};
The preceding code creates one Dog array, referenced by the variable myDogs, 
with a length of three elements. It assigns a previously created Dog object (as-
signed to the reference variable puppy) to the first element in the array. It also 
creates two new Dog objects (Clover and Aiko), and adds them to the last two 
Dog reference variable elements in the myDogs array. Figure 3-4 shows the result. Initializing an Array (Exam Objective 1.3) 227
 FIGURE 3-4 
Declaring, 
constructing, and 
initializing an array 
of objects
228 Chapter 3:  Assignments
You can also use the shortcut syntax with multidimensional arrays, as follows:
int[][] scores = {{5,2,4,7}, {9,2}, {3,4}};
The preceding code creates a total of four objects on the heap. First, an array 
of int arrays is constructed (the object that will be assigned to the scores 
reference variable). The scores array has a length of three, derived from the 
number of items (comma-separated) between the outer curly braces. Each of the 
three elements in the scores array is a reference variable to an int array, so the 
three int arrays are constructed and assigned to the three elements in the 
scores array. The size of each of the three int arrays is derived from the number of items 
within the corresponding inner curly braces. For example, the first array has a 
length of four, the second array has a length of two, and the third array has a 
length of two. So far, we have four objects: one array of int arrays (each element 
is a reference to an int array), and three int arrays (each element in the three 
int arrays is an int value). Finally, the three int arrays are initialized with 
the actual int values within the inner curly braces. Thus, the first int array 
contains the values 5, 2, 4, and 7. The following code shows the values of some 
of the elements in this two-dimensional array:
scores[0] // an array of four ints
scores[1] // an array of 2 ints
scores[2] // an array of 2 ints
scores[0][1] // the int value 2
scores[2][1] // the int value 4
Figure 3-5 shows the result of declaring, constructing, and initializing a two-
dimensional array in one statement. Constructing and Initializing an Anonymous Array
The second shortcut is called "anonymous array creation" and can be used 
to construct and initialize an array, and then assign the array to a previously 
declared array reference variable:
int[] testScores;
testScores = new int[] {4,7,2};
Cat
Cat[ ]array
object
Cat[ ][ ] myCats =
new Cat(”Bilbo”), new Cat(”Legolas”), new Cat(”Bert”)
{{
{
}
} }
new Cat(”Fluffy”), new Cat(”Zeus”) ,
Cat[ ]array
object
2-D Cat[ ][ ] array object
Picture demonstrates the result of the following code:
Cat[ ][ ]array
reference variable
Eight objects are created:
1 2-D Cat[ ][ ]array object
2 Cat[ ]array object
5 Cat object
Fluffy
0 021
01
1
Zeus Bilbo
Legolas
Bert
object
Cat object Cat object
Cat object
Cat object
The heap
The preceding code creates a new int array with three elements, initializes the 
three elements with the values 4, 7, and 2, and then assigns the new array to 
the previously declared int array reference variable testScores. We call this 
anonymous array creation because with this syntax you don't even need to assign 
the new array to anything. Maybe you're wondering, "What good is an array if you 
don't assign it to a reference variable?" You can use it to create a just-in-time array 
to use, for example, as an argument to a method that takes an array parameter. The following code demonstrates a just-in-time array argument:
Initializing an Array (Exam Objective 1.3) 229
 FIGURE 3-5 
Declaring, 
constructing, and 
initializing a two-
dimensional array
230 Chapter 3:  Assignments
public class Foof {
  void takesAnArray(int []  someArray) {
    // use the array parameter
  }
  public static void main (String [] args) {
    Foof f = new Foof();
    f.takesAnArray(new int[] {7,7,8,2,5}); // we need an array 
                                           // argument
  }
}
Legal Array Element Assignments
What can you put in a particular array? For the exam, you need to know that arrays 
can have only one declared type (int [], Dog[], String [], and so on), but that 
doesn't necessarily mean that only objects or primitives of the declared type can 
be assigned to the array elements. And what about the array reference itself? What 
kind of array object can be assigned to a particular array reference? For the exam, 
you'll need to know the answers to all of these questions. And, as if by magic, we're 
actually covering those very same topics in the following sections.

--- Chunk #1325 ---
Pay attention. Arrays of Primitives
Primitive arrays can accept any value that can be promoted implicitly to the 
declared type of the array. For example, an int array can hold any value that can fit 
into a 32-bit int variable. Thus, the following code is legal:
Remember that you do not specify a size when using anonymous array 
creation syntax. The size is derived from the number of items (comma-separated) 
between the curly braces. Pay very close attention to the array syntax used in exam 
questions (and there will be a lot of them). You might see syntax such as 
   new Object[3] {null, new Object(), new Object()}; 
     // not legal;size must not be specified
int[] weightList = new int[5];
byte b = 4;
char c = 'c';
short s = 7;
weightList[0] = b;  // OK, byte is smaller than int
weightList[1] = c;  // OK, char is smaller than int
weightList[2] = s;  // OK, short is smaller than int
Arrays of Object References
If the declared array type is a class, you can put objects of any subclass of the 
declared type into the array. For example, if Subaru is a subclass of Car, you can put 
both Subaru objects and Car objects into an array of type Car as follows:
class Car {}
class Subaru extends Car {}
class Ferrari extends Car {} 
... Car [] myCars = {new Subaru(), new Car(), new Ferrari()};
It helps to remember that the elements in a Car array are nothing more than Car 
reference variables. So anything that can be assigned to a Car reference variable can 
be legally assigned to a Car array element. If the array is declared as an interface type, the array elements can refer to any 
instance of any class that implements the declared interface. The following code 
demonstrates the use of an interface as an array type:
interface Sporty { 
  void beSporty();
}
class Ferrari extends Car implements Sporty {
  public void beSporty() {
    // implement cool sporty method in a Ferrari-specific way
  }
}
class RacingFlats extends AthleticShoe implements Sporty {
  public void beSporty() {
    // implement cool sporty method in a RacingShoe-specific way
  }
Initializing an Array (Exam Objective 1.3) 231
232 Chapter 3:  Assignments
}
class GolfClub { }
class TestSportyThings {
  public static void main (String [] args) {
    Sporty[] sportyThings = new Sporty [3];
    sportyThings[0] = new Ferrari();      // OK, Ferrari 
                                          // implements Sporty
    sportyThings[1] = new RacingFlats();  // OK, RacingFlats 
                                          // implements Sporty
    sportyThings[2] = new GolfClub(); 
        // Not OK; GolfClub does not implement Sporty
        // I don't care what anyone says 
  }
}
The bottom line is this: any object that passes the "IS-A" test for the declared 
array type can be assigned to an element of that array. Array Reference Assignments for One-Dimensional Arrays
For the exam, you need to recognize legal and illegal assignments for array reference 
variables. We're not talking about references in the array (in other words, array 
elements), but rather references to the array object. For example, if you declare an 
int array, the reference variable you declared can be reassigned to any int array (of 
any size), but cannot be reassigned to anything that is not an int array, including an 
int value. Remember, all arrays are objects, so an int array reference cannot refer to 
an int primitive. The following code demonstrates legal and illegal assignments for 
primitive arrays:
int[] splats;
int[] dats = new int[4];
char[] letters = new char[5];
splats = dats; // OK, dats refers to an int array
splats = letters; // NOT OK, letters refers to a char array
It's tempting to assume that because a variable of type byte, short, or char 
can be explicitly promoted and assigned to an int, an array of any of those types 
could be assigned to an int array. You can't do that in Java, but it would be just like 
those cruel, heartless (but otherwise attractive) exam developers to put tricky array 
assignment questions in the exam. Arrays that hold object references, as opposed to primitives, aren't as restrictive. Just as you can put a Honda object in a Car array (because Honda extends Car), you 
can assign an array of type Honda to a Car array reference variable as follows:
Car[] cars;
Honda[] cuteCars = new Honda[5];
cars = cuteCars; // OK because Honda is a type of Car
Beer[] beers = new Beer [99];
cars = beers; // NOT OK, Beer is not a type of Car
Apply the IS-A test to help sort the legal from the illegal. Honda IS-A Car, so a 
Honda array can be assigned to a Car array. Beer IS-A Car is not true; Beer does not 
extend Car (plus it doesn't make sense, unless you've already had too much of it). The rules for array assignment apply to interfaces as well as classes. An array 
declared as an interface type can reference an array of any type that implements the 
interface. Remember, any object from a class implementing a particular interface will 
pass the IS-A (instanceof) test for that interface. For example, if Box implements 
Foldable, the following is legal:
Foldable[]  foldingThings;
Box[] boxThings = new Box[3];
foldingThings = boxThings;  
// OK, Box implements Foldable, so Box IS-A Foldable
Array Reference Assignments for Multidimensional Arrays
When you assign an array to a previously declared array reference, the array you're 
assigning must be the same dimension as the reference you're assigning it to. For 
Initializing an Array (Exam Objective 1.3) 233
You cannot reverse the legal assignments. A Car array cannot be assigned 
to a Honda array. A Car is not necessarily a Honda, so if you’ve declared a Honda array, 
it might blow up if you assigned a Car array to the Honda reference variable. Think 
about it: a Car array could hold a reference to a Ferrari, so someone who thinks they 
have an array of Hondas could suddenly ﬁ  nd themselves with a Ferrari. Remember that 
the IS-A test can be checked in code using the instanceof operator. 234 Chapter 3:  Assignments
example, a two-dimensional array of int arrays cannot be assigned to a regular int 
array reference, as follows:
int[] blots;
int[][] squeegees = new int[3][];
blots = squeegees;         // NOT OK, squeegees is a 
                           // two-d array of int arrays
int[] blocks = new int[6];
blots = blocks;            // OK, blocks is an int array
Pay particular attention to array assignments using different dimensions. You 
might, for example, be asked if it's legal to assign an int array to the first element in 
an array of int arrays, as follows:
int[][]  books = new int[3][];
int[] numbers = new int[6];
int aNumber = 7;
books[0] = aNumber;     // NO, expecting an int array not an int
books[0] = numbers;     // OK, numbers is an int array
Figure 3-6 shows an example of legal and illegal assignments for references to 
an array. Initialization Blocks
We've talked about two places in a class where you can put code that performs 
operations: methods and constructors. Initialization blocks are the third place in a 
Java program where operations can be performed. Initialization blocks run when the 
class is first loaded (a static initialization block) or when an instance is created (an 
instance initialization block). Let's look at an example:
  class SmallInit {
  static int x;
  int y;
  static { x = 7 ; }       // static init block
  { y = 8; }               // instance init block
}
As you can see, the syntax for initialization blocks is pretty terse. They don't 
have names, they can't take arguments, and they don't return anything. A static 
initialization block runs once, when the class is first loaded. An instance initialization 
block runs once every time a new instance is created. Remember when we talked about 
the order in which constructor code executed? Instance init block code runs right 
Initialization Blocks (Exam Objective 1.3) 235
 FIGURE 3-6   Legal and illegal array assignments
moreCats
Cat[ ]array 
reference variable 
Array reference variable can
ONLY refer to a 1-D Cat array
Cat[ ][ ]2-D array 
reference variable 
2-D reference variable can
ONLY refer to a 2-D Cat array
myCats = myCats[0];
Can’t assign a 1-D array to a 2-D array reference
myCats = myCats[0][0];
Can’t assign a nonarray object to a 2-D array reference
myCats[1] = myCats[1][2];
Can’t assign a nonarray object to a 1-D array reference
myCats[0][1] = moreCats;
myCats[0][1] can only refer to a Cat object
Can’t assign an array object to a nonarray reference
2-D Cat[ ][ ]arra
y object 
Element in a 2-D Cat array can ONLY
refer to a 1-D Cat array
Legal
Illegal
Cat[ ]array 
object
Cat[ ]array 
object
Cat[ ]array 
object
01
01
01
012
The heap
Cat object
B
A
Illegal Array Reference Assignments
A
B
C
D
D
C
KEY
myCats
Cat object
null
Cat object
Cat object
Cat object
Element in a 1-D Cat array can
ONLY refer to a Cat object
Fluffy Zeus Bilbo
Legolas
Bert
//
//
//
//
//
236 Chapter 3:  Assignments
after the call to super() in a constructor, in other  words, after all 
super-constructors have run. You can have many initialization blocks in a class.

--- Chunk #1326 ---
It is important to note that 
unlike methods or constructors, the order in which initialization blocks appear in a class 
matters. When it's time for initialization blocks to run, if a class has more than one, 
they will run in the order in which they appear in the class file…in other words, 
from the top down. Based on the rules we just discussed, can you determine the 
output of the following program? class Init {
  Init(int x) { System.out.println("1-arg const"); }
  Init() { System.out.println("no-arg const"); }
  static { System.out.println("1st static init"); }
  { System.out.println("1st instance init"); }
  { System.out.println("2nd instance init"); }
  static { System.out.println("2nd static init"); }
  public static void main(String [] args) {
    new Init();
    new Init(7);
  }
}
To figure this out, remember these rules:
■ Init blocks execute in the order they appear. ■ Static init blocks run once, when the class is first loaded. ■ Instance init blocks run every time a class instance is created. ■ Instance init blocks run after the constructor's call to super(). With those rules in mind, the following output should make sense:
1st static init
2nd static init
1st instance init
2nd instance init
no-arg const
1st instance init
2nd instance init
1-arg const
As you can see, the instance init blocks each ran twice. Instance init blocks are 
often used as a place to put code that all the constructors in a class should share. That way, the code doesn't have to be duplicated across constructors. Finally, if you make a mistake in your static init block, the JVM can throw an 
ExceptionInInitializationError. Let's look at an example,
class InitError {
  static int [] x = new int[4];
  static { x[4] = 5; }           // bad array index! public static void main(String [] args) { }
}
which produces something like:
Exception in thread "main" java.lang.ExceptionInInitializerError
Caused by: java.lang.ArrayIndexOutOfBoundsException: 4
        at InitError.<clinit>(InitError.java:3)
CERTIFICATION OBJECTIVE
Using Wrapper Classes and Boxing 
(Exam Objective 3.1)
3.1 Develop code that uses the primitive wrapper classes (such as Boolean, 
Character, Double, Integer, etc.), and/or autoboxing & unboxing. Discuss the 
differences between the String, StringBuilder, and StringBuffer classes. Using Wrapper Classes and Boxing (Exam Objective 3.1) 237
By convention, init blocks usually appear near the top of the class ﬁ le, 
somewhere around the constructors. However, this is the SCJP exam we’re talking about. Don’t be surprised if you ﬁ  nd an init block tucked in between a couple of methods, 
looking for all the world like a compiler error waiting to happen! 238 Chapter 3:  Assignments
The wrapper classes in the Java API serve two primary purposes:
■ To provide a mechanism to "wrap" primitive values in an object so that 
the primitives can be included in activities reserved for objects, like 
being added to Collections, or returned from a method with an object 
return value. Note: With Java 5's addition of autoboxing (and unboxing), 
which we'll get to in a few pages, many of the wrapping operations that 
programmers used to do manually are now handled automatically. ■ To provide an assortment of utility functions for primitives. Most of 
these functions are related to various conversions: converting primitives 
to and from String objects, and converting primitives and String
 objects to and from different bases (or radix), such as binary, octal, 
and hexadecimal. An Overview of the Wrapper Classes
There is a wrapper class for every primitive in Java. For instance, the wrapper 
class for int is Integer, the class for float is Float, and so on. Remember that 
the primitive name is simply the lowercase name of the wrapper except for char, 
which maps to Character, and int, which maps to Integer. Table 3-2 lists the 
wrapper classes in the Java API. Primitive Wrapper Class Constructor Arguments
boolean Boolean boolean or String
byte Byte byte or String
char Character char
double Double double or String
float Float float, double, or String
int Integer int or String
long Long long or String
short Short short or String
 TABLE 3-2    Wrapper Classes and Their Constructor Arguments
Creating Wrapper Objects
For the exam you need to understand the three most common approaches for 
creating wrapper objects. Some approaches take a String representation of a 
primitive as an argument. Those that take a String throw NumberFormatException 
if the String provided cannot be parsed into the appropriate primitive. For example 
"two" can't be parsed into "2". Wrapper objects are immutable. Once they have 
been given a value, that value cannot be changed. We'll talk more about wrapper 
immutability when we discuss boxing in a few pages. The Wrapper Constructors
All of the wrapper classes except Character provide two constructors: one that takes 
a primitive of the type being constructed, and one that takes a String representation 
of the type being constructed—for example,
Integer i1 = new Integer(42);
Integer i2 = new Integer("42");
or
Float f1 = new Float(3.14f);
Float f2 = new Float("3.14f");
The Character class provides only one constructor, which takes a char as an 
argument—for example,
Character c1 = new Character('c');
The constructors for the Boolean wrapper take either a boolean value true or 
false, or a String. If the String's case-insensitive value is "true" the Boolean will 
be true—any other value will equate to false. Until Java 5,  a Boolean object 
couldn't be used as an expression in a boolean test—for instance,
Boolean b = new Boolean("false");
if (b)      // won't compile, using Java 1.4 or earlier
As of Java 5, a Boolean object can be used in a boolean test, because the compiler 
will automatically "unbox" the Boolean to a boolean. We'll be focusing on Java 5's 
autoboxing capabilities in the very next section—so stay tuned! Creating Wrapper Objects (Exam Objective 3.1) 239
240 Chapter 3:  Assignments
The valueOf() Methods
The two (well, usually two) static valueOf() methods provided in most of the 
wrapper classes give you another approach to creating wrapper objects. Both 
methods take a String representation of the appropriate type of primitive as 
their first argument, the second method (when provided) takes an additional 
argument, int radix, which indicates in what base (for example binary, octal, or 
hexadecimal) the first argument is represented—for example,
Integer i2 = Integer.valueOf("101011", 2);  // converts 101011 
                                            // to 43 and
                                            // assigns the value
                                            // 43 to the
                                            // Integer object i2
or
Float f2 = Float.valueOf("3.14f");   // assigns 3.14 to the
                                     // Float object f2
Using Wrapper Conversion Utilities
As we said earlier, a wrapper's second big function is converting stuff. The following 
methods are the most commonly used, and are the ones you're most likely to see on 
the test. xxxValue() 
When you need to convert the value of a wrapped numeric to a primitive, use 
one of the many xxxValue() methods. All of the methods in this family are no-
arg methods. As you can see by referring to Table 3-3, there are 36 xxxValue() 
methods. Each of the six numeric wrapper classes has six methods, so that any 
numeric wrapper can be converted to any primitive numeric type—for example,
Integer i2 = new Integer(42);  //  make a new wrapper object
byte b = i2.byteValue();       //  convert i2's value to a byte
                               //  primitive
short s = i2.shortValue();     //  another of Integer's xxxValue
                               //  methods
double d = i2.doubleValue();   //  yet another of Integer's
                               //  xxxValue methods
or
Float f2 = new Float(3.14f);   // make a new wrapper object
short s = f2.shortValue();     // convert f2's value to a short
                               // primitive
System.out.println(s);         // result is 3  (truncated, not
                               // rounded)
parseXxx() and valueOf()
The six parseXxx() methods (one for each numeric wrapper type) are closely 
related to the valueOf() method that exists in all of the numeric wrapper 
classes. Both parseXxx() and valueOf() take a String as an argument, throw a 
NumberFormatException (a.k.a. NFE) if the String argument is not properly formed, 
and can convert String objects from different bases (radix), when the underlying 
primitive type is any of the four integer types. (See Table 3-3.) The difference 
between the two methods is 
■ parseXxx() returns the named primitive. ■ valueOf() returns a newly created wrapped object of the type that invoked 
the method. Here are some examples of these methods in action:
double d4 = Double.parseDouble("3.14");   // convert a String
                                            // to a primitive
System.out.println("d4 = " + d4);         // result is d4 = 3.14
Double d5 = Double.valueOf("3.14");       // create a Double obj
System.out.println(d5 instanceof Double); // result is "true"
The next examples involve using the radix argument (in this case binary):
long L2 = Long.parseLong("101010", 2);    // binary String to a 
                                          // primitive
System.out.println("L2 = " + L2);         // result is: L2 = 42
Long L3 = Long.valueOf("101010", 2);      // binary String to 
                                          // Long object
System.out.println("L3 value = " + L3);   // result is: 
                                          // L3 value = 42
Using Wrapper Conversion Utilities (Exam Objective 3.1) 241
242 Chapter 3:  Assignments
toString()
Class Object, the alpha class, has a toString() method. Since we know that all 
other Java classes inherit from class Object, we also know that all other Java classes 
have a toString() method.

--- Chunk #1327 ---
The idea of the toString() method is to allow you 
to get some meaningful representation of a given object. For instance, if you have a 
Collection of various types of objects, you can loop through the Collection and print 
out some sort of meaningful representation of each object using the toString() 
method, which is guaranteed to be in every class. We'll talk more about toString() 
in the Collections chapter, but for now let's focus on how toString() relates to 
the wrapper classes which, as we know, are marked final. All of the wrapper classes 
have a no-arg, nonstatic, instance version of toString(). This method returns a 
String with the value of the primitive wrapped in the object—for instance,
Double d = new Double("3.14");
System.out.println("d = "+ d.toString() ); // result is d = 3.14
All of the numeric wrapper classes provide an overloaded, static toString() 
method that takes a primitive numeric of the appropriate type (Double. toString() takes a double, Long.toString() takes a long, and so on) and, of 
course, returns a String:
String d = Double.toString(3.14);      // d = "3.14"
Finally, Integer and Long provide a third toString() method. It's static, its first 
argument is the primitive, and its second argument is a radix. The radix tells the 
method to take the first argument, which is radix 10 (base 10) by default, and 
convert it to the radix provided, then return the result as a String—for instance,
String s = "hex = "+ Long.toString(254,16); // s = "hex = fe"
toXxxString() (Binary, Hexadecimal, Octal)
The Integer and Long wrapper classes let you convert numbers in base 10 to other 
bases. These conversion methods, toXxxString(), take an int or long, and return 
a String representation of the converted number, for example,
String s3 = Integer.toHexString(254);  // convert 254 to hex
System.out.println("254 is " + s3);    // result: "254 is fe"
String s4 = Long.toOctalString(254); // convert 254 to octal
System.out.print("254(oct) ="+ s4);  // result: "254(oct) =376"
  In summary, the essential method signatures for Wrapper conversion methods are
       primitive  xxxValue()      - to convert a Wrapper to a primitive
       primitive  parseXxx(String)    - to convert a String to a primitive
       Wrapper   valueOf(String)      - to convert a String to a Wrapper
Studying Table 3-3 is the single best way to prepare for this section of the test. If you can keep the differences between xxxValue(), parseXxx(), and 
valueOf() straight, you should do well on this part of the exam. Using Wrapper Conversion Utilities (Exam Objective 3.1) 243
 
Method
s = static
n = NFE exception Boolean
 
Byte
 
Character
 
Double
 
Float
 
Integer
 
Long
 
Short
byteValue x x x x x x
doubleValue xx x x x x
floatValue x x x x x x
intValue xx x x x x
longValue xx x x x x
shortValue xx x x x x
parseXxx        s,n xx x x x x
parseXxx        s,n
(with radix)
xx x x
valueOf          s,n sx x x x x x
valueOf          s,n
(with radix)
xx x x
toString         xx x x x x x x
toString         s
(primitive)
xx x x x x x x
toString         s
(primitive, radix)
xx
 TABLE 3-3    Common Wrapper Conversion Methods
244 Chapter 3:  Assignments
Autoboxing
New to Java 5 is a feature known variously as: autoboxing, auto-unboxing, boxing, 
and unboxing. We'll stick with the terms boxing and unboxing. Boxing and 
unboxing make using wrapper classes more convenient. In the old, pre–Java 5 days, 
if you wanted to make a wrapper, unwrap it, use it, and then rewrap it, you might do 
something like this:
Integer y = new Integer(567);    // make it
int x = y.intValue();            // unwrap it
x++;                             // use it
y = new Integer(x);              // re-wrap it
System.out.println("y = " + y);  // print it
Now, with new and improved Java 5 you can say
Integer y = new Integer(567);    // make it    
y++;                             // unwrap it, increment it,
                                 // rewrap it
System.out.println("y = " + y);  // print it
Both examples produce the output:
y = 568
And yes, you read that correctly. The code appears to be using the postincrement 
operator on an object reference variable! But it's simply a convenience. Behind 
the scenes, the compiler does the unboxing and reassignment for you. Earlier we 
mentioned that wrapper objects are immutable... this example appears to contradict 
that statement. It sure looks like y's value changed from 567 to 568. What actually 
happened, is that a second wrapper object was created and its value was set to 568. If 
only we could access that first wrapper object, we could prove it... Let's try this:
Integer y = 567;                   // make a wrapper
Integer x = y;                     // assign a second ref
                                   // var to THE wrapper
System.out.println(y==x);          // verify that they refer
                                   // to the same object
y++;                               // unwrap, use, "rewrap"
System.out.println(x + " " + y);   // print values
System.out.println(y==x);          // verify that they refer
                                   // to different objects
Which produces the output:
true
 567 568
 false
So, under the covers, when the compiler got to the line y++; it had to substitute 
something like this:
int x2 = y.intValue();           // unwrap it
x2++;                            // use it
y = new Integer(x2);             // re-wrap it
Just as we suspected, there's gotta be a call to new in there somewhere. Boxing, ==, and equals()
We just used == to do a little exploration of wrappers. Let's take a more thorough 
look at how wrappers work with ==, !=, and equals(). We'll talk a lot more about 
the equals() method in later chapters. For now all we have to know is that the 
intention of the equals() method is to determine whether two instances of a given 
class are "meaningfully equivalent." This definition is intentionally subjective; it's 
up to the creator of the class to determine what "equivalent" means for objects of the 
class in question. The API developers decided that for all the wrapper classes, two 
objects are equal if they are of the same type and have the same value. It shouldn't 
be surprising that
Integer i1 = 1000;
Integer i2 = 1000;
if(i1 != i2) System.out.println("different objects");
if(i1.equals(i2)) System.out.println("meaningfully equal");
                         
Produces the output:
different objects
 meaningfully equal
Autoboxing (Exam Objective 3.1) 245
246 Chapter 3:  Assignments
It's just two wrapper objects that happen to have the same value. Because they 
have the same int value, the equals() method considers them to be "meaningfully 
equivalent", and therefore returns true. How about this one:
Integer i3 = 10;
Integer i4 = 10;
if(i3 == i4) System.out.println("same object");
if(i3.equals(i4)) System.out.println("meaningfully equal");
This example produces the output:
same object
meaningfully equal
Yikes! The equals() method seems to be working, but what happened with == 
and != ? Why is != telling us that i1 and i2 are different objects, when == is saying 
that i3 and i4 are the same object? In order to save memory, two instances of the 
following wrapper objects (created through boxing), will always be ==  when their 
primitive values are the same:
■ Boolean
■ Byte
■ Character from \u0000 to \u007f     (7f is 127 in decimal)
■ Short and Integer from -128 to 127
Note: When == is used to compare a primitive to a wrapper, the wrapper will be 
unwrapped and the comparison will be primitive to primitive. Where Boxing Can Be Used
As we discussed earlier, it's very common to use wrappers in conjunction with 
collections. Any time you want your collection to hold objects and primitives, you'll 
want to use wrappers to make those primitives collection-compatible. The general 
rule is that boxing and unboxing work wherever you can normally use a primitive or 
a wrapped object. The following code demonstrates some legal ways to use boxing:
class UseBoxing {
  public static void main(String [] args) {
    UseBoxing u = new UseBoxing();
    u.go(5); 
  }
  boolean go(Integer i) {       // boxes the int it was passed
    Boolean ifSo = true;        // boxes the literal
    Short s = 300;              // boxes the primitive
    if(ifSo) {                  // unboxing
      System.out.println(++s);  // unboxes, increments, reboxes
    }
    return !ifSo;               // unboxes, returns the inverse
  }
}
CERTIFICATION OBJECTIVE
Overloading (Exam Objectives 1.5 and 5.4)
1.5 Given a code example, determine if a method is correctly overriding or overloading 
another method, and identify legal return values (including covariant returns), for the 
method. 5.4 Given a scenario, develop code that declares and/or invokes overridden or 
overloaded methods... Overloading (Exam Objectives 1.5 and 5.4) 247
Remember, wrapper reference variables can be null. That means that you 
have to watch out for code that appears to be doing safe primitive operations, but that 
could throw a NullPointerException:
class Boxing2 {
  static Integer x;
  public static void main(String [] args) {
    doStuff(x);
  }
  static void doStuff(int z) {
    int z2 = 5;
    System.out.println(z2 + z);
} }
This code compiles ﬁ  ne, but the JVM throws a NullPointerException 
when it attempts to invoke doStuff(x), because x doesn’t refer to an Integer object, so 
there’s no value to unbox. 248 Chapter 3:  Assignments
Overloading Made Hard—Method Matching
Although we covered some rules for overloading methods in Chapter 2, in this 
chapter we've added some new tools to our Java toolkit. In this section we're going 
to take a look at three factors that can make overloading a little tricky:
■ Widening
■ Autoboxing
■ Var-args
When a class has overloaded methods, one of the compiler's jobs is to determine 
which method to use whenever it finds an invocation for the overloaded method. Let's look at an example that doesn't use any new Java 5 features:
class EasyOver {
  static void go(int x) { System.out.print("int "); }
  static void go(long x) { System.out.print("long "); }
  static void go(double x) { System.out.print("double "); }
  public static void main(String [] args) {
    byte b = 5;
    short s = 5;
    long l = 5;
    float f = 5.0f;
    go(b);
    go(s);
    go(l);
    go(f);
  }
}
Which produces the output:
int int long double
This probably isn't much of a surprise; the calls that use byte and the short 
arguments are implicitly widened to match the version of the go() method that 
takes an int. Of course, the call with the long uses the long version of go(), and 
finally, the call that uses a float is matched to the method that takes a double. In every case, when an exact match isn't found, the JVM uses the method with the 
smallest argument that is wider than the parameter. You can verify for yourself that if there is only one version of the go() method, 
and it takes a double, it will be used to match all four invocations of go(). Overloading with Boxing and Var-args
Now let's take our last example, and add boxing into the mix:
class AddBoxing {
  static void go(Integer x) { System.out.println("Integer"); }
  static void go(long x) { System.out.println("long"); }
  public static void main(String [] args) {
    int i = 5;
    go(i);           // which go() will be invoked? }
}
As we've seen earlier, if the only version of the go() method was one that took 
an Integer, then Java 5's boxing capability would allow the invocation of go() to 
succeed. Likewise, if only the long version existed, the compiler would use it to 
handle the go() invocation. The question is, given that both methods exist, which 
one will be used? In other words, does the compiler think that widening a primitive 
parameter is more desirable than performing an autoboxing operation? The answer is 
that the compiler will choose widening over boxing, so the output will be
long
Java 5's designers decided that the most important rule should be that preexisting 
code should function the way it used to, so since widening capability already existed, 
a method that is invoked via widening shouldn't lose out to a newly created method 
that relies on boxing. Based on that rule, try to predict the output of the following:
class AddVarargs {
  static void go(int x, int y) { System.out.println("int,int");}
  static void go(byte... x) { System.out.println("byte... "); }
  public static void main(String[] args) {
    byte b = 5;
    go(b,b);         // which go() will be invoked? }
}
Overloading (Exam Objectives 1.5 and 5.4) 249
250 Chapter 3:  Assignments
As you probably guessed, the output is
int,int
Because, once again,  even though each invocation will require some sort of 
conversion, the compiler will choose the older style before it chooses the newer 
style, keeping existing code more robust. So far we've seen that
■ Widening beats boxing
■ Widening beats var-args
At this point, inquiring minds want to know, does boxing beat var-args? class BoxOrVararg {
  static void go(Byte x, Byte y) 
                { System.out.println("Byte, Byte"); }
  static void go(byte... x) { System.out.println("byte... "); }
  public static void main(String [] args) {
    byte b = 5;
    go(b,b);         // which go() will be invoked? }
}
As it turns out, the output is
Byte, Byte
A good way to remember this rule is to notice that the var-args method is "looser" 
than the other method, in that it could handle invocations with any number of 
byte parameters. A var-args method is more like a catch-all method, in terms of 
what invocations it can handle, and as we'll see in Chapter 5, it makes most sense 
for catch-all capabilities to be used as a last resort. Widening Reference Variables
We've seen that it's legal to widen a primitive. Can you widen a reference variable, 
and if so, what would it mean? Let's think back to our favorite polymorphic 
assignment:
Animal a = new Dog();
Along the same lines, an invocation might be:
class Animal {static void eat() { } }
class Dog3 extends Animal {
  public static void main(String[] args) {
    Dog3 d = new Dog3();
    d.go(d);              // is this legal ? }
  void go(Animal a) { }
}
No problem! The go() method needs an Animal, and Dog3 IS-A Animal. (Remember, the go() method thinks it's getting an Animal object, so it will only 
ask it to do Animal things, which of course anything that inherits from Animal can 
do.) So, in this case, the compiler widens the Dog3 reference to an Animal, and 
the invocation succeeds. The key point here is that reference widening depends on 
inheritance, in other words the IS-A test. Because of this, it's not legal to widen 
from one wrapper class to another, because the wrapper classes are peers to one 
another. For instance, it's NOT valid to say that Short IS-A Integer. Overloading (Exam Objectives 1.5 and 5.4) 251
It’s tempting to think that you might be able to widen an Integer 
wrapper to a Long wrapper, but the following will NOT compile:
class Dog4 {
  public static void main(String [] args) {
    Dog4 d = new Dog4();
    d.test(new Integer(5));  // can't widen an Integer 
                             // to a Long
  }
  void test(Long x) { }
}
Remember, none of the wrapper classes will widen from one to another! Bytes won’t widen to Shorts, Shorts won’t widen to Longs, etc. 252 Chapter 3:  Assignments
Overloading When Combining Widening and Boxing
We've looked at the rules that apply when the compiler can match an invocation to 
a method by performing a single conversion. Now let's take a look at what happens 
when more than one conversion is required. In this case the compiler will have to 
widen and then autobox the parameter for a match to be made:
class WidenAndBox {
  static void go(Long x) { System.out.println("Long"); }
  public static void main(String [] args) {
    byte b = 5;
    go(b);           // must widen then box - illegal
  }
}
This is just too much for the compiler:
WidenAndBox.java:6: go(java.lang.Long) in WidenAndBox cannot be 
applied to (byte)
Strangely enough, it IS possible for the compiler to perform a boxing operation 
followed by a widening operation in order to match an invocation to a method. This 
one might blow your mind:
class BoxAndWiden {
  static void go(Object o) { 
    Byte b2 = (Byte) o;       // ok - it's a Byte object
    System.out.println(b2); 
  }
  public static void main(String [] args) {
    byte b = 5;
    go(b);       // can this byte turn into an Object ? }
}
This compiles (!), and produces the output:
5
Wow! Here's what happened under the covers when the compiler, then the JVM, 
got to the line that invokes the go() method:
 1. The byte b was boxed to a Byte. 2. The Byte reference was widened to an Object (since Byte extends Object). 3. The go() method got an Object reference that actually refers to a Byte 
object. 4. The go() method cast the Object reference back to a Byte reference (re 
member, there was never an object of type Object in this scenario, only an 
object of type Byte!). 5. The go() method printed the Byte's value. Why didn't the compiler try to use the box-then-widen logic when it tried to deal 
with the WidenAndBox class? Think about it…if it tried to box first, the byte would 
have been converted to a Byte. Now we're back to trying to widen a Byte to a Long, 
and of course, the IS-A test fails. Overloading in Combination with Var-args
What happens when we attempt to combine var-args with either widening or boxing 
in a method-matching scenario? Let's take a look:
class Vararg {
  static void wide_vararg(long... x) 
              { System.out.println("long..."); }
  static void box_vararg(Integer... x) 
              { System.out.println("Integer..."); }
  public static void main(String [] args) {
    int i = 5;
    wide_vararg(i,i);    // needs to widen and use var-args
    box_vararg(i,i);     // needs to box and use var-args
  }
}
This compiles and produces:
long... Integer... Overloading (Exam Objectives 1.5 and 5.4) 253
254 Chapter 3:  Assignments
As we can see, you can successfully combine var-args with either widening or 
boxing. Here's a review of the rules for overloading methods using widening, boxing, 
and var-args:
■ Primitive widening uses the "smallest" method argument possible. ■ Used individually, boxing and var-args are compatible with overloading. ■ You CANNOT widen from one wrapper type to another. (IS-A fails.)
■ You CANNOT widen and then box. (An int can't become a Long.)
■  You can box and then widen. (An int can become an Object, via Integer.)
■ You can combine var-args with either widening or boxing. There are more tricky aspects to overloading, but other than a few rules 
concerning generics (which we'll cover in Chapter 7), this is all you'll need to know 
for the exam. Phew! CERTIFICATION OBJECTIVE
Garbage Collection (Exam Objective 7.4)
7.4 Given a code example, recognize the point at which an object becomes eligible for 
garbage collection, and determine what is and is not guaranteed by the garbage collection 
system, and recognize the behaviors of the Object finalize() method. Overview of Memory Management and Garbage Collection
This is the section you've been waiting for! It's finally time to dig into the wonderful 
world of memory management and garbage collection. Memory management is a crucial element in many types of applications. Consider a program that reads in large amounts of data, say from somewhere else 
on a network, and then writes that data into a database on a hard drive. A typical 
design would be to read the data into some sort of collection in memory, perform 
some operations on the data, and then write the data into the database. After the 
data is written into the database, the collection that stored the data temporarily 
must be emptied of old data or deleted and recreated before processing the next 
batch. This operation might be performed thousands of times, and in languages 
like C or C++ that do not offer automatic garbage collection, a small flaw in the 
logic that manually empties or deletes the collection data structures can allow small 
amounts of memory to be improperly reclaimed or lost. Forever. These small losses 
are called memory leaks, and over many thousands of iterations they can make 
enough memory inaccessible that programs will eventually crash. Creating code 
that performs manual memory management cleanly and thoroughly is a nontrivial 
and complex task, and while estimates vary, it is arguable that manual memory 
management can double the development effort for a complex program. Java's garbage collector provides an automatic solution to memory management. In most cases it frees you from having to add any memory management logic to 
your application. The downside to automatic garbage collection is that you can't 
completely control when it runs and when it doesn't. Overview of Java's Garbage Collector
Let's look at what we mean when we talk about garbage collection in the land of 
Java. From the 30,000 ft. level, garbage collection is the phrase used to describe 
automatic memory management in Java. Whenever a software program executes (in 
Java, C, C++, Lisp, Ruby, and so on), it uses memory in several different ways. We're 
not going to get into Computer Science 101 here, but it's typical for memory to be 
used to create a stack, a heap, in Java's case constant pools, and method areas. The 
heap is that part of memory where Java objects live, and it's the one and only part of 
memory that is in any way involved in the garbage collection process. A heap is a heap is a heap. For the exam it's important to know that you can call it the 
heap, you can call it the garbage collectible heap, or you can call it Johnson, but there is 
one and only one heap. So, all of garbage collection revolves around making sure that the heap has as 
much free space as possible. For the purpose of the exam, what this boils down to 
is deleting any objects that are no longer reachable by the Java program running. We'll talk more about what reachable means, but let's drill this point in. When 
the garbage collector runs, its purpose is to find and delete objects that cannot be 
reached. If you think of a Java program as being in a constant cycle of creating the 
objects it needs (which occupy space on the heap), and then discarding them when 
they're no longer needed, creating new objects, discarding them, and so on, the 
missing piece of the puzzle is the garbage collector. When it runs, it looks for those 
Overview of Java’s Garbage Collector (Exam Objective 7.4) 255
256 Chapter 3:  Assignments
discarded objects and deletes them from memory so that the cycle of using memory 
and releasing it can continue. Ah, the great circle of life. When Does the Garbage Collector Run? The garbage collector is under the control of the JVM. The JVM decides when to 
run the garbage collector. From within your Java program you can ask the JVM to 
run the garbage collector, but there are no guarantees, under any circumstances, that 
the JVM will comply. Left to its own devices, the JVM will typically run the garbage 
collector when it senses that memory is running low. Experience indicates that when 
your Java program makes a request for garbage collection, the JVM will usually grant 
your request in short order, but there are no guarantees. Just when you think you can 
count on it, the JVM will decide to ignore your request. How Does the Garbage Collector Work? You just can't be sure. You might hear that the garbage collector uses a mark and 
sweep algorithm, and for any given Java implementation that might be true, but the 
Java specification doesn't guarantee any particular implementation. You might hear 
that the garbage collector uses reference counting; once again maybe yes maybe no. The important concept to understand for the exam is when does an object become 
eligible for garbage collection? To answer this question fully, we have to jump ahead 
a little bit and talk about threads. (See Chapter 9 for the real scoop on threads.) In a 
nutshell, every Java program has from one to many threads. Each thread has its own 
little execution stack. Normally, you (the programmer) cause at least one thread to 
run in a Java program, the one with the main() method at the bottom of the stack. However, as you'll learn in excruciating detail in Chapter 9, there are many really 
cool reasons to launch additional threads from your initial thread. In addition to 
having its own little execution stack, each thread has its own lifecycle. For now, 
all we need to know is that threads can be alive or dead. With this background 
information, we can now say with stunning clarity and resolve that an object is eligible 
for garbage collection when no live thread can access it. (Note: Due to the vagaries of 
the String constant pool, the exam focuses its garbage collection questions on non-
String objects, and so our garbage collection discussions apply to only non-String 
objects too.)
Based on that definition, the garbage collector does some magical, unknown 
operations, and when it discovers an object that can't be reached by any live thread, 
it will consider that object as eligible for deletion, and it might even delete it at 
some point. (You guessed it; it also might not ever delete it.) When we talk about 
reaching an object, we're really talking about having a reachable reference variable 
that refers to the object in question. If our Java program has a reference variable 
that refers to an object, and that reference variable is available to a live thread, then 
that object is considered reachable. We'll talk more about how objects can become 
unreachable in the following section. Can a Java application run out of memory? Yes. The garbage collection system 
attempts to remove objects from memory when they are not used. However, if 
you maintain too many live objects (objects referenced from other live objects), 
the system can run out of memory. Garbage collection cannot ensure that there 
is enough memory, only that the memory that is available will be managed as 
efficiently as possible. Writing Code That Explicitly Makes Objects Eligible for Collection
In the preceding section, we learned the theories behind Java garbage collection. In this section, we show how to make objects eligible for garbage collection using 
actual code. We also discuss how to attempt to force garbage collection if it is 
necessary, and how you can perform additional cleanup on objects before they are 
removed from memory. Nulling a Reference
As we discussed earlier, an object becomes eligible for garbage collection when 
there are no more reachable references to it. Obviously, if there are no reachable 
references, it doesn't matter what happens to the object. For our purposes it is just 
floating in space, unused, inaccessible, and no longer needed. The first way to remove a reference to an object is to set the reference variable 
that refers to the object to null. Examine the following code:
1. public class GarbageTruck {
2. public static void main(String [] args) {
3. StringBuffer sb = new StringBuffer("hello");
4. System.out.println(sb);
5. // The StringBuffer object is not eligible for collection
6. sb = null;
7. // Now the StringBuffer object is eligible for collection
8. }
9. }
The StringBuffer object with the value hello is assigned to the reference 
variable sb in the third line. To make the object eligible (for GC), we set the 
reference variable sb to null, which removes the single reference that existed to the 
Writing Code That Explicitly Makes Objects Eligible for Collection (Exam Objective 7.4) 257
258 Chapter 3:  Assignments
StringBuffer object. Once line 6 has run, our happy little hello StringBuffer object 
is doomed, eligible for garbage collection. Reassigning a Reference Variable
We can also decouple a reference variable from an object by setting the reference 
variable to refer to another object. Examine the following code:
class GarbageTruck {
   public static void main(String [] args) {
      StringBuffer s1 = new StringBuffer("hello");
      StringBuffer s2 = new StringBuffer("goodbye");
      System.out.println(s1);
      // At this point the StringBuffer "hello" is not eligible
      s1 = s2; // Redirects s1 to refer to the "goodbye" object
      // Now the StringBuffer "hello" is eligible for collection
   }
}
Objects that are created in a method also need to be considered. When a method 
is invoked, any local variables created exist only for the duration of the method. Once the method has returned, the objects created in the method are eligible for 
garbage collection. There is an obvious exception, however. If an object is returned 
from the method, its reference might be assigned to a reference variable in the 
method that called it; hence, it will not be eligible for collection. Examine the 
following code:
import java.util.Date;
public class GarbageFactory {
   public static void main(String [] args) {
      Date d = getDate();
      doComplicatedStuff();
      System.out.println("d = " + d);    
   }
   
   public static Date getDate() {
      Date d2 = new Date();
      StringBuffer now = new StringBuffer(d2.toString());
      System.out.println(now);
      return d2;
   }
}
In the preceding example, we created a method called getDate() that returns a 
Date object. This method creates two objects: a Date and a StringBuffer containing 
the date information. Since the method returns the Date object, it will not be 
eligible for collection even after the method has completed. The StringBuffer object, 
though, will be eligible, even though we didn't explicitly set the now variable to null. Isolating a Reference
There is another way in which objects can become eligible for garbage collection, 
even if they still have valid references! We call this scenario "islands of isolation." 
A simple example is a class that has an instance variable that is a reference 
variable to another instance of the same class. Now imagine that two such instances 
exist and that they refer to each other. If all other references to these two objects 
are removed, then even though each object still has a valid reference, there will be 
no way for any live thread to access either object. When the garbage collector runs, 
it can usually discover any such islands of objects and remove them. As you can 
imagine, such islands can become quite large, theoretically containing hundreds of 
objects. Examine the following code:
public class Island {
  Island i;
  public static void main(String [] args) {
    Island i2 = new Island();
    Island i3 = new Island();
    Island i4 = new Island();
    i2.i = i3;   // i2 refers to i3
    i3.i = i4;   // i3 refers to i4
    i4.i = i2;   // i4 refers to i2
    i2 = null;
    i3 = null;
    i4 = null;
    // do complicated, memory intensive stuff
  }
}
When the code reaches // do complicated, the three Island objects 
(previously known as i2, i3, and i4) have instance variables so that they refer to 
Writing Code That Explicitly Makes Objects Eligible for Collection (Exam Objective 7.4) 259
260 Chapter 3:  Assignments
each other, but their links to the outside world (i2, i3, and i4) have been nulled. These three objects are eligible for garbage collection. This covers everything you will need to know about making objects eligible for 
garbage collection. Study Figure 3-7 to reinforce the concepts of objects without 
references and islands of isolation. Forcing Garbage Collection
The first thing that should be mentioned here is that, contrary to this section's 
title, garbage collection cannot be forced. However, Java provides some methods 
that allow you to request that the JVM perform garbage collection. Note: As of the Java 6 exam, the topic of using System.gc() has been removed 
from the exam. The garbage collector has evolved to such an advanced state that 
it’s recommended that you never invoke System.gc() in your code - leave it to the 
JVM. We are leaving this section in the book in case you’re studying for a version 
of the exam prior to SCJP 6. FIGURE 3-7   "Island" objects eligible for garbage collection
i2
i3
i3.n
Three island Objects
i2.n
i4.n
The heap
Indicated an
active reference x
Indicates a
deleted reference
Lost Object
i4
public class Island (
Island i2 = new Island();
Island i3 = new Island();
Island i4 = new Island();
i2.n = i3;
i3.n = i4;
i2 = null;
i3 = null;
i4 = null;
doComplexStuff();
public class Lost
public static void main(String
Lost x = new Lost ();
x = null;
doComplexStuff();
args)
i4.n = i2;
public static void main(String [] args) {
{
[{]
}
}
}
}
Island n;
In reality, it is possible only to suggest to the JVM that it perform garbage 
collection. However, there are no guarantees the JVM will actually remove all of the 
unused objects from memory (even if garbage collection is run). It is essential that 
you understand this concept for the exam. The garbage collection routines that Java provides are members of the Runtime 
class. The Runtime class is a special class that has a single object (a Singleton) for 
each main program. The Runtime object provides a mechanism for communicating 
directly with the virtual machine. To get the Runtime instance, you can use the 
method Runtime.getRuntime(), which returns the Singleton. Once you have 
the Singleton you can invoke the garbage collector using the gc() method. Alternatively, you can call the same method on the System class, which has static 
methods that can do the work of obtaining the Singleton for you. The simplest way 
to ask for garbage collection (remember—just a request) is
System.gc();
Theoretically, after calling System.gc(), you will have as much free memory as 
possible. We say theoretically because this routine does not always work that way. First, your JVM may not have implemented this routine; the language specification 
allows this routine to do nothing at all. Second, another thread (again, see the 
Chapter 9) might grab lots of memory right after you run the garbage collector. This is not to say that System.gc() is a useless method—it's much better than 
nothing. You just can't rely on System.gc() to free up enough memory so that 
you don't have to worry about running out of memory. The Certification Exam is 
interested in guaranteed behavior, not probable behavior. Now that we are somewhat familiar with how this works, let's do a little 
experiment to see if we can see the effects of garbage collection. The following 
program lets us know how much total memory the JVM has available to it and how 
much free memory it has. It then creates 10,000 Date objects. After this, it tells us 
how much memory is left and then calls the garbage collector (which, if it decides 
to run, should halt the program until all unused objects are removed). The final free 
memory result should indicate whether it has run. Let's look at the program:
 1. import java.util.Date;
 2. public class CheckGC { 
 3. public static void main(String [] args) {
 4.

--- Chunk #1328 ---
Runtime rt = Runtime.getRuntime();
 5. System.out.println("Total JVM memory: " 
                              + rt.totalMemory());
Writing Code That Explicitly Makes Objects Eligible for Collection (Exam Objective 7.4) 261
262 Chapter 3:  Assignments
 6. System.out.println("Before Memory = " 
                              + rt.freeMemory());
 7. Date d = null;
 8. for(int i = 0;i<10000;i++) {
 9. d = new Date();
10. d = null;
11.

--- Chunk #1329 ---
}
12. System.out.println("After Memory = " 
                              + rt.freeMemory());
13. rt.gc();   // an alternate to System.gc()
14. System.out.println("After GC Memory = " 
                              + rt.freeMemory());
15. }
16. }
Now, let's run the program and check the results:
Total JVM memory: 1048568
Before Memory = 703008
After Memory = 458048
After GC Memory = 818272
As we can see, the JVM actually did decide to garbage collect (i.e., delete) the 
eligible objects. In the preceding example, we suggested to the JVM to perform 
garbage collection with 458,048 bytes of memory remaining, and it honored our 
request. This program has only one user thread running, so there was nothing else 
going on when we called rt.gc(). Keep in mind that the behavior when gc() is 
called may be different for different JVMs, so there is no guarantee that the unused 
objects will be removed from memory. About the only thing you can guarantee is 
that if you are running very low on memory, the garbage collector will run before it 
throws an OutOfMemoryException. EXERCISE 3-2
Garbage Collection Experiment
Try changing the CheckGC program by putting lines 13 and 14 inside a loop. You might see that not all memory is released on any given run of the GC. Cleaning Up Before Garbage Collection—the finalize() Method
Java provides you a mechanism to run some code just before your object is deleted 
by the garbage collector. This code is located in a method named finalize() that 
all classes inherit from class Object. On the surface this sounds like a great idea; 
maybe your object opened up some resources, and you'd like to close them before 
your object is deleted. The problem is that, as you may have gathered by now, you 
can't count on the garbage collector to ever delete an object. So, any code that you 
put into your class's overridden finalize() method is not guaranteed to run. The 
finalize() method for any given object might run, but you can't count on it, so 
don't put any essential code into your finalize() method. In fact, we recommend 
that in general you don't override finalize() at all. Tricky Little finalize() Gotcha's
There are a couple of concepts concerning finalize() that you need to remember. ■ For any given object, finalize() will be called only once (at most) by the 
garbage collector. ■ Calling finalize() can actually result in saving an object from deletion. Let's look into these statements a little further. First of all, remember that any 
code that you can put into a normal method you can put into finalize(). For 
example, in the finalize() method you could write code that passes a reference 
to the object in question back to another object, effectively uneligiblizing the object 
for garbage collection. If at some point later on this same object becomes eligible for 
garbage collection again, the garbage collector can still process this object and delete 
it. The garbage collector, however, will remember that, for this object, finalize() 
already ran, and it will not run finalize() again. CERTIFICATION SUMMARY
This was a monster chapter!

--- Chunk #1330 ---
Don't worry if you find that you have to review some of 
these topics as you get into later chapters. This chapter has a lot of foundation stuff 
that will come into play later. We started the chapter by reviewing the stack and the heap; remember local 
variables live on the stack, and instance variables live with their objects on the heap. Certiﬁ  cation Summary 263
264 Chapter 3:  Assignments
We reviewed legal literals for primitives and Strings, then we discussed the 
basics of assigning values to primitives and reference variables, and the rules for 
casting primitives. Next we discussed the concept of scope, or "How long will this variable live?" 
Remember the four basic scopes, in order of lessening life span: static, instance, 
local, block. We covered the implications of using uninitialized variables, and the importance 
of the fact that local variables MUST be assigned a value explicitly. We talked 
about some of the tricky aspects of assigning one reference variable to another, and 
some of the finer points of passing variables into methods, including a discussion of 
"shadowing."
The next topic was creating arrays, where we talked about declaring, 
constructing, and initializing one-, and multi-dimensional arrays. We talked about 
anonymous arrays, and arrays of references. Next we reviewed static and instance initialization blocks, what they look like, 
and when they are called. Phew! We continued the chapter with a discussion of the wrapper classes; used to 
create immutable objects that hold a primitive, and also used to provide conversion 
capabilities for primitives: remember valueOf(), xxxValue(), and parseXxx(). Closely related to wrappers, we talked about a big new feature in Java 5, 
autoboxing. Boxing is a way to automate the use of wrappers, and we covered some 
of its trickier aspects such as how wrappers work with == and the equals() method. Having added boxing to our toolbox, it was time to take a closer look at 
method overloading and how boxing and var-args, in conjunction with widening 
conversions, make overloading more complicated. Finally, we dove into garbage collection, Java's automatic memory management 
feature. We learned that the heap is where objects live and where all the cool 
garbage collection activity takes place. We learned that in the end, the JVM will 
perform garbage collection whenever it wants to. You (the programmer) can request 
a garbage collection run, but you can't force it. We talked about garbage collection 
only applying to objects that are eligible, and that eligible means "inaccessible from 
any live thread." Finally, we discussed the rarely useful finalize() method, and what 
you'll have to know about it for the exam. All in all, one fascinating chapter. TWO-MINUTE DRILL
Here are some of the key points from this chapter. Stack and Heap
❑ Local variables (method variables) live on the  stack. ❑ Objects and their instance variables live on the heap. Literals and Primitive Casting (Objective 1.3)
❑ Integer literals can be decimal, octal (e.g. 013), or hexadecimal (e.g. 0x3d). ❑ Literals for longs end in L or l. ❑ Float literals end in F or f, double literals end in a digit or D or d. ❑ The boolean literals are true and false. ❑ Literals for chars are a single character inside single quotes: 'd'. Scope (Objectives 1.3 and 7.6)
❑ Scope refers to the lifetime of a variable. ❑ There are four basic scopes:
 ❑    Static variables live basically as long as their class lives. ❑    Instance variables live as long as their object lives. ❑    Local variables live as long as their method is on the stack; however, if 
       their method invokes another method, they are temporarily unavailable. ❑    Block variables (e.g., in a for or an if) live until the block completes. Basic Assignments (Objectives 1.3 and 7.6)
❑ Literal integers are implicitly ints. ❑ Integer expressions always result in an int-sized result, never smaller. ❑ Floating-point numbers are implicitly doubles (64 bits). ❑ Narrowing a primitive truncates the high order bits. ❑ Compound assignments (e.g. +=), perform an automatic cast. ❑ A reference variable holds the bits that are used to refer to an object. ❑ Reference variables can refer to subclasses of the declared type but not to 
superclasses. T wo-Minute Drill 265
✓
266 Chapter 3:  Assignments
❑ When creating a new object, e.g., Button b = new Button();, three 
things happen:
  ❑    Make a reference variable named b, of type Button
  ❑    Create a new Button object
  ❑    Assign the Button object to the reference variable b
Using a Variable or Array Element That Is Uninitialized and 
Unassigned (Objectives 1.3 and 7.6)
❑ When an array of objects is instantiated, objects within the array are not 
instantiated automatically, but all the references get the default value of null. ❑ When an array of primitives is instantiated, elements get default values. ❑ Instance variables are always initialized with a default value. ❑ Local/automatic/method variables are never given a default value. If you 
attempt to use one before initializing it, you'll get a compiler error. Passing Variables into Methods (Objective 7.3)
❑ Methods can take primitives and/or object references as arguments. ❑ Method arguments are always copies. ❑ Method arguments are never actual objects (they can be references to objects). ❑ A primitive argument is an unattached copy of the original primitive. ❑ A reference argument is another copy of a reference to the original object. ❑ Shadowing occurs when two variables with different scopes share the same 
name. This leads to hard-to-find bugs, and hard-to-answer exam questions. Array Declaration, Construction, and Initialization (Obj. 1.3)
❑ Arrays can hold primitives or objects, but the array itself is always an object. ❑ When you declare an array, the brackets can be left or right of the name. ❑ It is never legal to include the size of an array in the declaration. ❑ You must include the size of an array when you construct it (using new) 
unless you are creating an anonymous array. ❑ Elements in an array of objects are not automatically created, although 
primitive array elements are given default values. ❑ You'll get a NullPointerException if you try to use an array element in an 
object array, if that element does not refer to a real object. ❑ Arrays are indexed beginning with zero. ❑ An ArrayIndexOutOfBoundsException occurs if you use a bad index value. ❑ Arrays have a length variable whose value is the number of array elements. ❑ The last index you can access is always one less than the length of the array. ❑ Multidimensional arrays are just arrays of arrays. ❑ The dimensions in a multidimensional array can have different lengths. ❑ An array of primitives can accept any value that can be promoted implicitly 
to the array's declared type;. e.g., a byte variable can go in an int array. ❑ An array of objects can hold any object that passes the IS-A (or instanceof) 
test for the declared type of the array. For example, if Horse extends Animal, 
then a Horse object can go into an Animal array. ❑ If you assign an array to a previously declared array reference, the array you're 
assigning must be the same dimension as the reference you're assigning it to. ❑ You can assign an array of one type to a previously declared array reference of 
one of its supertypes. For example, a Honda array can be assigned to an array 
declared as type Car (assuming Honda extends Car). Initialization Blocks (Objectives 1.3 and 7.6)
❑ Static initialization blocks run once, when the class is first loaded. ❑ Instance initialization blocks run every time a new instance is created. They 
run after all super-constructors and before the constructor's code has run. ❑ If multiple init blocks exist in a class, they follow the rules stated above, 
AND they run in the order in which they appear in the source file. Using Wrappers (Objective 3.1)
❑ The wrapper classes correlate to the primitive types. ❑ Wrappers have two main functions:
  ❑   To wrap primitives so that they can be handled like objects
  ❑   To provide utility methods for primitives (usually conversions)
❑ The three most important method families are
  ❑     xxxValue()   Takes no arguments, returns a primitive 
  ❑     parseXxx()   Takes a String, returns a primitive, throws NFE
  ❑     valueOf()     Takes a String, returns a wrapped object, throws NFE
T wo-Minute Drill 267
268 Chapter 3:  Assignments
❑ Wrapper constructors can take a String or a primitive, except for Character, 
which can only take a char. ❑ Radix refers to bases (typically) other than 10; octal is radix = 8, hex = 16. Boxing (Objective 3.1)
❑ As of Java 5, boxing allows you to convert primitives to wrappers or to 
convert wrappers to primitives automatically. ❑ Using == with wrappers created through boxing is tricky; those with the same 
small values (typically lower than 127), will be ==, larger values will not be ==. Advanced Overloading (Objectives 1.5 and 5.4)
❑ Primitive widening uses the "smallest" method argument possible. ❑ Used individually, boxing and var-args are compatible with overloading. ❑ You CANNOT widen from one wrapper type to another. (IS-A fails.)
❑ You CANNOT widen and then box. (An int can't become a Long.)
❑  You can box and then widen. (An int can become an Object, via an Integer.)
❑ You can combine var-args with either widening or boxing. Garbage Collection (Objective 7.4)
❑ In Java, garbage collection (GC) provides automated memory management. ❑ The purpose of GC is to delete objects that can't be reached. ❑ Only the JVM decides when to run the GC, you can only suggest it. ❑ You can't know the GC algorithm for sure. ❑ Objects must be considered eligible before they can be garbage collected. ❑ An object is eligible when no live thread can reach it. ❑ To reach an object, you must have a live, reachable reference to that object. ❑ Java applications can run out of memory. ❑ Islands of objects can be GCed, even though they refer to each other. ❑ Request garbage collection with System.gc(); (only before the SCJP 6). ❑ Class Object has a finalize() method. ❑ The finalize() method is guaranteed to run once and only once before the 
garbage collector deletes an object. ❑ The garbage collector makes no guarantees, finalize() may never run. ❑ You can uneligibilize an object for GC from within finalize(). SELF TEST
 1. Given:
class CardBoard {
  Short story = 200;
  CardBoard go(CardBoard cb) {
    cb = null;
    return cb;
  }
  public static void main(String[] args) {
    CardBoard c1 = new CardBoard();
    CardBoard c2 = new CardBoard();
    CardBoard c3 = c1.go(c2);
    c1 = null;
    // do Stuff
} }     
  When // doStuff is reached, how many objects are eligible for GC? A.

--- Chunk #1331 ---
0
  B. 1
  C.

--- Chunk #1332 ---
2 
  D. Compilation fails
  E. It is not possible to know
  F. An exception is thrown at runtime
 2. Given:
class Alien {
  String invade(short ships) { return "a few"; }
  String invade(short... ships) { return "many"; }
}
class Defender {
  public static void main(String [] args) {
    System.out.println(new Alien().invade(7));
  }
}
  What is the result? A.

--- Chunk #1333 ---
many
  B. a few
  C. Compilation fails
  D. The output is not predictable
  E. An exception is thrown at runtime
Self T est 269
 3. Given:
 1. class Dims {
 2. public static void main(String[] args) {
 3. int[][] a = {{1,2,}, {3,4}};
 4. int[] b = (int[]) a[1];
 5. Object o1 = a;
 6. int[][] a2 = (int[][]) o1;
 7. int[] b2 = (int[]) o1; 
 8. System.out.println(b[1]);
 9. } }
  What is the result? A. 2
  B. 4
  C. An exception is thrown at runtime
  D. Compilation fails due to an error on line 4
  E. Compilation fails due to an error on line 5
  F. Compilation fails due to an error on line 6
  G. Compilation fails due to an error on line 7
 4. Given:
class Mixer {
  Mixer() { }
  Mixer(Mixer m) { m1 = m; }
  Mixer m1;
  public static void main(String[] args) {
    Mixer m2 = new Mixer();
    Mixer m3 = new Mixer(m2);  m3.go();
    Mixer m4 = m3.m1;          m4.go();
    Mixer m5 = m2.m1;          m5.go();
  }
  void go() { System.out.print("hi "); }
}
  What is the result? A.

--- Chunk #1334 ---
hi 
  B. hi hi
  C. hi hi hi
270 Chapter 3:  Assignments
  D. Compilation fails
  E. hi, followed by an exception
  F. hi hi, followed by an exception
 5. Given:
class Fizz {
  int x = 5;
  public static void main(String[] args) {
    final Fizz f1 = new Fizz();
    Fizz f2 = new Fizz();
    Fizz f3 = FizzSwitch(f1,f2);
    System.out.println((f1 == f3) + " " + (f1.x == f3.x));
  }
  static Fizz FizzSwitch(Fizz x, Fizz y) {
    final Fizz z = x;
    z.x = 6;
    return z;
} }
  What is the result? A. true true
  B. false true
  C. true false
  D. false false
  E. Compilation fails
  F. An exception is thrown at runtime
 6. Given:
class Bird {
  { System.out.print("b1 "); }
  public Bird() { System.out.print("b2 "); }
}
class Raptor extends Bird {
  static { System.out.print("r1 "); }
  public Raptor() { System.out.print("r2 "); }
  { System.out.print("r3 "); }
  static { System.out.print("r4 "); }
}
class Hawk extends Raptor {
  public static void main(String[] args) {
    System.out.print("pre ");
    new Hawk();
    System.out.println("hawk ");
  }
}
Self T est 271
272 Chapter 3:  Assignments
  What is the result? A.

--- Chunk #1335 ---
pre b1 b2 r3 r2 hawk
  B. pre b2 b1 r2 r3 hawk
  C. pre b2 b1 r2 r3 hawk r1 r4
  D. r1 r4 pre b1 b2 r3 r2 hawk
  E. r1 r4 pre b2 b1 r2 r3 hawk
  F. pre r1 r4 b1 b2 r3 r2 hawk
  G. pre r1 r4 b2 b1 r2 r3 hawk
  H. The order of output cannot be predicted
  I. Compilation fails
 7.

--- Chunk #1336 ---
Given:
 3. public class Bridge {
 4. public enum Suits {
 5. CLUBS(20), DIAMONDS(20), HEARTS(30), SPADES(30),
 6. NOTRUMP(40) { public int getValue(int bid) { 
                        return ((bid-1)*30)+40; } };
 7. Suits(int points) {  this.points = points;  }
 8. private int points; 
 9. public int getValue(int bid) { return points * bid; }
10. }
11. public static void main(String[] args) {
12. System.out.println(Suits.NOTRUMP.getValue(3));
13. System.out.println(Suits.SPADES + " " + Suits.SPADES.points);
14. System.out.println(Suits.values());
15. }
16. }
  Which are true? (Choose all that apply.)
  A. The output could contain 30
  B. The output could contain @bf73fa
  C. The output could contain DIAMONDS
  D. Compilation fails due to an error on line 6
  E. Compilation fails due to an error on line 7
  F. Compilation fails due to an error on line 8
  G. Compilation fails due to an error on line 9
  H. Compilation fails due to an error within lines 12 to 14
 8. Given:
 3. public class Ouch {
 4. static int ouch = 7;
 5. public static void main(String[] args) {
 6. new Ouch().go(ouch);
 7. System.out.print(" " + ouch);
 8. }
 9. void go(int ouch) {
10. ouch++;
11. for(int ouch = 3; ouch < 6; ouch++) 
12. ;
13. System.out.print(" " + ouch);
14. }
15. } 
  What is the result? A. 5 7
  B. 5 8
  C. 8 7
  D. 8 8 
  E. Compilation fails 
  F. An exception is thrown at runtime
 9. Given:
 3. public class Bertha {
 4. static String s = "";
 5. public static void main(String[] args) {
 6. int x = 4; Boolean y = true; short[] sa = {1,2,3};
 7. doStuff(x, y);
 8. doStuff(x);
 9. doStuff(sa, sa);
10. System.out.println(s);
11. }
12. static void doStuff(Object o)        { s += "1"; }
13. static void doStuff(Object... o)     { s += "2"; }
14. static void doStuff(Integer... i)    { s += "3"; }
15. static void doStuff(Long L)          { s += "4"; }
16. }
Self T est 273
274 Chapter 3:  Assignments
  What is the result? A. 212
  B. 232
  C. 234
  D. 312
  E. 332
  F. 334
  G. Compilation fails
 10. Given:
 3. class Dozens {
 4. int[] dz = {1,2,3,4,5,6,7,8,9,10,11,12};
 5. }
 6. public class Eggs {
 7. public static void main(String[] args) {
 8. Dozens [] da = new Dozens[3];
 9. da[0] = new Dozens();
10. Dozens d = new Dozens();
11. da[1] = d;
12. d = null;
13. da[1] = null;
14. // do stuff
15.

--- Chunk #1337 ---
}
16. }
  Which two are true about the objects created within main(), and eligible for garbage collection 
when line 14 is reached? A. Three objects were created
  B. Four objects were created
  C. Five objects were created
  D. Zero objects are eligible for GC
  E. One object is eligible for GC
  F. T wo objects are eligible for GC
  G. Three objects are eligible for GC
 11. Given:
 3. class Beta { }
 4. class Alpha {
 5. static Beta b1;
 6. Beta b2;
 7. }
 8. public class Tester {
 9. public static void main(String[] args) { 
10. Beta b1 = new Beta();     Beta b2 = new Beta();
11. Alpha a1 = new Alpha();   Alpha a2 = new Alpha();
12. a1.b1 = b1;
13. a1.b2 = b1;
14. a2.b2 = b2;
15. a1 = null;  b1 = null;  b2 = null;
16. // do stuff
17.

--- Chunk #1338 ---
}
18. }
  When line 16 is reached, how many objects will be eligible for garbage collection? A.

--- Chunk #1339 ---
0
  B. 1
  C. 2
  D. 3
  E. 4
  F. 5
 12. Given:
 3. class Box {
 4. int size;
 5. Box(int s) { size = s; }
 6. }
 7. public class Laser {
 8. public static void main(String[] args) {
 9. Box b1 = new Box(5);
10. Box[] ba = go(b1, new Box(6));
11. ba[0] = b1;
12. for(Box b : ba) System.out.print(b.size + " ");
13. }    
14. static Box[] go(Box b1, Box b2) {
15. b1.size = 4;
16. Box[] ma = {b2, b1};
17. return ma;
18.

--- Chunk #1340 ---
}
19. }
Self T est 275
276 Chapter 3:  Assignments
  What is the result? A.

--- Chunk #1341 ---
4 4
  B. 5 4
  C. 6 4
  D. 4 5
  E. 5 5
  F. Compilation fails
 13. Given:
 3. public class Dark {
 4. int x = 3;
 5. public static void main(String[] args) {
 6. new Dark().go1();
 7. }
 8. void go1() {
 9. int x;
10. go2(++x);
11. }
12. void go2(int y) {
13. int x = ++y;
14. System.out.println(x);
15. }
16. } 
  What is the result? A. 2
  B. 3
  C. 4
  D. 5
  E. Compilation fails
  F. An exception is thrown at runtime
SELF TEST ANSWERS
 1. Given:
class CardBoard {
  Short story = 200;
  CardBoard go(CardBoard cb) {
    cb = null;
    return cb;
  }
  public static void main(String[] args) {
    CardBoard c1 = new CardBoard();
    CardBoard c2 = new CardBoard();
    CardBoard c3 = c1.go(c2);
    c1 = null;
    // do Stuff
} }     
  When // doStuff is reached, how many objects are eligible for GC? A.

--- Chunk #1342 ---
0
  B. 1
  C.

--- Chunk #1343 ---
2 
  D. Compilation fails
  E. It is not possible to know
  F. An exception is thrown at runtime
  Answer:
  ® ✓  C is correct. Only one CardBoard object (c1) is eligible, but it has an associated Short 
wrapper object that is also eligible. ® ˚   A, B, D, E, and F are incorrect based on the above. (Objective 7.4)
 2. Given:
class Alien {
  String invade(short ships) { return "a few"; }
  String invade(short... ships) { return "many"; }
}
class Defender {
  public static void main(String [] args) {
    System.out.println(new Alien().invade(7));
} }
Self T est Answers 277
  What is the result? A.

--- Chunk #1344 ---
many
   B. a few
  C. Compilation fails
  D. The output is not predictable
  E. An exception is thrown at runtime
  Answer:
  ® ✓  C is correct, compilation fails. The var-args declaration is fine, but invade takes a short, 
so the argument 7 needs to be cast to a short. With the cast, the answer is B, 'a few'. ® ˚   A, B, D, and E are incorrect based on the above. (Objective 1.3)
 3.

--- Chunk #1345 ---
Given:
 1. class Dims {
 2. public static void main(String[] args) {
 3. int[][] a = {{1,2,}, {3,4}};
 4. int[] b = (int[]) a[1];
 5. Object o1 = a;
 6. int[][] a2 = (int[][]) o1;
 7. int[] b2 = (int[]) o1; 
 8. System.out.println(b[1]);
 9. } }
  What is the result? A. 2
  B. 4
  C. An exception is thrown at runtime
  D. Compilation fails due to an error on line 4
  E. Compilation fails due to an error on line 5
  F. Compilation fails due to an error on line 6
  G. Compilation fails due to an error on line 7
  Answer:
  ® ✓  C is correct. A ClassCastException is thrown at line 7 because o1 refers to an int[][] 
not an int[]. If line 7 was removed, the output would be 4. ® ˚   A, B, D, E, F, and G are incorrect based on the above. (Objective 1.3)
278 Chapter 3:  Assignments
 4. Given:
class Mixer {
  Mixer() { }
  Mixer(Mixer m) { m1 = m; }
  Mixer m1;
  public static void main(String[] args) {
    Mixer m2 = new Mixer();
    Mixer m3 = new Mixer(m2);  m3.go();
    Mixer m4 = m3.m1;          m4.go();
    Mixer m5 = m2.m1;          m5.go();
  }
  void go() { System.out.print("hi "); }
}
  What is the result? A.

--- Chunk #1346 ---
hi 
  B. hi hi
  C. hi hi hi
  D. Compilation fails
  E. hi, followed by an exception
  F.

--- Chunk #1347 ---
hi hi, followed by an exception
  Answer:
  ® ✓  F is correct. The m2 object’s m1 instance variable is never initialized, so when m5 tries to 
use it a NullPointerException is thrown. ® ˚   A, B, C, D, and E are incorrect based on the above.

--- Chunk #1348 ---
(Objective 7.3)
 5. Given:
class Fizz {
  int x = 5;
  public static void main(String[] args) {
    final Fizz f1 = new Fizz();
    Fizz f2 = new Fizz();
    Fizz f3 = FizzSwitch(f1,f2);
    System.out.println((f1 == f3) + " " + (f1.x == f3.x));
  }
  static Fizz FizzSwitch(Fizz x, Fizz y) {
    final Fizz z = x;
    z.x = 6;
    return z;
} }
Self T est Answers 279
280 Chapter 3:  Assignments
  What is the result? A.

--- Chunk #1349 ---
true true
  B. false true
  C. true false
  D. false false
  E. Compilation fails
  F. An exception is thrown at runtime
  Answer:
  ® ✓  A is correct. The references f1, z, and f3 all refer to the same instance of Fizz. The final 
modifier assures that a reference variable cannot be referred to a different object, but final  
doesn’t keep the object’s state from changing. ® ˚   B, C, D, E, and F are incorrect based on the above. (Objective 7.3)
 6. Given:
class Bird {
  { System.out.print("b1 "); }
  public Bird() { System.out.print("b2 "); }
}
class Raptor extends Bird {
  static { System.out.print("r1 "); }
  public Raptor() { System.out.print("r2 "); }
  { System.out.print("r3 "); }
  static { System.out.print("r4 "); }
}
class Hawk extends Raptor {
  public static void main(String[] args) {
    System.out.print("pre ");
    new Hawk();
    System.out.println("hawk ");
  }
}
  What is the result? A.

--- Chunk #1350 ---
pre b1 b2 r3 r2 hawk
  B. pre b2 b1 r2 r3 hawk
  C. pre b2 b1 r2 r3 hawk r1 r4
  D. r1 r4 pre b1 b2 r3 r2 hawk
  E. r1 r4 pre b2 b1 r2 r3 hawk
  F. pre r1 r4 b1 b2 r3 r2 hawk
  G. pre r1 r4 b2 b1 r2 r3 hawk
  H. The order of output cannot be predicted
  I. Compilation fails
  Answer:
  ® ✓  D is correct. Static init blocks are executed at class loading time, instance init blocks run 
right after the call to super() in a constructor. When multiple init blocks of a single type 
occur in a class, they run in order, from the top down. ® ˚   A, B, C, E, F, G, H, and I are incorrect based on the above. Note: you’ll probably never 
see this many choices on the real exam! (Objective 1.3)
 7.

--- Chunk #1351 ---
Given:
 3. public class Bridge {
 4. public enum Suits {
 5. CLUBS(20), DIAMONDS(20), HEARTS(30), SPADES(30),
 6. NOTRUMP(40) { public int getValue(int bid) { 
                        return ((bid-1)*30)+40; } };
 7. Suits(int points) {  this.points = points;  }
 8. private int points; 
 9. public int getValue(int bid) { return points * bid; }
10. }
11. public static void main(String[] args) {
12. System.out.println(Suits.NOTRUMP.getBidValue(3));
13. System.out.println(Suits.SPADES + " " + Suits.SPADES.points);
14. System.out.println(Suits.values());
15. }
16. }
  Which are true? (Choose all that apply.)
  A. The output could contain 30
  B. The output could contain @bf73fa
  C. The output could contain DIAMONDS
  D. Compilation fails due to an error on line 6
  E. Compilation fails due to an error on line 7
  F. Compilation fails due to an error on line 8
Self T est Answers 281
282 Chapter 3:  Assignments
  G. Compilation fails due to an error on line 9
  H. Compilation fails due to an error within lines 12 to 14
  Answer:
  ® ✓  A and B are correct. The code compiles and runs without exception. The values() 
method returns an array reference, not the contents of the enum, so DIAMONDS is never 
printed. ® ˚   C, D, E, F, G, and H are incorrect based on the above. (Objective 1.3)
 8.

--- Chunk #1352 ---
Given:
 3. public class Ouch {
 4. static int ouch = 7;
 5. public static void main(String[] args) {
 6. new Ouch().go(ouch);
 7. System.out.print(" " + ouch);
 8. }
 9. void go(int ouch) {
10. ouch++;
11. for(int ouch = 3; ouch < 6; ouch++) 
12. ;
13. System.out.print(" " + ouch);
14. }
15. } 
  What is the result? A. 5 7
  B. 5 8
  C. 8 7
  D. 8 8 
  E. Compilation fails 
  F. An exception is thrown at runtime
  Answer:
  ® ✓  E is correct. The parameter declared on line 9 is valid (although ugly), but the variable 
name ouch cannot be declared again on line 11 in the same scope as the declaration on 
line 9. ® ˚   A, B, C, D, and F are incorrect based on the above. (Objective 1.3)
 9.

--- Chunk #1353 ---
Given:
 3. public class Bertha {
 4. static String s = "";
 5. public static void main(String[] args) {
 6. int x = 4; Boolean y = true; short[] sa = {1,2,3};
 7. doStuff(x, y);
 8. doStuff(x);
 9. doStuff(sa, sa);
10. System.out.println(s);
11. }
12. static void doStuff(Object o)        { s += "1"; }
13. static void doStuff(Object... o)     { s += "2"; }
14. static void doStuff(Integer... i)    { s += "3"; }
15. static void doStuff(Long L)          { s += "4"; }
16. }
  What is the result?

--- Chunk #1354 ---
A. 212
  B. 232
  C. 234
  D. 312
  E. 332
  F. 334
  G. Compilation fails
  Answer:
  ® ✓  A is correct. It's legal to autobox and then widen. The first call to doStuff() boxes 
the int to an Integer then passes two objects. The second call cannot widen and then 
box (making the Long method unusable), so it boxes the int to an Integer. As always, a 
var-args method will be chosen only if no non-var-arg method is possible. The third call is 
passing two objects—they are of type 'short array.'
  ® ˚   B, C, D, E, F, and G are incorrect based on the above. (Objective 3.1)
 10. Given:
 3. class Dozens {
 4. int[] dz = {1,2,3,4,5,6,7,8,9,10,11,12};
 5. }
 6. public class Eggs {
 7. public static void main(String[] args) {
Self T est Answers 283
284 Chapter 3:  Assignments
 8. Dozens [] da = new Dozens[3];
 9. da[0] = new Dozens();
10. Dozens d = new Dozens();
11. da[1] = d;
12. d = null;
13. da[1] = null;
14. // do stuff
15.

--- Chunk #1355 ---
}
16. }
  Which two are true about the objects created within main(), and eligible for garbage collection 
when line 14 is reached? A. Three objects were created
  B. Four objects were created
  C. Five objects were created
  D. Zero objects are eligible for GC
  E. One object is eligible for GC
  F. T wo objects are eligible for GC
  G. Three objects are eligible for GC
  Answer:
  ® ✓  C and F are correct. da refers to an object of type "Dozens array," and each Dozens object 
that is created comes with its own "int array" object. When line 14 is reached, only the 
second Dozens object (and its "int array" object) are not reachable. ® ˚   A, B, D, E, and G are incorrect based on the above. (Objective 7.4)
 11.

--- Chunk #1356 ---
Given:
 3. class Beta { }
 4. class Alpha {
 5. static Beta b1;
 6. Beta b2;
 7. }
 8. public class Tester {
 9. public static void main(String[] args) { 
10. Beta b1 = new Beta();     Beta b2 = new Beta();
11. Alpha a1 = new Alpha();   Alpha a2 = new Alpha();
12. a1.b1 = b1;
13. a1.b2 = b1;
14. a2.b2 = b2;
15. a1 = null;  b1 = null;  b2 = null;
16. // do stuff
17.

--- Chunk #1357 ---
}
18. }
  When line 16 is reached, how many objects will be eligible for garbage collection? A.

--- Chunk #1358 ---
0
  B. 1
  C. 2
  D. 3
  E.

--- Chunk #1359 ---
4
  F. 5
  Answer:
  ® ✓  B is correct. It should be clear that there is still a reference to the object referred to by 
a2, and that there is still a reference to the object referred to by a2.b2. What might be 
less clear is that you can still access the other Beta object through the static variable 
a2.b1—because it's static. ® ˚   A, C, D, E, and F are incorrect based on the above.

--- Chunk #1360 ---
(Objective 7.4)
 12.

--- Chunk #1361 ---
Given:
 3. class Box {
 4. int size;
 5. Box(int s) { size = s; }
 6. }
 7. public class Laser {
 8. public static void main(String[] args) {
 9. Box b1 = new Box(5);
10. Box[] ba = go(b1, new Box(6));
11. ba[0] = b1;
12. for(Box b : ba) System.out.print(b.size + " ");
13. }    
14. static Box[] go(Box b1, Box b2) {
15. b1.size = 4;
16. Box[] ma = {b2, b1};
17. return ma;
18. }
19. }
  What is the result? A. 4 4
  B. 5 4
Self T est Answers 285
286 Chapter 3:  Assignments
  C. 6 4
  D.

--- Chunk #1362 ---
4 5
  E. 5 5
  F. Compilation fails
  Answer:
  ® ✓  A is correct. Although main()'s b1 is a different reference variable than go()'s b1, they 
refer to the same Box object. ® ˚   B, C, D, E, and F are incorrect based on the above. (Objective 7.3)
 13.

--- Chunk #1363 ---
Given:
 3. public class Dark {
 4. int x = 3;
 5. public static void main(String[] args) {
 6. new Dark().go1();
 7. }
 8. void go1() {
 9. int x;
10. go2(++x);
11. }
12. void go2(int y) {
13. int x = ++y;
14. System.out.println(x);
15. }
16. } 
  What is the result? A. 2
  B. 3
  C. 4
  D. 5
  E. Compilation fails
  F. An exception is thrown at runtime
  Answer:
  ® ✓  E is correct. In go1() the local variable x is not initialized. ® ˚   A, B, C, D, and F are incorrect based on the above. (Objective 1.3)
4
Operators
CERTIFICATION OBJECTIVES
 
     Using Operators
   ✓        T wo-Minute Drill 
Q&A    Self Test
 
	
288 Chapter 4:  Operators
I
f you've got variables, you're going to modify them. Y ou'll increment them, add them together,  
and compare one to another (in about a dozen different ways). In this chapter, you'll learn 
how to do all that in Java. For an added bonus, you'll learn how to do things that you'll 
probably never use in the real world, but that will almost certainly be on the exam. CERTIFICATION OBJECTIVE
Java Operators (Exam Objective 7.6)
7.6 Write code that correctly applies the appropriate operators including assignment 
operators (limited to: =, +=, -=), arithmetic operators (limited to: +, -, *, /, %, ++, --), 
relational operators (limited to: <, <=, >, >=, ==, !=), the instanceof operator, logical 
operators (limited to: &, |, ^, !, &&, ||), and the conditional operator (? :), to produce 
a desired result. Write code that determines the equality of two objects or two primitives. Java operators produce new values from one or more operands (just so we're all clear, 
remember the operands are the things on the right or left side of the operator). The 
result of most operations is either a boolean or numeric value. Because you know by 
now that Java is not C++, you won't be surprised that Java operators aren't typically 
overloaded. There are, however, a few exceptional operators that come overloaded: 
■ The + operator can be used to add two numeric primitives together, or to 
perform a concatenation operation if either operand is a String. ■ The &, |, and ^ operators can all be used in two different ways, although as 
of this version of the exam, their bit-twiddling capabilities won't be tested. Stay awake. Operators are often the section of the exam where candidates see 
their lowest scores. Additionally, operators and assignments are a part of many 
questions in other topics…it would be a shame to nail a really tricky threads 
question, only to blow it on a pre-increment statement. Assignment Operators
We covered most of the functionality of the assignment operator, "=",  in Chapter 3. To summarize:
■  When assigning a value to a primitive, size matters. Be sure you know when 
implicit casting will occur, when explicit casting is necessary, and when trun-
cation might occur. ■ Remember that a reference variable isn't an object; it's a way to get to an 
object. (We know all you C++ programmers are just dying for us to say "it's a 
pointer", but we're not going to.)
■ When assigning a value to a reference variable, type matters. Remember the 
rules for supertypes, subtypes, and arrays. Next we'll cover a few more details about the assignment operators that are on 
the exam, and when we get to Chapter 7, we'll take a look at how the assignment 
operator "=" works with Strings (which are immutable). Compound Assignment Operators
There are actually 11 or so compound assignment operators, but only the four 
most commonly used (+=,  -=, *=, and /=), are on the exam (despite what the 
objectives say). The compound assignment operators let lazy typists shave a few 
keystrokes off their workload. Here are several example assignments, first without 
using a compound operator,
Assignment Operators (Exam Objective 7.6) 289
Don’t spend time preparing for topics that are no longer on the exam! In a nutshell, the Java 5 exam differs from the 1.4 exam by moving away from bits, and 
towards the API. Many 1.4 topics related to operators have been removed from the exam, 
so in this chapter you WON’T see
■ bit shifting operators
■ bitwise operators
■ two’s complement
■ divide by zero stuff
It’s not that these aren’t important topics, it’s just that they’re not on the 
exam anymore, and we’re really focused on the exam. y = y - 6;
x = x + 2 * 5;
Now, with compound operators:
y -= 6;
x += 2 * 5;
The last two assignments give the same result as the first two. Earlier versions of the exam put big emphasis on operator precedence 
(like:  What’s the result of:  x = y++ + ++x/z;). Other than a very basic knowledge 
of precedence (such as: * and / are higher precedence than + and -),  you won’t need to 
study operator precedence, except that when using a compound operator, the expression 
on the right side of the = will always be evaluated ﬁ  rst. For example, you might expect 
 x *= 2 + 5;
to be evaluated like this:
x = (x * 2) + 5;   // incorrect precedence
  since multiplication has higher precedence than addition. But instead, the 
expression on the right is always placed inside parentheses. it is evaluated like this:
 x = x * (2 + 5);
Relational Operators 
The exam covers six relational operators (<, <=, >, >=, ==, and !=). Relational 
operators always result in a boolean (true or false) value. This boolean value is 
most often used in an if test, as follows,
int x = 8;
if (x < 9) {
  // do something
}
290 Chapter 4:  Operators
but the resulting value can also be assigned directly to a boolean primitive:
class CompareTest {
  public static void main(String [] args) {
    boolean b = 100 > 99;
    System.out.println("The value of b is " + b);
  }
}
Java has four relational operators that can be used to compare any combination of 
integers, floating-point numbers, or characters:
■ >      greater than
■ >=    greater than or equal to
■ <      less than
■ <=    less than or equal to
Let's look at some legal comparisons:
class GuessAnimal {
  public static void main(String[] args) {
    String animal = "unknown";
    int weight = 700;
    char sex = 'm';
    double colorWaveLength = 1.630;
    if (weight >= 500) { animal = "elephant"; }
    if (colorWaveLength > 1.621) { animal = "gray " + animal; }
    if (sex <= 'f') { animal = "female " + animal; }
    System.out.println("The animal is a " + animal);
  }
}
In the preceding code, we are using a comparison between characters. It's also 
legal to compare a character primitive with any number (though it isn't great 
programming style). Running the preceding class will output the following:
The animal is a gray elephant
We mentioned that characters can be used in comparison operators. When 
comparing a character with a character, or a character with a number, Java will use 
the Unicode value of the character as the numerical value, for comparison. Relational Operators (Exam Objective 7.6) 291
"Equality" Operators
Java also has two relational operators (sometimes called "equality operators") that 
compare two similar "things" and return a boolean the represents what's true about 
the two "things" being equal. These operators are
■ == equals (also known as "equal to")
■ != not equals (also known as "not equal to")
Each individual comparison can involve two numbers (including char), two 
boolean values, or two object reference variables. You can't compare incompatible 
types, however. What would it mean to ask if a boolean is equal to a char? Or if a 
Button is equal to a String array? (Exactly, nonsense, which is why you can't do 
it.) There are four different types of things that can be tested:
■ numbers
■ characters
■ boolean primitives
■ Object reference variables
So what does == look at? The value in the variable—in other words, the bit pattern. Equality for Primitives
Most programmers are familiar with comparing primitive values. The following code 
shows some equality tests on primitive variables:
class ComparePrimitives {
  public static void main(String[] args) {
    System.out.println("char 'a' == 'a'? " + ('a' == 'a'));
    System.out.println("char 'a' == 'b'? " + ('a' == 'b'));
    System.out.println("5 != 6? " + (5 != 6));
    System.out.println("5.0 == 5L? " + (5.0 == 5L));
    System.out.println("true == false? " + (true == false));
  }
}
This program produces the following output:
char 'a' == 'a'? true
char 'a' == 'b'? false
5 != 6? true
5.0 == 5L? true  
true == false? false
292 Chapter 4:  Operators
As we can see, usually if a floating-point number is compared with an integer and 
the values are the same, the == operator returns true as expected. Equality for Reference Variables
As we saw earlier, two reference variables can refer to the same object, as the 
following code snippet demonstrates:
JButton a = new JButton("Exit");
JButton b = a;
After running this code, both variable a and variable b will refer to the same object 
(a JButton with the label Exit). Reference variables can be tested to see if they 
refer to the same object by using the == operator. Remember, the == operator is 
looking at the bits in the variable, so for reference variables this means that if the 
Relational Operators (Exam Objective 7.6) 293
Don't mistake = for == in a boolean expression. The following is legal:
11. boolean b = false;
12. if (b = true) { System.out.println("b is true");
13. } else { System.out.println("b is false");  }
Look carefully! You might be tempted to think the output is  b is false 
but look at the boolean test in line 12. The boolean variable b is not being compared to 
true, it's being set to true, so the println executes and we get  b is true . The result 
of any assignment expression is the value of the variable following the assignment. This 
substitution of = for == works only with boolean variables, since the if test can be done 
only on boolean expressions. Thus, this does not compile:
7. int x = 1;
8. if (x = 0) { }
Because x is an integer (and not a boolean), the result of (x = 0) is 0 
(the result of the assignment). Primitive ints cannot be used where a boolean value is 
expected, so the code in line 8 won't work unless changed from an assignment (=) to an 
equality test (==) as follows:
8. if (x == 0) { }
bits in both reference variables are identical, then both refer to the same object. Look at the following code:
import javax.swing.JButton;
class CompareReference {
  public static void main(String[] args) {
    JButton a = new JButton("Exit");
    JButton b = new JButton("Exit");
    JButton c = a;
    System.out.println("Is reference a == b? " + (a == b));
    System.out.println("Is reference a == c? " + (a == c));
  }
}
This code creates three reference variables. The first two, a and b, are separate 
JButton objects that happen to have the same label. The third reference variable, c, 
is initialized to refer to the same object that a refers to. When this program runs, the 
following output is produced:
Is reference a == b? false
Is reference a == c? true
This shows us that a and c reference the same instance of a JButton. The == 
operator will not test whether two objects are "meaningfully equivalent," a concept 
we'll cover in much more detail in Chapter 7, when we look at the equals() method 
(as opposed to the equals operator we're looking at here). Equality for Enums
Once you've declared an enum, it's not expandable. At runtime, there's no way to 
make additional enum constants. Of course, you can have as many variables as you'd 
like refer to a given enum constant, so it's important to be able to compare two 
enum reference variables to see if they're "equal", i.e. do they refer to the same enum 
constant. You can use either the == operator or the equals() method to determine 
if two variables are referring to the same enum constant:
class EnumEqual {
  enum Color {RED, BLUE}                   // ; is optional
  public static void main(String[] args) {
    Color c1 = Color.RED;  Color c2 = Color.RED;
    if(c1 == c2) { System.out.println("=="); }
    if(c1.equals(c2)) { System.out.println("dot equals"); }
} }
294 Chapter 4:  Operators
(We know } } is ugly, we're prepping you). This produces the output:
==
dot equals
instanceof Comparison
The instanceof operator is used for object reference variables only, and you can 
use it to check whether an object is of a particular type. By type, we mean class or 
interface type—in other words, if the object referred to by the variable on the left 
side of the operator passes the IS-A test for the class or interface type on the right 
side (Chapter 2 covered IS-A relationships in detail). The following simple example
public static void main(String[] args) {
  String s = new String("foo");
  if (s instanceof String) {
    System.out.print("s is a String");
  }
}
prints this:    s is a String
Even if the object being tested is not an actual instantiation of the class type on 
the right side of the operator, instanceof will still return true if the object being 
compared is assignment compatible with the type on the right. The following example demonstrates a common use for instanceof: testing an 
object to see if it's an instance of one of its subtypes, before attempting a "downcast":
class A { }
class B extends A { 
  public static void main (String [] args) {
    A myA = new B();
    m2(myA);
  }
  public static void m2(A a) { 
    if (a instanceof B)
      ((B)a).doBstuff();     // downcasting an A reference
                              // to a B reference
  }
  public static void doBstuff() { 
    System.out.println("'a' refers to a B");
  }
}
instanceof Comparison (Exam Objective 7.6) 295
The preceding code compiles and produces the output:
'a' refers to a B
In examples like this, the use of the instanceof operator protects the program from 
attempting an illegal downcast. You can test an object reference against its own class type, or any of its 
superclasses. This means that any object reference will evaluate to true if you use 
the instanceof operator against type Object, as follows, 
B b = new B();
if (b instanceof Object) {
   System.out.print("b is definitely an Object");
}
which prints this:   b is definitely an Object
Look for instanceof questions that test whether an object is an instance 
of an interface, when the object's class implements the interface indirectly. An indirect 
implementation occurs when one of an object's superclasses implements an interface, 
but the actual class of the instance does not—for example,
interface Foo { }
class A implements Foo { }
class B extends A { }
... A a = new A();
B b = new B();
the following are true:
a instanceof Foo
b instanceof A
b instanceof Foo  // implemented indirectly
An object is said to be of a particular interface type (meaning it will pass 
the instanceof test) if any of the object's superclasses implement the interface. 296 Chapter 4:  Operators
In addition, it is legal to test whether the null reference is an instance of a class. This will always result in false, of course. For example:
class InstanceTest {
   public static void main(String [] args) {
      String a = null;
      boolean b = null instanceof String;
      boolean c = a instanceof String;
      System.out.println(b + " " + c);
   }
}
prints this:   false false
instanceof Compiler Error
You can't use the instanceof operator to test across two different class hierarchies. For instance, the following will NOT compile:
class Cat { }
class Dog {
  public static void main(String [] args) {
    Dog d = new Dog();
    System.out.println(d instanceof Cat);
  }
}
Compilation fails—there's no way d could ever refer to a Cat or a subtype of Cat. instanceof Comparison (Exam Objective 7.6) 297
Remember that arrays are objects, even if the array is an array of 
primitives. Watch for questions that look something like this:
int [] nums = new int[3];
if (nums instanceof Object) { } // result is true
An array is always an instance of Object. Any array. Table 4-1 summarizes the use of the instanceof operator given the following:
interface Face { }
class Bar implements Face{ }
class Foo extends Bar { }
Arithmetic Operators
We're sure you're familiar with the basic arithmetic operators. ■ + addition
■ – subtraction
■ * multiplication
■ / division
These can be used in the standard way:
int x = 5 * 3;
int y = x - 4;
System.out.println("x - 4 is " +  y);  // Prints 11
 
First Operand
(Reference Being T ested)
instanceof Operand
(T ype We’re Comparing
the Reference Against) Result
null Any class or interface type false 
Foo instance Foo, Bar, Face, Object true
Bar instance Bar, Face, Object true
Bar instance Foo false
Foo [ ] Foo, Bar, Face false
Foo [ ] Object true
Foo [ 1 ] Foo, Bar, Face, Object true
 TABLE 4-1    Operands and Results Using instanceof Operator. 298 Chapter 4:  Operators
The Remainder (%) Operator
One operator you might not be as familiar with is the remainder operator, %. The 
remainder operator divides the left operand by the right operand, and the result is 
the remainder, as the following code demonstrates:
class MathTest {
  public static void main (String [] args) {
    int x = 15;
    int y = x % 4; 
    System.out.println("The result of 15 % 4 is the "
      + "remainder of 15 divided by 4. The remainder is " + y);
  }
}
Running class MathTest prints the following:
The result of 15 % 4 is the remainder of 15 divided by 4. The 
remainder is 3
(Remember: Expressions are evaluated from left to right by default. You can change 
this sequence, or precedence, by adding parentheses. Also remember that the * , / , 
and % operators have a higher precedence than the + and - operators.)
String Concatenation Operator
The plus sign can also be used to concatenate two strings together, as we saw earlier 
(and as we'll definitely see again):
String animal = "Grey " + "elephant";
String concatenation gets interesting when you combine numbers with Strings. Check out the following:
String a = "String";
int b = 3;
int c = 7;
System.out.println(a + b + c);
Will the + operator act as a plus sign when adding the int variables b + c? Or will 
the + operator treat 3 and 7 as characters, and concatenate them individually? Will 
the result be String10 or String37? OK, you've had long enough to think about it. The int values were simply treated as characters and glued on to the right side of 
the String, giving the result:
Arithmetic Operators (Exam Objective 7.6) 299
String37
So we could read the previous code as
    "Start with String a, String, and add the character 3 (the value of b) to it,
    to produce a new string String3, and then add the character 7 (the value of c)
    to that, to produce a new string String37, then print it out."
However, if you put parentheses around the two int variables, as follows,
System.out.println(a + (b + c));
you'll get this:   String10
Using parentheses causes the (b + c) to evaluate first, so the rightmost + operator 
functions as the addition operator, given that both operands are int values. The key 
point here is that within the parentheses, the left-hand operand is not a String. If it 
were, then the + operator would perform String concatenation. The previous code 
can be read as
     "Add the values of b + c together, then take the sum and convert it to a String
   and concatenate it with the String from variable a."
The rule to remember is this:
    If either operand is a String, the + operator becomes a String concatenation
    operator. If both operands are numbers, the + operator is the addition operator. You'll find that sometimes you might have trouble deciding whether, say, the left- 
hand operator is a String or not. On the exam, don't expect it to always be obvious. (Actually, now that we think about it, don't expect it ever to be obvious.) Look at 
the following code:
System.out.println(x.foo() + 7); 
You can't know how the + operator is being used until you find out what the foo() 
method returns! If foo() returns a String, then 7 is concatenated to the returned 
300 Chapter 4:  Operators
String. But if foo() returns a number, then the + operator is used to add 7 to the 
return value of foo(). Finally, you need to know that it's legal to mush together the compound additive 
operator (+=) and Strings, like so:
String s = "123";
s += "45";
s += 67;
System.out.println(s);
Since both times the += operator was used and the left operand was a String, 
both operations were concatenations, resulting in
1234567
If you don't understand how String concatenation works, especially 
within a print statement, you could actually fail the exam even if you know the rest of 
the answer to the questions! Because so many questions ask, "What is the result?", you 
need to know not only the result of the code running, but also how that result is printed. Although there will be at least a few questions directly testing your String knowledge, 
String concatenation shows up in other questions on virtually every objective. Experiment! For example, you might see a line such as
int b = 2;
System.out.println("" + b + 3);
which prints   23
but if the print statement changes to
System.out.println(b + 3);
then the result becomes   5
Arithmetic Operators (Exam Objective 7.6) 301
Increment and Decrement Operators
Java has two operators that will increment or decrement a variable by exactly one. These operators are composed of either two plus signs (++) or two minus signs (--):
■ ++ increment (prefix and postfix)
■ -- decrement (prefix and postfix)
The operator is placed either before (prefix) or after (postfix) a variable to change 
its value. Whether the operator comes before or after the operand can change the 
outcome of an expression. Examine the following:
1.

--- Chunk #1364 ---
class MathTest {
2. static int players = 0;
3. public static void main (String [] args) {
4. System.out.println("players online: " + players++);
5. System.out.println("The value of players is " 
                              + players);
6. System.out.println("The value of players is now " 
                              + ++players);
7. }
8. }
Notice that in the fourth line of the program the increment operator is after the 
variable players. That means we're using the postfix increment operator, which 
causes players to be incremented by one but only after the value of players is used 
in the expression. When we run this program, it outputs the following:
%java MathTest
players online: 0
The value of players is 1
The value of players is now 2
Notice that when the variable is written to the screen, at first it says the value is 
0. Because we used the postfix increment operator, the increment doesn't happen 
until after the players variable is used in the print statement. Get it? The "post" 
in postfix means after. Line 5 doesn't increment players; it just outputs its value to 
the screen, so the newly incremented value displayed is 1. Line 6 applies the prefix 
increment operator to players, which means the increment happens before the 
value of the variable is used, so the output is 2. Expect to see questions mixing the increment and decrement operators with 
other operators, as in the following example:
302 Chapter 4:  Operators
int x = 2;  int y = 3;
if ((y == x++) | (x < ++y)) {
  System.out.println("x = " + x + " y = " + y);
 }
The preceding code prints:    x = 3 y = 4
You can read the code as follows:    "If 3 is equal to 2 OR 3 < 4" 
The first expression compares x and y, and the result is false, because the 
increment on x doesn't happen until after the == test is made. Next, we increment 
x, so now x is 3. Then we check to see if x is less than y, but we increment y before 
comparing it with x! So the second logical test is (3 < 4). The result is true, so the 
print statement runs. As with String concatenation, the increment and decrement operators are used 
throughout the exam, even on questions that aren't trying to test your knowledge 
of how those operators work. You might see them in questions on for loops, 
exceptions, even threads. Be ready. Arithmetic Operators (Exam Objective 7.6) 303
Look out for questions that use the increment or decrement operators on 
a ﬁ  nal variable. Because ﬁ  nal variables can't be changed, the increment and decrement 
operators can't be used with them, and any attempt to do so will result in a compiler 
error. The following code won't compile:
final int x = 5;
int y = x++;
and produces the error:
Test.java:4: cannot assign a value to final variable x
int y = x++;
        ^
You can expect a violation like this to be buried deep in a complex piece 
of code. If you spot it, you know the code won't compile and you can move on without 
working through the rest of the code. This question might seem to be testing you on some complex arithmetic 
operator trivia, when in fact it’s testing you on your knowledge of the ﬁ  nal modiﬁ er. Conditional Operator
The conditional operator is a ternary operator (it has three operands) and is used 
to evaluate boolean expressions, much like an if statement except instead of 
executing a block of code if the test is true, a conditional operator will assign a 
value to a variable. In other words, the goal of the conditional operator is to decide 
which of two values to assign to a variable. This operator is constructed using a ? (question mark) and a : (colon). The parentheses are optional. Its structure is:
x = (boolean expression) ? value to assign if true : value to assign if false
Let's take a look at a conditional operator in code:
class Salary {
  public static void main(String [] args) {
    int numOfPets = 3;
    String status = (numOfPets<4) ? "Pet limit not exceeded"
                    : "too many pets";
    System.out.println("This pet status is " + status);
  }
}
You can read the preceding code as
     Set numOfPets equal to 3. Next we're going to assign a String to the status 
     variable. If numOfPets is less than 4, assign "Pet limit not exceeded" to the
     status variable; otherwise, assign "too many pets" to the status variable. A conditional operator starts with a boolean operation, followed by two possible 
values for the variable to the left of the assignment (=) operator. The first value (the 
one to the left of the colon) is assigned if the conditional (boolean) test is true, 
and the second value is assigned if the conditional test is false. You can even nest 
conditional operators into one statement:
class AssignmentOps {
  public static void main(String [] args) {
   int sizeOfYard = 10;
   int numOfPets = 3;
   String status = (numOfPets<4)?"Pet count OK"
       :(sizeOfYard > 8)? "Pet limit on the edge"
         :"too many pets"; 
    System.out.println("Pet status is " + status);
304 Chapter 4:  Operators
  }
}
Don't expect many questions using conditional operators, but remember that 
conditional operators are sometimes confused with assertion statements, so be 
certain you can tell the difference. Chapter 5 covers assertions in detail. Logical Operators 
The exam objectives specify six "logical" operators (&, |, ^, !, &&, and ||). Some 
Sun documentation uses other terminology for these operators, but for our purposes 
the "logical operators" are the six listed above, and in the exam objectives. Bitwise Operators (Not on the Exam!)
Okay, this is going to be confusing. Of the six logical operators listed above, three of 
them (&, |, and ^) can also be used as "bitwise" operators. Bitwise operators were 
included in previous versions of the exam, but they're not on the Java 5 exam. Here 
are several legal statements that use bitwise operators:
byte b1 = 6 & 8;
byte b2 = 7 | 9;
byte b3 = 5 ^ 4;
System.out.println(b1 + " " + b2 + " " + b3);
Bitwise operators compare two variables bit by bit, and return a variable 
whose bits have been set based on whether the two variables being compared had 
respective bits that were either both "on" (&), one or the other "on" (|), or exactly 
one "on" (^). By the way, when we run the preceding code, we get
0 15 1
Having said all this about bitwise operators, the key thing to remember is this: 
BITWISE OPERATORS ARE NOT ON THE EXAM! So why did we bring them up? If you get hold of an old exam preparation book, or if 
you find some mock exams that haven't been properly updated, you're bound to find 
questions that perform bitwise operations. Unless you're a glutton for punishment, 
you can skip this kind of mock question. Logical Operators (Exam Objective 7.6) 305
Short-Circuit Logical Operators
There are five logical operators on the exam that are used to evaluate statements 
that contain more than one boolean expression. The most commonly used of the 
five are the two short-circuit logical operators. They are
■ && short-circuit AND
■ || short-circuit OR
They are used to link little boolean expressions together to form bigger boolean 
expressions. The && and || operators evaluate only boolean values. For an AND 
(&&) expression to be true, both operands must be true—for example,
if ((2 < 3) && (3 < 4)) { }
The preceding expression evaluates to true because both operand one (2 < 3) and 
operand two (3 < 4) evaluate to true. The short-circuit feature of the && operator is so named because it doesn't waste 
its time on pointless evaluations. A short-circuit && evaluates the left side of the 
operation first (operand one), and if it resolves to false, the && operator doesn't 
bother looking at the right side of the expression (operand two) since the && 
operator already knows that the complete expression can't possibly be true. class Logical {
  public static void main(String [] args) {
    boolean b = true && false; 
    System.out.println("boolean b = " + b);
  }
}
When we run the preceding code, we get
%java Logical
boolean b = false
The || operator is similar to the && operator, except that it evaluates to true if 
EITHER of the operands is true. If the first operand in an OR operation is true, the 
result will be true, so the short-circuit || doesn't waste time looking at the right 
side of the equation. If the first operand is false, however, the short-circuit || 
has to evaluate the second operand to see if the result of the OR operation will be 
306 Chapter 4:  Operators
true or false. Pay close attention to the following example; you'll see quite a few 
questions like this on the exam:
 1.

--- Chunk #1365 ---
class TestOR {
 2. public static void main(String[] args) {
 3. if ((isItSmall(3)) || (isItSmall(7))) {
 4. System.out.println("Result is true");
 5. }
 6. if ((isItSmall(6)) || (isItSmall(9))) {
 7. System.out.println("Result is true");
 8. }
 9.

--- Chunk #1366 ---
}
10.

--- Chunk #1367 ---
11. public static boolean isItSmall(int i) {
12. if (i < 5) {
13. System.out.println("i < 5");
14. return true;
15. } else {
16. System.out.println("i >= 5");
17. return false;
18. }
19. }
20. }
What is the result? % java TestOR
i < 5
Result is true
i >= 5
i >= 5
Here's what happened when the main() method ran:
1. When we hit line 3, the first operand in the || expression (in other words, 
the left side of the || operation) is evaluated. 2. The isItSmall(3) method is invoked, prints "i < 5", and returns true. 3. Because the first operand in the || expression on line 3 is true, the || 
operator doesn't bother evaluating the second operand. So we never see the 
"i >= 5" that would have printed had the second operand been evaluated 
(which would have invoked isItSmall(7)). Logical Operators (Exam Objective 7.6) 307
4. Line 6 is evaluated, beginning with the first operand in the || expression. 5. The isItSmall(6) method is called, prints "i >= 5", and returns false. 6. Because the first operand in the || expression on line 6 is false, the || 
operator can't skip the second operand; there's still a chance the expression 
can be true, if the second operand evaluates to true. 7. The isItSmall(9) method is invoked and prints "i >= 5". 8. The isItSmall(9) method returns false, so the expression on line 6 is 
false, and thus line 7 never executes. Logical Operators (Not Short-Circuit)
There are two non-short-circuit logical operators. ■ & non-short-circuit AND
■ | non-short-circuit OR
These operators are used in logical expressions just like the && and || operators 
are used, but because they aren't the short-circuit operators, they evaluate both sides 
of the expression, always! They're inefficient. For example, even if the first operand 
(left side) in an & expression is false, the second operand will still be evaluated—
even though it's now impossible for the result to be true! And the | is just as 
inefficient: if the first operand is true, the Java Virtual Machine (JVM) still plows 
ahead and evaluates the second operand even when it knows the expression will be 
true regardless. 308 Chapter 4:  Operators
The || and && operators work only with boolean operands. The exam 
may try to fool you by using integers with these operators:
if (5 && 6) { }
It looks as though we're trying to do a bitwise AND on the bits 
representing the integers 5 and 6, but the code won't even compile. You'll find a lot of questions on the exam that use both the short-circuit and 
non-short-circuit logical operators. You'll have to know exactly which operands are 
evaluated and which are not, since the result will vary depending on whether the 
second operand in the expression is evaluated:
int z = 5;
if(++z > 5 || ++z > 6) z++;   // z = 7 after this code
versus:
int z = 5;
if(++z > 5 | ++z > 6) z++;   // z = 8 after this code
Logical Operators  ^ and ! The last two logical operators on the exam are
■ ^ exclusive-OR  (XOR)
■ ! boolean invert
The ^ (exclusive-OR) operator evaluates only boolean values. The ^ operator 
is related to the non-short-circuit operators we just reviewed, in that it always 
evaluates both the left and right operands in an expression. For an exclusive-OR (^) 
expression to be true, EXACTLY one operand must be true—for example,
System.out.println("xor " + ((2<3) ^ (4>3)));
produces the output:     xor false
The preceding expression evaluates to false because BOTH operand one (2 < 3) 
and operand two (4 > 3) evaluate to true. The ! (boolean invert) operator returns the opposite of a boolean's current value: 
    if(!(7 == 5)) { System.out.println("not equal"); }
can be read "if it's not true that 7 == 5," and the statement produces this output:
not equal
Here's another example using booleans:
Logical Operators (Exam Objective 7.6) 309
boolean t = true;
boolean f = false;
System.out.println("! " + (t & !f) + " " + f);
produces the output:
! true false
In the preceding example, notice that the & test succeeded (printing true), and 
that the value of the boolean variable f did not change, so it printed false. CERTIFICATION SUMMARY
If you've studied this chapter diligently, you should have a firm grasp on Java 
operators, and you should understand what equality means when tested with the == 
operator. Let's review the highlights of what you've learned in this chapter. The logical operators (&& , ||, &, |, and ^) can be used only to evaluate two 
boolean expressions. The difference between && and & is that the && operator 
won't bother testing the right operand if the left evaluates to false, because the 
result of the && expression can never be true. The difference between || and | is 
that the || operator won't bother testing the right operand if the left evaluates to 
true, because the result is already known to be true at that point. The == operator can be used to compare values of primitives, but it can also 
be used to determine whether two reference variables refer to the same object. The instanceof operator is used to determine if the object referred to by a 
reference variable passes the IS-A test for a specified type. The + operator is overloaded to perform String concatenation tasks, and can 
also concatenate Strings and primitives, but be careful—concatenation can be 
tricky. The conditional operator (a.k.a. the "ternary operator") has an unusual, three-
operand syntax—don't mistake it for a complex assert statement. The ++ and -- operators will be used throughout the exam, and you must pay 
attention to whether they are prefixed or postfixed to the variable being updated. Be prepared for a lot of exam questions involving the topics from this chapter. Even within questions testing your knowledge of another objective, the code will 
frequently use operators, assignments, object and primitive passing, and so on. 310 Chapter 4:  Operators
TWO-MINUTE DRILL
Here are some of the key points from each section in this chapter. Relational Operators (Objective 7.6)
❑ Relational operators always result in a boolean value (true or false). ❑ There are six relational operators: >, >=, <, <=, ==, and !=. The last two (== 
and !=) are sometimes referred to as equality operators. ❑ When comparing characters, Java uses the Unicode value of the character as 
the numerical value. ❑ Equality operators
 ❑    There are two equality operators: == and !=. ❑    Four types of things can be tested: numbers, characters, booleans, and
      reference variables. ❑ When comparing reference variables, == returns true only if both references 
refer to the same object. instanceof Operator (Objective 7.6)
❑ instanceof is for reference variables only, and checks for whether the object 
is of a particular type. ❑ The instanceof operator can be used only to test objects (or null) against 
class types that are in the same class hierarchy. ❑ For interfaces, an object passes the instanceof test if any of its superclasses 
implement the interface on the right side of the instanceof operator. Arithmetic Operators (Objective 7.6)
❑ There are four primary math operators: add, subtract, multiply, and divide. ❑ The remainder operator (%), returns the remainder of a division. ❑ Expressions are evaluated from left to right, unless you add parentheses, or 
unless some operators in the expression have higher precedence than others. ❑ The *, /, and % operators have higher precedence than + and -. T wo-Minute Drill 311
✓
String Concatenation Operator (Objective 7.6)
❑ If either operand is a String, the + operator concatenates the operands. ❑ If both operands are numeric, the + operator adds the operands. Increment/Decrement Operators (Objective 7.6)
❑ Prefix operators (++ and --) run before the value is used in the expression. ❑ Postfix operators (++ and --) run after the value is used in the expression. ❑ In any expression, both operands are fully evaluated before the operator 
is applied. ❑ Variables marked final cannot be incremented or decremented. T ernary (Conditional Operator) (Objective 7.6)
❑ Returns one of two values based on whether a boolean expression is true 
or false. ❑     Returns the value after the ? if the expression is true. ❑     Returns the value after the : if the expression is false. Logical Operators (Objective 7.6)
❑ The exam covers six "logical" operators: &, |, ^, !, &&, and ||. ❑ Logical operators work with two expressions (except for !) that must resolve 
to boolean values. ❑ The && and & operators return true only if both operands are true. ❑ The || and | operators return true if either or both operands are true. ❑ The && and || operators are known as short-circuit operators. ❑ The && operator does not evaluate the right operand if the left operand 
is false. ❑ The || does not evaluate the right operand if the left operand is true. ❑ The & and | operators always evaluate both operands. ❑ The ^ operator (called the "logical XOR"), returns true if exactly one oper-
and is true. ❑ The ! operator (called the "inversion" operator), returns the opposite value of 
the boolean operand it precedes. 312 Chapter 4:  Operators
Self T est 313
SELF TEST
 1. Given:
class Hexy {
  public static void main(String[] args) {
    Integer i = 42;
    String s = (i<40)?"life":(i>50)?"universe":"everything";
    System.out.println(s);
  }
}
  What is the result? A. null
  B. life
  C. universe
   D. everything
  E. Compilation fails
   F. An exception is thrown at runtime
 2. Given:
 1. class Comp2 {
 2. public static void main(String[] args) {
 3. float f1 = 2.3f;
 4. float[][] f2 = {{42.0f}, {1.7f, 2.3f}, {2.6f, 2.7f}};
 5. float[] f3 = {2.7f};
 6. Long x = 42L;
 7. // insert code here
 8. System.out.println("true");
 9. }
10. }
  And the following five code fragments:
F1. if(f1 == f2)
F2. if(f1 == f2[2][1])
F3. if(x == f2[0][0])
F4. if(f1 == f2[1,1])
F5. if(f3 == f2[2])
314 Chapter 4:  Operators
  What is true? A. One of them will compile, only one will be true
  B. T wo of them will compile, only one will be true
  C. T wo of them will compile, two will be true
   D. Three of them will compile, only one will be true
  E. Three of them will compile, exactly two will be true
   F. Three of them will compile, exactly three will be true
 3. Given:
class Fork {
  public static void main(String[] args) {
    if(args.length == 1 | args[1].equals("test")) {
      System.out.println("test case");
    } else {
      System.out.println("production " + args[0]);
    }
  }
}
  And the command-line invocation:
java Fork live2
  What is the result? A.

--- Chunk #1368 ---
test case
  B. production live2
  C. test case live2
   D. Compilation fails
  E.

--- Chunk #1369 ---
An exception is thrown at runtime
 4. Given:
class Feline {
  public static void main(String[] args) {
    Long x = 42L;
    Long y = 44L;
    System.out.print(" " + 7 + 2 + " ");
    System.out.print(foo() + x + 5 + " ");
    System.out.println(x + y + foo());   
  }
  static String foo() { return "foo"; }
}
  What is the result? A.

--- Chunk #1370 ---
9 foo47 86foo
  B. 9 foo47 4244foo
  C. 9 foo425 86foo
   D. 9 foo425 4244foo
  E. 72 foo47 86foo
  F. 72 foo47 4244foo
  G. 72 foo425 86foo
  H. 72 foo425 4244foo 
  I. Compilation fails
 5. Place the fragments into the code to produce the output 33. Note, you must use each fragment 
exactly once. CODE:
class Incr {
  public static void main(String[] args) {
    Integer x = 7;
    int y = 2;
    x    ___  ___;
    ___  ___  ___;
    ___  ___  ___;
    ___  ___  ___;
    System.out.println(x);
  }
}
  FRAGMENTS:
    y    y    y    y
    y    x    x 
    -=   *=   *=   *=
Self T est 315
 6. Given:
 3. public class Twisty {
 4. { index = 1; }
 5. int index;
 6. public static void main(String[] args) {
 7. new Twisty().go();
 8. }
 9. void go() {
10. int [][] dd = {{9,8,7}, {6,5,4}, {3,2,1,0}};
11. System.out.println(dd[index++][index++]);
12. }
13.

--- Chunk #1371 ---
}
  What is the result? (Choose all that apply.)
  A. 1
  B. 2
  C. 4
  D. 6
  E.

--- Chunk #1372 ---
8
  F. Compilation fails
  G. An exception is thrown at runtime
 7. Given:
 3. public class McGee {
 4. public static void main(String[] args) {
 5. Days d1 = Days.TH;
 6. Days d2 = Days.M;
 7. for(Days d: Days.values()) {
 8. if(d.equals(Days.F)) break;
 9. d2 = d;
10.

--- Chunk #1373 ---
}
11. System.out.println((d1 == d2)?"same old" : "newly new");   
12. }
13. enum Days {M, T, W, TH, F, SA, SU};
14. }
  What is the result?

--- Chunk #1374 ---
A.

--- Chunk #1375 ---
same old
  B. newly new
316 Chapter 4:  Operators
  C. Compilation fails due to multiple errors
  D. Compilation fails due only to an error on line 7
  E. Compilation fails due only to an error on line 8
  F. Compilation fails due only to an error on line 11
  G. Compilation fails due only to an error on line 13
 8. Given:
 4. public class SpecialOps {
 5. public static void main(String[] args) {
 6. String s = "";
 7. Boolean b1 = true;
 8. boolean b2 = false;
 9. if((b2 = false) | (21%5) > 2) s += "x";
10. if(b1 || (b2 == true))        s += "y";
11. if(b2 == true)                s += "z";
12. System.out.println(s);
13. }
14. }
  Which are true? (Choose all that apply.)
  A. Compilation fails
  B. x will be included in the output
  C. y will be included in the output
  D. z will be included in the output
  E. An exception is thrown at runtime
 9. Given:
 3. public class Spock {
 4. public static void main(String[] args) {
 5. int mask = 0;
 6. int count = 0;
 7. if( ((5<7) || (++count < 10)) | mask++ < 10 )   mask = mask + 1; 
 8. if(  (6 > 8) ^ false)                           mask = mask + 10;
 9. if( !(mask > 1) && ++count > 1)                 mask = mask + 100;
10. System.out.println(mask + " " + count);
11. }
12. }
Self T est 317
  Which two are true about the value of mask and the value of count at line 10? (Choose two.)
  A. mask is 0
  B. mask is 1
  C. mask is 2
  D. mask is 10
  E. mask is greater than 10
  F. count is 0
  G. count is greater than 0
 10. Given:
 3. interface Vessel { }
 4. interface Toy { }
 5. class Boat implements Vessel { }
 6. class Speedboat extends Boat implements Toy { }
 7. public class Tree {
 8. public static void main(String[] args) {
 9. String s = "0";
10. Boat b = new Boat();
11. Boat b2 = new Speedboat();
12. Speedboat s2 = new Speedboat();
13. if((b instanceof Vessel) && (b2 instanceof Toy))  s += "1";
14. if((s2 instanceof Vessel) && (s2 instanceof Toy)) s += "2";
15. System.out.println(s);
16. }
17. }
  What is the result? A. 0
  B. 01
  C. 02
  D. 012
  E. Compilation fails
  F. An exception is thrown at runtime
318 Chapter 4:  Operators
SELF TEST ANSWERS
 1. Given:
class Hexy {
  public static void main(String[] args) {
    Integer i = 42;
    String s = (i<40)?"life":(i>50)?"universe":"everything";
    System.out.println(s);
  }
}
  What is the result? A. null
  B. life
  C. universe
   D. everything
  E. Compilation fails
   F. An exception is thrown at runtime
Answer:
   ✓   D is correct. This is a ternary nested in a ternary with a little unboxing thrown in. Both of the ternary expressions are false.     A, B, C, E, and F are incorrect based on the above. (Objective 7.6)
 2.

--- Chunk #1376 ---
Given:
 1. class Comp2 {
 2. public static void main(String[] args) {
 3. float f1 = 2.3f;
 4. float[][] f2 = {{42.0f}, {1.7f, 2.3f}, {2.6f, 2.7f}};
 5. float[] f3 = {2.7f};
 6. Long x = 42L;
 7. // insert code here
 8. System.out.println("true");
 9. }
10. }
Self T est Answers 319
  And the following five code fragments:
F1. if(f1 == f2)
F2. if(f1 == f2[2][1])
F3. if(x == f2[0][0])
F4. if(f1 == f2[1,1])
F5. if(f3 == f2[2])
  What is true? A. One of them will compile, only one will be true
  B. T wo of them will compile, only one will be true
  C. T wo of them will compile, two will be true
   D. Three of them will compile, only one will be true
  E. Three of them will compile, exactly two will be true
   F. Three of them will compile, exactly three will be true
Answer:
   ✓   D is correct. Fragments F2, F3, and F5 will compile, and only F3 is true.     A, B, C, E, and F are incorrect. F1 is incorrect because you can’t compare a primitive to 
an array. F4 is incorrect syntax to access an element of a two-dimensional array. (Objective 7.6)
 3. Given:
class Fork {
  public static void main(String[] args) {
    if(args.length == 1 | args[1].equals("test")) {
      System.out.println("test case");
    } else {
      System.out.println("production " + args[0]);
    }
  }
}
  And the command-line invocation:
java Fork live2
  What is the result? A.

--- Chunk #1377 ---
test case
  B. production live2
320 Chapter 4:  Operators
  C. test case live2
   D. Compilation fails
  E. An exception is thrown at runtime
Answer:
   ✓   E is correct. Because the short circuit (||) is not used, both operands are evaluated. Since 
args[1] is past the args array bounds, an ArrayIndexOutOfBoundsException is thrown.     A, B, C, and D are incorrect based on the above.

--- Chunk #1378 ---
(Objective 7.6)
 4. Given:
class Feline {
  public static void main(String[] args) {
    Long x = 42L;
    Long y = 44L;
    System.out.print(" " + 7 + 2 + " ");
    System.out.print(foo() + x + 5 + " ");
    System.out.println(x + y + foo());   
  }
  static String foo() { return "foo"; }
}
  What is the result? A.

--- Chunk #1379 ---
9 foo47 86foo
  B. 9 foo47 4244foo
  C. 9 foo425 86foo
   D. 9 foo425 4244foo
  E. 72 foo47 86foo
  F. 72 foo47 4244foo
  G. 72 foo425 86foo
  H. 72 foo425 4244foo 
  I. Compilation fails
Answer:
   ✓   G is correct. Concatenation runs from left to right, and if either operand is a String, 
the operands are concatenated. If both operands are numbers they are added together. Unboxing works in conjunction with concatenation.     A, B, C, D, E, F, H, and I are incorrect based on the above. (Objective 7.6)
Self T est Answers 321
 5. Place the fragments into the code to produce the output 33. Note, you must use each fragment 
exactly once. CODE:
class Incr {
  public static void main(String[] args) {
    Integer x = 7;
    int y = 2;
    x    ___  ___;
    ___  ___  ___;
    ___  ___  ___;
    ___  ___  ___;
    System.out.println(x);
  }
}
  FRAGMENTS:
    y    y    y    y
    y    x    x 
    -=   *=   *=   *=
Answer:
class Incr {
  public static void main(String[] args) {
    Integer x = 7;
    int y = 2;
    x *= x;
    y *= y;
    y *= y;
    x -= y;
    System.out.println(x);
  }
}
  Yeah, we know it’s kind of puzzle-y, but you might encounter something like it on the real exam. (Objective 7.6)
322 Chapter 4:  Operators
 6.

--- Chunk #1380 ---
Given:
 3. public class Twisty {
 4. { index = 1; }
 5. int index;
 6. public static void main(String[] args) {
 7. new Twisty().go();
 8. }
 9. void go() {
10. int [][] dd = {{9,8,7}, {6,5,4}, {3,2,1,0}};
11. System.out.println(dd[index++][index++]);
12. }
13.

--- Chunk #1381 ---
}
  What is the result? (Choose all that apply.)
  A. 1
  B. 2
  C. 4
  D. 6
  E.

--- Chunk #1382 ---
8
  F. Compilation fails
  G. An exception is thrown at runtime
Answer:
   ✓   C is correct. Multidimensional arrays' dimensions can be inconsistent, the code uses an 
initialization block, and the increment operators are both post-increment operators.     A, B, D, E, F, and G are incorrect based on the above. (Objective 1.3)
 7.

--- Chunk #1383 ---
Given:
 3. public class McGee {
 4. public static void main(String[] args) {
 5. Days d1 = Days.TH;
 6. Days d2 = Days.M;
 7. for(Days d: Days.values()) {
 8. if(d.equals(Days.F)) break;
 9. d2 = d;
10.

--- Chunk #1384 ---
}
11. System.out.println((d1 == d2)?"same old" : "newly new");   
Self T est Answers 323
12. }
13. enum Days {M, T, W, TH, F, SA, SU};
14. }
  What is the result?

--- Chunk #1385 ---
A. same old
  B. newly new
  C. Compilation fails due to multiple errors
  D. Compilation fails due only to an error on line 7
  E. Compilation fails due only to an error on line 8
  F. Compilation fails due only to an error on line 11
  G. Compilation fails due only to an error on line 13
Answer:
   ✓   A is correct. All of this syntax is correct. The for-each iterates through the enum using 
the values() method to return an array. Enums can be compared using either equals() 
or ==. Enums can be used in a ternary operator's Boolean test.     B, C, D, E, F, and G are incorrect based on the above. (Objective 7.6)
 8.

--- Chunk #1386 ---
Given:
 4. public class SpecialOps {
 5. public static void main(String[] args) {
 6. String s = "";
 7. Boolean b1 = true;
 8. Boolean b2 = false;
 9. if((b2 = false) | (21%5) > 2) s += "x";
10. if(b1 || (b2 = true))         s += "y";
11. if(b2 == true)                s += "z";
12. System.out.println(s);
13. }
14. }
  Which are true? (Choose all that apply.)
  A. Compilation fails
  B. x will be included in the output
  C. y will be included in the output
324 Chapter 4:  Operators
  D. z will be included in the output
  E. An exception is thrown at runtime
Answer:
   ✓   C is correct. First of all, boxing takes care of the Boolean. Line 9 uses the modulus operator, 
which returns the remainder of the division, which in this case is 1. Also, line 9 sets b2 to 
false, and it doesn't test b2's value. Line 10 sets b2 to true, and it doesn’t test its value; 
however, the short circuit operator keeps the expression b2 = true from being executed.     A, B, D, and E are incorrect based on the above. (Objective 7.6)
 9.

--- Chunk #1387 ---
Given:
 3. public class Spock {
 4. public static void main(String[] args) {
 5. int mask = 0;
 6. int count = 0;
 7. if( ((5<7) || (++count < 10)) | mask++ < 10 )   mask = mask + 1; 
 8. if(  (6 > 8) ^ false)                           mask = mask + 10;
 9. if( !(mask > 1) && ++count > 1)                 mask = mask + 100;
10. System.out.println(mask + " " + count);
11. }
12. }
  Which two answers are true about the value of mask and the value of count at line 10? (Choose two.)
  A. mask is 0
  B. mask is 1
  C. mask is 2
  D. mask is 10
  E. mask is greater than 10
  F. count is 0
  G. count is greater than 0
Answer:
   ✓   C and F are correct. At line 7 the || keeps count from being incremented, but the 
| allows mask to be incremented. At line 8 the ^ returns true only if exactly one operand 
is true. At line 9 mask is 2 and the && keeps count from being incremented.     A, B, D, E, and G are incorrect based on the above. (Objective 7.6)
Self T est Answers 325
 10.

--- Chunk #1388 ---
Given:
 3. interface Vessel { }
 4. interface Toy { }
 5. class Boat implements Vessel { }
 6. class Speedboat extends Boat implements Toy { }
 7. public class Tree {
 8. public static void main(String[] args) {
 9. String s = "0";
10. Boat b = new Boat();
11. Boat b2 = new Speedboat();
12. Speedboat s2 = new Speedboat();
13. if((b instanceof Vessel) && (b2 instanceof Toy))  s += "1";
14. if((s2 instanceof Vessel) && (s2 instanceof Toy)) s += "2";
15. System.out.println(s);
16. }
17. }
  What is the result? A. 0
  B. 01
  C. 02
  D. 012
  E. Compilation fails
  F. An exception is thrown at runtime
Answer:
   ✓   D is correct. First, remember that instanceof can look up through multiple levels of an 
inheritance tree. Also remember that instanceof is commonly used before attempting 
a downcast, so in this case, after line 15, it would be possible to say Speedboat s3 = 
(Speedboat)b2;.     A, B, C, E, and F are incorrect based on the above. (Objective 7.6)
326 Chapter 4:  Operators
5
Flow Control, 
Exceptions, and 
Assertions
CERTIFICATION OBJECTIVES
 Use if and switch Statements
    Develop for, do, and while Loops
       Use break and continue Statements
 Develop Code with Assertions
   Use try, catch, and finally Statements

 State the Effects of Exceptions
    Recognize Common Exceptions
 ✓   T wo-Minute Drill
          Q&A Self T est
 
	
328 Chapter 5:  Flow Control, Exceptions, and Assertions
C
an you imagine trying to write code using a language that didn't give you a way to 
execute statements conditionally? Flow control is a key part of most any useful 
programming language, and Java offers several ways to do it. Some, like if statements 
and for loops, are common to most languages. But Java also throws in a couple of flow control 
features you might not have used before—exceptions and assertions. The if statement and the switch statement are types of conditional/decision 
controls that allow your program to behave differently at a "fork in the road," 
depending on the result of a logical test. Java also provides three different looping 
constructs—for, while, and do—so you can execute the same code over and 
over again depending on some condition being true. Exceptions give you a clean, 
simple way to organize code that deals with problems that might crop up at runtime. Finally, the assertion mechanism, added to the language with version 1.4, gives you 
a way to do testing and debugging checks on conditions you expect to smoke out 
while developing, when you don't necessarily need or want the runtime overhead 
associated with exception handling. With these tools, you can build a robust program that can handle any logical 
situation with grace. Expect to see a wide range of questions on the exam that 
include flow control as part of the question code, even on questions that aren't 
testing your knowledge of flow control. CERTIFICATION OBJECTIVE
if and switch Statements (Exam Objective 2.1)
2.1 Develop code that implements an if or switch statement; and identify legal argument 
types for these statements. The if and switch statements are commonly referred to as decision statements. When you use decision statements in your program, you're asking the program to 
evaluate a given expression to determine which course of action to take. We'll look 
at the if statement first. if-else Branching (Exam Objective 2.1) 329
if-else Branching
The basic format of an if statement is as follows:
if (booleanExpression) { 
  System.out.println("Inside if statement");
}
The expression in parentheses must evaluate to (a boolean) true or false. Typically you're testing something to see if it's true, and then running a code block 
(one or more statements) if it is true, and (optionally) another block of code if it 
isn't. The following code demonstrates a legal if-else statement:
if (x > 3) {
  System.out.println("x is greater than 3");
} else {
  System.out.println("x is not greater than 3");
}  
The else block is optional, so you can also use the following:
if (x > 3) {
  y = 2;
}
z += 8;
a = y + x;
The preceding code will assign 2 to y if the test succeeds (meaning x really is greater 
than 3), but the other two lines will execute regardless. Even the curly braces 
are optional if you have only one statement to execute within the body of the 
conditional block. The following code example is legal (although not recommended 
for readability):
if (x > 3)    // bad practice, but seen on the exam
  y = 2;
z += 8;
a = y + x;
Sun considers it good practice to enclose blocks within curly braces, even if 
there's only one statement in the block. Be careful with code like the above, because 
you might think it should read as, 
330 Chapter 5:  Flow Control, Exceptions, and Assertions
"If x is greater than 3, then set y to 2, z to z + 8, and a to y + x." 
But the last two lines are going to execute no matter what! They aren't part of the 
conditional flow. You might find it even more misleading if the code were indented 
as follows:
if (x > 3) 
  y = 2;
  z += 8;
  a = y + x;
You might have a need to nest if-else statements (although, again, it's not 
recommended for readability, so nested if tests should be kept to a minimum). You 
can set up an if-else statement to test for multiple conditions. The following 
example uses two conditions so that if the first test fails, we want to perform a 
second test before deciding what to do:
if (price < 300) {
  buyProduct();
} else {
  if (price < 400) {
    getApproval();
  }
  else {
    dontBuyProduct();
  }
}
This brings up the other if-else construct, the if, else if, else. The preceding 
code could (and should) be rewritten:
if (price < 300) {
  buyProduct();
} else if (price < 400) {
    getApproval();
} else {
    dontBuyProduct();
}
There are a couple of rules for using else and else if:
if-else Branching (Exam Objective 2.1) 331
■ You can have zero or one else for a given if, and it must come after any 
else ifs. ■ You can have zero to many else ifs for a given if and they must come 
before the (optional) else. ■ Once an else if succeeds, none of the remaining else ifs or elses will 
be tested. The following example shows code that is horribly formatted for the real world. As you've probably guessed, it's fairly likely that you'll encounter formatting like this 
on the exam. In any case, the code demonstrates the use of multiple else ifs:
int x = 1;
if ( x == 3 ) { }
else if (x < 4) {System.out.println("<4"); }
else if (x < 2) {System.out.println("<2"); }
else { System.out.println("else"); }
It produces the output: 
<4
(Notice that even though the second else if is true, it is never reached.)
Sometimes you can have a problem figuring out which if your else should pair 
with, as follows:
if (exam.done())
if (exam.getScore() < 0.61)
System.out.println("Try again.");
// Which if does this belong to? else System.out.println("Java master!"); 
We intentionally left out the indenting in this piece of code so it doesn't give clues 
as to which if statement the else belongs to. Did you figure it out? Java law decrees 
that an else clause belongs to the innermost if statement to which it might 
possibly belong (in other words, the closest preceding if that doesn't have an else). In the case of the preceding example, the else belongs to the second if statement 
in the listing. With proper indenting, it would look like this:
332 Chapter 5:  Flow Control, Exceptions, and Assertions
if (exam.done())
  if (exam.getScore() < 0.61)
    System.out.println("Try again.");
  // Which if does this belong to? else 
    System.out.println("Java master!"); 
Following our coding conventions by using curly braces, it would be even easier to read:
if (exam.done()) {
  if (exam.getScore() < 0.61) {
    System.out.println("Try again.");
  // Which if does this belong to? } else {
    System.out.println("Java master!"); 
  }
}
Don't get your hopes up about the exam questions being all nice and indented 
properly. Some exam takers even have a slogan for the way questions are presented 
on the exam: anything that can be made more confusing, will be. Be prepared for questions that not only fail to indent nicely, but intentionally 
indent in a misleading way: Pay close attention for misdirection like the following:
if (exam.done())
  if (exam.getScore() < 0.61)
    System.out.println("Try again.");
else
  System.out.println("Java master!"); // Hmmmmm… now where does
                                      // it belong? Of course, the preceding code is exactly the same as the previous two examples, 
except for the way it looks. Legal Expressions for if Statements
The expression in an if statement must be a boolean expression. Any expression 
that resolves to a boolean is fine, and some of the expressions can be complex. Assume doStuff() returns true,
int y = 5;
int x = 2;
if-else Branching (Exam Objective 2.1) 333
if (((x > 3) && (y < 2)) | doStuff()) { 
   System.out.println("true");
}
which prints
true
You can read the preceding code as, "If both (x > 3) and (y < 2) are true, or if the 
result of doStuff() is true, then print true." So basically, if just doStuff() alone 
is true, we'll still get true. If doStuff() is false, though, then both (x > 3) and 
(y < 2) will have to be true in order to print true. The preceding code is even 
more complex if you leave off one set of parentheses as follows,
int y = 5;
int x = 2;
if ((x > 3) && (y < 2) | doStuff()) { 
  System.out.println("true");
}
which now prints…nothing! Because the preceding code (with one less set of 
parentheses) evaluates as though you were saying, "If (x > 3) is true, and either 
(y < 2) or the result of doStuff() is true, then print true." So if (x > 3) is not 
true, no point in looking at the rest of the expression." Because of the short-circuit 
&&, the expression is evaluated as though there were parentheses around (y < 2) | 
doStuff(). In other words, it is evaluated as a single expression before the && and a 
single expression after the &&. Remember that the only legal expression in an if test is a boolean. In some 
languages, 0 == false, and 1 == true. Not so in Java! The following code shows if 
statements that might look tempting, but are illegal, followed by legal substitutions:
int trueInt = 1;
int falseInt = 0;
if (trueInt)             // illegal
if (trueInt == true)     // illegal
if (1)         // illegal
if (falseInt == false)   // illegal
if (trueInt == 1)        // legal
if (falseInt == 0)       // legal
334 Chapter 5:  Flow Control, Exceptions, and Assertions
switch Statements 
A way to simulate the use of multiple if statements is with the switch statement. Take a look at the following if-else code, and notice how confusing it can be to 
have nested if tests, even just a few levels deep:
int x = 3;
if(x == 1) {
One common mistake programmers make (and that can be difﬁ cult to 
spot), is assigning a boolean variable when you meant to test a boolean variable. Look 
out for code like the following:
boolean boo = false;
if (boo = true) { }
You might think one of three things:
1. The code compiles and runs ﬁ  ne, and the if test fails because 
boo is false. 2. The code won’t compile because you’re using an assignment (=) 
rather than an equality test (==). 3. The code compiles and runs ﬁ  ne and the if test succeeds because 
boo is SET to true (rather than TESTED for true) in the if argument! Well, number 3 is correct. Pointless, but correct. Given that the result of any assignment is 
the value of the variable after the assignment, the expression (boo = true) has a result 
of true. Hence, the if test succeeds. But the only variables that can be assigned (rather 
than tested against something else) are a boolean or a Boolean; all other assignments 
will result in something non-boolean, so they’re not legal, as in the following:
int x = 3;
if (x = 5) { }  // Won't compile because x is not a boolean! Because if tests require boolean expressions, you need to be really solid 
on both logical operators and if test syntax and semantics. switch Statements (Exam Objective 2.1) 335
  System.out.println("x equals 1");
}
else if(x == 2) {
      System.out.println("x equals 2");
   }
   else if(x == 3) {
         System.out.println("x equals 3");
      }
      else {
         System.out.println("No idea what x is");
      }
Now let's see the same functionality represented in a switch construct:
int x = 3;
switch (x) {
   case 1:
      System.out.println("x is equal to 1");
      break;
   case 2:
      System.out.println("x is equal to 2");
      break;
   case 3:
      System.out.println("x is equal to 3");
      break;
   default:
      System.out.println("Still no idea what x is");
}
Note: The reason this switch statement emulates the nested ifs listed earlier is 
because of the break statements that were placed inside of the switch. In general, 
break statements are optional, and as we will see in a few pages, their inclusion or 
exclusion causes huge changes in how a switch statement will execute. Legal Expressions for switch and case
The general form of the switch statement is:
switch (expression) {
  case constant1: code block
  case constant2: code block
  default: code block
}
336 Chapter 5:  Flow Control, Exceptions, and Assertions
A switch's expression must evaluate to a char, byte, short, int, or, as of Java 
6, an enum. That means if you're not using an enum, only variables and values 
that can be automatically promoted (in other words, implicitly cast) to an int are 
acceptable. You won't be able to compile if you use anything else, including the 
remaining numeric types of long, float, and double. A case constant must evaluate to the same type as the switch expression can 
use, with one additional—and big—constraint: the case constant must be a 
compile time constant! Since the case argument has to be resolved at compile 
time, that means you can use only a constant or final variable that is assigned a 
literal value. It is not enough to be final, it must be a compile time constant. For 
example:
final int a = 1;
final int b;
b = 2;
int x = 0;
switch (x) {
  case a:     // ok
  case b:     // compiler error
Also, the switch can only check for equality. This means that the other relational 
operators such as greater than are rendered unusable in a case. The following is an 
example of a valid expression using a method invocation in a switch statement. Note that for this code to be legal, the method being invoked on the object 
reference must return a value compatible with an int. String s = "xyz";
switch (s.length()) {
  case 1:  
    System.out.println("length is one");  
    break;
  case 2:
    System.out.println("length is two"); 
    break;
  case 3:
    System.out.println("length is three"); 
    break;
  default: 
    System.out.println("no match");
}
switch Statements (Exam Objective 2.1) 337
One other rule you might not expect involves the question, "What happens if I 
switch on a variable smaller than an int?" Look at the following switch:
byte g = 2;
switch(g) {
  case 23: 
  case 128:
}
This code won't compile. Although the switch argument is legal—a byte is 
implicitly cast to an int—the second case argument (128) is too large for a byte, 
and the compiler knows it! Attempting to compile the preceding example gives 
you an error something like
Test.java:6: possible loss of precision
found   : int
required: byte
    case 128:
         ^
It's also illegal to have more than one case label using the same value. For example, 
the following block of code won't compile because it uses two cases with the same 
value of 80:
int temp = 90;
switch(temp) {
  case 80 :  System.out.println("80");
  case 80 :  System.out.println("80");   // won't compile! case 90 :  System.out.println("90");
  default :  System.out.println("default");
}
It is legal to leverage the power of boxing in a switch expression. For instance, 
the following is legal:
switch(new Integer(4)) {
  case 4: System.out.println("boxing is OK");
}
338 Chapter 5:  Flow Control, Exceptions, and Assertions
Break and Fall-Through in switch Blocks
We're finally ready to discuss the break statement, and more details about flow 
control within a switch statement. The most important thing to remember about 
the flow of execution through a switch statement is this:
case constants are evaluated from the top down, and the first case constant 
that matches the switch's expression is the execution entry point. In other words, once a case constant is matched, the JVM will execute the 
associated code block, and ALL subsequent code blocks (barring a break statement) 
too! The following example uses an enum in a case statement. enum Color {red, green, blue}
class SwitchEnum {
  public static void main(String [] args) {
    Color c = Color.green;
    switch(c) {
Look for any violation of the rules for switch and case arguments. For example, you might ﬁ  nd illegal examples like the following snippets:
switch(x) {
  case 0 {
    y = 7;
  }
}
switch(x) {
  0: { }
  1: { }
}
 In the ﬁ  rst example, the case uses a curly brace and omits the colon. The second example omits the keyword case. switch Statements (Exam Objective 2.1) 339
      case red: System.out.print("red ");
      case green: System.out.print("green ");
      case blue: System.out.print("blue ");
      default: System.out.println("done");
    }
  }
}
In this example case green: matched, so the JVM executed that code block and 
all subsequent code blocks to produce the output:
green blue done
Again, when the program encounters the keyword break during the execution 
of a switch statement, execution will immediately move out of the switch block 
to the next statement after the switch. If break is omitted, the program just 
keeps executing the remaining case blocks until either a break is found or the 
switch statement ends. Examine the following code:
int x = 1;
switch(x) {
  case 1:  System.out.println("x is one");
  case 2:  System.out.println("x is two");
  case 3:  System.out.println("x is three");
}
System.out.println("out of the switch");
The code will print the following:
x is one
x is two
x is three
out of the switch
This combination occurs because the code didn't hit a break statement; execution 
just kept dropping down through each case until the end. This dropping down is 
actually called "fall-through," because of the way execution falls from one case to 
the next. Remember, the matching case is simply your entry point into the switch 
block! In other words, you must not think of it as, "Find the matching case, execute 
just that code, and get out." That's not how it works. If you do want that "just the 
matching code" behavior, you'll insert a break into each case as follows:
340 Chapter 5:  Flow Control, Exceptions, and Assertions
int x = 1;
switch(x) {
  case 1:  { 
    System.out.println("x is one");  break;
  }
  case 2:  {
    System.out.println("x is two");  break;
  }
  case 3:  {
    System.out.println("x is two");  break;
  }
}
System.out.println("out of the switch");
Running the preceding code, now that we've added the break statements, will print
x is one
out of the switch
and that's it. We entered into the switch block at case 1. Because it matched the 
switch() argument, we got the println statement, then hit the break and jumped 
to the end of the switch. An interesting example of this fall-through logic is shown in the following code:
int x = someNumberBetweenOneAndTen;
switch (x) {
  case 2:
  case 4:
  case 6:
  case 8:
  case 10: {
    System.out.println("x is an even number");  break;
  }
}
This switch statement will print x is an even number or nothing, depending on 
whether the number is between one and ten and is odd or even. For example, if x is 
4, execution will begin at case 4, but then fall down through 6, 8, and 10, where 
it prints and then breaks. The break at case 10, by the way, is not needed; we're 
already at the end of the switch anyway. Note: Because fall-through is less than intuitive, Sun recommends that you add a 
comment like:  // fall through when you use fall-through logic. switch Statements (Exam Objective 2.1) 341
The Default Case
What if, using the preceding code, you wanted to print "x is an odd number" 
if none of the cases (the even numbers) matched? You couldn't put it after the 
switch statement, or even as the last case in the switch, because in both of those 
situations it would always print x is an odd number. To get this behavior, you'll 
use the default keyword. (By the way, if you've wondered why there is a default 
keyword even though we don't use a modifier for default access control, now you'll 
see that the default keyword is used for a completely different purpose.) The only 
change we need to make is to add the default case to the preceding code:
int x = someNumberBetweenOneAndTen;
switch (x) {
  case 2:
  case 4:
  case 6:
  case 8:
  case 10: {
    System.out.println("x is an even number");
    break;
  }
  default: System.out.println("x is an odd number");
}
The default case doesn’t have to come at the end of the switch. Look for it in strange places such as the following:
int x = 2;
switch (x) {
  case 2:  System.out.println("2");
  default: System.out.println("default");
  case 3: System.out.println("3");
  case 4: System.out.println("4");
}
342 Chapter 5:  Flow Control, Exceptions, and Assertions
EXERCISE 5-1
Creating a switch-case Statement
Try creating a switch statement using a char value as the case. Include a default 
behavior if none of the char values match. ■ Make sure a char variable is declared before the switch statement. ■ Each case statement should be followed by a break. ■ The default case can be located at the end, middle, or top. Running the preceding code prints
2
default
3
4
And if we modify it so that the only match is the default case:
int x = 7;
switch (x) {
  case 2:  System.out.println("2");
  default: System.out.println("default");
  case 3: System.out.println("3");
  case 4: System.out.println("4");
}
Running the preceding code prints
default
3
4
The rule to remember is that default works just like any other case 
for fall-through! Using while Loops (Exam Objective 2.2) 343
CERTIFICATION OBJECTIVE
Loops and Iterators (Exam Objective 2.2)
2.2 Develop code that implements all forms of loops and iterators, including the use of 
for, the enhanced for loop (for-each), do, while, labels, break, and continue; and explain 
the values taken by loop counter variables during and after loop execution. Java loops come in three flavors: while, do, and for (and as of Java 6, the for 
loop has two variations). All three let you repeat a block of code as long as some 
condition is true, or for a specific number of iterations. You're probably familiar with 
loops from other languages, so even if you're somewhat new to Java, these won't be a 
problem to learn. Using while Loops
The while loop is good for scenarios where you don't know how many times a 
block or statement should repeat, but you want to continue looping as long as some 
condition is true. A while statement looks like this:
while (expression) {
  // do stuff
}
            or 
int x = 2;
while(x == 2) {
  System.out.println(x);
  ++x;
}
In this case, as in all loops, the expression (test) must evaluate to a boolean 
result. The body of the while loop will only execute if the expression (sometimes 
called the "condition") results in a value of true. Once inside the loop, the loop 
body will repeat until the condition is no longer met because it evaluates to false. In the previous example, program control will enter the loop body because x is equal 
to 2. However, x is incremented in the loop, so when the condition is checked again 
it will evaluate to false and exit the loop. 344 Chapter 5:  Flow Control, Exceptions, and Assertions
Any variables used in the expression of a while loop must be declared before the 
expression is evaluated. In other words, you can't say
while (int x = 2) { }   // not legal
Then again, why would you? Instead of testing the variable, you'd be declaring 
and initializing it, so it would always have the exact same value. Not much of a 
test condition! The key point to remember about a while loop is that it might not ever run. If 
the test expression is false the first time the while expression is checked, the loop 
body will be skipped and the program will begin executing at the first statement after 
the while loop. Look at the following example:
int x = 8;
while (x > 8) {
  System.out.println("in the loop");
  x = 10;
}
System.out.println("past the loop");
Running this code produces
past the loop
Because the expression (x > 8) evaluates to false, none of the code within the 
while loop ever executes. Using do Loops
The do loop is similar to the while loop, except that the expression is not evaluated 
until after the do loop's code is executed. Therefore the code in a do loop is 
guaranteed to execute at least once. The following shows a do loop in action:
do {
   System.out.println("Inside loop");
} while(false);
The System.out.println()  statement will print once, even though the 
expression evaluates to false. Remember, the do loop will always run the code 
in the loop body at least once. Be sure to note the use of the semicolon at the 
end of the while expression. Using for Loops (Exam Objective 2.2) 345
Using for Loops
As of Java 6, the for loop took on a second structure. We'll call the old style of for 
loop the "basic for loop", and we'll call the new style of for loop the "enhanced 
for loop" (even though the Sun objective 2.2 refers to it as the for-each). Depending on what documentation you use (Sun's included), you'll see both terms, 
along with for-in. The terms for-in, for-each, and "enhanced for" all refer to 
the same Java construct. The basic for loop is more flexible than the enhanced for loop, but the 
enhanced for loop was designed to make iterating through arrays and collections 
easier to code. The Basic for Loop
The for loop is especially useful for flow control when you already know how 
many times you need to execute the statements in the loop's block. The for loop 
declaration has three main parts, besides the body of the loop:
■ Declaration and initialization of variables
■ The boolean expression (conditional test)
■ The iteration expression
The three for declaration parts are separated by semicolons. The following two 
examples demonstrate the for loop. The first example shows the parts of a for loop 
in a pseudocode form, and the second shows a typical example of a for loop. As with if tests, look for while loops (and the while test in a do loop) 
with an expression that does not resolve to a boolean. Take a look at the following 
examples of legal and illegal while expressions:
int x = 1;
while (x) { }        // Won't compile; x is not a boolean
while (x = 5) { }    // Won't compile; resolves to 5 
                     //(as the result of assignment)
while (x == 5) { }   // Legal, equality test
while (true) { }     // Legal
346 Chapter 5:  Flow Control, Exceptions, and Assertions
for (/*Initialization*/ ; /*Condition*/ ;  /* Iteration */) {
  /* loop body */
}
for (int i = 0; i<10; i++) {
  System.out.println("i is " + i);
}
The Basic for Loop: Declaration and Initialization
The first part of the for statement lets you declare and initialize zero, one, or 
multiple variables of the same type inside the parentheses after the for keyword. If 
you declare more than one variable of the same type, then you'll need to separate 
them with commas as follows:
for (int x = 10, y = 3; y > 3; y++) { } 
The declaration and initialization happens before anything else in a for loop. And 
whereas the other two parts—the boolean test and the iteration expression—will 
run with each iteration of the loop, the declaration and initialization happens just 
once, at the very beginning. You also must know that the scope of variables declared 
in the for loop ends with the for loop! The following demonstrates this:
for (int x = 1; x < 2; x++) {
  System.out.println(x);  // Legal
}
System.out.println(x);  // Not Legal! x is now out of scope 
                        // and can't be accessed. If you try to compile this, you'll get something like this:
Test.java:19: cannot resolve symbol
symbol  : variable x  
location: class Test
  System.out.println(x);
                     ^
Basic for Loop: Conditional (boolean) Expression 
The next section that executes is the conditional expression, which (like all 
other conditional tests) must evaluate to a boolean value. You can have only one 
Using for Loops (Exam Objective 2.2) 347
logical expression, but it can be very complex. Look out for code that uses logical 
expressions like this:
for (int x = 0; ((((x < 10) && (y-- > 2)) | x == 3)); x++) { }
The preceding code is legal, but the following is not:
for (int x = 0; (x > 5), (y < 2); x++) { } // too many
                                           //expressions
The compiler will let you know the problem:
TestLong.java:20: ';' expected
for (int x = 0; (x > 5), (y < 2); x++) { } 
                       ^
The rule to remember is this:  You can have only one test expression. In other words, you can't use multiple tests separated by commas, even though 
the other two parts of a for statement can have multiple parts. Basic for Loop: Iteration Expression
After each execution of the body of the for loop, the iteration expression is 
executed. This is where you get to say what you want to happen with each iteration 
of the loop. Remember that it always happens after the loop body runs! Look at the 
following:
for (int x = 0; x < 1; x++) {
  // body code that doesn't change the value of x
}
The preceding loop executes just once. The first time into the loop x is set to 0, 
then x is tested to see if it's less than 1 (which it is), and then the body of the 
loop executes. After the body of the loop runs, the iteration expression runs, 
incrementing x by 1. Next, the conditional test is checked, and since the result is 
now false, execution jumps to below the for loop and continues on. Keep in mind that barring a forced exit, evaluating the iteration expression and 
then evaluating the conditional expression are always the last two things that 
happen in a for loop! 348 Chapter 5:  Flow Control, Exceptions, and Assertions
Examples of forced exits include a break, a return, a System.exit(), or an 
exception, which will all cause a loop to terminate abruptly, without running the 
iteration expression. Look at the following code:
static boolean doStuff() {
  for (int x = 0; x < 3; x++) {
    System.out.println("in for loop");
    return true;
  }
  return true;
}
Running this code produces
in for loop
The statement only prints once, because a return causes execution to leave not just 
the current iteration of a loop, but the entire method. So the iteration expression 
never runs in that case. Table 5-1 lists the causes and results of abrupt loop 
termination. Basic for Loop: for Loop Issues
None of the three sections of the for declaration are required! The following 
example is perfectly legal (although not necessarily good practice):
for( ; ; ) {
  System.out.println("Inside an endless loop");
}
In the preceding example, all the declaration parts are left out so the for loop will 
act like an endless loop. For the exam, it's important to know that with the absence 
Code in Loop What Happens
break Execution jumps immediately to the 1st statement after the for loop. return Execution jumps immediately back to the calling method. System.exit() All program execution stops; the VM shuts down. TABLE 5-1    Causes of Early Loop T ermination
Using for Loops (Exam Objective 2.2) 349
of the initialization and increment sections, the loop will act like a while loop. The 
following example demonstrates how this is accomplished:
int i = 0;
for (;i<10;) {
  i++;
  //do some other work
}
The next example demonstrates a for loop with multiple variables in play. A 
comma separates the variables, and they must be of the same type. Remember that 
the variables declared in the for statement are all local to the for loop, and can't 
be used outside the scope of the loop. for (int i = 0,j = 0; (i<10) && (j<10); i++, j++) {
  System.out.println("i is " + i + " j is " +j);
}
 
The last thing to note is that all three sections of the for loop are independent of 
each other. The three expressions in the for statement don't need to operate on the 
same variables, although they typically do. But even the iterator expression, which 
Variable scope plays a large role in the exam. You need to know that a 
variable declared in the for loop can’t be used beyond the for loop. But a variable only 
initialized in the for statement (but declared earlier) can be used beyond the loop. For 
example, the following is legal,
int x = 3;
for (x = 12; x < 20; x++) { }
System.out.println(x);
while this is not
for (int x = 3; x < 20; x++) { } System.out.println(x);
350 Chapter 5:  Flow Control, Exceptions, and Assertions
many mistakenly call the "increment expression," doesn't need to increment or set 
anything; you can put in virtually any arbitrary code statements that you want to 
happen with each iteration of the loop. Look at the following:
int b = 3;
for (int a = 1;  b != 1; System.out.println("iterate")) {
  b = b - a;
}
The preceding code prints
iterate
iterate
The Enhanced for Loop (for Arrays)
 The enhanced for loop, new to Java 6, is a specialized for loop that simplifies 
looping through an array or a collection. In this chapter we're going to focus on 
using the enhanced for to loop through arrays. In Chapter 7 we'll revisit the 
enhanced for as we discuss collections—where the enhanced for really comes into 
its own. Instead of having three components, the enhanced for has two. Let's loop 
through an array the basic (old) way, and then using the enhanced for:
int [] a = {1,2,3,4};
for(int x = 0; x < a.length; x++)   // basic for loop
  System.out.print(a[x]);
for(int n : a)                      // enhanced for loop
  System.out.print(n);
Many questions in the new (Java 6) exam list “Compilation fails” and 
“An exception occurs at runtime” as possible answers. This makes it more difﬁ  cult 
because you can’t simply work through the behavior of the code.

--- Chunk #1389 ---
You must ﬁ  rst make 
sure the code isn’t violating any fundamental rules that will lead to compiler error, 
and then look for possible exceptions. Only after you’ve satisﬁ  ed those two, should 
you dig into the logic and ﬂ  ow of the code in the question. Using for Loops (Exam Objective 2.2) 351
Which produces this output:
12341234
More formally, let's describe the enhanced for as follows:
for(declaration : expression)
The two pieces of the for statement are
■ declaration The newly declared block variable, of a type compatible with 
the elements of the array you are accessing. This variable will be available 
within the for block, and its value will be the same as the current array 
element. ■ expression This must evaluate to the array you want to loop through. This could be an array variable or a method call that returns an array. The 
array can be any type: primitives, objects, even arrays of arrays. Using the above definitions, let's look at some legal and illegal enhanced for 
declarations:
int x;  
long x2;
Long [] La = {4L, 5L, 6L};
long [] la = {7L, 8L, 9L};
int [][] twoDee = {{1,2,3}, {4,5,6}, {7,8,9}};
String [] sNums = {"one", "two", "three"};
Animal [] animals = {new Dog(), new Cat()};
// legal 'for' declarations
for(long y : la ) ;        // loop thru an array of longs
for(long lp : La) ;        // autoboxing the Long objects 
                           // into longs
for(int[] n : twoDee) ;    // loop thru the array of arrays
for(int n2 : twoDee[2]) ;  // loop thru the 3rd sub-array
for(String s : sNums) ;    // loop thru the array of Strings
for(Object o : sNums) ;    // set an Object reference to
                           // each String
for(Animal a : animals) ;  // set an Animal reference to each 
                           // element
352 Chapter 5:  Flow Control, Exceptions, and Assertions
// ILLEGAL 'for' declarations
for(x2 : la) ;             // x2 is already declared
for(int x2 : twoDee) ;     // can't stuff an array into an int
for(int x3 : la) ;         // can't stuff a long into an int
for(Dog d : animals) ;     // you might get a Cat! The enhanced for loop assumes that, barring an early exit from the loop, you'll 
always loop through every element of the array.

--- Chunk #1390 ---
The following discussions of break 
and continue apply to both the basic and enhanced for loops. Using break and continue
The break and continue keywords are used to stop either the entire loop 
(break) or just the current iteration (continue). Typically if you're using break 
or continue, you'll do an if test within the loop, and if some condition becomes 
true (or false depending on the program), you want to get out immediately. The 
difference between them is whether or not you continue with a new iteration or 
jump to the first statement below the loop and continue from there. The break statement causes the program to stop execution of the innermost loop 
and start processing the next line of code after the block. The continue statement causes only the current iteration of the innermost loop 
to cease and the next iteration of the same loop to start if the condition of the loop 
is met. When using a continue statement with a for loop, you need to consider the 
effects that continue has on the loop iteration. Examine the following code:
for (int i = 0; i < 10; i++) {
  System.out.println("Inside loop");
  continue;
}
The question is, is this an endless loop? The answer is no. When the continue 
statement is hit, the iteration expression still runs! It runs just as though the current 
Remember, continue statements must be inside a loop; otherwise, 
you’ll get a compiler error. break statements must be used inside either a loop or 
switch statement. (Note: this does not apply to labeled break statements.). Unlabeled Statements (Exam Objective 2.2) 353
iteration ended "in the natural way." So in the preceding example, i will still 
increment before the condition (i < 10) is checked again. Most of the time, a 
continue is used within an if test as follows:
for (int i = 0; i < 10; i++) {
  System.out.println("Inside loop");
  if (foo.doStuff() == 5) {
    continue;
  }
  // more loop code, that won't be reached when the above if 
  // test is true
}
Unlabeled Statements
Both the break statement and the continue statement can be unlabeled or 
labeled. Although it's far more common to use break and continue unlabeled, the 
exam expects you to know how labeled break and continue statements work. As 
stated before, a break statement (unlabeled) will exit out of the innermost looping 
construct and proceed with the next line of code beyond the loop block. The 
following example demonstrates a break statement:
boolean problem = true;
while (true) {
  if (problem) {
    System.out.println("There was a problem");
    break;
  }
}
// next line of code
In the previous example, the break statement is unlabeled. The following is an 
example of an unlabeled continue statement:
while (!EOF) {
  //read a field from a file
  if (wrongField) {
    continue;    // move to the next field in the file
  }
  // otherwise do other stuff with the field
}
354 Chapter 5:  Flow Control, Exceptions, and Assertions
In this example, a file is being read one field at a time. When an error is 
encountered, the program moves to the next field in the file and uses the continue 
statement to go back into the loop (if it is not at the end of the file) and keeps 
reading the various fields. If the break command were used instead, the code would 
stop reading the file once the error occurred and move on to the next line of code 
after the loop. The continue statement gives you a way to say, "This particular 
iteration of the loop needs to stop, but not the whole loop itself. I just don't want the 
rest of the code in this iteration to finish, so do the iteration expression and then start 
over with the test, and don't worry about what was below the continue statement."
Labeled Statements
Although many statements in a Java program can be labeled, it's most common to 
use labels with loop statements like for or while, in conjunction with break and 
continue statements. A label statement must be placed just before the statement 
being labeled, and it consists of a valid identifier that ends with a colon (:). You need to understand the difference between labeled and unlabeled break and 
continue. The labeled varieties are needed only in situations where you have a 
nested loop, and need to indicate which of the nested loops you want to break from, 
or from which of the nested loops you want to continue with the next iteration. A 
break statement will exit out of the labeled loop, as opposed to the innermost loop, 
if the break keyword is combined with a label. An example of what a label looks 
like is in the following code:
foo:
  for (int x = 3; x < 20; x++) {
    while(y > 7) {
      y--;
    }
  }
The label must adhere to the rules for a valid variable name and should adhere to the 
Java naming convention. The syntax for the use of a label name in conjunction with a 
break statement is the break keyword, then the label name, followed by a semicolon. A more complete example of the use of a labeled break statement is as follows:
boolean isTrue = true;
outer:
  for(int i=0; i<5; i++) {
    while (isTrue) {
Labeled Statements (Exam Objective 2.2) 355
      System.out.println("Hello");
      break outer;
    } // end of inner while loop
    System.out.println("Outer loop."); // Won't print
  } // end of outer for loop
System.out.println("Good-Bye");
Running this code produces
Hello
Good-Bye
In this example the word Hello will be printed one time. Then, the labeled 
break statement will be executed, and the flow will exit out of the loop labeled 
outer. The next line of code will then print out Good-Bye. Let's see what will 
happen if the continue statement is used instead of the break statement. The 
following code example is similar to the preceding one, with the exception of 
substituting continue for break:
outer:
  for (int i=0; i<5; i++) {
    for (int j=0; j<5; j++) {
      System.out.println("Hello");
      continue outer;
    } // end of inner loop
    System.out.println("outer"); // Never prints
  }
System.out.println("Good-Bye");
Running this code produces
Hello
Hello
Hello
Hello
Hello
Good-Bye
In this example, Hello will be printed five times. After the continue statement is 
executed, the flow continues with the next iteration of the loop identified with the 
label. Finally, when the condition in the outer loop evaluates to false, this loop 
will finish and Good-Bye will be printed. 356 Chapter 5:  Flow Control, Exceptions, and Assertions
EXERCISE 5-2
Creating a Labeled while Loop
Try creating a labeled while loop. Make the label outer and provide a condition to 
check whether a variable age is less than or equal to 21. Within the loop, increment  
age by one. Every time the program goes through the loop, check whether age is 16. If it is, print the message "get your driver's license" and continue to the outer loop. If 
not, print "Another year."
■ The outer label should appear just before the while loop begins. ■ Make sure age is declared outside of the while loop. CERTIFICATION OBJECTIVE
Handling Exceptions (Exam Objectives 2.4 and 2.5)
2.4 Develop code that makes use of exceptions and exception handling clauses (try, catch, 
finally), and declares methods and overriding methods that throw exceptions. 2.5 Recognize the effect of an exception arising at a specific point in a code fragment. Note that the exception may be a runtime exception, a checked exception, or an error. An old maxim in software development says that 80 percent of the work is used 
20 percent of the time. The 80 percent refers to the effort required to check and 
handle errors. In many languages, writing program code that checks for and deals 
with errors is tedious and bloats the application source into confusing spaghetti. Labeled continue and break statements must be inside the loop that 
has the same label name; otherwise, the code will not compile. Still, error detection and handling may be the most important ingredient of any 
robust application. Java arms developers with an elegant mechanism for handling 
errors that produces efficient and organized error-handling code: exception handling. Exception handling allows developers to detect errors easily without writing 
special code to test return values. Even better, it lets us keep exception-handling code 
cleanly separated from the exception-generating code. It also lets us use the same 
exception-handling code to deal with a range of possible exceptions. The exam has three objectives covering exception handling. We'll cover the first 
two in this section, and in the next section we'll cover those aspects of exception 
handling that are new to the exam as of Java 6. Catching an Exception Using try and catch
Before we begin, let's introduce some terminology. The term "exception" means 
"exceptional condition" and is an occurrence that alters the normal program flow. A bunch of things can lead to exceptions, including hardware failures, resource 
exhaustion, and good old bugs. When an exceptional event occurs in Java, an 
exception is said to be "thrown." The code that's responsible for doing something 
about the exception is called an "exception handler," and it "catches" the thrown 
exception. Exception handling works by transferring the execution of a program to an 
appropriate exception handler when an exception occurs. For example, if you call 
a method that opens a file but the file cannot be opened, execution of that method 
will stop, and code that you wrote to deal with this situation will be run. Therefore, 
we need a way to tell the JVM what code to execute when a certain exception 
happens. To do this, we use the try and catch keywords. The try is used to define a 
block of code in which exceptions may occur. This block of code is called a guarded 
region (which really means "risky code goes here"). One or more catch clauses 
match a specific exception (or group of exceptions—more on that later) to a block 
of code that handles it. Here's how it looks in pseudocode:
 1. try {
 2. // This is the first line of the "guarded region"
 3. // that is governed by the try keyword. 4. // Put code here that might cause some kind of exception. 5. // We may have many code lines here or just one. 6.

--- Chunk #1391 ---
}
 7. catch(MyFirstException) {
 8. // Put code here that handles this exception. Catching an Exception Using try and catch (Exam Objectives 2.4 and 2.5) 357
358 Chapter 5:  Flow Control, Exceptions, and Assertions
 9. // This is the next line of the exception handler. 10. // This is the last line of the exception handler. 11. }
12. catch(MySecondException) {
13. // Put code here that handles this exception
14. }
15.

--- Chunk #1392 ---
16. // Some other unguarded (normal, non-risky) code begins here
In this pseudocode example, lines 2 through 5 constitute the guarded region that 
is governed by the try clause. Line 7 is an exception handler for an exception of 
type MyFirstException. Line 12 is an exception handler for an exception of type 
MySecondException. Notice that the catch blocks immediately follow the try 
block. This is a requirement; if you have one or more catch blocks, they must 
immediately follow the try block. Additionally, the catch blocks must all follow 
each other, without any other statements or blocks in between. Also, the order in 
which the catch blocks appear matters, as we'll see a little later. Execution of the guarded region starts at line 2. If the program executes all the 
way past line 5 with no exceptions being thrown, execution will transfer to line 
15 and continue downward. However, if at any time in lines 2 through 5 (the try 
block) an exception is thrown of type MyFirstException, execution will immediately 
transfer to line 7. Lines 8 through 10 will then be executed so that the entire catch 
block runs, and then execution will transfer to line 15 and continue. Note that if an exception occurred on, say, line 3 of the try block, the rest of 
the lines in the try block (4 and 5) would never be executed. Once control jumps 
to the catch block, it never returns to complete the balance of the try block. This is exactly what you want, though. Imagine your code looks something like 
this pseudocode:
try {
  getTheFileFromOverNetwork
  readFromTheFileAndPopulateTable
}
catch(CantGetFileFromNetwork) {
  displayNetworkErrorMessage
}
The preceding pseudocode demonstrates how you typically work with exceptions. Code that's dependent on a risky operation (as populating a table with file data is 
dependent on getting the file from the network) is grouped into a try block in such 
a way that if, say, the first operation fails, you won't continue trying to run other 
code that's also guaranteed to fail. In the pseudocode example, you won't be able to 
read from the file if you can't get the file off the network in the first place. One of the benefits of using exception handling is that code to handle any 
particular exception that may occur in the governed region needs to be written only 
once. Returning to our earlier code example, there may be three different places 
in our try block that can generate a MyFirstException, but wherever it occurs it 
will be handled by the same catch block (on line 7). We'll discuss more benefits of 
exception handling near the end of this chapter. Using ﬁ nally
Although try and catch provide a terrific mechanism for trapping and handling 
exceptions, we are left with the problem of how to clean up after ourselves if an 
exception occurs. Because execution transfers out of the try block as soon as an 
exception is thrown, we can't put our cleanup code at the bottom of the try block 
and expect it to be executed if an exception occurs. Almost as bad an idea would be 
placing our cleanup code in each of the catch blocks—let's see why. Exception handlers are a poor place to clean up after the code in the try block 
because each handler then requires its own copy of the cleanup code. If, for example, 
you allocated a network socket or opened a file somewhere in the guarded region, 
each exception handler would have to close the file or release the socket. That 
would make it too easy to forget to do cleanup, and also lead to a lot of redundant 
code. To address this problem, Java offers the finally block. A finally block encloses code that is always executed at some point after the 
try block, whether an exception was thrown or not. Even if there is a return 
statement in the try block, the finally block executes right after the return 
statement is encountered, and before the return executes! This is the right place to close your files, release your network sockets, and 
perform any other cleanup your code requires. If the try block executes with 
no exceptions, the finally block is executed immediately after the try block 
completes. If there was an exception thrown, the finally block executes 
immediately after the proper catch block completes. Let's look at another 
pseudocode example:
 1: try {
 2:   // This is the first line of the "guarded region". 3: }
 4: catch(MyFirstException) {
Using ﬁ  nally (Exam Objectives 2.4 and 2.5) 359
360 Chapter 5:  Flow Control, Exceptions, and Assertions
 5:   // Put code here that handles this exception
 6: }
 7: catch(MySecondException) {
 8:   // Put code here that handles this exception
 9: }
10: finally {
11:   // Put code here to release any resource we 
12:   // allocated in the try clause. 13: }
14:
15: // More code here
As before, execution starts at the first line of the try block, line 2. If there are no 
exceptions thrown in the try block, execution transfers to line 11, the first line of 
the finally block. On the other hand, if a MySecondException is thrown while 
the code in the try block is executing, execution transfers to the first line of that 
exception handler, line 8 in the catch clause. After all the code in the catch clause 
is executed, the program moves to line 11, the first line of the finally clause. Repeat after me: finally always runs! OK, we'll have to refine that a little, but for 
now, start burning in the idea that finally always runs. If an exception is thrown, 
finally runs. If an exception is not thrown, finally runs. If the exception is 
caught, finally runs. If the exception is not caught, finally runs. Later we'll look 
at the few scenarios in which finally might not run or complete. Remember, finally clauses are not required. If you don't write one, your code 
will compile and run just fine. In fact, if you have no resources to clean up after your 
try block completes, you probably don't need a finally clause. Also, because the 
compiler doesn't even require catch clauses, sometimes you'll run across code that 
has a try block immediately followed by a finally block. Such code is useful when 
the exception is going to be passed back to the calling method, as explained in the 
next section. Using a finally block allows the cleanup code to execute even when 
there isn't a catch clause. The following legal code demonstrates a try with a finally but no catch:
try {
  // do stuff
} finally {
  //clean up
}
The following legal code demonstrates a try, catch, and finally:
try {
  // do stuff
} catch (SomeException ex) {
  // do exception handling 
} finally {
  // clean up
}
The following ILLEGAL code demonstrates a try without a catch or finally:
try {
  // do stuff
}
// need a catch or finally here
System.out.println("out of try block"); 
The following ILLEGAL code demonstrates a misplaced catch block:
try {
  // do stuff
}
// can't have code between try/catch
System.out.println("out of try block");  
catch(Exception ex) { }
Using ﬁ  nally (Exam Objectives 2.4 and 2.5) 361
It is illegal to use a try clause without either a catch clause or a ﬁ  nally 
clause. A try clause by itself will result in a compiler error. Any catch clauses must 
immediately follow the try block. Any ﬁ  nally clause must immediately follow the last 
catch clause (or it must immediately follow the try block if there is no catch). It is legal 
to omit either the catch clause or the ﬁ  nally clause, but not both. 362 Chapter 5:  Flow Control, Exceptions, and Assertions
Propagating Uncaught Exceptions 
Why aren't catch clauses required? What happens to an exception that's thrown 
in a try block when there is no catch clause waiting for it? Actually, there's no 
requirement that you code a catch clause for every possible exception that could 
be thrown from the corresponding try block. In fact, it's doubtful that you could 
accomplish such a feat! If a method doesn't provide a catch clause for a particular 
exception, that method is said to be "ducking" the exception (or "passing the buck"). So what happens to a ducked exception? Before we discuss that, we need to 
briefly review the concept of the call stack. Most languages have the concept of 
a method stack or a call stack. Simply put, the call stack is the chain of methods 
that your program executes to get to the current method. If your program starts in 
method main() and main() calls method a(), which calls method b(), which in 
turn calls method c(), the call stack consists of the following:
c
b
a
main
We will represent the stack as growing upward (although it can also be visualized 
as growing downward). As you can see, the last method called is at the top of the 
stack, while the first calling method is at the bottom. The method at the very top of 
the stack trace would be the method you were currently executing. If we move back 
down the call stack, we're moving from the current method to the previously called 
method. Figure 5-1 illustrates a way to think about how the call stack in Java works. You can’t sneak any code in between the try, catch, or ﬁ  nally blocks. The following won’t compile:
try {
  // do stuff
}
System.out.print("below the try");  //Illegal! catch(Exception ex) { }
Now let's examine what happens to ducked exceptions. Imagine a building, say, 
five stories high, and at each floor there is a deck or balcony. Now imagine that on 
each deck, one person is standing holding a baseball mitt. Exceptions are like balls 
dropped from person to person, starting from the roof. An exception is first thrown 
from the top of the stack (in other words, the person on the roof), and if it isn't 
caught by the same person who threw it (the person on the roof), it drops down 
the call stack to the previous method, which is the person standing on the deck one 
floor down. If not caught there, by the person one floor down, the exception/ball 
again drops down to the previous method (person on the next floor down), and 
so on until it is caught or until it reaches the very bottom of the call stack. This is 
called exception propagation. If an exception reaches the bottom of the call stack, it's like reaching the bottom 
of a very long drop; the ball explodes, and so does your program. An exception that's 
never caught will cause your application to stop running. A description (if one is 
available) of the exception will be displayed, and the call stack will be "dumped." 
This helps you debug your application by telling you what exception was thrown, 
from what method it was thrown, and what the stack looked like at the time. FIGURE 5-1 
   
The Java method
call stack
Propagating Uncaught Exceptions (Exam Objectives 2.4 and 2.5) 363
1) The call stack while method3() is running. 2) The call stack after method3() completes
Execution returns to method2()
The order in which methods are put on the call stack
The order in which methods complete
4 
3 
2 
1
1 
2 
3
method3() 
method2() 
method1() 
main()
method2() 
method1() 
main()
method2 invokes method3 
method1 invokes method2 
main invokes method1 
main begins
method2() will complete 
method1() will complete 
main() will complete and the JVM will exit
364 Chapter 5:  Flow Control, Exceptions, and Assertions
EXERCISE 5-3
Propagating and Catching an Exception
In this exercise you're going to create two methods that deal with exceptions. One of 
the methods is the main() method, which will call another method. If an exception 
is thrown in the other method,  main() must deal with it. A finally statement will 
be included to indicate that the program has completed. The method that main() 
You can keep throwing an exception down through the methods on 
the stack. But what about when you get to the main() method at the bottom? You can 
throw the exception out of main() as well. This results in the Java Virtual Machine (JVM) 
halting, and the stack trace will be printed to the output. The following code throws an exception,
class TestEx {
  public static void main (String [] args) {
    doStuff();
  } 
  static void doStuff() {
    doMoreStuff();   
  }
  static void doMoreStuff() {
    int x = 5/0;  // Can't divide by zero! // ArithmeticException is thrown here
  } 
}
which prints out a stack trace something like,
 %java TestEx
Exception in thread "main" java.lang.ArithmeticException: / 
by zero
at TestEx.doMoreStuff(TestEx.java:10)
at TestEx.doStuff(TestEx.java:7)
at TestEx.main(TestEx.java:3)
will call will be named reverse, and it will reverse the order of the characters in a 
String. If the String contains no characters, reverse will propagate an exception up 
to the main() method. ■ Create a class called Propagate and a main() method, which will remain 
empty for now. ■ Create a method called reverse. It takes an argument of a String and 
returns a String. ■ In reverse, check if the String has a length of 0 by using the 
String.length() method. If the length is 0, the reverse method will 
throw an exception. ■ Now include the code to reverse the order of the String. Because this isn't 
the main topic of this chapter, the reversal code has been provided, but feel 
free to try it on your own. String reverseStr = "";
  for(int i=s.length()-1;i>=0;--i) {
    reverseStr += s.charAt(i);
  }
  return reverseStr;
■ Now in the main() method you will attempt to call this method and deal 
with any potential exceptions. Additionally, you will include a finally 
statement that displays when main() has finished.

--- Chunk #1393 ---
Deﬁ ning Exceptions
We have been discussing exceptions as a concept. We know that they are thrown 
when a problem of some type happens, and we know what effect they have on 
the flow of our program. In this section we will develop the concepts further and 
use exceptions in functional Java code. Earlier we said that an exception is an 
occurrence that alters the normal program flow. But because this is Java, anything 
that's not a primitive must be…an object. Exceptions are no, well, exception to 
this rule. Every exception is an instance of a class that has class Exception in its 
inheritance hierarchy. In other words, exceptions are always some subclass of 
java.lang.Exception. Deﬁ  ning Exceptions (Exam Objectives 2.4 and 2.5) 365
366 Chapter 5:  Flow Control, Exceptions, and Assertions
When an exception is thrown, an object of a particular Exception subtype is 
instantiated and handed to the exception handler as an argument to the catch 
clause. An actual catch clause looks like this:
try {
   // some code here
}
catch (ArrayIndexOutOfBoundsException e) {
   e.printStackTrace();
}
In this example, e is an instance of the ArrayIndexOutOfBoundsException class. As with any other object, you can call its methods. Exception Hierarchy
All exception classes are subtypes of class Exception. This class derives from the 
class Throwable (which derives from the class Object). Figure 5-2 shows the 
hierarchy for the exception classes. As you can see, there are two subclasses that derive from Throwable: Exception 
and Error. Classes that derive from Error represent unusual situations that are 
not caused by program errors, and indicate things that would not normally happen 
 FIGURE 5-2 
   
Exception class
hierarchy
Object
Throwable
Error Exception
RuntimeException
during program execution, such as the JVM running out of memory. Generally, your 
application won't be able to recover from an Error, so you're not required to handle 
them. If your code does not handle them (and it usually won't), it will still compile 
with no trouble. Although often thought of as exceptional conditions, Errors are 
technically not exceptions because they do not derive from class Exception. In general, an exception represents something that happens not as a result of 
a programming error, but rather because some resource is not available or some 
other condition required for correct execution is not present. For example, if your 
application is supposed to communicate with another application or computer that 
is not answering, this is an exception that is not caused by a bug. Figure 5-2 also 
shows a subtype of Exception called RuntimeException. These exceptions are 
a special case because they sometimes do indicate program errors. They can also 
represent rare, difficult-to-handle exceptional conditions. Runtime exceptions are 
discussed in greater detail later in this chapter. Java provides many exception classes, most of which have quite descriptive 
names. There are two ways to get information about an exception. The first is 
from the type of the exception itself. The next is from information that you can 
get from the exception object. Class Throwable (at the top of the inheritance 
tree for exceptions) provides its descendants with some methods that are useful in 
exception handlers. One of these is printStackTrace(). As expected, if you call 
an exception object's printStackTrace() method, as in the earlier example, a 
stack trace from where the exception occurred will be printed. We discussed that a call stack builds upward with the most recently called method 
at the top. You will notice that the printStackTrace() method prints the most 
recently entered method first and continues down, printing the name of each 
method as it works its way down the call stack (this is called unwinding the stack) 
from the top. For the exam, it is not necessary to know any of the methods 
contained in the Throwable classes, including Exception and Error. You are expected 
to know that Exception, Error, RuntimeException , and Throwable types can all be 
thrown using the throw keyword, and can all be caught (although you rarely will 
catch anything other than Exception subtypes). Exception Hierarchy (Exam Objectives 2.4 and 2.5) 367
368 Chapter 5:  Flow Control, Exceptions, and Assertions
Handling an Entire Class Hierarchy of Exceptions
We've discussed that the catch keyword allows you to specify a particular type of 
exception to catch. You can actually catch more than one type of exception in a 
single catch clause. If the exception class that you specify in the catch clause has 
no subclasses, then only the specified class of exception will be caught. However, if 
the class specified in the catch clause does have subclasses, any exception object 
that subclasses the specified class will be caught as well. For example, class IndexOutOfBoundsException has two subclasses, 
ArrayIndexOutOfBoundsException and StringIndexOutOfBoundsException. You may want to write one exception handler that deals with exceptions produced 
by either type of boundary error, but you might not be concerned with which 
exception you actually have. In this case, you could write a catch clause like 
the following:
try {
  // Some code here that can throw a boundary exception
}
catch (IndexOutOfBoundsException e) {
  e.printStackTrace();
}
If any code in the try block throws ArrayIndexOutOfBoundsException or 
StringIndexOutOfBoundsException, the exception will be caught and handled. This can be convenient, but it should be used sparingly. By specifying an exception 
class's superclass in your catch clause, you're discarding valuable information about 
the exception. You can, of course, find out exactly what exception class you have, 
but if you're going to do that, you're better off writing a separate catch clause for 
each exception type of interest. ON THE JOB
Resist the temptation to write a single catchall exception handler such as the 
following:
try {
  // some code
}
catch (Exception e) {
  e.printStackTrace();
}
This code will catch every exception generated. Of course, no single exception 
handler can properly handle every exception, and programming in this way 
defeats the design objective. Exception handlers that trap many errors at once 
will probably reduce the reliability of your program because it's likely that an 
exception will be caught that the handler does not know how to handle. Exception Matching
If you have an exception hierarchy composed of a superclass exception and a number 
of subtypes, and you're interested in handling one of the subtypes in a special way 
but want to handle all the rest together, you need write only two catch clauses. When an exception is thrown, Java will try to find (by looking at the available 
catch clauses from the top down) a catch clause for the exception type. If it doesn't 
find one, it will search for a handler for a supertype of the exception. If it does not 
find a catch clause that matches a supertype for the exception, then the exception 
is propagated down the call stack. This process is called exception matching. Let's 
look at an example:
 1: import java.io.*;
 2: public class ReadData {
 3:   public static void main(String args[]) {
 4:     try {
 5:       RandomAccessFile raf = 
 6:         new RandomAccessFile("myfile.txt", "r");
 7:       byte b[] = new byte[1000];
 8:       raf.readFully(b, 0, 1000);
 9:     }
10:     catch(FileNotFoundException e) {
11:       System.err.println("File not found");
12:       System.err.println(e.getMessage());
13:       e.printStackTrace();
14:     }
15:     catch(IOException e) {
16:       System.err.println("IO Error");
17:       System.err.println(e.toString());
18:       e.printStackTrace();
19:     }
20:   }
21: }
Exception Matching (Exam Objectives 2.4 and 2.5) 369
370 Chapter 5:  Flow Control, Exceptions, and Assertions
This short program attempts to open a file and to read some data from it. Opening 
and reading files can generate many exceptions, most of which are some type of 
IOException. Imagine that in this program we're interested in knowing only 
whether the exact exception is a FileNotFoundException. Otherwise, we don't 
care exactly what the problem is. FileNotFoundException is a subclass of IOException. Therefore, we 
could handle it in the catch clause that catches all subtypes of IOException, 
but then we would have to test the exception to determine whether it was a 
FileNotFoundException. Instead, we coded a special exception handler for 
the FileNotFoundException and a separate exception handler for all other 
IOException subtypes. If this code generates a FileNotFoundException, it will be handled by the 
catch clause that begins at line 10. If it generates another IOException—perhaps 
EOFException, which is a subclass of IOException—it will be handled by the 
catch clause that begins at line 15. If some other exception is generated, such as 
a runtime exception of some type, neither catch clause will be executed and the 
exception will be propagated down the call stack. Notice that the catch clause for the FileNotFoundException was placed above 
the handler for the IOException. This is really important! If we do it the opposite 
way, the program will not compile. The handlers for the most specific exceptions 
must always be placed above those for more general exceptions. The following will 
not compile:
try {
  // do risky IO things
} catch (IOException e) {
  // handle general IOExceptions
} catch (FileNotFoundException ex) {
  // handle just FileNotFoundException
}
You'll get a compiler error something like this:
TestEx.java:15: exception java.io.FileNotFoundException has
 already been caught
} catch (FileNotFoundException ex) {
  ^
If you think back to the people with baseball mitts (in the section "Propagating 
Uncaught Exceptions"), imagine that the most general mitts are the largest, and 
can thus catch many different kinds of balls. An IOException mitt is large enough 
and flexible enough to catch any type of IOException. So if the person on the 
fifth floor (say, Fred) has a big ‘ol IOException mitt, he can't help but catch a 
FileNotFoundException ball with it. And if the guy (say, Jimmy) on the second 
floor is holding a FileNotFoundException mitt, that FileNotFoundException 
ball will never get to him, since it will always be stopped by Fred on the fifth floor, 
standing there with his big-enough-for-any-IOException mitt. So what do you do with exceptions that are siblings in the class hierarchy? If one 
Exception class is not a subtype or supertype of the other, then the order in which 
the catch clauses are placed doesn't matter. Exception Declaration and the Public Interface
So, how do we know that some method throws an exception that we have to catch? Just as a method must specify what type and how many arguments it accepts and 
what is returned, the exceptions that a method can throw must be declared (unless 
the exceptions are subclasses of RuntimeException). The list of thrown exceptions 
is part of a method's public interface. The throws keyword is used as follows to list 
the exceptions that a method can throw:
void myFunction() throws MyException1, MyException2 {
  // code for the method here
}
This method has a void return type, accepts no arguments, and declares that 
it can throw one of two types of exceptions: either type MyException1 or type 
MyException2. (Just because the method declares that it throws an exception 
doesn't mean it always will. It just tells the world that it might.)
Suppose your method doesn't directly throw an exception, but calls a method that 
does. You can choose not to handle the exception yourself and instead just declare it, 
as though it were your method that actually throws the exception. If you do declare 
the exception that your method might get from another method, and you don't 
provide a try/catch for it, then the method will propagate back to the method that 
called your method, and either be caught there or continue on to be handled by a 
method further down the stack. Any method that might throw an exception (unless it's a subclass of 
RuntimeException) must declare the exception. That includes methods that 
aren't actually throwing it directly, but are "ducking" and letting the exception pass 
down to the next method in the stack. If you "duck" an exception, it is just as if you 
were the one actually throwing the exception. RuntimeException subclasses are 
Exception Declaration and the Public Interface (Exam Objectives 2.4 and 2.5) 371
372 Chapter 5:  Flow Control, Exceptions, and Assertions
exempt, so the compiler won't check to see if you've declared them. But all non-
RuntimeExceptions are considered "checked" exceptions, because the compiler 
checks to be certain you've acknowledged that "bad things could happen here."
Remember this: 
Each method must either handle all checked exceptions by supplying a catch clause or 
list each unhandled checked exception as a thrown exception. This rule is referred to as Java's "handle or declare" requirement. (Sometimes 
called "catch or declare.")
Look for code that invokes a method declaring an exception, where the 
calling method doesn’t handle or declare the checked exception. The following code 
(which uses the throw keyword to throw an exception manually—more on this next) has 
two big problems that the compiler will prevent:
void doStuff() {
  doMore();
}
void doMore() {
  throw new IOException();
}
First, the doMore() method throws a checked exception, but does not 
declare it! But suppose we ﬁ x the doMore() method as follows:
void doMore() throws IOException { … }
The doStuff() method is still in trouble because it, too, must declare the 
IOException, unless it handles it by providing a try/catch, with a catch clause that can 
take an IOException. Again, some exceptions are exempt from this rule. An object of type 
RuntimeException may be thrown from any method without being specified as 
part of the method's public interface (and a handler need not be present). And 
even if a method does declare a RuntimeException, the calling method is under 
no obligation to handle or declare it. RuntimeException, Error, and all of their 
subtypes are unchecked exceptions and unchecked exceptions do not have to be 
specified or handled. Here is an example:
import java.io.*;
class Test {
  public int myMethod1() throws EOFException {
    return myMethod2();
  }
  public int myMethod2() throws EOFException {
    // code that actually could throw the exception goes here
    return 1;
  }
}
Let's look at myMethod1(). Because EOFException subclasses IOException and 
IOException subclasses Exception, it is a checked exception and must be declared 
as an exception that may be thrown by this method. But where will the exception 
actually come from? The public interface for method myMethod2() called here 
declares that an exception of this type can be thrown. Whether that method actually 
throws the exception itself or calls another method that throws it is unimportant to 
us; we simply know that we have to either catch the exception or declare that we 
throw it. The method myMethod1() does not catch the exception, so it declares that 
it throws it. Now let's look at another legal example, myMethod3(). public void myMethod3() {
  // code that could throw a NullPointerException goes here
}
According to the comment, this method can throw a NullPointerException. Because RuntimeException is the superclass of NullPointerException, it is an 
unchecked exception and need not be declared. We can see that myMethod3() does 
not declare any exceptions. Runtime exceptions are referred to as unchecked exceptions. All other exceptions 
are checked exceptions, and they don't derive from java.lang.RuntimeException. A checked exception must be caught somewhere in your code. If you invoke a 
method that throws a checked exception but you don't catch the checked exception 
Exception Declaration and the Public Interface (Exam Objectives 2.4 and 2.5) 373
374 Chapter 5:  Flow Control, Exceptions, and Assertions
somewhere, your code will not compile. That's why they're called checked 
exceptions; the compiler checks to make sure that they're handled or declared. A number of the methods in the Java 2 Standard Edition libraries throw checked 
exceptions, so you will often write exception handlers to cope with exceptions 
generated by methods you didn't write. You can also throw an exception yourself, and that exception can be either 
an existing exception from the Java API or one of your own. To create your own 
exception, you simply subclass Exception (or one of its subclasses) as follows:
class MyException extends Exception { }
And if you throw the exception, the compiler will guarantee that you declare it 
as follows:
class TestEx {
  void doStuff() {
    throw new MyException();  // Throw a checked exception
  }
}
The preceding code upsets the compiler:
TestEx.java:6: unreported exception MyException; must be caught 
or
declared to be thrown
  throw new MyException();
  ^
When an object of a subtype of Exception is thrown, it must be handled 
or declared. These objects are called checked exceptions, and include all exceptions 
except those that are subtypes of RuntimeException, which are unchecked exceptions. Be ready to spot methods that don’t follow the “handle or declare” rule, such as
class MyException extends Exception { 
  void someMethod () {
    doStuff();
  }
You need to know how an Error compares with checked and unchecked 
exceptions. Objects of type Error are not Exception objects, although they do 
represent exceptional conditions. Both Exception and Error share a common 
superclass, Throwable, thus both can be thrown using the throw keyword. When an 
Error or a subclass of Error is thrown, it's unchecked. You are not required to catch 
Error objects or Error subtypes. You can also throw an Error yourself (although 
other than AssertionError you probably won't ever want to), and you can catch 
one, but again, you probably won't. What, for example, would you actually do if you 
got an OutOfMemoryError? It's not like you can tell the garbage collector to run; 
you can bet the JVM fought desperately to save itself (and reclaimed all the memory 
it could) by the time you got the error. In other words, don't expect the JVM at that 
point to say, "Run the garbage collector? Oh, thanks so much for telling me.

--- Chunk #1394 ---
That 
just never occurred to me. Sure, I'll get right on it." Even better, what would you do 
if a VirtualMachineError arose? Your program is toast by the time you'd catch the 
Error, so there's really no point in trying to catch one of these babies. Just remember, 
though, that you can! The following compiles just fine:
Exception Declaration and the Public Interface (Exam Objectives 2.4 and 2.5) 375
  void doStuff() throws MyException {
    try {
      throw new MyException();
    }
    catch(MyException me) { 
      throw me;
    }
  }
}
You need to recognize that this code won’t compile. If you try, you’ll get
MyException.java:3: unreported exception MyException; must 
be caught or declared to be thrown
doStuff();
       ^
Notice that someMethod() fails to either handle or declare the exception 
that can be thrown by doStuff(). 376 Chapter 5:  Flow Control, Exceptions, and Assertions
class TestEx {
  public static void main (String [] args) {
    badMethod();  
  }
  static void badMethod() {  // No need to declare an Error
    doStuff();
  }
  static void doStuff() {  //No need to declare an Error
    try {
      throw new Error();
    }
    catch(Error me) { 
      throw me; // We catch it, but then rethrow it
    }
  }
}
If we were throwing a checked exception rather than Error, then the doStuff() 
method would need to declare the exception. But remember, since Error is not a 
subtype of Exception, it doesn't need to be declared. You're free to declare it if you 
like, but the compiler just doesn't care one way or another when or how the Error 
is thrown, or by whom. ON THE JOB 
Because Java has checked exceptions, it's commonly said that Java forces 
developers to handle exceptions. Yes, Java forces us to write exception 
handlers for each exception that can occur during normal operation, but it's 
up to us to make the exception handlers actually do something useful. We 
know software managers who melt down when they see a programmer write:
try {
  callBadMethod();
} catch (Exception ex) { }
Notice anything missing? Don't "eat" the exception by catching it without 
actually handling it. You won't even be able to tell that the exception occurred, 
because you'll never see the stack trace. Rethrowing the Same Exception
Just as you can throw a new exception from a catch clause, you can also throw the 
same exception you just caught. Here's a catch clause that does this:
catch(IOException e) {
  // Do things, then if you decide you can't handle it…
  throw e;
}
All other catch clauses associated with the same try are ignored, if a finally 
block exists, it runs, and the exception is thrown back to the calling method (the 
next method down the call stack). If you throw a checked exception from a catch 
clause, you must also declare that exception! In other words, you must handle and 
declare, as opposed to handle or declare. The following example is illegal:
public void doStuff() {
  try {
    // risky IO things
  } catch(IOException ex) {
    // can't handle it
     throw ex;  // Can't throw it unless you declare it
  }
}
In the preceding code, the doStuff() method is clearly able to throw a checked 
exception—in this case an IOException—so the compiler says, "Well, that's just 
peachy that you have a try/catch in there, but it's not good enough. If you might 
rethrow the IOException you catch, then you must declare it!"
EXERCISE 5-4
Creating an Exception
In this exercise we attempt to create a custom exception. We won't put in any new 
methods (it will have only those inherited from Exception), and because it extends 
Exception, the compiler considers it a checked exception. The goal of the program 
is to determine whether a command-line argument, representing a particular food 
(as a string), is considered bad or OK. ■ Let's first create our exception. We will call it BadFoodException. This 
exception will be thrown when a bad food is encountered. ■ Create an enclosing class called MyException and a main() method, 
which will remain empty for now. Rethrowing the Same Exception (Exam Objectives 2.4 and 2.5) 377
378 Chapter 5:  Flow Control, Exceptions, and Assertions
■ Create a method called checkFood(). It takes a String argument and 
throws our exception if it doesn't like the food it was given. Otherwise, it 
tells us it likes the food. You can add any foods you aren't particularly fond of 
to the list. ■ Now in the main() method, you'll get the command-line argument out of 
the String array, and then pass that String on to the checkFood() meth-
od. Because it's a checked exception, the checkFood() method must declare 
it, and the main() method must handle it (using a try/catch). Do not have 
main() declare the exception, because if main() ducks the exception, who 
else is back there to catch it? ■ As nifty as exception handling is, it's still up to the developer to make 
proper use of it. Exception handling makes organizing our code and signaling 
problems easy, but the exception handlers still have to be written. You'll find 
that even the most complex situations can be handled, and your code will be 
reusable, readable, and maintainable. CERTIFICATION OBJECTIVE
Common Exceptions and Errors
(Exam Objective 2.6)
2.6 Recognize situations that will result in any of the following being thrown: 
ArrayIndexOutOfBoundsException, ClassCastException, IllegalArgumentException, 
IllegalStateException, NullPointerException, NumberFormatException, AssertionError, 
ExceptionInInitializerError, StackOverflowError, or NoClassDefFoundError. Understand 
which of these are thrown by the virtual machine and recognize situations in which others 
should be thrown programmatically. Exception handling is another area that the exam creation team decided to expand 
for the SCJP 5 exam. This section discusses the aspects of exceptions that were 
added for this new version. The intention of Objective 2.6 is to make sure that you 
are familiar with some of the most common exceptions and errors you'll encounter 
as a Java programmer. This is another one of those objectives that will turn up all through the real 
exam (does "An exception is thrown at runtime" ring a bell?), so make sure this 
section gets a lot of your attention. Where Exceptions Come From
Jump back a page and take a look at the last sentence of Objective 2.6. It's 
important to understand what causes exceptions and errors, and where they come 
from. For the purposes of exam preparation, let's define two broad categories of 
exceptions and errors:
■ JVM exceptions Those exceptions or errors that are either exclusively 
or most logically thrown by the JVM. ■ Programmatic exceptions Those exceptions that are thrown explicitly 
by application and/or API programmers. JVM Thrown Exceptions
Let's start with a very common exception, the NullPointerException . As we 
saw in Chapter 3, this exception occurs when you attempt to access an object 
using a reference variable with a current value of null. There's no way that 
the compiler can hope to find these problems before runtime. Let's look at the 
following:
Common Exceptions and Errors (Exam Objective 2.6) 379
The questions from this section are likely to be along the lines of, "Here’s 
some code that just did something bad, which exception will be thrown?"
Throughout the exam, questions will present some code and ask you to 
determine whether the code will run, or whether an exception will be thrown. Since these 
questions are so common, understanding the causes for these exceptions is critical to 
your success. 380 Chapter 5:  Flow Control, Exceptions, and Assertions
class NPE {
  static String s;
  public static void main(String [] args) {
    System.out.println(s.length());
  }
}
Surely, the compiler can find the problem with that tiny little program! Nope, 
you're on your own. The code will compile just fine, and the JVM will throw a 
NullPointerException when it tries to invoke the length() method. Earlier in this chapter we discussed the call stack. As you recall, we used the 
convention that main() would be at the bottom of the call stack, and that as 
main() invokes another method, and that method invokes another, and so on, 
the stack grows upward. Of course the stack resides in memory, and even if your 
OS gives you a gigabyte of RAM for your program, it's still a finite amount. It's 
possible to grow the stack so large that the OS runs out of space to store the call 
stack. When this happens you get (wait for it...), a StackOverflowError . The 
most common way for this to occur is to create a recursive method. A recursive 
method is one that invokes itself in the method body. While that may sound 
weird, it's a very common and useful technique for such things as searching and 
sorting algorithms. Take a look at this code:
void go() {    // recursion gone bad
   go();
}
As you can see, if you ever make the mistake of invoking the go() 
method, your program will fall into a black hole; go() invoking go() 
invoking go(), until, no matter how much memory you have, you'll get a 
StackOverflowError . Again, only the JVM knows when this moment occurs, 
and the JVM will be the source of this error. Programmatically Thrown Exceptions
Now let's look at programmatically thrown exceptions. Remember we defined 
"programmatically" as meaning something like this:
 Created by an application and/or API developer. For instance, many classes in the Java API have methods that take String 
arguments, and convert these Strings into numeric primitives. A good example 
of these classes are the so-called "wrapper classes" that we studied in Chapter 3. At some point long ago, some programmer wrote the  java.lang. Integer class, and created methods like parseInt() and valueOf(). That programmer wisely decided that if one of these methods was passed a 
String that could not be converted into a number, the method should throw 
a NumberFormatException . The partially implemented code might look 
something like this:
  int parseInt(String s) throws NumberFormatException {
    boolean parseSuccess = false;
    int result = 0;
    // do complicated parsing
    if (!parseSuccess)   // if the parsing failed
      throw new NumberFormatException();
    return result;
  }
Other examples of programmatic exceptions include an AssertionError (okay, 
it's not an exception, but it IS thrown programmatically), and throwing an
IllegalArgumentException . In fact, our mythical API developer could have 
used IllegalArgumentException  for her parseInt() method. But it turns 
out that NumberFormatException  extends IllegalArgumentException , and 
is a little more precise, so in this case, using NumberFormatException  supports 
the notion we discussed earlier: that when you have an exception hierarchy, you 
should use the most precise exception that you can. Of course, as we discussed earlier, you can also make up your very own special, 
custom exceptions, and throw them whenever you want to. These homemade 
exceptions also fall into the category of "programmatically thrown exceptions."
A Summary of the Exam's Exceptions and Errors
Objective 2.6 lists ten specific exceptions and errors. In this section we discussed 
the StackOverflowError . The other nine exceptions and errors listed in the 
objective are covered elsewhere in this book. Table 5-2 summarizes this list and 
provides chapter references to the exceptions and errors we did not discuss here. Common Exceptions and Errors (Exam Objective 2.6) 381
 
Exception
(Chapter Location)
Description T ypically 
Thrown
ArrayIndexOutOfBoundsException
(Chapter 3, "Assignments")
Thrown when attempting to access an array 
with an invalid index value (either negative 
or beyond the length of the array). By the JVM
ClassCastException
(Chapter 2, "Object Orientation")
Thrown when attempting to cast a reference 
variable to a type that fails the IS-A test. By the JVM
IllegalArgumentException
(This chapter)
Thrown when a method receives an argument 
formatted differently than the method 
expects. Programmatically
IllegalStateException
(Chapter 6, "Formatting")
Thrown when the state of the environment 
doesn’t match the operation being attempted, 
e.g., using a Scanner that’s been closed. Programmatically
NullPointerException
(Chapter 3, "Assignments")
Thrown when attempting to access an object 
with a reference variable whose current value 
is  null. By the JVM
NumberFormatException
(Chapter 3, "Assignments")
Thrown when a method that converts a 
String to a number receives a String that it 
cannot convert. Programmatically
AssertionError
(This chapter)
Thrown when a statement’s boolean test 
returns  false. Programmatically
ExceptionInInitializerError
(Chapter 3, "Assignments")
Thrown when attempting to initialize a static 
variable or an initialization block. By the JVM
StackOverflowError
(This chapter)
Typically thrown when a method recurses 
too deeply. (Each invocation is added to the 
stack.)
By the JVM
NoClassDefFoundError
(Chapter 10, "Development")
Thrown when the JVM can’t find a class it 
needs, because of a command-line error, a 
classpath issue, or a missing  .class  file. By the JVM
   
 TABLE 5-2    Descriptions and Sources of Common Exceptions. 382 Chapter 5:  Flow Control, Exceptions, and Assertions
CERTIFICATION OBJECTIVE
Working with the Assertion Mechanism 
(Exam Objective 2.3)
2.3 Develop code that makes use of assertions, and distinguish appropriate from 
inappropriate uses of assertions. You know you're not supposed to make assumptions, but you can't help it when 
you're writing code. You put them in comments:
if (x > 2 && y) {
  // do something
} else if (x < 2 || y) {
  // do something
} else {
  // x must be 2
  // do something else
}
You write print statements with them:
while (true) {
  if (x > 2) {
    break;
  }
  System.out.print("If we got here " +
                   "something went horribly wrong");
}
Added to the Java language beginning with version 1.4, assertions let you test your 
assumptions during development, without the expense (in both your time and 
program overhead) of writing exception handlers for exceptions that you assume 
will never happen once the program is out of development and fully deployed. Starting with exam 310-035 (version 1.4 of the Sun Certified Java Programmer 
exam) and continuing through to the current exam 310-065 (SCJP 6), you're 
expected to know the basics of how assertions work, including how to enable them, 
how to use them, and how not to use them. Working with the Assertion Mechanism (Exam Objective 2.3) 383
384 Chapter 5:  Flow Control, Exceptions, and Assertions
Assertions Overview
Suppose you assume that a number passed into a method (say, methodA()) 
will never be negative. While testing and debugging, you want to validate your 
assumption, but you don't want to have to strip out print statements, runtime 
exception handlers, or if/else tests when you're done with development. But 
leaving any of those in is, at the least, a performance hit. Assertions to the rescue! Check out the following code:
private void methodA(int num) {
  if (num >= 0) {
    useNum(num + x);
  } else {  // num must be < 0
            // This code should never be reached! System.out.println("Yikes! num is a negative number! "
                       + num);
  }
}
Because you're so certain of your assumption, you don't want to take the time (or 
program performance hit) to write exception-handling code. And at runtime, you 
don't want the if/else either because if you do reach the else condition, it means 
your earlier logic (whatever was running prior to this method being called) is flawed. Assertions let you test your assumptions during development, but the assertion 
code basically evaporates when the program is deployed, leaving behind no overhead 
or debugging code to track down and remove. Let's rewrite methodA() to validate 
that the argument was not negative:
private void methodA(int num) {
  assert (num>=0);   // throws an AssertionError 
                     // if this test isn't true
  useNum(num + x);
}
Not only do assertions let your code stay cleaner and tighter, but because assertions 
are inactive unless specifically "turned on" (enabled), the code will run as though it 
were written like this:
private void methodA(int num) {
  useNum(num + x); // we've tested this; 
                   // we now know we're good here
}
Assertions work quite simply. You always assert that something is true. If it is, no 
problem. Code keeps running. But if your assertion turns out to be wrong (false), 
then a stop-the-world AssertionError is thrown (that you should never, ever 
handle!) right then and there, so you can fix whatever logic flaw led to the problem. Assertions come in two flavors: really simple and simple, as follows:
Really simple:
private void doStuff() {
  assert (y > x);
  // more code assuming y is greater than x
}
Simple:
private void doStuff() {
  assert (y > x): "y is " + y + " x is " + x;
  // more code assuming y is greater than x
}
The difference between the two is that the simple version adds a second expression, 
separated from the first (boolean expression) by a colon, this expression's 
string value is added to the stack trace. Both versions throw an immediate 
AssertionError, but the simple version gives you a little more debugging help 
while the really simple version simply tells you only that your assumption was false. Assertions are typically enabled when an application is being tested and 
debugged, but disabled when the application is deployed. The assertions are 
still in the code, although ignored by the JVM, so if you do have a deployed 
application that starts misbehaving, you can always choose to enable 
assertions in the field for additional testing. Assertion Expression Rules
Assertions can have either one or two expressions, depending on whether you're 
using the "simple" or the "really simple." The first expression must always result in 
a boolean value! Follow the same rules you use for if and while tests. The whole 
point is to assert aTest, which means you're asserting that aTest is true. If it is 
true, no problem. If it's not true, however, then your assumption was wrong and 
you get an AssertionError. Assertions Overview (Exam Objective 2.3) 385
386 Chapter 5:  Flow Control, Exceptions, and Assertions
The second expression, used only with the simple version of an assert 
statement, can be anything that results in a value. Remember, the second expression 
is used to generate a String message that displays in the stack trace to give you a 
little more debugging information. It works much like System.out.println() in 
that you can pass it a primitive or an object, and it will convert it into a String 
representation. It must resolve to a value! The following code lists legal and illegal expressions for both parts of an assert 
statement. Remember, expression2 is used only with the simple assert statement, 
where the second expression exists solely to give you a little more debugging detail:
void noReturn() { }
int aReturn() { return 1; }
void go() {
  int x = 1;
  boolean b = true;
  // the following six are legal assert statements
  assert(x == 1);
  assert(b);
  assert true;
  assert(x == 1) : x;
  assert(x == 1) : aReturn();
  assert(x == 1) : new ValidAssert();
  // the following six are ILLEGAL assert statements
  assert(x = 1);  // none of these are booleans
  assert(x);
  assert 0;
  assert(x == 1) : ;           // none of these return a value
  assert(x == 1) : noReturn();
  assert(x == 1) : ValidAssert va;
}
If you see the word “expression” in a question about assertions, and the 
question doesn’t specify whether it means expression1 (the boolean test) or expression2 
(the value to print in the stack trace), then always assume the word "expression" refers 
to expression1, the boolean test. For example, consider the following question:
Enabling Assertions 
If you want to use assertions, you have to think first about how to compile with 
assertions in your code, and then about how to run with assertions enabled. Both 
require version 1.4 or greater, and that brings us to the first issue: how to compile 
with assertions in your code. Identifier vs. Keyword
Prior to version 1.4, you might very well have written code like this:
int assert = getInitialValue();
if (assert == getActualResult()) {
  // do something
}
Notice that in the preceding code, assert is used as an identifier. That's not a 
problem prior to 1.4. But you cannot use a keyword/reserved word as an identifier, and 
beginning with version 1.4, assert is a keyword. The bottom line is this:
You can use assert as a keyword or as an identifier, but not both. If for some reason you're using a Java 1.4 compiler, and if you're using assert 
as a keyword (in other words, you're actually trying to assert something in 
your code), then you must explicitly enable assertion-awareness at compile 
time, as follows:
javac -source 1.4 com/geeksanonymous/TestClass.java
Enabling Assertions (Exam Objective 2.3) 387
  An assert expression must result in a boolean value, true or false? Assume that the word 'expression' refers to expression1 of an assert, 
so the question statement is correct. If the statement were referring to expression2, 
however, the statement would not be correct, since expression2 can have a result of any 
value, not just a boolean. 388 Chapter 5:  Flow Control, Exceptions, and Assertions
You can read that as "compile the class TestClass, in the directory 
com/geeksanonymous, and do it in the 1.4 way, where assert is a keyword." 
Use Version 6 of java and javac
As far as the exam is concerned, you'll ALWAYS be using version 6 of the Java 
compiler (javac), and version 6 of the Java application launcher (java). You might 
see questions about older versions of source code, but those questions will always 
be in the context of compiling and launching old code with the current versions of 
javac and java. Compiling Assertion-Aware Code
The Java 6 compiler will use the assert keyword by default. Unless you tell it 
otherwise, the compiler will generate an error message if it finds the word assert 
used as an identifier. However, you can tell the compiler that you're giving it an old 
piece of code to compile, and that it should pretend to be an old compiler! (More 
about compiler commands in Chapter 10.) Let's say you've got to make a quick fix to 
an old piece of 1.3 code that uses assert as an identifier. At the command line you 
can type
javac -source 1.3 OldCode.java 
The compiler will issue warnings when it discovers the word assert used as an 
identifier, but the code will compile and execute. Suppose you tell the compiler that 
your code is version 1.4 or later, for instance:
javac -source 1.4 NotQuiteSoOldCode.java 
 
In this case, the compiler will issue errors when it discovers the word assert used as 
an identifier. If you want to tell the compiler to use Java 6 rules you can do one of three 
things: omit the -source option, which is the default, or add one of two source 
options: 
    -source 1.6 or -source 6. If you want to use assert as an identifier in your code, you MUST compile using 
the -source 1.3 option. Table 5-3 summarizes how the Java 6 compiler will react 
to assert as either an identifier or a keyword. Running with Assertions
Here's where it gets cool. Once you've written your assertion-aware code (in 
other words, code that uses assert as a keyword, to actually perform assertions at 
runtime), you can choose to enable or disable your assertions at runtime! Remember, 
assertions are disabled by default. Enabling Assertions at Runtime
You enable assertions at runtime with
java -ea com.geeksanonymous.TestClass
or
java -enableassertions com.geeksanonymous.TestClass
The preceding command-line switches tell the JVM to run with assertions enabled. Command Line If assert Is an Identifier If assert Is a Keyword
javac -source 1.3 TestAsserts.java Code compiles with warnings. Compilation fails. javac -source 1.4 TestAsserts.java Compilation fails. Code compiles. javac -source 1.5 TestAsserts.java Compilation fails. Code compiles. javac -source 5 TestAsserts.java Compilation fails. Code compiles. javac -source 1.6 TestAsserts.java Compilation fails. Code compiles. javac -source 6 TestAsserts.java Compilation fails. Code compiles. javac TestAsserts.java Compilation fails. Code compiles. TABLE 5-3    Using Java 6 to Compile Code That Uses assert as an Identifier or a Keyword
Enabling Assertions (Exam Objective 2.3) 389
390 Chapter 5:  Flow Control, Exceptions, and Assertions
Disabling Assertions at Runtime
You must also know the command-line switches for disabling assertions,  
java -da com.geeksanonymous.TestClass
or
java -disableassertions com.geeksanonymous.TestClass
Because assertions are disabled by default, using the disable switches might seem 
unnecessary. Indeed, using the switches the way we do in the preceding example just 
gives you the default behavior (in other words, you get the same result regardless 
of whether you use the disabling switches). But…you can also selectively enable 
and disable assertions in such a way that they're enabled for some classes and/or 
packages, and disabled for others, while a particular program is running. Selective Enabling and Disabling
The command-line switches for assertions can be used in various ways:
■ With no arguments (as in the preceding examples)  Enables or disables 
assertions in all classes, except for the system classes. ■ With a package name  Enables or disables assertions in the package speci-
fied, and any packages below this package in the same directory hierarchy 
(more on that in a moment). ■ With a class name  Enables or disables assertions in the class specified. You can combine switches to, say, disable assertions in a single class, but keep 
them enabled for all others, as follows:
java -ea  -da:com.geeksanonymous.Foo
The preceding command line tells the JVM to enable assertions in general, 
but disable them in the class com.geeksanonymous.Foo. You can do the same 
selectivity for a package as follows:
java -ea -da:com.geeksanonymous... The preceding command line tells the JVM to enable assertions in general, but 
disable them in the package com.geeksanonymous, and all of its subpackages! You 
may not be familiar with the term subpackages, since there wasn't much use of that 
term prior to assertions. A subpackage is any package in a subdirectory of the named 
package. For example, look at the following directory tree:
com
   |_geeksanonymous
                 |_Foo
                 |_twelvesteps
                            |_StepOne
                            |_StepTwo
This tree lists three directories,
com
geeksanonymous
twelvesteps
and three classes:
com.geeksanonymous.Foo
com.geeksanonymous.twelvesteps.StepOne
com.geeksanonymous.twelvesteps.StepTwo
The subpackage of com.geeksanonymous is the twelvesteps package. Remember 
that in Java, the com.geeksanonymous.twelvesteps package is treated as a 
completely distinct package that has no relationship with the packages above it 
(in this example, the com.geeksanonymous package), except they just happen to 
share a couple of directories. Table 5-4 lists examples of command-line switches for 
enabling and disabling assertions. Enabling Assertions (Exam Objective 2.3) 391
 
Command-Line Example What It Means
java -ea
java -enableassertions
Enable assertions. java -da
java -disableassertions
Disable assertions (the default behavior of Java 6). java -ea:com.foo.Bar Enable assertions in class com.foo.Bar. java -ea:com.foo... Enable assertions in package com.foo and any of its subpackages. java -ea -dsa Enable assertions in general, but disable assertions in system classes. java -ea -da:com.foo... Enable assertions in general, but disable assertions in package
com.foo and any of its subpackages. TABLE 5-4    Assertion Command-Line Switches
392 Chapter 5:  Flow Control, Exceptions, and Assertions
Using Assertions Appropriately
Not all legal uses of assertions are considered appropriate. As with so much of Java, 
you can abuse the intended use of assertions, despite the best efforts of Sun's Java 
engineers to discourage you from doing so. For example, you're never supposed 
to handle an assertion failure. That means you shouldn't catch it with a catch 
clause and attempt to recover. Legally, however, AssertionError is a subclass 
of Throwable, so it can be caught. But just don't do it! If you're going to try to 
recover from something, it should be an exception. To discourage you from trying 
to substitute an assertion for an exception, the AssertionError doesn't provide 
access to the object that generated it. All you get is the String message.

--- Chunk #1395 ---
So who gets to decide what's appropriate? Sun. The exam uses Sun's "official" 
assertion documentation to define appropriate and inappropriate uses. Don't Use Assertions to Validate Arguments to a Public Method
The following is an inappropriate use of assertions:
public void doStuff(int x) {   
  assert (x > 0);             // inappropriate ! // do things with x
}
A public method might be called from code that you don't control (or from code 
you have never seen). Because public methods are part of your interface to the 
outside world, you're supposed to guarantee that any constraints on the arguments 
will be enforced by the method itself. But since assertions aren't guaranteed to 
actually run (they're typically disabled in a deployed application), the enforcement 
won't happen if assertions aren't enabled. You don't want publicly accessible code 
that works only conditionally, depending on whether assertions are enabled. If you see the word "appropriate" on the exam, do not mistake that for 
"legal." "Appropriate" always refers to the way in which something is supposed to be 
used, according to either the developers of the mechanism or best practices ofﬁ cially 
embraced by Sun. If you see the word “correct” in the context of assertions, as in, “Line 
3 is a correct use of assertions,” you should also assume that correct is referring to how 
assertions SHOULD be used rather than how they legally COULD be used. If you need to validate public method arguments, you'll probably use exceptions 
to throw, say, an IllegalArgumentException if the values passed to the public 
method are invalid. Do Use Assertions to Validate Arguments to a Private Method
If you write a private method, you almost certainly wrote (or control) any code 
that calls it. When you assume that the logic in code calling your private method 
is correct, you can test that assumption with an assertion as follows:
private void doMore(int x) {
  assert (x > 0);
  // do things with x
}
The only difference that matters between the preceding example and the one before 
it is the access modifier. So, do enforce constraints on private methods' arguments, 
but do not enforce constraints on public methods. You're certainly free to compile 
assertion code with an inappropriate validation of public arguments, but for the 
exam (and real life) you need to know that you shouldn't do it. Don't Use Assertions to Validate Command-Line Arguments
This is really just a special case of the "Do not use assertions to validate arguments to 
a public method" rule. If your program requires command-line arguments, you'll 
probably use the exception mechanism to enforce them. Do Use Assertions, Even in Public Methods, to Check for Cases 
that Y ou Know Are Never, Ever Supposed to Happen
This can include code blocks that should never be reached, including the default of 
a switch statement as follows:
switch(x) {
  case 1: y = 3; break;
  case 2: y = 9; break;
  case 3: y = 27; break;
  default: assert false; // we're never supposed to get here! }
If you assume that a particular code block won't be reached, as in the preceding 
example where you assert that x must be either 1, 2, or 3, then you can use assert 
false to cause an AssertionError to be thrown immediately if you ever do reach 
that code. So in the switch example, we're not performing a boolean test—we've 
Using Assertions Appropriately (Exam Objective 2.3) 393
394 Chapter 5:  Flow Control, Exceptions, and Assertions
already asserted that we should never be there, so just getting to that point is an 
automatic failure of our assertion/assumption. Don't Use Assert Expressions that Can Cause Side Effects! The following would be a very bad idea:
public void doStuff() {
  assert (modifyThings());
  // continues on
}
public boolean modifyThings() {
  y = x++;
  return true;
}   
The rule is, an assert expression should leave the program in the same state it was 
in before the expression! Think about it. assert expressions aren't guaranteed to 
always run, so you don't want your code to behave differently depending on whether 
assertions are enabled. Assertions must not cause any side effects. If assertions are 
enabled, the only change to the way your program runs is that an AssertionError 
can be thrown if one of your assertions (think: assumptions) turns out to be false. Using assertions that cause side effects can cause some of the most maddening 
and hard-to-find bugs known to man! When a hot tempered Q.A. analyst is 
screaming at you that your code doesn't work, trotting out the old "well it 
works on MY machine" excuse won't get you very far. CERTIFICATION SUMMARY
This chapter covered a lot of ground, all of which involves ways of controlling your 
program flow, based on a conditional test. First you learned about if and switch 
statements. The if statement evaluates one or more expressions to a boolean 
result. If the result is true, the program will execute the code in the block that is 
encompassed by the if. If an else statement is used and the if expression evaluates 
to false, then the code following the else will be performed. If no else block is 
defined, then none of the code associated with the if statement will execute. You also learned that the switch statement can be used to replace multiple if-
else statements. The switch statement can evaluate integer primitive types that 
can be implicitly cast to an int (those types are byte, short, int, and char), or it 
can evaluate enums. At runtime, the JVM will try to find a match between the expression in the 
switch statement and a constant in a corresponding case statement. If a match 
is found, execution will begin at the matching case, and continue on from there, 
executing code in all the remaining case statements until a break statement is 
found or the end of the switch statement occurs. If there is no match, then the 
default case will execute, if there is one. You've learned about the three looping constructs available in the Java language. These constructs are the for loop (including the basic for and the enhanced  
for which is new to Java 6), the while loop, and the do loop. In general, the for 
loop is used when you know how many times you need to go through the loop. The 
while loop is used when you do not know how many times you want to go through, 
whereas the do loop is used when you need to go through at least once. In the for 
loop and the while loop, the expression will have to evaluate to true to get inside 
the block and will check after every iteration of the loop. The do loop does not 
check the condition until after it has gone through the loop once. The major benefit 
of the for loop is the ability to initialize one or more variables and increment or 
decrement those variables in the for loop definition. The break and continue statements can be used in either a labeled or unlabeled 
fashion. When unlabeled, the break statement will force the program to stop 
processing the innermost looping construct and start with the line of code following 
the loop. Using an unlabeled continue command will cause the program to stop 
execution of the current iteration of the innermost loop and proceed with the next 
iteration. When a break or a continue statement is used in a labeled manner, it 
will perform in the same way, with one exception: the statement will not apply to 
the innermost loop; instead, it will apply to the loop with the label. The break 
statement is used most often in conjunction with the switch statement. When 
there is a match between the switch expression and the case constant, the code 
following the case constant will be performed. To stop execution, a break is needed. You've seen how Java provides an elegant mechanism in exception handling. Exception handling allows you to isolate your error-correction code into separate 
blocks so that the main code doesn't become cluttered by error-checking code. Another elegant feature allows you to handle similar errors with a single error-
handling block, without code duplication. Also, the error handling can be deferred 
to methods further back on the call stack. You learned that Java's try keyword is used to specify a guarded region—a block 
of code in which problems might be detected. An exception handler is the code that 
is executed when an exception occurs. The handler is defined by using Java's catch 
keyword. All catch clauses must immediately follow the related try block. Java 
also provides the finally keyword. This is used to define a block of code that is 
always executed, either immediately after a catch clause completes or immediately 
Certiﬁ  cation Summary 395
396 Chapter 5:  Flow Control, Exceptions, and Assertions
after the associated try block in the case that no exception was thrown (or there 
was a try but no catch). Use finally blocks to release system resources and to 
perform any cleanup required by the code in the try block. A finally block is not 
required, but if there is one it must immediately follow the last catch. (If there is 
no catch block, the finally block must immediately follow the try block.) It's 
guaranteed to be called except when the try or catch issues a System.exit(). An exception object is an instance of class Exception or one of its subclasses. The catch clause takes, as a parameter, an instance of an object of a type derived 
from the Exception class. Java requires that each method either catches any 
checked exception it can throw or else declares that it throws the exception. The 
exception declaration is part of the method's public interface. To declare that an 
exception may be thrown, the throws keyword is used in a method definition, along 
with a list of all checked exceptions that might be thrown. Runtime exceptions are of type RuntimeException (or one of its subclasses). These exceptions are a special case because they do not need to be handled or 
declared, and thus are known as "unchecked" exceptions. Errors are of type 
java.lang.Error or its subclasses, and like runtime exceptions, they do not need 
to be handled or declared. Checked exceptions include any exception types that 
are not of type RuntimeException or Error. If your code fails to either handle a 
checked exception or declare that it is thrown, your code won't compile. But with 
unchecked exceptions or objects of type Error, it doesn't matter to the compiler 
whether you declare them or handle them, do nothing about them, or do some 
combination of declaring and handling. In other words, you're free to declare them 
and handle them, but the compiler won't care one way or the other. It's not good 
practice to handle an Error, though, because you can rarely recover from one. Exceptions can be generated by the JVM, or by a programmer. Assertions, added to the language in version 1.4, are a useful debugging tool. You 
learned how you can use them for testing, by enabling them, but keep them disabled 
when the application is deployed. If you have older Java code that uses the 
word assert as an identifier, then you won't be able to use assertions, and you 
must recompile your older code using the -source 1.3 flag. Remember that as 
of Java 6, assertions are compiled as a keyword by default, but must be enabled 
explicitly at runtime. You learned how assert statements always include a boolean expression, and 
if the expression is true the code continues on, but if the expression is false, 
an AssertionError is thrown. If you use the two-expression assert statement, 
then the second expression is evaluated, converted to a String representation and 
inserted into the stack trace to give you a little more debugging info. Finally, you 
saw why assertions should not be used to enforce arguments to public methods, and 
why assert expressions must not contain side effects! TWO-MINUTE DRILL
Here are some of the key points from each certification objective in this chapter. You might want to loop through them several times. Writing Code Using if and switch Statements (Obj. 2.1)
❑ The only legal expression in an if statement is a boolean expression, in 
other words an expression that resolves to a boolean or a Boolean variable. ❑ Watch out for boolean assignments (=) that can be mistaken for boolean 
equality (==) tests:
   boolean x = false;
if (x = true) { } // an assignment, so x will always be true! ❑ Curly braces are optional for if  blocks that have only one conditional state-
ment. But watch out for misleading indentations. ❑ switch statements can evaluate only to enums or the byte, short, int, and 
char data types. You can't say,
 long s = 30;
 switch(s) { }
❑ The case constant must be a literal or final variable, or a constant 
expression, including an enum. You cannot have a case that includes a non-
final variable, or a range of values. ❑ If the condition in a switch statement matches a case constant, execution 
will run through all code in the switch following the matching case 
statement until a break statement or the end of the switch statement is 
encountered. In other words, the matching case is just the entry point into 
the case block, but unless there's a break statement, the matching case is 
not the only case code that runs. ❑ The default keyword should be used in a switch statement if you want to 
run some code when none of the case values match the conditional value. ❑ The default block can be located anywhere in the switch block, so if no 
case matches, the default block will be entered, and if the default does 
not contain a break, then code will continue to execute (fall-through) to the 
end of the switch or until the break statement is encountered. T wo-Minute Drill 397
✓
398 Chapter 5:  Flow Control, Exceptions, and Assertions
Writing Code Using Loops (Objective 2.2)
❑ A basic for statement has three parts: declaration and/or initialization, bool-
ean evaluation, and the iteration expression. ❑ If a variable is incremented or evaluated within a basic for loop, it must be 
declared before the loop, or within the for loop declaration. ❑ A variable declared (not just initialized) within the basic for loop declara-
tion cannot be accessed outside the for loop (in other words, code below the 
for loop won't be able to use the variable). ❑ You can initialize more than one variable of the same type in the first part 
of the basic for loop declaration; each initialization must be separated by a 
comma. ❑ An enhanced for statement (new as of Java 6), has two parts, the declaration 
and the expression. It is used only to loop through arrays or collections. ❑ With an enhanced for, the expression is the array or collection through 
which you want to loop. ❑ With an enhanced for, the declaration is the block variable, whose type is 
compatible with the elements of the array or collection, and that variable 
contains the value of the element for the given iteration. ❑ You cannot use a number (old C-style language construct) or anything that 
does not evaluate to a boolean value as a condition for an if statement or 
looping construct. You can't, for example, say if(x), unless x is a boolean 
variable. ❑ The do loop will enter the body of the loop at least once, even if the test 
condition is not met. Using break and continue (Objective 2.2)
❑ An unlabeled break statement will cause the current iteration of the inner-
most looping construct to stop and the line of code following the loop to run. ❑ An unlabeled continue statement will cause: the current iteration of the 
innermost loop to stop, the condition of that loop to be checked, and if
the condition is met, the loop to run again. ❑ If the break statement or the continue statement is labeled, it will cause 
similar action to occur on the labeled loop, not the innermost loop. Handling Exceptions (Objectives 2.4, 2.5, and 2.6)
❑ Exceptions come in two flavors: checked and unchecked. ❑ Checked exceptions include all subtypes of Exception, excluding classes 
that extend RuntimeException. ❑ Checked exceptions are subject to the handle or declare rule; any method 
that might throw a checked exception (including methods that invoke meth-
ods that can throw a checked exception) must either declare the exception 
using throws, or handle the exception with an appropriate try/catch. ❑ Subtypes of Error or RuntimeException are unchecked, so the compiler 
doesn't enforce the handle or declare rule. You're free to handle them, or to 
declare them, but the compiler doesn't care one way or the other. ❑ If you use an optional finally block, it will always be invoked, regardless of 
whether an exception in the corresponding try is thrown or not, and regard-
less of whether a thrown exception is caught or not. ❑ The only exception to the finally-will-always-be-called rule is that a fi-
nally will not be invoked if the JVM shuts down. That could happen if code 
from the try or catch blocks calls System.exit(). ❑ Just because finally is invoked does not mean it will complete. Code in the 
finally block could itself raise an exception or issue a System.exit(). ❑ Uncaught exceptions propagate back through the call stack, starting from 
the method where the exception is thrown and ending with either the first 
method that has a corresponding catch for that exception type or a JVM 
shutdown (which happens if the exception gets to main(), and main() is 
"ducking" the exception by declaring it). ❑ You can create your own exceptions, normally by extending Exception or 
one of its subtypes. Your exception will then be considered a checked excep-
tion, and the compiler will enforce the handle or declare rule for that exception. ❑ All catch blocks must be ordered from most specific to most general. If you have a catch clause for both IOException and Exception, you must 
put the catch for IOException first in your code. Otherwise, the IOExcep-
tion would be caught by catch(Exception e), because a catch argument 
can catch the specified exception or any of its subtypes! The compiler will 
stop you from defining catch clauses that can never be reached. ❑ Some exceptions are created by programmers, some by the JVM. T wo-Minute Drill 399
400 Chapter 5:  Flow Control, Exceptions, and Assertions
    Working with the Assertion Mechanism (Objective 2.3)
❑ Assertions give you a way to test your assumptions during development and 
debugging. ❑ Assertions are typically enabled during testing but disabled during deployment. ❑ You can use assert as a keyword (as of version 1.4) or an identifier, but not 
both together. To compile older code that uses assert as an identifier 
(for example, a method name), use the -source 1.3 command-line flag 
to javac. ❑ Assertions are disabled at runtime by default. To enable them, use a com-
mand-line flag -ea or -enableassertions. ❑ Selectively disable assertions by using the -da or -disableassertions flag. ❑ If you enable or disable assertions using the flag without any arguments, 
you're enabling or disabling assertions in general. You can combine enabling 
and disabling switches to have assertions enabled for some classes and/or 
packages, but not others. ❑ You can enable and disable assertions on a class-by-class basis, using the fol-
lowing syntax:
java -ea  -da:MyClass  TestClass
❑ You can enable and disable assertions on a package-by-package basis, and any 
package you specify also includes any subpackages (packages further down the 
directory hierarchy). ❑ Do not use assertions to validate arguments to public methods. ❑ Do not use assert expressions that cause side effects. Assertions aren't guar-
anteed to always run, and you don't want behavior that changes depending 
on whether assertions are enabled. ❑ Do use assertions—even in public methods—to validate that a particular 
code block will never be reached. You can use assert false; for code that 
should never be reached, so that an assertion error is thrown immediately if 
the assert statement is executed. Self T est 401
SELF TEST
 1. Given two files:
1. class One {
2. public static void main(String[] args) {
3. int assert = 0;
4. }
5.

--- Chunk #1396 ---
}
1. class Two {
2. public static void main(String[] args) {
3. assert(false);
4. }
5. }
      And the four command-line invocations:
javac -source 1.3 One.java
javac -source 1.4 One.java
javac -source 1.3 Two.java
javac -source 1.4 Two.java
  What is the result? (Choose all that apply.)
  A. Only one compilation will succeed
  B. Exactly two compilations will succeed
  C. Exactly three compilations will succeed
  D. All four compilations will succeed
  E. No compiler warnings will be produced
  F. At least one compiler warning will be produced
 2. Given:
class Plane {
  static String s = "-";
  public static void main(String[] args) {
    new Plane().s1();
    System.out.println(s);
  }
  void s1() {
    try { s2(); }
    catch (Exception e) { s += "c"; }
  }
  void s2() throws Exception  {
    s3();  s += "2";
    s3();  s += "2b";
  }
  void s3() throws Exception {
    throw new Exception();
  }
}
  What is the result? A.

--- Chunk #1397 ---
-
  B. -c
  C. -c2
  D. -2c
  E. -c22b
  F. -2c2b
  G. -2c2bc
  H. Compilation fails
 3. Given:
try { int x = Integer.parseInt("two"); }
  Which could be used to create an appropriate catch block? (Choose all that apply.)
  A. ClassCastException
  B. IllegalStateException
  C. NumberFormatException
  D. IllegalArgumentException
  E. ExceptionInInitializerError
  F. ArrayIndexOutOfBoundsException
 4. Which are true?

--- Chunk #1398 ---
(Choose all that apply.)
  A. It is appropriate to use assertions to validate arguments to methods marked public
  B. It is appropriate to catch and handle assertion errors
  C. It is NOT appropriate to use assertions to validate command-line arguments
  D. It is appropriate to use assertions to generate alerts when you reach code that should not 
be reachable
  E. It is NOT appropriate for assertions to change a program’s state
402 Chapter 5:  Flow Control, Exceptions, and Assertions
Self T est 403
 5. Given:
1.

--- Chunk #1399 ---
class Loopy {
2. public static void main(String[] args) {
3. int[] x = {7,6,5,4,3,2,1};
4. // insert code here 
5. System.out.print(y + " ");
6. }
7.

--- Chunk #1400 ---
}
8. }
       Which, inserted independently at line 4, compiles? (Choose all that apply.)
  A. for(int y : x) {
  B. for(x : int y) {
  C. int y = 0; for(y : x) {
  D. for(int y=0, z=0; z<x.length; z++) { y = x[z]; 
  E. for(int y=0, int z=0; z<x.length; z++) { y = x[z]; 
  F. int y = 0; for(int z=0; z<x.length; z++) { y = x[z];
 6. Given:
class Emu {
  static String s = "-";
  public static void main(String[] args) {
    try {
      throw new Exception();
    } catch (Exception e) {
        try { 
          try { throw new Exception();
          } catch (Exception ex) { s += "ic "; }
          throw new Exception(); } 
        catch (Exception x) { s += "mc "; }
        finally { s += "mf "; }
    } finally { s += "of "; }
    System.out.println(s);
} }
  What is the result? A.

--- Chunk #1401 ---
-ic of
  B. -mf of
  C. -mc mf
404 Chapter 5:  Flow Control, Exceptions, and Assertions
  D. -ic mf of
  E. -ic mc mf of
  F. -ic mc of mf
  G. Compilation fails
 7.

--- Chunk #1402 ---
Given:
 3. class SubException extends Exception { }
 4. class SubSubException extends SubException { }
 5. 6. public class CC { void doStuff() throws SubException { } }
 7. 8. class CC2 extends CC { void doStuff() throws SubSubException { } }
 9. 10. class CC3 extends CC { void doStuff() throws Exception { } }
11. 12. class CC4 extends CC { void doStuff(int x) throws Exception { } }
13. 14. class CC5 extends CC {  void doStuff()  { } }
  What is the result? (Choose all that apply.)
  A. Compilation succeeds
  B. Compilation fails due to an error on line 8
  C. Compilation fails due to an error on line 10
  D. Compilation fails due to an error on line 12
  E. Compilation fails due to an error on line 14
 8. Given:
 3. public class Ebb {
 4. static int x = 7;
 5. public static void main(String[] args) {
 6. String s = "";
 7. for(int y = 0; y < 3; y++) {
 8. x++;
 9. switch(x) {
10. case 8: s += "8 ";
11. case 9: s += "9 ";
12. case 10: { s+= "10 "; break; }
13. default: s += "d ";
14. case 13: s+= "13 ";
15. }
16. }
17. System.out.println(s);   
18. }
19. static { x++; }
20. }  
  What is the result?

--- Chunk #1403 ---
A. 9 10 d
  B. 8 9 10 d
  C. 9 10 10 d
  D. 9 10 10 d 13
  E. 8 9 10 10 d 13
  F. 8 9 10 9 10 10 d 13
  G. Compilation fails
 9. Given:
 3. class Infinity { }
 4. public class Beyond extends Infinity {
 5. static Integer i;
 6. public static void main(String[] args) {
 7. int sw = (int)(Math.random() * 3);
 8. switch(sw) {
 9. case 0: {  for(int x = 10; x > 5; x++)
10. if(x > 10000000) x = 10;  
11. break; }
12. case 1: {  int y = 7 * i;  break;  }
13. case 2: {  Infinity inf = new Beyond();
14. Beyond b = (Beyond)inf;  }
15. }
16. }
17. }
  And given that line 7 will assign the value 0, 1, or 2 to sw, which are true? (Choose all that apply.)
  A. Compilation fails
  B. A ClassCastException might be thrown
  C. A StackOverflowError might be thrown
  D. A NullPointerException might be thrown
Self T est 405
406 Chapter 5:  Flow Control, Exceptions, and Assertions
  E. An IllegalStateException might be thrown
  F. The program might hang without ever completing
  G. The program will always complete without exception
 10. Given:
 3. public class Circles {
 4. public static void main(String[] args) {
 5. int[] ia = {1,3,5,7,9};
 6. for(int x : ia) {
 7. for(int j = 0; j < 3; j++) {
 8. if(x > 4 && x < 8) continue;
 9. System.out.print(" " + x);
10. if(j == 1) break;
11. continue;
12. }
13. continue;
14. }
15. }
16. }
  What is the result? A. 1 3 9
  B. 5 5 7 7 
  C. 1 3 3 9 9
  D. 1 1 3 3 9 9
  E. 1 1 1 3 3 3 9 9 9
  F. Compilation fails
 11.

--- Chunk #1404 ---
Given:
 3. public class OverAndOver {
 4. static String s = "";
 5. public static void main(String[] args) {
 6. try {
 7. s += "1";
 8. throw new Exception();
 9. } catch (Exception e) { s += "2"; 
10. } finally { s += "3"; doStuff(); s += "4"; 
11. }
12. System.out.println(s);
13. }
14. static void doStuff() { int x = 0; int y = 7/x; }
15. }
  What is the result?

--- Chunk #1405 ---
A. 12
  B. 13
  C. 123
  D. 1234
  E. Compilation fails
  F. 123 followed by an exception
  G. 1234 followed by an exception
  H. An exception is thrown with no other output
 12. Given:
 3. public class Wind {
 4. public static void main(String[] args) {
 5. foreach:
 6. for(int j=0; j<5; j++) {
 7. for(int k=0; k< 3; k++) {
 8. System.out.print(" " + j);
 9. if(j==3 && k==1) break foreach;
10. if(j==0 || j==2) break;
11. }
12.

--- Chunk #1406 ---
}
13. }
14. }
  What is the result? A. 0 1 2 3
  B. 1 1 1 3 3
  C. 0 1 1 1 2 3 3
  D. 1 1 1 3 3 4 4 4 
  E.

--- Chunk #1407 ---
0 1 1 1 2 3 3 4 4 4 
  F. Compilation fails
Self T est 407
408 Chapter 5:  Flow Control, Exceptions, and Assertions
 13. Given:
 3. public class Gotcha {
 4. public static void main(String[] args) {
 5. // insert code here
 6. 7.

--- Chunk #1408 ---
}
 8. void go() {
 9. go();
10. }
11. }
  And given the following three code fragments:
I. new Gotcha().go();
II. try { new Gotcha().go(); } 
     catch (Error e) { System.out.println("ouch"); }
III. try { new Gotcha().go(); }
     catch (Exception e) { System.out.println("ouch"); }
  When fragments I - III are added, independently, at line 5, which are true? (Choose all that apply.)
  A.

--- Chunk #1409 ---
Some will not compile
  B. They will all compile
  C. All will complete normally
  D. None will complete normally
  E. Only one will complete normally
  F. T wo of them will complete normally
 14. Given:
 3. public class Clumsy {
 4. public static void main(String[] args) {
 5. int j = 7;
 6. assert(++j > 7);
 7. assert(++j > 8): "hi";
 8. assert(j > 10): j=12;
 9. assert(j==12): doStuff();
10. assert(j==12): new Clumsy();
11. }
12. static void doStuff() { }
13. }
  Which are true? (Choose all that apply.)
  A. Compilation succeeds
  B. Compilation fails due to an error on line 6
  C. Compilation fails due to an error on line 7
  D. Compilation fails due to an error on line 8
  E. Compilation fails due to an error on line 9
  F. Compilation fails due to an error on line 10
 15. Given:
 1. public class Frisbee {
 2. // insert code here
 3. int x = 0;
 4. System.out.println(7/x);
 5. }
 6. }
  And given the following four code fragments:
I. public static void main(String[] args) {
II. public static void main(String[] args) throws Exception {
III. public static void main(String[] args) throws IOException { 
IV. public static void main(String[] args) throws RuntimeException {
  If the four fragments are inserted independently at line 4, which are true? (Choose all that apply.)
  A. All four will compile and execute without exception
  B. All four will compile and execute and throw an exception
  C. Some, but not all, will compile and execute without exception
  D. Some, but not all, will compile and execute and throw an exception
  E. When considering fragments II, III, and IV , of those that will compile, adding a try/catch 
block around line 6 will cause compilation to fail
Self T est 409
410 Chapter 5:  Flow Control, Exceptions, and Assertions
 16. Given:
 2.

--- Chunk #1410 ---
class MyException extends Exception { }
 3. class Tire {
 4. void doStuff() {  }
 5. } 
 6. public class Retread extends Tire {
 7. public static void main(String[] args) {
 8. new Retread().doStuff();
 9. }
10. // insert code here
11. System.out.println(7/0);
12. }
13. }
  And given the following four code fragments:
I. void doStuff() {
II. void doStuff() throws MyException {
III. void doStuff() throws RuntimeException {
IV. void doStuff() throws ArithmeticException {
  When fragments I - IV are added, independently, at line 10, which are true? (Choose all that apply.)
  A. None will compile
  B. They will all compile
  C. Some, but not all, will compile
  D. All of those that compile will throw an exception at runtime
  E. None of those that compile will throw an exception at runtime
  F. Only some of those that compile will throw an exception at runtime
 
SELF TEST ANSWERS
 1. Given two files:
1. class One {
2. public static void main(String[] args) {
3. int assert = 0;
4. }
5.

--- Chunk #1411 ---
}
1. class Two {
2. public static void main(String[] args) {
3. assert(false);
4. }
5. }
  And the four command-line invocations:
javac -source 1.3 One.java
javac -source 1.4 One.java
javac -source 1.3 Two.java
javac -source 1.4 Two.java
  What is the result? (Choose all that apply.)
  A. Only one compilation will succeed
  B. Exactly two compilations will succeed
  C. Exactly three compilations will succeed
  D. All four compilations will succeed
  E. No compiler warnings will be produced
  F. At least one compiler warning will be produced
Answer:
   ✓  B and F are correct. Cl ass One will compile (and issue a warning) using the 1.3 flag, and 
class T wo will compile using the 1.4 flag.     A, C, D, and E are incorrect based on the above. (Objective 2.3)
 2. Given:
class Plane {
  static String s = "-";
  public static void main(String[] args) {
    new Plane().s1();
Self T est Answers 411
    System.out.println(s);
  }
  void s1() {
    try { s2(); }
    catch (Exception e) { s += "c"; }
  }
  void s2() throws Exception  {
    s3();  s += "2";
    s3();  s += "2b";
  }
  void s3() throws Exception {
    throw new Exception();
} }
  What is the result? A.

--- Chunk #1412 ---
-
  B. -c
  C. -c2
  D. -2c
  E. -c22b
  F. -2c2b
  G. -2c2bc
  H. Compilation fails
Answer:
   ✓   B is correct. Once s3() throws the exception to s2(), s2() throws it to s1(), and no 
more of s2()’s code will be executed.     A, C, D, E, F, G, and H are incorrect based on the above.

--- Chunk #1413 ---
(Objective 2.5)
 3. Given:
try { int x = Integer.parseInt("two"); }
  Which could be used to create an appropriate catch block? (Choose all that apply.)
  A. ClassCastException
  B. IllegalStateException
  C. NumberFormatException
  D. IllegalArgumentException
412 Chapter 5:  Flow Control, Exceptions, and Assertions
  E. ExceptionInInitializerError
  F. ArrayIndexOutOfBoundsException
Answer:
   ✓   C and D are correct. Integer.parseInt can throw a NumberFormatException, and 
IllegalArgumentException is its superclass (i.e., a broader exception).     A, B, E, and F are not in NumberFormatException’s class hierarchy. (Objective 2.6)
 4.

--- Chunk #1414 ---
Which are true? (Choose all that apply.)
  A. It is appropriate to use assertions to validate arguments to methods marked public
  B. It is appropriate to catch and handle assertion errors
  C. It is NOT appropriate to use assertions to validate command-line arguments
  D. It is appropriate to use assertions to generate alerts when you reach code that should not 
be reachable
  E. It is NOT appropriate for assertions to change a program’s state
Answer:
   ✓   C, D, and E are correct statements.     A is incorrect. It is acceptable to use assertions to test the arguments of private methods. B is incorrect. While assertion errors can be caught, Sun discourages you from doing so. (Objective 2.3)
 5.

--- Chunk #1415 ---
Given:
1. class Loopy {
2. public static void main(String[] args) {
3. int[] x = {7,6,5,4,3,2,1};
4. // insert code here 
5. System.out.print(y + " ");
6. }
7. } }
  Which, inserted independently at line 4, compiles? (Choose all that apply.)
  A. for(int y : x) {
  B. for(x : int y) {
  C. int y = 0; for(y : x) {
Self T est Answers 413
414 Chapter 5:  Flow Control, Exceptions, and Assertions
  D. for(int y=0, z=0; z<x.length; z++) { y = x[z]; 
  E. for(int y=0, int z=0; z<x.length; z++) { y = x[z]; 
  F. int y = 0; for(int z=0; z<x.length; z++) { y = x[z];
Answer:
   ✓   A, D, and F are correct. A is an example of the enhanced for loop. D and F are examples 
of the basic for loop.     B is incorrect because its operands are swapped. C is incorrect because the enhanced 
for must declare its first operand. E is incorrect syntax to declare two variables in a for 
statement. (Objective 2.2)
 6. Given:
class Emu {
  static String s = "-";
  public static void main(String[] args) {
    try {
      throw new Exception();
    } catch (Exception e) {
        try { 
          try { throw new Exception();
          } catch (Exception ex) { s += "ic "; }
          throw new Exception(); } 
        catch (Exception x) { s += "mc "; }
        finally { s += "mf "; }
    } finally { s += "of "; }
    System.out.println(s);
} }
  What is the result? A.

--- Chunk #1416 ---
-ic of
  B. -mf of
  C. -mc mf
  D. -ic mf of
  E. -ic mc mf of
  F. -ic mc of mf
  G. Compilation fails
Answer:
   ✓   E is correct. There is no problem nesting try / catch blocks. As is normal, when an 
exception is thrown, the code in the catch block runs, then the code in the finally block 
runs.      A, B, C, D, and F are incorrect based on the above.

--- Chunk #1417 ---
(Objective 2.5)
 7.

--- Chunk #1418 ---
Given:
 3. class SubException extends Exception { }
 4. class SubSubException extends SubException { }
 5. 6. public class CC { void doStuff() throws SubException { } }
 7. 8. class CC2 extends CC { void doStuff() throws SubSubException { } }
 9. 10. class CC3 extends CC { void doStuff() throws Exception { } }
11. 12. class CC4 extends CC { void doStuff(int x) throws Exception { } }
13. 14. class CC5 extends CC {  void doStuff()  { } }
  What is the result? (Choose all that apply.)
  A. Compilation succeeds
  B. Compilation fails due to an error on line 8
  C. Compilation fails due to an error on line 10
  D. Compilation fails due to an error on line 12
  E. Compilation fails due to an error on line 14
Answer:
   ✓  C is correct. An overriding method cannot throw a broader exception than the method it's 
overriding. Class CC4's method is an overload, not an override.     A, B, D, and E are incorrect based on the above. (Objectives 1.5, 2.4)
 8. Given:
 3. public class Ebb {
 4. static int x = 7;
 5. public static void main(String[] args) {
 6. String s = "";
Self T est Answers 415
416 Chapter 5:  Flow Control, Exceptions, and Assertions
 7. for(int y = 0; y < 3; y++) {
 8. x++;
 9. switch(x) {
10. case 8: s += "8 ";
11. case 9: s += "9 ";
12. case 10: { s+= "10 "; break; }
13. default: s += "d ";
14. case 13: s+= "13 ";
15. }
16. }
17. System.out.println(s);   
18. }
19. static { x++; }
20. }  
  What is the result?

--- Chunk #1419 ---
A. 9 10 d
  B. 8 9 10 d
  C. 9 10 10 d
  D. 9 10 10 d 13
  E. 8 9 10 10 d 13
  F. 8 9 10 9 10 10 d 13
  G. Compilation fails
Answer:
   ✓  D is correct. Did you catch the static initializer block? Remember that switches work on 
"fall-thru" logic, and that fall-thru logic also applies to the default case, which is used when 
no other case matches.     A, B, C, E, F, and G are incorrect based on the above. (Objective 2.1)
 9.

--- Chunk #1420 ---
Given:
 3. class Infinity { }
 4. public class Beyond extends Infinity {
 5. static Integer i;
 6. public static void main(String[] args) {
 7. int sw = (int)(Math.random() * 3);
 8. switch(sw) {
 9. case 0: {  for(int x = 10; x > 5; x++)
10. if(x > 10000000) x = 10;  
11. break; }
12. case 1: {  int y = 7 * i;  break;  }
13. case 2: {  Infinity inf = new Beyond();
14. Beyond b = (Beyond)inf;  }
15. }
16. }
17. }
  And given that line 7 will assign the value 0, 1, or 2 to sw, which are true? (Choose all that apply.)
  A. Compilation fails
  B. A ClassCastException might be thrown
  C. A StackOverflowError might be thrown
  D. A NullPointerException might be thrown
  E. An IllegalStateException might be thrown
  F. The program might hang without ever completing
  G. The program will always complete without exception
Answer:
   ✓  D and F are correct. Because i was not initialized, case 1 will throw an NPE. Case 0 will 
initiate an endless loop, not a stack overflow. Case 2's downcast will not cause an exception.     A, B, C, E, and G are incorrect based on the above. (Objective 2.6)
 10.

--- Chunk #1421 ---
Given:
 3. public class Circles {
 4. public static void main(String[] args) {
 5. int[] ia = {1,3,5,7,9};
 6. for(int x : ia) {
 7. for(int j = 0; j < 3; j++) {
 8. if(x > 4 && x < 8) continue;
 9. System.out.print(" " + x);
10. if(j == 1) break;
11. continue;
12. }
13. continue;
14. }
15.

--- Chunk #1422 ---
}
16. }
Self T est Answers 417
418 Chapter 5:  Flow Control, Exceptions, and Assertions
  What is the result? A.

--- Chunk #1423 ---
1 3 9
  B. 5 5 7 7 
  C. 1 3 3 9 9
  D. 1 1 3 3 9 9
  E. 1 1 1 3 3 3 9 9 9
  F. Compilation fails
Answer:
   ✓  D is correct. The basic rule for unlabeled continue statements is that the current iteration 
stops early and execution jumps to the next iteration. The last two continue statements are 
redundant!     A, B, C, E, and F are incorrect based on the above. (Objective 2.2)
 11.

--- Chunk #1424 ---
Given:
 3. public class OverAndOver {
 4. static String s = "";
 5. public static void main(String[] args) {
 6. try {
 7. s += "1";
 8. throw new Exception();
 9. } catch (Exception e) { s += "2"; 
10. } finally { s += "3"; doStuff(); s += "4"; 
11. }
12. System.out.println(s);
13. }
14. static void doStuff() { int x = 0; int y = 7/x; }
15. }
  What is the result?

--- Chunk #1425 ---
A. 12
  B. 13
  C. 123
  D. 1234
  E. Compilation fails
  F. 123 followed by an exception
  G. 1234 followed by an exception
  H. An exception is thrown with no other output
Answer:
   ✓  H is correct. It's true that the value of String s is 123 at the time that the divide-by-
zero exception is thrown, but finally() is not guaranteed to complete, and in this case 
finally() never completes, so the System.out.println (S.O.P .) never executes.     A, B, C, D, E, F, and G are incorrect based on the above.

--- Chunk #1426 ---
(Objective 2.5)
 12.

--- Chunk #1427 ---
Given:
 3. public class Wind {
 4. public static void main(String[] args) {
 5. foreach:
 6. for(int j=0; j<5; j++) {
 7. for(int k=0; k< 3; k++) {
 8. System.out.print(" " + j);
 9. if(j==3 && k==1) break foreach;
10. if(j==0 || j==2) break;
11. }
12.

--- Chunk #1428 ---
}
13. }
14. }
  What is the result? A. 0 1 2 3
  B. 1 1 1 3 3
  C. 0 1 1 1 2 3 3
  D. 1 1 1 3 3 4 4 4 
  E. 0 1 1 1 2 3 3 4 4 4 
  F. Compilation fails
Answer:
   ✓  C is correct. A break breaks out of the current innermost loop and continues. A labeled 
break breaks out of and terminates the current loops.     A, B, D, E, and F are incorrect based on the above. (Objective 2.2)
Self T est Answers 419
420 Chapter 5:  Flow Control, Exceptions, and Assertions
 13. Given:
 3. public class Gotcha {
 4. public static void main(String[] args) {
 5. // insert code here
 6. 7.

--- Chunk #1429 ---
}
 8. void go() {
 9. go();
10. }
11. }
  And given the following three code fragments:
I. new Gotcha().go();
II. try { new Gotcha().go(); } 
     catch (Error e) { System.out.println("ouch"); }
III. try { new Gotcha().go(); }
     catch (Exception e) { System.out.println("ouch"); }
  When fragments I - III are added, independently, at line 5, which are true? (Choose all that apply.)
  A.

--- Chunk #1430 ---
Some will not compile
  B. They will all compile
  C. All will complete normally
  D. None will complete normally
  E. Only one will complete normally
  F. T wo of them will complete normally
Answer:
   ✓  B and E are correct. First off, go() is a badly designed recursive method, guaranteed to 
cause a StackOverflowError. Since Exception is not a superclass of Error, catching an 
Exception will not help handle an Error, so fragment III will not complete normally. Only fragment II will catch the Error.     A, C, D, and F are incorrect based on the above. (Objective 2.5)
 14.

--- Chunk #1431 ---
Given:
 3. public class Clumsy {
 4. public static void main(String[] args) {
 5. int j = 7;
 6. assert(++j > 7);
 7. assert(++j > 8): "hi";
 8. assert(j > 10): j=12;
 9. assert(j==12): doStuff();
10. assert(j==12): new Clumsy();
11. }
12. static void doStuff() { }
13. }
  Which are true? (Choose all that apply.)
  A. Compilation succeeds
  B. Compilation fails due to an error on line 6
  C. Compilation fails due to an error on line 7
  D. Compilation fails due to an error on line 8
  E. Compilation fails due to an error on line 9
  F. Compilation fails due to an error on line 10
Answer:
   ✓  E is correct. When an assert statement has two expressions, the second expression must 
return a value. The only two-expression assert statement that doesn’t return a value is on 
line 9.     A, B, C, D, and F are incorrect based on the above. (Objective 2.3)
 15.

--- Chunk #1432 ---
Given:
 1. public class Frisbee {
 2. // insert code here
 3. int x = 0;
 4. System.out.println(7/x);
 5. }
 6. }
Self T est Answers 421
422 Chapter 5:  Flow Control, Exceptions, and Assertions
  And given the following four code fragments:
I. public static void main(String[] args) {
II. public static void main(String[] args) throws Exception {
III. public static void main(String[] args) throws IOException { 
IV. public static void main(String[] args) throws RuntimeException {
  If the four fragments are inserted independently at line 4, which are true? (Choose all that apply.)
  A. All four will compile and execute without exception
  B. All four will compile and execute and throw an exception
  C. Some, but not all, will compile and execute without exception
  D. Some, but not all, will compile and execute and throw an exception
  E. When considering fragments II, III, and IV , of those that will compile, adding a try/catch 
block around line 6 will cause compilation to fail
Answer:
   ✓  D is correct. This is kind of sneaky, but remember that we're trying to toughen you up for 
the real exam. If you're going to throw an IOException, you have to import the java.io 
package or declare the exception with a fully qualified name.     E is incorrect because it's okay to both handle and declare an exception. A, B, and C are 
incorrect based on the above. (Objective 2.4)
 16.

--- Chunk #1433 ---
Given:
 2. class MyException extends Exception { }
 3. class Tire {
 4. void doStuff() {  }
 5. } 
 6. public class Retread extends Tire {
 7. public static void main(String[] args) {
 8. new Retread().doStuff();
 9. }
10. // insert code here
11. System.out.println(7/0);
12. }
13. }
  And given the following four code fragments:
I. void doStuff() {
II. void doStuff() throws MyException {
III. void doStuff() throws RuntimeException {
IV. void doStuff() throws ArithmeticException {
  When fragments I - IV are added, independently, at line 10, which are true? (Choose all that apply.)
  A. None will compile
  B. They will all compile
  C. Some, but not all, will compile
  D. All of those that compile will throw an exception at runtime
  E. None of those that compile will throw an exception at runtime
  F. Only some of those that compile will throw an exception at runtime
Answer:
   ✓  C and D are correct. An overriding method cannot throw checked exceptions that are 
broader than those thrown by the overridden method. However an overriding method can 
throw RuntimeExceptions not thrown by the overridden method.     A, B, E, and F are incorrect based on the above. (Objective 2.4)
Self T est Answers 423
			

6
Strings, I/O, 
Formatting, 
and Parsing
CERTIFICATION OBJECTIVES
Using String, StringBuilder, and 
       StringBuffer
    File I/O using the java.io package
 Serialization using the java.io 
       package
 Working with Dates, Numbers, 
       and Currencies
 Using Regular Expressions
 ✓   T wo-Minute Drill
          Q&A Self T est
 
	
426 Chapter 6:  Strings, I/O, Formatting, and Parsing
T
his chapter focuses on the various API-related topics that were added to the exam 
for Java 5 and remain in the Java 6 exam. J2SE comes with an enormous API, and a lot 
of your work as a Java programmer will revolve around using this API. The exam team 
chose to focus on APIs for I/O, formatting, and parsing. Each of these topics could fill an entire 
book. Fortunately, you won't have to become a total I/O or regex guru to do well on the exam. The intention of the exam team was to include just the basic aspects of these technologies, and in 
this chapter we cover more than you'll need to get through the String, I/O, formatting, and parsing 
objectives on the exam. CERTIFICATION OBJECTIVE
String, StringBuilder, and StringBuffer 
(Exam Objective 3.1)
3.1 Discuss the differences between the String, StringBuilder, and StringBuffer classes. Everything you needed to know about Strings in the SCJP 1.4 exam, you'll need to 
know for the SCJP 5 and SCJP 6 exams. plus, Sun added the StringBuilder class to the 
API, to provide faster, nonsynchronized StringBuffer capability. The StringBuilder 
class has exactly the same methods as the old StringBuffer class, but StringBuilder 
is faster because its methods aren't synchronized. Both classes give you String-like 
objects that handle some of the String class's shortcomings (like immutability). The String Class
This section covers the String class, and the key concept to understand is that once 
a String object is created, it can never be changed—so what is happening when a 
String object seems to be changing? Let's find out. Strings Are Immutable Objects
We'll start with a little background information about strings. You may not need 
this for the test, but a little context will help. Handling "strings" of characters is a 
fundamental aspect of most programming languages. In Java, each character in a 
The String Class (Exam Objective 3.1) 427
string is a 16-bit Unicode character. Because Unicode characters are 16 bits (not 
the skimpy 7 or 8 bits that ASCII provides), a rich, international set of characters is 
easily represented in Unicode. In Java, strings are objects. Just like other objects, you can create an instance of a 
String with the new keyword, as follows:
String s = new String();
This line of code creates a new object of class String, and assigns it to the 
reference variable s. So far, String objects seem just like other objects. Now, let's 
give the String a value:
s = "abcdef";
As you might expect, the String class has about a zillion constructors, so you can 
use a more efficient shortcut:
String s = new String("abcdef");
And just because you'll use strings all the time, you can even say this:
String s = "abcdef";
There are some subtle differences between these options that we'll discuss later, 
but what they have in common is that they all create a new String object, with a 
value of "abcdef", and assign it to a reference variable s. Now let's say that you 
want a second reference to the String object referred to by s:
String s2 = s;   //  refer s2 to the same String as s
So far so good. String objects seem to be behaving just like other objects, so 
what's all the fuss about?…Immutability! (What the heck is immutability?) Once 
you have assigned a String a value, that value can never change— it's immutable, 
frozen solid, won't budge, fini, done. (We'll talk about why later, don't let us forget.) 
The good news is that while the String object is immutable, its reference variable is 
not, so to continue with our previous example:
s = s.concat(" more stuff");  // the concat() method 'appends'
                              // a literal to the end 
Now wait just a minute, didn't we just say that Strings were immutable? So what's 
all this "appending to the end of the string" talk? Excellent question: let's look at 
what really happened…
The VM took the value of String s (which was "abcdef"), and tacked " more 
stuff" onto the end, giving us the value "abcdef more stuff". Since Strings 
are immutable, the VM couldn't stuff this new value into the old String referenced 
by s, so it created a new String object, gave it the value "abcdef more stuff", 
and made s refer to it. At this point in our example, we have two String objects: the 
first one we created, with the value "abcdef", and the second one with the value 
"abcdef more stuff". Technically there are now three String objects, because 
the literal argument to concat, " more stuff", is itself a new String object. But we 
have references only to "abcdef" (referenced by s2) and "abcdef more stuff" 
(referenced by s). What if we didn't have the foresight or luck to create a second reference variable 
for the "abcdef" String before we called s = s.concat(" more stuff");? In 
that case, the original, unchanged String containing "abcdef" would still exist in 
memory, but it would be considered "lost." No code in our program has any way to 
reference it—it is lost to us. Note, however, that the original "abcdef" String 
didn't change (it can't, remember, it's immutable); only the reference variable s 
was changed, so that it would refer to a different String. Figure 6-1 shows what 
happens on the heap when you reassign a reference variable. Note that the 
dashed line indicates a deleted reference. To review our first example:
String s = "abcdef";   // create a new String object, with 
                       // value "abcdef", refer s to it
String s2 = s;         // create a 2nd reference variable 
                       // referring to the same String
// create a new String object, with value "abcdef more stuff", 
// refer s to it. (Change s's reference from the old String
// to the new String.) ( Remember s2 is still referring to 
// the original "abcdef" String.)
s = s.concat(" more stuff"); 
428 Chapter 6:  Strings, I/O, Formatting, and Parsing
 FIGURE 6-1    String objects and their reference variables 
   
The String Class (Exam Objective 3.1) 429
The heap
String objectString reference
variable
String reference
variable
String reference
variable
String reference
variable
String reference
variable
s
s2
s
s2
s
String s = “abc”;
“abc”
The heap
String object
“abc”
The heap
String object 
String object
“abc”
“abcdef”
Step 1:
String s2 = s;Step 2:
s = s.concat (”def”);Step 3:
  
Let's look at another example:
String x = "Java";
x.concat(" Rules!");
System.out.println("x = " + x);  // the output is "x = Java"
The first line is straightforward: create a new String object, give it the value 
"Java", and refer x to it. Next the VM creates a second String object with the value 
"Java Rules!" but nothing refers to it. The second String object is instantly lost; 
you can't get to it. The reference variable x still refers to the original String with the 
value "Java". Figure 6-2 shows creating a String without assigning a reference to it. FIGURE 6-2    A String object is abandoned upon creation
430 Chapter 6:  Strings, I/O, Formatting, and Parsing
String reference
variable
String reference
variable
Notice that no reference
variable is created to access
the “Java Rules!” String. String object
String object
String object
The heap
The heap
Step 1:     String x = “Java”;
Step 2:     x.concat (” Rules!”);
x
x
“Java”
“Java”
“Java Rules!”
Let's expand this current example. We started with
String x = "Java";
x.concat(" Rules!");
System.out.println("x = " + x);   // the output is: x = Java
Now let's add
x.toUpperCase();
System.out.println("x = " + x);   // the output is still: 
                                  // x = Java
(We actually did just create a new String object with the value "JAVA", but it was lost, 
and x still refers to the original, unchanged String "Java".) How about adding
x.replace('a', 'X');
System.out.println("x = " + x);   // the output is still:  
                                  // x = Java
Can you determine what happened? The VM created yet another new String 
object, with the value "JXvX", (replacing the a's with X's), but once again this new 
String was lost, leaving x to refer to the original unchanged and unchangeable String 
object, with the value "Java". In all of these cases we called various String methods 
to create a new String by altering an existing String, but we never assigned the newly 
created String to a reference variable. But we can put a small spin on the previous example:
String x = "Java";
x = x.concat(" Rules!");           // Now we're assigning the
                                   // new String to x
System.out.println("x = " + x);    // the output will be:
                                   // x = Java Rules! This time, when the VM runs the second line, a new String object is created with 
the value of "Java Rules!", and x is set to reference it. But wait, there's more—
now the original String object, "Java", has been lost, and no one is referring to it. So in both examples we created two String objects and only one reference variable, 
so one of the two String objects was left out in the cold. See Figure 6-3 for a graphic 
depiction of this sad story. The dashed line indicates a deleted reference. The String Class (Exam Objective 3.1) 431
  FIGURE 6-3    An old String object being abandoned
Let's take this example a little further:
String x = "Java";
x = x.concat(" Rules!");
System.out.println("x = " + x);    // the output is:   
                                   // x = Java Rules! x.toLowerCase();                   // no assignment, create a 
                                   // new, abandoned String
System.out.println("x = " + x);    // no assignment, the output
                                   // is still: x = Java Rules! 432 Chapter 6:  Strings, I/O, Formatting, and Parsing
String reference
variable
String reference
variable
Notice in step 2 that there is no
valid reference to the “Java” String;
that object has been “abandoned,”
and a new object created. String object
String object
String object
The heap
The heap
Step 1:     String x = “Java”;
Step 2:     x = x.concat (” Rules!”);
x
x
“Java”
“Java”
“Java Rules!”
x = x.toLowerCase();               // create a new String, 
                                   // assigned to x
System.out.println("x = " + x);    // the assignment causes the
                                   // output: x = java rules! The preceding discussion contains the keys to understanding Java String 
immutability. If you really, really get the examples and diagrams, backward and 
forward, you should get 80 percent of the String questions on the exam correct. We will cover more details about Strings next, but make no mistake—in terms of 
bang for your buck, what we've already covered is by far the most important part of 
understanding how String objects work in Java. We'll finish this section by presenting an example of the kind of devilish String 
question you might expect to see on the exam. Take the time to work it out on paper 
(as a hint, try to keep track of how many objects and reference variables there are, 
and which ones refer to which). String s1 = "spring ";
String s2 = s1 + "summer ";
s1.concat("fall ");
s2.concat(s1);
s1 += "winter ";
System.out.println(s1 + " " + s2);
What is the output? For extra credit, how many String objects and how many 
reference variables were created prior to the println statement? Answer:  The result of this code fragment is spring winter  spring summer. There are two reference variables, s1 and s2. There were a total of eight String objects 
created as follows: "spring", "summer " (lost), "spring summer", "fall" (lost), "spring 
fall" (lost), "spring summer spring" (lost), "winter" (lost), "spring winter" (at this point 
"spring" is lost). Only two of the eight String objects are not lost in this process. Important Facts About Strings and Memory 
In this section we'll discuss how Java handles String objects in memory, and some of 
the reasons behind these behaviors. One of the key goals of any good programming language is to make efficient use 
of memory. As applications grow, it's very common for String literals to occupy large 
amounts of a program's memory, and there is often a lot of redundancy within the 
Important Facts About Strings and Memory (Exam Objective 3.1) 433
universe of String literals for a program. To make Java more memory efficient, the 
JVM sets aside a special area of memory called the "String constant pool." When the 
compiler encounters a String literal, it checks the pool to see if an identical String 
already exists. If a match is found, the reference to the new literal is directed to the 
existing String, and no new String literal object is created. (The existing String simply 
has an additional reference.) Now we can start to see why making String objects 
immutable is such a good idea. If several reference variables refer to the same String 
without even knowing it, it would be very bad if any of them could change the 
String's value. You might say, "Well that's all well and good, but what if someone overrides the 
String class functionality; couldn't that cause problems in the pool?" That's one of 
the main reasons that the String class is marked final. Nobody can override the 
behaviors of any of the String methods, so you can rest assured that the String 
objects you are counting on to be immutable will, in fact, be immutable. Creating New Strings
Earlier we promised to talk more about the subtle differences between the various 
methods of creating a String. Let's look at a couple of examples of how a String 
might be created, and let's further assume that no other String objects exist in the 
pool:
    String s = "abc";    //  creates one String object and one 
                         //  reference variable
                        
In this simple case, "abc" will go in the pool and s will refer to it. String s = new String("abc");  // creates two objects, 
                                   // and one reference variable 
                            
In this case, because we used the new keyword, Java will create a new String object 
in normal (nonpool) memory, and s will refer to it. In addition, the literal "abc" will 
be placed in the pool. Important Methods in the String Class
The following methods are some of the more commonly used methods in the String 
class, and also the ones that you're most likely to encounter on the exam. 434 Chapter 6:  Strings, I/O, Formatting, and Parsing
■ charAt()    Returns the character located at the specified index
■ concat()    Appends one String to the end of another ( "+" also works)
■ equalsIgnoreCase()    Determines the equality of two Strings, ignoring case
■ length()    Returns the number of characters in a String
■ replace()    Replaces occurrences of a character with a new character
■ substring()    Returns a part of a String
■ toLowerCase()    Returns a String with uppercase characters converted
■ toString()    Returns the value of a String
■ toUpperCase()    Returns a String with lowercase characters converted
■ trim()    Removes whitespace from the ends of a String
Let's look at these methods in more detail. public char charAt(int index)   This method returns the character located at 
the String's specified index. Remember, String indexes are zero-based—for example,
String x = "airplane";
System.out.println( x.charAt(2) );       //  output is 'r'
public String concat(String s)   This method returns a String with the value 
of the String passed in to the method appended to the end of the String used to 
invoke the method—for example,
String x = "taxi";
System.out.println( x.concat(" cab") ); // output is "taxi cab"
The overloaded + and += operators perform functions similar to the concat() 
method—for example,
String x = "library";
System.out.println( x + " card");    // output is "library card"
String x = "Atlantic";
x+= " ocean";
System.out.println( x );         // output is "Atlantic ocean"
Important Methods in the String Class (Exam Objective 3.1) 435
In the preceding "Atlantic ocean" example, notice that the value of x really did 
change! Remember that the += operator is an assignment operator, so line 2 is really 
creating a new String, "Atlantic ocean", and assigning it to the x variable. After 
line 2 executes, the original String x was referring to, "Atlantic", is abandoned. public boolean equalsIgnoreCase(String s)   This method returns a 
boolean value (true or false) depending on whether the value of the String in the 
argument is the same as the value of the String used to invoke the method. This 
method will return true even when characters in the String objects being compared 
have differing cases—for example,
String x = "Exit";
System.out.println( x.equalsIgnoreCase("EXIT"));   // is "true" 
System.out.println( x.equalsIgnoreCase("tixe"));   // is "false" 
public int length()   This method returns the length of the String used to invoke 
the method—for example,
String x = "01234567";
System.out.println( x.length() );     // returns "8"
public String replace(char old, char new)   This method returns a String 
whose value is that of the String used to invoke the method, updated so that any 
occurrence of the char in the first argument is replaced by the char in the second 
argument—for example,
String x = "oxoxoxox";
System.out.println( x.replace('x', 'X') );    // output is  
                                              // "oXoXoXoX"
public String substring(int begin)
public String substring(int begin, int end)   The substring() method 
is used to return a part (or substring) of the String used to invoke the method. The 
first argument represents the starting location (zero-based) of the substring.

--- Chunk #1434 ---
If the call 
has only one argument, the substring returned will include the characters to the end 
of the original String. If the call has two arguments, the substring returned will end 
with the character located in the nth position of the original String where n is the
436 Chapter 6:  Strings, I/O, Formatting, and Parsing
second argument. Unfortunately, the ending argument is not zero-based, so if the 
second argument is 7, the last character in the returned String will be in the original 
String's 7 position, which is index 6 (ouch). Let's look at some examples:
String x = "0123456789";         // as if by magic, the value 
                                 // of each char
                                 // is the same as its index! System.out.println( x.substring(5) );     // output is  "56789"
System.out.println( x.substring(5, 8));   // output is "567"
The first example should be easy: start at index 5 and return the rest of the 
String. The second example should be read as follows: start at index 5 and return 
the characters up to and including the 8th position (index 7). public String toLowerCase()   This method returns a String whose value is 
the String used to invoke the method, but with any uppercase characters converted to 
lowercase—for example,
String x = "A New Moon";
System.out.println( x.toLowerCase() );    // output is  
                                          // "a new moon"
Important Methods in the String Class (Exam Objective 3.1) 437
Arrays have an attribute (not a method), called length. You may 
encounter questions in the exam that attempt to use the length() method on an array, 
or that attempt to use the length attribute on a String. Both cause compiler errors—for 
example,
String x = "test";
System.out.println( x.length );     // compiler error
or
String[] x = new String[3];
System.out.println( x.length() );   // compiler error
public String toString()   This method returns the value of the String used 
to invoke the method. What? Why would you need such a seemingly "do nothing" 
method? All objects in Java must have a toString() method, which typically returns 
a String that in some meaningful way describes the object in question. In the case of 
a String object, what more meaningful way than the String's value? For the sake of 
consistency, here's an example:
String x = "big surprise";
System.out.println( x.toString() );     // output – 
                                        // reader's exercise
public String toUpperCase()   This method returns a String whose value is 
the String used to invoke the method, but with any lowercase characters converted to 
uppercase—for example,
String x = "A New Moon";
System.out.println( x.toUpperCase() );    // output is  
                                          // "A NEW MOON"
public String trim()   This method returns a String whose value is the String 
used to invoke the method, but with any leading or trailing blank spaces removed—
for example,
String x = "       hi        ";
System.out.println( x + "x" );             // result is 
                                           // "     hi    x"
System.out.println( x.trim() + "x");       // result is "hix"
The StringBuffer and StringBuilder Classes
The java.lang.StringBuffer and java.lang.StringBuilder classes should be used when 
you have to make a lot of modifications to strings of characters. As we discussed in 
the previous section, String objects are immutable, so if you choose to do a lot of 
manipulations with String objects, you will end up with a lot of abandoned String 
objects in the String pool. (Even in these days of gigabytes of RAM, it's not a good 
idea to waste precious memory on discarded String pool objects.) On the other hand, 
objects of type StringBuffer and StringBuilder can be modified over and over again 
without leaving behind a great effluence of discarded String objects. 438 Chapter 6:  Strings, I/O, Formatting, and Parsing
The StringBuffer and StringBuilder Classes (Exam Objective 3.1) 439
A common use for StringBuffers and StringBuilders is file I/O when large, 
ever-changing streams of input are being handled by the program. In these 
cases, large blocks of characters are handled as units, and StringBuffer 
objects are the ideal way to handle a block of data, pass it on, and then 
reuse the same memory to handle the next block of data. StringBuffer vs. StringBuilder
The StringBuilder class was added in Java 5. It has exactly the same API as the 
StringBuffer class, except StringBuilder is not thread safe. In other words, its 
methods are not synchronized. (More about thread safety in Chapter 9.) Sun 
recommends that you use StringBuilder instead of StringBuffer whenever possible 
because StringBuilder will run faster (and perhaps jump higher). So apart from 
synchronization, anything we say about StringBuilder's methods holds true for 
StringBuffer's methods, and vice versa. The exam might use these classes in the 
creation of thread-safe applications, and we'll discuss how that works in Chapter 9. Using StringBuilder and StringBuffer
In the previous section, we saw how the exam might test your understanding of 
String immutability with code fragments like this: 
String x = "abc";
x.concat("def");
System.out.println("x = " + x);     //  output is "x = abc"
Because no new assignment was made, the new String object created with the 
concat() method was abandoned instantly. We also saw examples like this:
String x = "abc";
x = x.concat("def");
System.out.println("x = " + x);    // output is "x = abcdef"
We got a nice new String out of the deal, but the downside is that the old String 
"abc" has been lost in the String pool, thus wasting memory. If we were using a 
StringBuffer instead of a String, the code would look like this:
StringBuffer sb = new StringBuffer("abc");
sb.append("def");
System.out.println("sb = " + sb);     // output is "sb = abcdef"
All of the StringBuffer methods we will discuss operate on the value of the 
StringBuffer object invoking the method. So a call to sb.append("def");  is actually 
appending "def" to itself (StringBuffer sb). In fact, these method calls can be 
chained to each other—for example,
StringBuilder sb = new StringBuilder("abc");
sb.append("def").reverse().insert(3, "---");
System.out.println( sb );              // output is  "fed---cba"
Notice that in each of the previous two examples, there was a single call to new, 
concordantly in each example we weren't creating any extra objects. Each example 
needed only a single StringXxx object to execute. Important Methods in the StringBuffer and StringBuilder Classes
The following method returns a StringXxx object with the argument's value 
appended to the value of the object that invoked the method. public synchronized StringBuffer append(String s)   As we've seen 
earlier, this method will update the value of the object that invoked the method, 
whether or not the return is assigned to a variable. This method will take many dif-
ferent arguments, including boolean, char, double, float, int, long, and others, but 
the most likely use on the exam will be a String argument—for example,
StringBuffer sb = new StringBuffer("set ");
sb.append("point");
System.out.println(sb);       // output is "set point"
StringBuffer sb2 = new StringBuffer("pi = ");
sb2.append(3.14159f);
System.out.println(sb2);      // output is  "pi = 3.14159"
public StringBuilder delete(int start, int end)   This method returns a 
StringBuilder object and updates the value of the StringBuilder object that invoked 
the method call. In both cases, a substring is removed from the original object. The 
starting index of the substring to be removed is defined by the first argument (which 
is zero-based), and the ending index of the substring to be removed is defined by the 
second argument (but it is one-based)! Study the following example carefully:
StringBuilder sb = new StringBuilder("0123456789");
System.out.println(sb.delete(4,6));      // output is "01236789"
440 Chapter 6:  Strings, I/O, Formatting, and Parsing
Important Methods in the StringBuffer and StringBuilder Classes (Exam Objective 3.1) 441
public StringBuilder insert(int offset, String s)   This method returns 
a StringBuilder object and updates the value of the StringBuilder object that invoked 
the method call. In both cases, the String passed in to the second argument is 
inserted into the original StringBuilder starting at the offset location represented by 
the first argument (the offset is zero-based). Again, other types of data can be passed 
in through the second argument (boolean, char, double, float, int, long, and so 
on), but the String argument is the one you're most likely to see:
StringBuilder sb = new StringBuilder("01234567");
sb.insert(4, "---");
System.out.println( sb );          //   output is  "0123---4567"
public synchronized StringBuffer reverse()   This method returns a 
StringBuffer object and updates the value of the StringBuffer object that invoked the 
method call. In both cases, the characters in the StringBuffer are reversed, the first 
character becoming the last, the second becoming the second to the last, and so on:
StringBuffer s = new StringBuffer("A man a plan a canal Panama");
sb.reverse();
System.out.println(sb); // output: "amanaP lanac a nalp a nam A"
public String toString()   This method returns the value of the StringBuffer 
object that invoked the method call as a String:
StringBuffer sb = new StringBuffer("test string");
System.out.println( sb.toString() );  // output is "test string"
The exam will probably test your knowledge of the difference between 
String and StringBuffer objects. Because StringBuffer objects are changeable, the 
following code fragment will behave differently than a similar code fragment that uses 
String objects:
StringBuffer sb = new StringBuffer("abc");
sb.append("def");
System.out.println( sb );
In this case, the output will be:   "abcdef"
That's it for StringBuffers and StringBuilders. If you take only one thing away 
from this section, it's that unlike Strings, StringBuffer objects and StringBuilder 
objects can be changed. 442 Chapter 6:  Strings, I/O, Formatting, and Parsing
Many of the exam questions covering this chapter’s topics use a tricky 
(and not very readable) bit of Java syntax known as "chained methods."  A statement 
with chained methods has this general form:
result = method1().method2().method3();
In theory, any number of methods can be chained in this fashion, 
although typically you won't see more than three. Here's how to decipher these 
"handy Java shortcuts" when you encounter them:
1. Determine what the leftmost method call will return (let’s call it x). 2. Use x as the object invoking the second (from the left) method. If there
                         are only two chained methods, the result of the second method call is 
                         the expression's result. 3. If there is a third method, the result of the second method call is used 
to invoke the third method, whose result is the expression's result—
for example,
String x = "abc";
String y = x.concat("def").toUpperCase().replace('C','x'); 
//chained methods
System.out.println("y = " + y); // result is "y = ABxDEF"
Let's look at what happened. The literal def was concatenated to abc, 
creating a temporary, intermediate String (soon to be lost), with the value abcdef. The toUpperCase() method created a new (soon to be lost) temporary String with 
the value ABCDEF. The replace() method created a ﬁ  nal String with the value ABxDEF, 
and referred y to it. CERTIFICATION OBJECTIVE
File Navigation and I/O (Exam Objective 3.2)
3.2 Given a scenario involving navigating file systems, reading from files, or writing to 
files, develop the correct solution using the following classes (sometimes in combination), 
from java.io: BufferedReader, BufferedWriter, File, FileReader, FileWriter, PrintWriter, 
and Console. I/O has had a strange history with the SCJP certification. It was included in all the 
versions of the exam up to and including 1.2, then removed from the 1.4 exam, and 
then re-introduced for Java 5 and extended for Java 6. I/O is a huge topic in general, and the Java APIs that deal with I/O in one fashion 
or another are correspondingly huge. A general discussion of I/O could include 
topics such as file I/O, console I/O, thread I/O, high-performance I/O, byte-oriented 
I/O, character-oriented I/O, I/O filtering and wrapping, serialization, and more. Luckily for us, the I/O topics included in the Java 5 exam are fairly well restricted to 
file I/O for characters, and serialization. Here's a summary of the I/O classes you'll need to understand for the exam:
■ File The API says that the class File is "An abstract representation of file 
and directory pathnames." The File class isn't used to actually read or write 
data; it's used to work at a higher level, making new empty files, searching for 
files, deleting files, making directories, and working with paths. ■ FileReader This class is used to read character files. Its read() methods are 
fairly low-level, allowing you to read single characters, the whole stream of 
characters, or a fixed number of characters. FileReaders are usually wrapped 
by higher-level objects such as BufferedReaders, which improve performance 
and provide more convenient ways to work with the data. ■ BufferedReader This class is used to make lower-level Reader classes like 
FileReader more efficient and easier to use. Compared to FileReaders, 
BufferedReaders read relatively large chunks of data from a file at once, and 
keep this data in a buffer. When you ask for the next character or line of data, 
it is retrieved from the buffer, which minimizes the number of times that 
time-intensive, file read operations are performed. In addition, 
File Navigation and I/O (Exam Objective 3.2) 443
BufferedReader provides more convenient methods such as readLine(), that 
allow you to get the next line of characters from a file. ■ FileWriter This class is used to write to character files. Its write() 
methods allow you to write character(s) or Strings to a file. FileWriters are 
usually wrapped by higher-level Writer objects such as BufferedWriters or 
PrintWriters, which provide better performance and higher-level, more 
flexible methods to write data. ■ BufferedWriter This class is used to make lower-level classes like 
FileWriters more efficient and easier to use. Compared to FileWriters, 
BufferedWriters write relatively large chunks of data to a file at once, 
minimizing the number of times that slow, file writing operations are 
performed. The BufferedWriter class also provides a newLine() 
method to create platform-specific line separators automatically. ■ PrintWriter This class has been enhanced significantly in Java 5. Because 
of newly created methods and constructors (like building a PrintWriter with 
a File or a String), you might find that you can use PrintWriter in places 
where you previously needed a Writer to be wrapped with a FileWriter and/or 
a BufferedWriter. New methods like format(), printf(), and append() 
make PrintWriters very flexible and powerful. ■ Console This new, Java 6 convenience class provides methods to read input 
from the console and write formatted output to the console. 444 Chapter 6:  Strings, I/O, Formatting, and Parsing
Stream classes are used to read and write bytes, and Readers and Writers 
are used to read and write characters. Since all of the ﬁ  le I/O on the exam is related 
to characters, if you see API class names containing the word "Stream", for instance 
DataOutputStream, then the question is probably about serialization, or something 
unrelated to the actual I/O objective. Creating Files Using Class File
Objects of type File are used to represent the actual files (but not the data in the 
files) or directories that exist on a computer's physical disk. Just to make sure we're 
clear, when we talk about an object of type File, we'll say File, with a capital F . When we're talking about what exists on a hard drive, we'll call it a file with a 
lowercase f (unless it's a variable name in some code). Let's start with a few basic 
examples of creating files, writing to them, and reading from them. First, let's create 
a new file and write a few lines of data to it:
import java.io.*;              // The Java 6 exam focuses on
                               // classes from java.io
class Writer1 {
  public static void main(String [] args) {
    File file = new File("fileWrite1.txt");    // There's no 
                                               // file yet! }
}
If you compile and run this program, when you look at the contents of 
your current directory, you'll discover absolutely no indication of a file called 
fileWrite1.txt. When you make a new instance of the class File, you're not yet 
making an actual file, you're just creating a filename. Once you have a File object, there 
are several ways to make an actual file. Let's see what we can do with the File object 
we just made:
import java.io.*;
class Writer1 {
 public static void main(String [] args) {
   try {                        // warning: exceptions possible
     boolean newFile = false;
     File file = new File                // it's only an object
                    ("fileWrite1.txt");
     System.out.println(file.exists());  // look for a real file
     newFile = file.createNewFile();     // maybe create a file! System.out.println(newFile);        // already there? System.out.println(file.exists());  // look again
   } catch(IOException e) { }
 }
}
File Navigation and I/O (Exam Objective 3.2) 445
This produces the output
false
true
true
And also produces an empty file in your current directory. If you run the code a 
second time you get the output
true
false
true
Let's examine these sets of output: 
■ First execution The first call to exists() returned false, which we 
expected…remember new File() doesn't create a file on the disk! The 
createNewFile() method created an actual file, and returned true, 
indicating that a new file was created, and that one didn't already exist. Finally, we called exists() again, and this time it returned true, indicating 
that the file existed on the disk. ■ Second execution The first call to exists() returns true because we 
built the file during the first run. Then the call to createNewFile() returns 
false since the method didn't create a file this time through. Of course, the 
last call to exists() returns true. A couple of other new things happened in this code. First, notice that we had 
to put our file creation code in a try/catch. This is true for almost all of the file I/O 
code you'll ever write. I/O is one of those inherently risky things. We're keeping it 
simple for now, and ignoring the exceptions, but we still need to follow the handle-
or-declare rule since most I/O methods declare checked exceptions. We'll talk more 
about I/O exceptions later. We used a couple of File's methods in this code:
■ boolean exists() This method returns true if it can find the actual file. ■ boolean createNewFile()  This method creates a new file if it doesn't 
already exist. 446 Chapter 6:  Strings, I/O, Formatting, and Parsing
Using FileWriter and FileReader
In practice, you probably won't use the FileWriter and FileReader classes without 
wrapping them (more about "wrapping" very soon). That said, let's go ahead and do 
a little "naked" file I/O:
import java.io.*;
class Writer2 {
  public static void main(String [] args) {
    char[] in = new char[50];           // to store input
    int size = 0;
    try {
      File file = new File(             // just an object
                  "fileWrite2.txt");
      FileWriter fw = 
                 new FileWriter(file);  // create an actual file
                                        // & a FileWriter obj
      fw.write("howdy\nfolks\n");       // write characters to
                                        // the file
      fw.flush();                       // flush before closing
      fw.close();                       // close file when done
File Navigation and I/O (Exam Objective 3.2) 447
Remember, the exam creators are trying to jam as much code as they can 
into a small space, so in the previous example, instead of these three lines of code,
      boolean newFile = false;
      ... newFile = file.createNewFile();
      System.out.println(newFile);
You might see something like the following single line of code, which is a 
bit harder to read, but accomplishes the same thing:
      System.out.println(file.createNewFile());
      FileReader fr = 
                 new FileReader(file);  // create a FileReader 
                                        // object
      size = fr.read(in);               // read the whole file! System.out.print(size + " ");     // how many bytes read
      for(char c : in)                  // print the array
        System.out.print(c);
      fr.close();                       // again, always close
    } catch(IOException e) { }
  }
}
which produces the output:
12 howdy
folks
Here's what just happened:
1. FileWriter fw = new FileWriter(file) did three things:
 a. It created a FileWriter reference variable, fw. b. It created a FileWriter object, and assigned it to fw. c. It created an actual empty file out on the disk (and you can prove it). 2. We wrote 12 characters to the file with the write() method, and we did a 
flush() and a close(). 3. We made a new FileReader object, which also opened the file on disk for 
reading. 4. The read() method read the whole file, a character at a time, and put it into 
the char[] in. 5. We printed out the number of characters we read size, and we looped 
through the in array printing out each character we read, then we closed 
the file. Before we go any further let's talk about flush() and close(). When you write 
data out to a stream, some amount of buffering will occur, and you never know for 
sure exactly when the last of the data will actually be sent. You might perform many 
448 Chapter 6:  Strings, I/O, Formatting, and Parsing
write operations on a stream before closing it, and invoking the flush() method 
guarantees that the last of the data you thought you had already written actually 
gets out to the file. Whenever you're done using a file, either reading it or writing 
to it, you should invoke the close() method. When you are doing file I/O you're 
using expensive and limited operating system resources, and so when you're done, 
invoking close() will free up those resources. Now, back to our last example.

--- Chunk #1435 ---
This program certainly works, but it's painful in a 
couple of different ways:
 1. When we were writing data to the file, we manually inserted line separators 
       (in this case \n), into our data. 2. When we were reading data back in, we put it into a character array. It 
       being an array and all, we had to declare its size beforehand, so we'd have 
       been in trouble if we hadn't made it big enough! We could have read the
       data in one character at a time, looking for the end of file after each 
       read(), but that's pretty painful too. Because of these limitations, we'll typically want to use higher-level I/O classes 
like BufferedWriter or BufferedReader in combination with FileWriter or FileReader. Combining I/O classes
Java's entire I/O system was designed around the idea of using several classes in 
combination. Combining I/O classes is sometimes called wrapping and sometimes 
called chaining. The java.io package contains about 50 classes, 10 interfaces, and 
15 exceptions. Each class in the package has a very specific purpose (creating high 
cohesion), and the classes are designed to be combined with each other in countless 
ways, to handle a wide variety of situations. When it's time to do some I/O in real life, you'll undoubtedly find yourself 
pouring over the java.io API, trying to figure out which classes you'll need, and 
how to hook them together. For the exam, you'll need to do the same thing, but 
we've artificially reduced the API. In terms of studying for exam Objective 3.2, we 
can imagine that the entire java.io package consisted of the classes listed in exam 
Objective 3.2, and summarized in Table 6-1, our mini I/O API. File Navigation and I/O (Exam Objective 3.2) 449
Now let's say that we want to find a less painful way to write data to a file and 
read the file's contents back into memory. Starting with the task of writing data to 
a file, here's a process for determining what classes we'll need, and how we'll hook 
them together:
 1. We know that ultimately we want to hook to a File object. So whatever 
  other class or classes we use, one of them must have a constructor that takes
  an object of type File. 450 Chapter 6:  Strings, I/O, Formatting, and Parsing
 
java.io  Class Extends 
From
Key Constructor(s)
Arguments
Key Methods
File Object File, String
String
String, String
createNewFile()
delete()
exists()
isDirectory()
isFile()
list()
mkdir()
renameTo()
FileWriter Writer File
String
close()
flush()
write()
BufferedWriter Writer Writer close()
flush()
newLine()
write()
PrintWriter Writer File (as of Java 5)
String (as of Java 5)
OutputStream
Writer
close()
flush()
format()*, printf()*
print(), println()
write()
FileReader Reader File
String
read()
BufferedReader Reader Reader read()
readLine()
*Discussed later
 TABLE 6-1    java.io Mini  API
   
 2. Find a method that sounds like the most powerful, easiest way to accomplish
  the task. When we look at Table 6-1 we can see that BufferedWriter has 
  a newLine() method. That sounds a little better than having to manually 
  embed a separator after each line, but if we look further we see that 
  PrintWriter has a method called println(). That sounds like the easiest 
  approach of all, so we'll go with it. 3. When we look at PrintWriter's constructors, we see that we can build a 
  PrintWriter object if we have an object of type File, so all we need to do to 
  create a PrintWriter object is the following:
     File file = new File("fileWrite2.txt");   // create a File
     PrintWriter pw = new PrintWriter(file);   // pass file to
                                              // the PrintWriter
                                              // constructor
Okay, time for a pop quiz. Prior to Java 5, PrintWriter did not have constructors 
that took either a String or a File. If you were writing some I/O code in Java 1.4, 
how would you get a PrintWriter to write data to a file? Hint: You can figure this out 
by studying the mini I/O API, Table 6-1. Here's one way to go about solving this puzzle: First, we know that we'll create 
a File object on one end of the chain, and that we want a PrintWriter object on 
the other end. We can see in Table 6-1 that a PrintWriter can also be built using 
a Writer object. Although Writer isn't a class we see in the table, we can see that 
several other classes extend Writer, which for our purposes is just as good; any class 
that extends Writer is a candidate. Looking further, we can see that FileWriter has 
the two attributes we're looking for:
 1. It can be constructed using a File. 2. It extends Writer. Given all of this information, we can put together the following code (remember, 
this is a Java 1.4 example):
 File file = new File("fileWrite2.txt");  // create a File object
 FileWriter fw = new FileWriter(file);    // create a FileWriter
                                         // that will send its
                                         // output to a File
File Navigation and I/O (Exam Objective 3.2) 451
 PrintWriter pw = new PrintWriter(fw);    // create a PrintWriter 
                                         // that will send its 
                                         // output to a Writer 
 pw.println("howdy");      // write the data
 pw.println("folks");
At this point it should be fairly easy to put together the code to more easily read 
data from the file back into memory. Again, looking through the table, we see a 
method called readLine() that sounds like a much better way to read data. Going 
through a similar process we get the following code:
 File file = 
      new File("fileWrite2.txt");  // create a File object AND
                                   // open "fileWrite2.txt"
 FileReader fr = 
          new FileReader(file);    // create a FileReader to get
                                   // data from 'file'
 BufferedReader br = 
         new BufferedReader(fr);   // create a BufferReader to
                                   // get its data from a Reader
 String data = br.readLine();       // read some data
Working with Files and Directories
Earlier we touched on the fact that the File class is used to create files and 
directories. In addition, File's methods can be used to delete files, rename files, 
determine whether files exist, create temporary files, change a file's attributes, and 
differentiate between files and directories. A point that is often confusing is that an 
object of type File is used to represent either a file or a directory. We'll talk about both 
cases next. 452 Chapter 6:  Strings, I/O, Formatting, and Parsing
You’re almost certain to encounter exam questions that test your 
knowledge of how I/O classes can be chained. If you’re not totally clear on this last 
section, we recommend that you use Table 6-1 as a reference, and write code to 
experiment with which chaining combinations are legal and which are illegal. We saw earlier that the statement
 File file = new File("foo");
always creates a File object, and then does one of two things:
 1. If " foo" does NOT exist, no actual file is created. 2. If " foo" does exist, the new File object refers to the existing file. Notice that File file = new File("foo"); NEVER creates an actual file. There are two ways to create a file:
 1. Invoke the createNewFile() method on a File object. For example:
 File file = new File("foo");    // no file yet
 file.createNewFile();     // make a file, "foo" which
         // is assigned to 'file'
 
 2. Create a Writer or a Stream. Specifically, create a FileWriter, a PrintWriter, 
or a FileOutputStream. Whenever you create an instance of one of these 
classes, you automatically create a file, unless one already exists, for instance
 File file = new File("foo"); // no file yet
 PrintWriter pw = 
        new PrintWriter(file); // make a PrintWriter object AND
                                // make a file, "foo" to which
                             // 'file' is assigned, AND assign
                                // 'pw' to the PrintWriter 
                               
Creating a directory is similar to creating a file. Again, we'll use the convention 
of referring to an object of type File that represents an actual directory, as a Directory  
File object, capital D, (even though it's of type File.) We'll call an actual directory 
on a computer a directory, small d. Phew! As with creating a file, creating a directory 
is a two-step process; first we create a Directory (File) object, then we create an 
actual directory using the following mkdir() method:
File Navigation and I/O (Exam Objective 3.2) 453
File myDir = new File("mydir");   // create an object
myDir.mkdir();                    // create an actual directory
Once you've got a directory, you put files into it, and work with those files:
File myFile = new File(myDir, "myFile.txt");
myFile.createNewFile();
This code is making a new file in a subdirectory. Since you provide the 
subdirectory to the constructor, from then on you just refer to the file by its reference 
variable. In this case, here's a way that you could write some data to the file myFile:
PrintWriter pw = new PrintWriter(myFile);
pw.println("new stuff");
pw.flush();
pw.close();
Be careful when you're creating new directories! As we've seen, constructing a 
Writer or a Stream will often create a file for you automatically if one doesn't exist, 
but that's not true for a directory:
File myDir = new File("mydir");
// myDir.mkdir();                   // call to mkdir() omitted! File myFile = new File(
              myDir, "myFile.txt");
myFile.createNewFile();             // exception if no mkdir! This will generate an exception something like
java.io.IOException: No such file or directory
You can refer a File object to an existing file or directory. For example, assume 
that we already have a subdirectory called existingDir in which resides an existing 
file existingDirFile.txt, which contains several lines of text. When you run the 
following code,
File existingDir = new File("existingDir");     // assign a dir
System.out.println(existingDir.isDirectory());
454 Chapter 6:  Strings, I/O, Formatting, and Parsing
File existingDirFile = new File(
          existingDir, "existingDirFile.txt");  // assign a file
System.out.println (existingDirFile.isFile());
FileReader fr = new FileReader(existingDirFile);
BufferedReader br = new BufferedReader(fr);     // make a Reader
String s;
while( (s = br.readLine()) != null)             // read data
  System.out.println(s);
   
br.close();
the following output will be generated:
true
true
existing sub-dir data
line 2 of text
line 3 of text
Take special note of what the readLine() method returns. When there is no 
more data to read, readLine() returns a null—this is our signal to stop reading the 
file. Also, notice that we didn't invoke a flush() method. When reading a file, no 
flushing is required, so you won't even find a flush() method in a Reader kind of 
class. In addition to creating files, the File class also lets you do things like renaming 
and deleting files. The following code demonstrates a few of the most common ins 
and outs of deleting files and directories (via delete()), and renaming files and 
directories (via renameTo()):
File delDir = new File("deldir");       // make a directory
delDir.mkdir();
File delFile1 = new File(
           delDir, "delFile1.txt");     // add file to directory
delFile1.createNewFile();      
File delFile2 = new File(
           delDir, "delFile2.txt");     // add file to directory
delFile2.createNewFile(); 
File Navigation and I/O (Exam Objective 3.2) 455
456 Chapter 6:  Strings, I/O, Formatting, and Parsing 
delFile1.delete();                      // delete a file
System.out.println("delDir is " 
                  + delDir.delete());   // attempt to delete
                                        // the directory
File newName = new File(
           delDir, "newName.txt");      // a new object
delFile2.renameTo(newName);             // rename file
File newDir = new File("newDir");       // rename directory
delDir.renameTo(newDir);
This outputs
delDir is false
and leaves us with a directory called newDir that contains a file called 
newName.txt. Here are some rules that we can deduce from this result:
■ delete() You can't delete a directory if it's not empty, which is why the 
invocation delDir.delete() failed. ■ renameTo() You must give the existing File object a valid new File object 
with the new name that you want. (If newName had been null we would 
have gotten a NullPointerException.)
■ renameTo() It's okay to rename a directory, even if it isn't empty. There's a lot more to learn about using the java.io package, but as far as the 
exam goes we only have one more thing to discuss, and that is how to search for a 
file. Assuming that we have a directory named searchThis that we want to search 
through, the following code uses the File.list() method to create a String array 
of files and directories, which we then use the enhanced for loop to iterate through 
and print:
String[] files = new String[100];
File search = new File("searchThis");
files = search.list();                 // create the list
      
for(String fn : files)                 // iterate through it
  System.out.println("found " + fn);
On our system, we got the following output:
found dir1
found dir2
found dir3
found file1.txt
found file2.txt
Your results will almost certainly vary  : )
In this section we've scratched the surface of what's available in the java.io package. Entire books have been written about this package, so we're obviously covering only 
a very small (but frequently used) portion of the API. On the other hand, if you 
understand everything we've covered in this section, you will be in great shape to 
handle any java.io questions you encounter on the exam (except for the Console class, 
which we'll cover next, and serialization, which is covered in the next section). The java.io.Console Class
New to Java 6 is the java.io.Console class. In this context, the console is the 
physical device with a keyboard and a display (like your Mac or PC). If you’re 
running Java SE 6 from the command line, you'll typically have access to a console 
object, to which you can get a reference by invoking System.console(). Keep in 
mind that it's possible for your Java program to be running in an environment that 
doesn't have access to a console object, so be sure that your invocation of System
.console() actually returns a valid console reference and not null. The Console class makes it easy to accept input from the command line, both 
echoed and nonechoed (such as a password), and makes it easy to write formatted 
output to the command line. It's a handy way to write test engines for unit testing 
or if you want to support a simple but secure user interaction and you don't need 
a GUI. On the input side, the methods you'll have to understand are readLine and 
readPassword. The readLine method returns a string containing whatever the 
user keyed in—that's pretty intuitive. However, the readPassword method doesn't 
return a string: it returns a character array. Here's the reason for this: Once you've 
got the password, you can verify it and then absolutely remove it from memory. If a 
string was returned, it could exist in a pool somewhere in memory and perhaps some 
nefarious hacker could find it. The java.io.Console Class (Exam Objective 3.2) 457
458 Chapter 6:  Strings, I/O, Formatting, and Parsing 
Let's take a look at a small program that uses a console to support testing 
another class:
import java.io.Console;
public class NewConsole {
  public static void main(String[] args) {
    Console c = System.console();            // #1: get a Console
    char[] pw;  
    pw = c.readPassword("%s", "pw: ");       // #2: return a char[]
    for(char ch: pw)
      c.format("%c ", ch);                   // #3: format output
    c.format("\n");
    MyUtility mu = new MyUtility();
    while(true) {
      name = c.readLine("%s", "input?: ");   // #4: return a String
      c.format("output: %s \n", mu.doStuff(name));
    }   
  }
}
class MyUtility {                            // #5: class to test
  String doStuff(String arg1) {
    // stub code
    return "result is " + arg1;
  }
} 
Let's review this code:
■ At line 1, we get a new console object. Remember that we can't say this:
   Console c = new Console();
■ At line 2, we invoke readPassword, which returns a char[], not a string. You'll notice when you test this code that the password you enter isn't echoed 
on the screen. ■ At line 3, we're just manually displaying the password you keyed in, separat-
ing each character with a space. Later on in this chapter, you'll read about the 
format method, so stay tuned. ■ At line 4, we invoke readLine, which returns a string. ■ At line 5 is the class that we want to test. Later in this chapter, when you're 
studying regex and formatting, we recommend that you use something like 
NewConsole to test the concepts that you're learning. The Console class has more capabilities than are covered here, but if you 
understand everything discussed so far, you'll be in good shape for the exam. CERTIFICATION OBJECTIVE
Serialization (Exam Objective 3.3)
3.3 Develop code that serializes and/or de-serializes objects using the following APIs from 
java.io: DataInputStream, DataOutputStream, FileInputStream, FileOutputStream, 
ObjectInputStream, ObjectOutputStream, and Serializable. Imagine you want to save the state of one or more objects. If Java didn't have 
serialization (as the earliest version did not), you'd have to use one of the I/O 
classes to write out the state of the instance variables of all the objects you want to 
save. The worst part would be trying to reconstruct new objects that were virtually 
identical to the objects you were trying to save. You'd need your own protocol for 
the way in which you wrote and restored the state of each object, or you could end 
up setting variables with the wrong values. For example, imagine you stored an 
object that has instance variables for height and weight. At the time you save the 
state of the object, you could write out the height and weight as two ints in a file, 
but the order in which you write them is crucial. It would be all too easy to re-create 
the object but mix up the height and weight values—using the saved height as the 
value for the new object's weight and vice versa. Serialization lets you simply say "save this object and all of its instance variables." 
Actually it is a little more interesting than that, because you can add, "... unless I've 
Serialization (Exam Objective 3.3) 459
460 Chapter 6:  Strings, I/O, Formatting, and Parsing 
explicitly marked a variable as transient, which means, don't include the transient 
variable's value as part of the object's serialized state."
Working with ObjectOutputStream and ObjectInputStream
The magic of basic serialization happens with just two methods: one to serialize objects 
and write them to a stream, and a second to read the stream and deserialize objects. ObjectOutputStream.writeObject()   // serialize and write
ObjectInputStream.readObject()     // read and deserialize
The java.io.ObjectOutputStream and java.io.ObjectInputStream classes are 
considered to be higher-level classes in the java.io package, and as we learned earlier, 
that means that you'll wrap them around lower-level classes, such as 
java.io.FileOutputStream and java.io.FileInputStream. Here's a small program that 
creates a (Cat) object, serializes it, and then deserializes it:
import java.io.*;
class Cat implements Serializable { }   // 1
public class SerializeCat {
  public static void main(String[] args) {
    Cat c = new Cat();  // 2
    try {
      FileOutputStream fs = new FileOutputStream("testSer.ser");
      ObjectOutputStream os = new ObjectOutputStream(fs);
      os.writeObject(c);   // 3
      os.close();
    } catch (Exception e) { e.printStackTrace(); }
    try { 
      FileInputStream fis = new FileInputStream("testSer.ser");
      ObjectInputStream ois = new ObjectInputStream(fis);
      c = (Cat) ois.readObject();  // 4
      ois.close();
    } catch (Exception e) { e.printStackTrace(); }
  }
}
Let's take a look at the key points in this example:
1. We declare that the Cat class implements the Serializable interface. Serializable is a marker interface; it has no methods to implement. (In the 
next several sections, we'll cover various rules about when you need to declare 
classes Serializable.)
2. We make a new Cat object, which as we know is serializable. 3. We serialize the Cat object c by invoking the writeObject() method. It 
took a fair amount of preparation before we could actually serialize our Cat. First, we had to put all of our I/O-related code in a try/catch block. Next we 
had to create a FileOutputStream to write the object to. Then we wrapped the 
FileOutputStream in an ObjectOutputStream, which is the class that has the 
magic serialization method that we need. Remember that the invocation of 
writeObject() performs two tasks: it serializes the object, and then it writes 
the serialized object to a file. 4. We de-serialize the Cat object by invoking the readObject() method. The 
readObject() method returns an Object, so we have to cast the deserialized 
object back to a Cat. Again, we had to go through the typical I/O hoops to 
set this up. This is a bare-bones example of serialization in action. Over the next set of pages 
we'll look at some of the more complex issues that are associated with serialization. Object Graphs
What does it really mean to save an object? If the instance variables are all primitive 
types, it's pretty straightforward. But what if the instance variables are themselves 
references to objects? What gets saved? Clearly in Java it wouldn't make any sense to 
save the actual value of a reference variable, because the value of a Java reference has 
meaning only within the context of a single instance of a JVM. In other words, if you 
tried to restore the object in another instance of the JVM, even running on the same 
computer on which the object was originally serialized, the reference would be useless. But what about the object that the reference refers to? Look at this class:
class Dog {
   private Collar theCollar;
   private int dogSize;
   public Dog(Collar collar, int size) {
     theCollar = collar;
     dogSize = size;
Serialization (Exam Objective 3.3) 461
462 Chapter 6:  Strings, I/O, Formatting, and Parsing 
   }
   public Collar getCollar() { return theCollar; }
}
class Collar {
   private int collarSize;
   public Collar(int size) { collarSize = size; }
   public int getCollarSize() { return collarSize; }
}
Now make a dog... First, you make a Collar for the Dog:
Collar c = new Collar(3);
Then make a new Dog, passing it the Collar:
Dog d = new Dog(c, 8);
Now what happens if you save the Dog? If the goal is to save and then restore a 
Dog, and the restored Dog is an exact duplicate of the Dog that was saved, then the 
Dog needs a Collar that is an exact duplicate of the Dog's Collar at the time the Dog 
was saved. That means both the Dog and the Collar should be saved. And what if the Collar itself had references to other objects—like perhaps 
a Color object? This gets quite complicated very quickly. If it were up to the 
programmer to know the internal structure of each object the Dog referred to, so 
that the programmer could be sure to save all the state of all those objects…whew. That would be a nightmare with even the simplest of objects. Fortunately, the Java serialization mechanism takes care of all of this. When you 
serialize an object, Java serialization takes care of saving that object's entire "object 
graph." That means a deep copy of everything the saved object needs to be restored. For example, if you serialize a Dog object, the Collar will be serialized automatically. And if the Collar class contained a reference to another object, THAT object would 
also be serialized, and so on. And the only object you have to worry about saving 
and restoring is the Dog. The other objects required to fully reconstruct that Dog are 
saved (and restored) automatically through serialization. Remember, you do have to make a conscious choice to create objects that are 
serializable, by implementing the Serializable interface. If we want to save Dog 
objects, for example, we'll have to modify the Dog class as follows:
class Dog implements Serializable {
   // the rest of the code as before
   // Serializable has no methods to implement
}
And now we can save the Dog with the following code:
import java.io.*;
public class SerializeDog {
  public static void main(String[] args) {
    Collar c = new Collar(3);
    Dog d = new Dog(c, 8);
    try {
      FileOutputStream fs = new FileOutputStream("testSer.ser");
      ObjectOutputStream os = new ObjectOutputStream(fs);
      os.writeObject(d);
      os.close();
    } catch (Exception e) { e.printStackTrace(); }
  }
}
But when we run this code we get a runtime exception something like this
java.io.NotSerializableException: Collar
What did we forget? The Collar class must ALSO be Serializable. If we modify 
the Collar class and make it serializable, then there's no problem:
class Collar implements Serializable {
   // same
}
Here's the complete listing:
import java.io.*;
public class SerializeDog {  
  public static void main(String[] args) {
    Collar c = new Collar(3);
    Dog d = new Dog(c, 5);
    System.out.println("before: collar size is " 
                       + d.getCollar().getCollarSize());
    try {
      FileOutputStream fs = new FileOutputStream("testSer.ser");
Serialization (Exam Objective 3.3) 463
464 Chapter 6:  Strings, I/O, Formatting, and Parsing 
      ObjectOutputStream os = new ObjectOutputStream(fs);
      os.writeObject(d);
      os.close();
    } catch (Exception e) { e.printStackTrace(); }
    try { 
      FileInputStream fis = new FileInputStream("testSer.ser");
      ObjectInputStream ois = new ObjectInputStream(fis);
      d = (Dog) ois.readObject();
      ois.close();
    } catch (Exception e) { e.printStackTrace(); }
    System.out.println("after:  collar size is " 
                       + d.getCollar().getCollarSize());
  }
}
class Dog implements Serializable {
   private Collar theCollar;
   private int dogSize;
   public Dog(Collar collar, int size) {
     theCollar = collar;
     dogSize = size;
   }
   public Collar getCollar() { return theCollar; }
}
class Collar implements Serializable {
   private int collarSize;
   public Collar(int size) { collarSize = size; }
   public int getCollarSize() { return collarSize; }
}
This produces the output:   
 before: collar size is 3
    after:  collar size is 3
But what would happen if we didn't have access to the Collar class source code? In other words, what if making the Collar class serializable was not an option? Are 
we stuck with a non-serializable Dog? Obviously we could subclass the Collar class, mark the subclass as Serializable, 
and then use the Collar subclass instead of the Collar class. But that's not always an 
option either for several potential reasons:
  1 . The Collar class might be final, preventing subclassing. OR
  2 . The Collar class might itself refer to other non-serializable objects, and with-
out knowing the internal structure of Collar, you aren't able to make all these 
fixes (assuming you even wanted to TRY to go down that road). OR
  3 . Subclassing is not an option for other reasons related to your design. So…THEN what do you do if you want to save a Dog? That's where the transient modifier comes in. If you mark the Dog's Collar 
instance variable with transient, then serialization will simply skip the Collar 
during serialization:
class Dog implements Serializable {
   private transient Collar theCollar;  // add transient
   // the rest of the class as before
}
class Collar {             // no longer Serializable
   // same code
}
Now we have a Serializable Dog, with a non-serializable Collar, but the Dog has 
marked the Collar transient; the output is
before: collar size is 3
Exception in thread "main" java.lang.NullPointerException
So NOW what can we do? Using writeObject and readObject
Consider the problem: we have a Dog object we want to save. The Dog has a Collar, 
and the Collar has state that should also be saved as part of the Dog's state. But…the 
Collar is not Serializable, so we must mark it transient. That means when the Dog 
is deserialized, it comes back with a null Collar. What can we do to somehow make 
sure that when the Dog is deserialized, it gets a new Collar that matches the one the 
Dog had when the Dog was saved? Serialization (Exam Objective 3.3) 465
466 Chapter 6:  Strings, I/O, Formatting, and Parsing 
Java serialization has a special mechanism just for this—a set of private methods 
you can implement in your class that, if present, will be invoked automatically 
during serialization and deserialization. It's almost as if the methods were defined 
in the Serializable interface, except they aren't. They are part of a special callback 
contract the serialization system offers you that basically says, "If you (the 
programmer) have a pair of methods matching this exact signature (you'll see them 
in a moment), these methods will be called during the serialization/deserialization 
process. These methods let you step into the middle of serialization and deserialization. So they're perfect for letting you solve the Dog/Collar problem: when a Dog is 
being saved, you can step into the middle of serialization and say, "By the way, I'd 
like to add the state of the Collar's variable (an int) to the stream when the Dog 
is serialized." You've manually added the state of the Collar to the Dog's serialized 
representation, even though the Collar itself is not saved. Of course, you'll need to restore the Collar during deserialization by stepping into 
the middle and saying, "I'll read that extra int I saved to the Dog stream, and use 
it to create a new Collar, and then assign that new Collar to the Dog that's being 
deserialized." The two special methods you define must have signatures that look 
EXACTLY like this:
private void writeObject(ObjectOutputStream os) {
  // your code for saving the Collar variables
}
private void readObject(ObjectInputStream is) {
   // your code to read the Collar state, create a new Collar,
   // and assign it to the Dog
}
Yes, we're going to write methods that have the same name as the ones we've 
been calling! Where do these methods go? Let's change the Dog class:
class Dog implements Serializable {  
  transient private Collar theCollar; // we can't serialize this
  private int dogSize;
  public Dog(Collar collar, int size) {
    theCollar = collar;
    dogSize = size;
  }
  public Collar getCollar() { return theCollar; }
  private void writeObject(ObjectOutputStream os) {
    //  throws IOException {                           // 1
   try {
    os.defaultWriteObject();                           // 2
    os.writeInt(theCollar.getCollarSize());            // 3 
   } catch (Exception e) { e.printStackTrace(); }
  }
  private void readObject(ObjectInputStream is) {
    //   throws IOException, ClassNotFoundException {  // 4 
   try {
    is.defaultReadObject();                            // 5 
    theCollar = new Collar(is.readInt());              // 6
   } catch (Exception e) { e.printStackTrace(); }
  }
}
Let's take a look at the preceding code. In our scenario we've agreed that, for whatever real-world reason, we can't 
serialize a Collar object, but we want to serialize a Dog. To do this we're going 
to implement writeObject() and readObject(). By implementing these two 
methods you're saying to the compiler: "If anyone invokes writeObject() or 
readObject() concerning a Dog object, use this code as part of the read and write."
 1. Like most I/O-related methods writeObject() can throw exceptions. You 
  can declare them or handle them but we recommend handling them. 2. When you invoke defaultWriteObject() from within writeObject() 
you're telling the JVM to do the normal serialization process for this object. When implementing writeObject(), you will typically request the normal 
serialization process, and do some custom writing and reading too. 3. In this case we decided to write an extra int (the collar size) to the stream  
  that's creating the serialized Dog. You can write extra stuff before and/or
  after you invoke defaultWriteObject(). BUT…when you read it back in,
  you have to read the extra stuff in the same order you wrote it. 4. Again, we chose to handle rather than declare the exceptions.

--- Chunk #1436 ---
5. When it's time to deserialize, defaultReadObject() handles the normal 
  deserialization you'd get if you didn't implement a readObject() method. 6. Finally we build a new Collar object for the Dog using the collar size that we
  manually serialized. (We had to invoke readInt() after we invoked
  defaultReadObject() or the streamed data would be out of sync!)
Serialization (Exam Objective 3.3) 467
468 Chapter 6:  Strings, I/O, Formatting, and Parsing 
Remember, the most common reason to implement writeObject() and 
readObject() is when you have to save some part of an object's state manually. If 
you choose, you can write and read ALL of the state yourself, but that's very rare. So, when you want to do only a part of the serialization/deserialization yourself, you 
MUST invoke the defaultReadObject() and defaultWriteObject() methods 
to do the rest. Which brings up another question—why wouldn't all Java classes be serializable? Why isn't class Object serializable? There are some things in Java that simply cannot 
be serialized because they are runtime specific. Things like streams, threads, runtime, 
etc. and even some GUI classes (which are connected to the underlying OS) cannot 
be serialized. What is and is not serializable in the Java API is NOT part of the exam, 
but you'll need to keep them in mind if you're serializing complex objects. How Inheritance Affects Serialization
Serialization is very cool, but in order to apply it effectively you're going to have to 
understand how your class's superclasses affect serialization. That brings up another key issue with serialization…what happens if a superclass 
is not marked Serializable, but the subclass is? Can the subclass still be serialized 
even if its superclass does not implement Serializable? Imagine this:
 If a superclass is Serializable, then according to normal Java interface 
rules, all subclasses of that class automatically implement Serializable implicitly. In other 
words, a subclass of a class marked Serializable passes the IS-A test for Serializable, 
and thus can be saved without having to explicitly mark the subclass as Serializable. You simply cannot tell whether a class is or is not Serializable UNLESS you can see the 
class inheritance tree to see if any other superclasses implement Serializable. If the class 
does not explicitly extend any other class, and does not implement Serializable, then 
you know for CERTAIN that the class is not Serializable, because class Object does NOT 
implement Serializable. class Animal { }
class Dog extends Animal implements Serializable {
   // the rest of the Dog code
}
Now you have a Serializable Dog class, with a non-Serializable superclass. This 
works! But there are potentially serious implications. To fully understand those 
implications, let's step back and look at the difference between an object that comes 
from deserialization vs. an object created using new. Remember, when an object 
is constructed using new (as opposed to being deserialized), the following things 
happen (in this order):
 1. All instance variables are assigned default values. 2. The constructor is invoked, which immediately invokes the superclass  
  constructor (or another overloaded constructor, until one of the overloaded
  constructors invokes the superclass constructor). 3. All superclass constructors complete. 4. Instance variables that are initialized as part of their declaration are assigned 
  their initial value (as opposed to the default values they're given prior to 
  the superclass constructors completing). 5. The constructor completes. But these things do NOT happen when an object is deserialized. When an instance of 
a serializable class is deserialized, the constructor does not run, and instance variables 
are NOT given their initially assigned values! Think about it—if the constructor 
were invoked, and/or instance variables were assigned the values given in their 
declarations, the object you're trying to restore would revert back to its original 
state, rather than coming back reflecting the changes in its state that happened 
sometime after it was created. For example, imagine you have a class that declares an 
instance variable and assigns it the int value 3, and includes a method that changes 
the instance variable value to 10:
class Foo implements Serializable {
   int num = 3;
   void changeNum() {  num = 10;   }
}
Serialization (Exam Objective 3.3) 469
470 Chapter 6:  Strings, I/O, Formatting, and Parsing 
Obviously if you serialize a Foo instance after the changeNum() method runs, 
the value of the num variable should be 10. When the Foo instance is deserialized, 
you want the num variable to still be 10! You obviously don't want the initialization 
(in this case, the assignment of the value 3 to the variable num) to happen. Think 
of constructors and instance variable assignments together as part of one complete 
object initialization process (and in fact, they DO become one initialization method 
in the bytecode). The point is, when an object is deserialized we do NOT want any 
of the normal initialization to happen. We don't want the constructor to run, and 
we don't want the explicitly declared values to be assigned. We want only the values 
saved as part of the serialized state of the object to be reassigned. Of course if you have variables marked transient, they will not be restored to 
their original state (unless you implement readObject()), but will instead be given 
the default value for that data type. In other words, even if you say
class Bar implements Serializable {
   transient int x = 42;
}
when the Bar instance is deserialized, the variable x will be set to a value of 0. Object references marked transient will always be reset to null, regardless of 
whether they were initialized at the time of declaration in the class. So, that's what happens when the object is deserialized, and the class of the 
serialized object directly extends Object, or has ONLY serializable classes in its 
inheritance tree. It gets a little trickier when the serializable class has one or more 
non-serializable superclasses. Getting back to our non-serializable Animal class with 
a serializable Dog subclass example:
class Animal {
   public String name;
}
class Dog extends Animal implements Serializable {
   // the rest of the Dog code
}
Because Animal is NOT serializable, any state maintained in the Animal class, 
even though the state variable is inherited by the Dog, isn't going to be restored 
with the Dog when it's deserialized! The reason is, the (unserialized) Animal part of 
the Dog is going to be reinitialized just as it would be if you were making a new Dog 
(as opposed to deserializing one). That means all the things that happen to an object 
during construction, will happen—but only to the Animal parts of a Dog. In other 
words, the instance variables from the Dog's class will be serialized and deserialized 
correctly, but the inherited variables from the non-serializable Animal superclass will 
come back with their default/initially assigned values rather than the values they 
had at the time of serialization. If you are a serializable class, but your superclass is NOT serializable, then any 
instance variables you INHERIT from that superclass will be reset to the values they 
were given during the original construction of the object. This is because the non-
serializable class constructor WILL run! In fact, every constructor ABOVE the first non-serializable class constructor will 
also run, no matter what, because once the first super constructor is invoked, (during 
deserialization), it of course invokes its super constructor and so on up the inheritance 
tree. For the exam, you'll need to be able to recognize which variables will and will not 
be restored with the appropriate values when an object is deserialized, so be sure to 
study the following code example and the output:
import java.io.*;
class SuperNotSerial {
  public static void main(String [] args) {
    Dog d = new Dog(35, "Fido");  
    System.out.println("before: " + d.name + " "
                       + d.weight);
    try {
      FileOutputStream fs = new FileOutputStream("testSer.ser");
      ObjectOutputStream os = new ObjectOutputStream(fs);
      os.writeObject(d);
      os.close();
    } catch (Exception e) { e.printStackTrace(); }
    try { 
      FileInputStream fis = new FileInputStream("testSer.ser");
      ObjectInputStream ois = new ObjectInputStream(fis);
      d = (Dog) ois.readObject();
      ois.close();
    } catch (Exception e) { e.printStackTrace(); }
    System.out.println("after:  " + d.name + " "
                       + d.weight);
  }
}
class Dog extends Animal implements Serializable { 
  String name;
Serialization (Exam Objective 3.3) 471
472 Chapter 6:  Strings, I/O, Formatting, and Parsing 
  Dog(int w, String n) { 
    weight = w;          // inherited
    name = n;            // not inherited
  }
}
class Animal {           // not serializable ! int weight = 42;
}
which produces the output:
before: Fido 35
after:  Fido 42
The key here is that because Animal is not serializable, when the Dog was 
deserialized, the Animal constructor ran and reset the Dog's inherited weight variable. Serialization Is Not for Statics
Finally, you might notice that we've talked ONLY about instance variables, not 
static variables. Should static variables be saved as part of the object's state? Isn't the 
state of a static variable at the time an object was serialized important? Yes and no. It might be important, but it isn't part of the instance's state at all. Remember, you 
should think of static variables purely as CLASS variables. They have nothing to 
do with individual instances. But serialization applies only to OBJECTS. And what 
happens if you deserialize three different Dog instances, all of which were serialized 
at different times, and all of which were saved when the value of a static variable 
in class Dog was different. Which instance would "win"? Which instance's static 
value would be used to replace the one currently in the one and only Dog class that's 
currently loaded? See the problem? Static variables are NEVER saved as part of the object's state…because they do 
not belong to the object! If you serialize a collection or an array, every element must be 
serializable! A single non-serializable element will cause serialization to fail. Note also 
that while the collection interfaces are not serializable, the concrete collection classes in 
the Java API are. As simple as serialization code is to write, versioning problems can occur 
in the real world. If you save a Dog object using one version of the class, 
but attempt to deserialize it using a newer, different version of the class, 
deserialization might fail. See the Java API for details about versioning 
issues and solutions. CERTIFICATION OBJECTIVE
Dates, Numbers, and Currency 
(Exam Objective 3.4)
3.4 Use standard J2SE APIs in the java.text package to correctly format or parse dates, 
numbers and currency values for a specific locale; and, given a scenario, determine the 
appropriate methods to use if you want to use the default locale or a specific locale. Describe 
the purpose and use of the java.util.Locale class. The Java API provides an extensive (perhaps a little too extensive) set of classes 
to help you work with dates, numbers, and currency. The exam will test your 
knowledge of the basic classes and methods you'll use to work with dates and such. When you've finished this section you should have a solid foundation in tasks such 
as creating new Date and DateFormat objects, converting Strings to Dates and back 
again, performing Calendaring functions, printing properly formatted currency 
values, and doing all of this for locations around the globe. In fact, a large part of 
why this section was added to the exam was to test whether you can do some basic 
internationalization (often shortened to "i18n"). Dates, Numbers, and Currency (Exam Objective 3.4) 473
What about DataInputStream and DataOutputStream? They're in the 
objectives! It turns out that while the exam was being created, it was decided that those 
two classes wouldn't be on the exam after all, but someone forgot to remove them from 
the objectives! So you get a break.

--- Chunk #1437 ---
That's one less thing you'll have to worry about. 474 Chapter 6:  Strings, I/O, Formatting, and Parsing 
Working with Dates, Numbers, and Currencies
If you want to work with dates from around the world (and who doesn't?), you'll 
need to be familiar with at least four classes from the java.text and java.util 
packages. In fact, we'll admit it right up front, you might encounter questions on the 
exam that use classes that aren't specifically mentioned in the Sun objective. Here 
are the four date related classes you'll need to understand:
■ java.util.Date    Most of this class's methods have been deprecated, but 
you can use this class to bridge between the Calendar and DateFormat class. An instance of Date represents a mutable date and time, to a millisecond. ■ java.util.Calendar    This class provides a huge variety of methods that 
help you convert and manipulate dates and times. For instance, if you want 
to add a month to a given date, or find out what day of the week January 1, 
3000 falls on, the methods in the Calendar class will save your bacon. ■ java.text.DateFormat    This class is used to format dates not only 
providing various styles such as "01/01/70" or "January 1, 1970," but also to 
format dates for numerous locales around the world. ■ java.text.NumberFormat    This class is used to format numbers and 
currencies for locales around the world. ■ java.util.Locale    This class is used in conjunction with DateFormat 
and NumberFormat to format dates, numbers and currency for specific lo-
cales. With the help of the Locale class you'll be able to convert a date like 
"10/10/2005" to "Segunda-feira, 10 de Outubro de 2005" in no time. If you 
want to manipulate dates without producing formatted output, you can use 
the Locale class directly with the Calendar class. Orchestrating Date- and Number-Related Classes
When you work with dates and numbers, you'll often use several classes together. It's important to understand how the classes we described above relate to each 
other, and when to use which classes in combination. For instance, you'll need to 
know that if you want to do date formatting for a specific locale, you need to create 
your Locale object before your DateFormat object, because you'll need your Locale 
object as an argument to your DateFormat factory method. Table 6-2 provides a 
quick overview of common date- and number-related use cases and solutions using 
these classes. Table 6-2 will undoubtedly bring up specific questions about individual 
classes, and we will dive into specifics for each class next. Once you've gone through 
the class level discussions, you should find that Table 6-2 provides a good summary. Working with Dates, Numbers, and Currencies (Exam Objective 3.4) 475
 
Use Case Steps
Get the current date and 
time. 1. Create a Date: Date d = new Date();
2. Get its value:   String s = d.toString();
Get an object that lets 
you perform date and time 
calculations in your locale. 1. Create a Calendar:
     Calendar c = Calendar.getInstance();
2. Use c.add(...) and c.roll(...) to perform date and time
    manipulations. Get an object that lets 
you perform date and time 
calculations in a different 
locale. 1. Create a Locale: 
     Locale loc = new Locale(language);       or
     Locale loc = new Locale(language, country);                
2. Create a Calendar for that locale: 
     Calendar c = Calendar.getInstance(loc);
3. Use c.add(...) and c.roll(...) to perform date and time 
    manipulations. Get an object that lets 
you perform date and time 
calculations, and then format 
it for output in different 
locales with different date 
styles. 1. Create a Calendar:
     Calendar c = Calendar.getInstance();
2. Create a Locale for each location: 
     Locale loc = new Locale(...);
3. Convert your Calendar to a Date:
     Date d = c.getTime();
4. Create a DateFormat for each Locale:
     DateFormat df = DateFormat.getDateInstance
                     (style, loc);
5. Use the format() method to create formatted dates:
     String s = df.format(d);
Get an object that lets you 
format numbers or currencies 
across many different locales. 1. Create a Locale for each location: 
     Locale loc = new Locale(...);
2. Create a NumberFormat:
     NumberFormat nf = NumberFormat.getInstance(loc);
  -or- NumberFormat nf = NumberFormat. getCurrencyInstance(loc);
3. Use the format() method to create formatted output:
     String s = nf.format(someNumber);
 TABLE 6-2    Common Use Cases When Working with Dates and Numbers
   
476 Chapter 6:  Strings, I/O, Formatting, and Parsing 
The Date Class 
The Date class has a checkered past. Its API design didn't do a good job of handling 
internationalization and localization situations. In its current state, most of its 
methods have been deprecated, and for most purposes you'll want to use the 
Calendar class instead of the Date class. The Date class is on the exam for several 
reasons: you might find it used in legacy code, it's really easy if all you want is a 
quick and dirty way to get the current date and time, it's good when you want 
a universal time that is not affected by time zones, and finally, you'll use it as a 
temporary bridge to format a Calendar object using the DateFormat class. As we mentioned briefly above, an instance of the Date class represents a 
single date and time. Internally, the date and time is stored as a primitive long. Specifically, the long holds the number of milliseconds (you know, 1000 of these per 
second), between the date being represented and January 1, 1970. Have you ever tried to grasp how big really big numbers are? Let's use the Date 
class to find out how long it took for a trillion milliseconds to pass, starting at 
January 1, 1970:
import java.util.*;
class TestDates {
  public static void main(String[] args) {
    Date d1 = new Date(1000000000000L);  // a trillion! System.out.println("1st date " + d1.toString());
  }
}
On our JVM, which has a US locale, the output is
1st date Sat Sep 08 19:46:40 MDT 2001
Okay, for future reference remember that there are a trillion milliseconds for 
every 31 and 2/3 years. Although most of Date's methods have been deprecated, it's still acceptable to 
use the getTime and setTime methods, although as we'll soon see, it's a bit painful. Let's add an hour to our Date instance, d1, from the previous example:
import java.util.*;
class TestDates {
  public static void main(String[] args) {
    Date d1 = new Date(1000000000000L);  // a trillion! System.out.println("1st date " + d1.toString());
    d1.setTime(d1.getTime() + 3600000); // 3600000 millis / hour
    System.out.println("new time " + d1.toString());
  }
}
which produces (again, on our JVM):
1st date Sat Sep 08 19:46:40 MDT 2001
new time Sat Sep 08 20:46:40 MDT 2001
Notice that both setTime() and getTime() used the handy millisecond scale... if you want to manipulate dates using the Date class, that's your only choice. While 
that wasn't too painful, imagine how much fun it would be to add, say, a year to a 
given date. We'll revisit the Date class later on, but for now the only other thing you need 
to know is that if you want to create an instance of Date to represent "now," you use 
Date's no-argument constructor:
Date now = new Date();
(We're guessing that if you call now.getTime(), you'll get a number somewhere 
between one trillion and two trillion.)
The Calendar Class
We've just seen that manipulating dates using the Date class is tricky. The Calendar 
class is designed to make date manipulation easy! (Well, easier.) While the Calendar 
class has about a million fields and methods, once you get the hang of a few of them 
the rest tend to work in a similar fashion. When you first try to use the Calendar class you might notice that it's an 
abstract class. You can't say
Calendar c = new Calendar();   // illegal, Calendar is abstract
In order to create a Calendar instance, you have to use one of the overloaded 
getInstance() static factory methods:
Calendar cal = Calendar.getInstance();
Working with Dates, Numbers, and Currencies (Exam Objective 3.4) 477
478 Chapter 6:  Strings, I/O, Formatting, and Parsing 
When you get a Calendar reference like cal, from above, your Calendar reference 
variable is actually referring to an instance of a concrete subclass of Calendar. You 
can't know for sure what subclass you'll get (java.util.GregorianCalendar 
is what you'll almost certainly get), but it won't matter to you. You'll be using 
Calendar's API. (As Java continues to spread around the world, in order to maintain 
cohesion, you might find additional, locale-specific subclasses of Calendar.)
Okay, so now we've got an instance of Calendar, let's go back to our earlier 
example, and find out what day of the week our trillionth millisecond falls on, and 
then let's add a month to that date:
import java.util.*;
class Dates2 {
  public static void main(String[] args) {
    Date d1 = new Date(1000000000000L);
    System.out.println("1st date " + d1.toString());
    Calendar c = Calendar.getInstance();
    c.setTime(d1);                          // #1
    if(Calendar.SUNDAY == c.getFirstDayOfWeek())   // #2
      System.out.println("Sunday is the first day of the week");
    System.out.println("trillionth milli day of week is " 
                + c.get(Calendar.DAY_OF_WEEK));    // #3
    c.add(Calendar.MONTH, 1);                      // #4
    Date d2 = c.getTime();                         // #5
    System.out.println("new date " + d2.toString() ); 
  }
}
This produces something like
1st date Sat Sep 08 19:46:40 MDT 2001
Sunday is the first day of the week
trillionth milli day of week is 7
new date Mon Oct 08 19:46:40 MDT 2001
Let's take a look at this program, focusing on the five highlighted lines:
1. We assign the Date d1 to the Calendar instance c. 2. We use Calendar's SUNDAY field to determine whether, for our JVM, SUNDAY 
is considered to be the first day of the week. (In some locales, MONDAY is the 
first day of the week.) The Calendar class provides similar fields for days of 
the week, months, the day of the month, the day of the year, and so on. 3. We use the DAY_OF_WEEK field to find out the day of the week that the 
trillionth millisecond falls on. 4.

--- Chunk #1438 ---
So far we've used setter and getter methods that should be intuitive to figure 
out. Now we're going to use Calendar's add() method. This very 
powerful method lets you add or subtract units of time appropriate for 
whichever Calendar field you specify. For instance:
c.add(Calendar.HOUR, -4);     // subtract 4 hours from c's value
c.add(Calendar.YEAR, 2);          // add 2 years to c's value
c.add(Calendar.DAY_OF_WEEK, -2);  // subtract two days from 
                                     // c's  value
5. Convert c's value back to an instance of Date. The other Calendar method you should know for the exam is the roll() 
method. The roll() method acts like the add() method, except that when a part 
of a Date gets incremented or decremented, larger parts of the Date will not get 
incremented or decremented. Hmmm…for instance:
// assume c is October 8, 2001
c.roll(Calendar.MONTH, 9);      // notice the year in the output
Date d4 = c.getTime();
System.out.println("new date " + d4.toString() );
The output would be something like this
new date Fri Jul 08 19:46:40 MDT 2001
Notice that the year did not change, even though we added 9 months to an 
October date. In a similar fashion, invoking roll() with HOUR won't change the 
date, the month, or the year. For the exam, you won't have to memorize the Calendar class's fields. If you need 
them to help answer a question, they will be provided as part of the question. Working with Dates, Numbers, and Currencies (Exam Objective 3.4) 479
480 Chapter 6:  Strings, I/O, Formatting, and Parsing 
The DateFormat Class
Having learned how to create dates and manipulate them, let's find out how to 
format them. So that we're all on the same page, here's an example of how a date 
can be formatted in different ways:
import java.text.*;
import java.util.*;
class Dates3 {
  public static void main(String[] args) {
    Date d1 = new Date(1000000000000L);
    
    DateFormat[] dfa = new DateFormat[6];
    dfa[0] = DateFormat.getInstance();
    dfa[1] = DateFormat.getDateInstance();
    dfa[2] = DateFormat.getDateInstance(DateFormat.SHORT);
    dfa[3] = DateFormat.getDateInstance(DateFormat.MEDIUM);
    dfa[4] = DateFormat.getDateInstance(DateFormat.LONG);
    dfa[5] = DateFormat.getDateInstance(DateFormat.FULL);  
    for(DateFormat df : dfa)
      System.out.println(df.format(d1));
  }
}
which on our JVM produces
9/8/01 7:46 PM
Sep 8, 2001
9/8/01
Sep 8, 2001
September 8, 2001
Saturday, September 8, 2001
Examining this code we see a couple of things right away. First off, it looks 
like DateFormat is another abstract class, so we can't use new to create instances 
of DateFormat. In this case we used two factory methods, getInstance() and 
getDateInstance(). Notice that getDateInstance() is overloaded; when we 
discuss locales, we'll look at the other version of getDateInstance() that you'll 
need to understand for the exam. Next, we used static fields from the DateFormat class to customize our various 
instances of DateFormat. Each of these static fields represents a formatting style. In 
this case it looks like the no-arg version of getDateInstance() gives us the same 
style as the MEDIUM version of the method, but that's not a hard and fast rule. (More 
on this when we discuss locales.)  Finally, we used the format() method to create 
Strings representing the properly formatted versions of the Date we're working with. The last method you should be familiar with is the parse() method. The 
parse() method takes a String formatted in the style of the DateFormat instance 
being used, and converts the String into a Date object. As you might imagine, this is 
a risky operation because the parse() method could easily receive a badly formatted 
String. Because of this, parse() can throw a ParseException. The following code 
creates a Date instance, uses DateFormat.format() to convert it into a String, and 
then uses DateFormat.parse() to change it back into a Date:
    Date d1 = new Date(1000000000000L);
    System.out.println("d1 = " + d1.toString());
    
    DateFormat df = DateFormat.getDateInstance(
                                     DateFormat.SHORT);
    String s = df.format(d1);
    System.out.println(s);
    try {        
      Date d2 = df.parse(s);
      System.out.println("parsed = " + d2.toString());
    } catch (ParseException pe) { 
      System.out.println("parse exc"); }
which on our JVM produces
d1 = Sat Sep 08 19:46:40 MDT 2001
9/8/01
parsed = Sat Sep 08 00:00:00 MDT 2001
Note: If we'd wanted to retain the time along with the date we could have used 
the getDateTimeInstance()method, but it's not on the exam. The API for DateFormat.parse() explains that by default, the parse() 
method is lenient when parsing dates. Our experience is that parse() isn't 
very lenient about the formatting of Strings it will successfully parse into 
dates; take care when you use this method! Working with Dates, Numbers, and Currencies (Exam Objective 3.4) 481
482 Chapter 6:  Strings, I/O, Formatting, and Parsing 
The Locale Class 
Earlier we said that a big part of why this objective exists is to test your ability to 
do some basic internationalization tasks. Your wait is over; the Locale class is your 
ticket to worldwide domination. Both the DateFormat class and the NumberFormat 
class (which we'll cover next) can use an instance of Locale to customize formatted 
output to be specific to a locale. You might ask how Java defines a locale? The API 
says a locale is "a specific geographical, political, or cultural region." The two Locale 
constructors you'll need to understand for the exam are
Locale(String language)
Locale(String language, String country)
The language argument represents an ISO 639 Language Code, so for instance 
if you want to format your dates or numbers in Walloon (the language sometimes 
used in southern Belgium), you'd use "wa" as your language string. There are over 
500 ISO Language codes, including one for Klingon ("tlh"), although unfortunately 
Java doesn't yet support the Klingon locale. We thought about telling you that you'd 
have to memorize all these codes for the exam…but we didn't want to cause any 
heart attacks. So rest assured, you won't have to memorize any ISO Language codes 
or ISO Country codes (of which there are about 240) for the exam. Let's get back to how you might use these codes. If you want to represent basic 
Italian in your application, all you need is the language code. If, on the other hand, 
you want to represent the Italian used in Switzerland, you'd want to indicate that 
the country is Switzerland (yes, the country code for Switzerland is "CH"), but that 
the language is Italian:
Locale locPT = new Locale("it");        // Italian
Locale locBR = new Locale("it", "CH");  // Switzerland
Using these two locales on a date could give us output like this:
sabato 1 ottobre 2005
sabato, 1. ottobre 2005
Now let's put this all together in some code that creates a Calendar object, sets its 
date, then converts it to a Date. After that we'll take that Date object and print it 
out using locales from around the world:
Calendar c = Calendar.getInstance();
c.set(2010, 11, 14);                  // December 14, 2010
                                      // (month is 0-based
Date d2 = c.getTime();
Locale locIT = new Locale("it", "IT");  // Italy
Locale locPT = new Locale("pt");        // Portugal
Locale locBR = new Locale("pt", "BR");  // Brazil
Locale locIN = new Locale("hi", "IN");  // India
Locale locJA = new Locale("ja");        // Japan
DateFormat dfUS = DateFormat.getInstance();
System.out.println("US       " + dfUS.format(d2));
DateFormat dfUSfull = DateFormat.getDateInstance(
                                        DateFormat.FULL);
System.out.println("US full  " + dfUSfull.format(d2));    
    
DateFormat dfIT = DateFormat.getDateInstance(
                                        DateFormat.FULL, locIT);
System.out.println("Italy    " + dfIT.format(d2));
DateFormat dfPT = DateFormat.getDateInstance(
                                        DateFormat.FULL, locPT);
System.out.println("Portugal " + dfPT.format(d2));
DateFormat dfBR = DateFormat.getDateInstance(
                                        DateFormat.FULL, locBR);
System.out.println("Brazil   " + dfBR.format(d2));    
DateFormat dfIN = DateFormat.getDateInstance(
                                        DateFormat.FULL, locIN);
System.out.println("India    " + dfIN.format(d2));
DateFormat dfJA = DateFormat.getDateInstance(
                                        DateFormat.FULL, locJA);
System.out.println("Japan    " + dfJA.format(d2));
This, on our JVM, produces
US       12/14/10 3:32 PM
US full  Sunday, December 14, 2010
Italy    domenica 14 dicembre 2010
Working with Dates, Numbers, and Currencies (Exam Objective 3.4) 483
484 Chapter 6:  Strings, I/O, Formatting, and Parsing 
Portugal Domingo, 14 de Dezembro de 2010
Brazil   Domingo, 14 de Dezembro de 2010
India    ??????, ?? ??????, ????

--- Chunk #1439 ---
Japan    2010?12?14? Oops! Our machine isn't configured to support locales for India or Japan, but you 
can see how a single Date object can be formatted to work for many locales. There are a couple more methods in Locale (getDisplayCountry() and 
getDisplayLanguage()) that you'll have to know for the exam. These methods let 
you create Strings that represent a given locale's country and language in terms of 
both the default locale and any other locale:
Calendar c = Calendar.getInstance();
c.set(2010, 11, 14);
Date d2 = c.getTime();
Locale locBR = new Locale("pt", "BR");  // Brazil
Locale locDK = new Locale("da", "DK");  // Denmark
Locale locIT = new Locale("it", "IT");  // Italy
System.out.println("def " + locBR.getDisplayCountry());
System.out.println("loc " + locBR.getDisplayCountry(locBR));
System.out.println("def " + locDK.getDisplayLanguage());
System.out.println("loc " + locDK.getDisplayLanguage(locDK));
System.out.println("D>I " + locDK.getDisplayLanguage(locIT));
This, on our JVM, produces
Remember that both DateFormat and NumberFormat objects can have 
their locales set only at the time of instantiation. Watch for code that attempts to 
change the locale of an existing instance —no such methods exist! def Brazil
loc Brasil
def Danish
loc dansk
D>I danese
Given that our JVM's locale (the default for us) is US, the default for the 
country  Brazil is " Brazil", and the default for the Danish language is " Danish". In Brazil, the country is  called " Brasil", and in Denmark the language is called 
"dansk". Finally, just for fun, we discovered that in Italy, the Danish language is 
called "danese". The NumberFormat Class
We'll wrap up this objective by discussing the NumberFormat class. Like the 
DateFormat class, NumberFormat is abstract, so you'll typically use some version 
of either getInstance() or getCurrencyInstance() to create a NumberFormat 
object. Not surprisingly, you use this class to format numbers or currency values:
float f1 = 123.4567f;
Locale locFR = new Locale("fr");          // France
NumberFormat[] nfa = new NumberFormat[4];
nfa[0] = NumberFormat.getInstance();
nfa[1] = NumberFormat.getInstance(locFR);
nfa[2] = NumberFormat.getCurrencyInstance();
nfa[3] = NumberFormat.getCurrencyInstance(locFR);
for(NumberFormat nf : nfa)
  System.out.println(nf.format(f1));
This, on our JVM, produces
123.457
123,457
$123.46
123,46 ? Don't be worried if, like us, you're not set up to display the symbols for 
francs, pounds, rupees, yen, baht, or drachmas. You won't be expected to 
Working with Dates, Numbers, and Currencies (Exam Objective 3.4) 485
486 Chapter 6:  Strings, I/O, Formatting, and Parsing 
know the symbols used for currency: if you need one, it will be specified in 
the question. You might encounter methods other than the format method 
on the exam. Here's a little code that uses getMaximumFractionDigits(), 
setMaximumFractionDigits(), parse(), and setParseIntegerOnly():
float f1 = 123.45678f;
NumberFormat nf = NumberFormat.getInstance(); 
System.out.print(nf.getMaximumFractionDigits() + " ");
System.out.print(nf.format(f1) + "  ");
nf.setMaximumFractionDigits(5);
System.out.println(nf.format(f1) + "  ");      
try {
  System.out.println(nf.parse("1234.567"));
  nf.setParseIntegerOnly(true);
  System.out.println(nf.parse("1234.567"));
} catch (ParseException pe) {
  System.out.println("parse exc");
} 
This, on our JVM, produces
3  123.457  123.45678 
1234.567
1234
Notice that in this case, the initial number of fractional digits for the default 
NumberFormat is three: and that the format() method rounds f1's value, it 
doesn't truncate it. After changing nf's fractional digits, the entire value of f1 is 
displayed. Next, notice that the parse() method must run in a try/catch block 
and that the setParseIntegerOnly() method takes a boolean and in this 
case, causes subsequent calls to parse() to return only the integer part of Strings 
formatted as floating-point numbers. As we've seen, several of the classes covered in this objective are abstract.

--- Chunk #1440 ---
In 
addition, for all of these classes, key functionality for every instance is established 
at the time of creation. Table 6-3 summarizes the constructors or methods used to 
create instances of all the classes we've discussed in this section. CERTIFICATION OBJECTIVE
Parsing, T okenizing, and Formatting 
(Exam Objective 3.5)
3.5 Write code that uses standard J2SE APIs in the java.util and java.util.regex packages to 
format or parse strings or streams. For strings, write code that uses the Pattern and Matcher 
classes and the String.split method. Recognize and use regular expression patterns for matching 
(limited to: .(dot), *(star), +(plus), ?, \d, \s, \w, [ ], () ). The use of *, + , and ? will 
be limited to greedy quantifiers, and the parenthesis operator will only be used as a grouping 
mechanism, not for capturing content during matching. For streams, write code using the 
Formatter and Scanner classes and the PrintWriter.format/printf methods.

--- Chunk #1441 ---
Recognize and use 
formatting parameters (limited to: %b, %c, %d, %f, %s) in format strings. Parsing, T okenizing, and Formatting (Exam Objective 3.5) 487
 
Class Key Instance Creation Options
util.Date new Date();
new Date(long millisecondsSince010170);
util.Calendar Calendar.getInstance();
Calendar.getInstance(Locale);
util.Locale Locale.getDefault();
new Locale(String language);
new Locale(String language, String country);
text.DateFormat DateFormat.getInstance(); 
DateFormat.getDateInstance(); 
DateFormat.getDateInstance(style);   
DateFormat.getDateInstance(style, Locale);
text.NumberFormat NumberFormat.getInstance()
NumberFormat.getInstance(Locale)
NumberFormat.getNumberInstance()
NumberFormat.getNumberInstance(Locale)
NumberFormat.getCurrencyInstance()
NumberFormat.getCurrencyInstance(Locale)
 TABLE 6-3   Instance Creation for Key java.text and java.util Classes 
488 Chapter 6:  Strings, I/O, Formatting, and Parsing 
We're going to start with yet another disclaimer: This small section isn't going to morph 
you from regex newbie to regex guru. In this section we'll cover three basic ideas:
■ Finding stuff    You've got big heaps of text to look through.

--- Chunk #1442 ---
Maybe you're 
doing some screen scraping, maybe you're reading from a file. In any case, 
you need easy ways to find textual needles in textual haystacks. We'll use the 
java.util.regex.Pattern, java.util.regex.Matcher, and java.util.Scanner classes 
to help us find stuff. ■ Tokenizing stuff     You've got a delimited file that you want to get useful 
data out of. You want to transform a piece of a text file that looks like: 
"1500.00,343.77,123.4"  into some individual float variables. We'll show you 
the basics of using the String.split() method and the java.util.Scanner 
class, to tokenize your data. ■ Formatting stuff    You've got a report to create and you need to take a float 
variable with a value of 32500.000f and transform it into a String with a 
value of "$32,500.00". We'll introduce you to the java.util.Formatter class 
and to the printf() and format() methods. A Search T utorial
Whether you're looking for stuff or tokenizing stuff, a lot of the concepts are the 
same, so let's start with some basics. No matter what language you're using, sooner 
or later you'll probably be faced with the need to search through large amounts of 
textual data, looking for some specific stuff. Regular expressions (regex for short) are a kind of language within a language, 
designed to help programmers with these searching tasks. Every language that 
provides regex capabilities uses one or more regex engines. Regex engines search 
through textual data using instructions that are coded into expressions. A regex 
expression is like a very short program or script. When you invoke a regex engine, 
you'll pass it the chunk of textual data you want it to process (in Java this is usually 
a String or a stream), and you pass it the expression you want it to use to search 
through the data. It's fair to think of regex as a language, and we will refer to it that way throughout 
this section. The regex language is used to create expressions, and as we work 
through this section, whenever we talk about expressions or expression syntax, we're 
talking about syntax for the regex "language."  Oh, one more disclaimer…we know 
that you regex mavens out there can come up with better expressions than what 
we're about to present. Keep in mind that for the most part we're creating these 
expressions using only a portion of the total regex instruction set, thanks. Simple Searches
For our first example, we'd like to search through the following source String
abaaaba
for all occurrences (or matches) of the expression
ab
In all of these discussions we'll assume that our data sources use zero-based 
indexes, so if we apply an index to our source string we get
source: abaaaba
index:  0123456
We can see that we have two occurrences of the expression ab: one starting at 
position 0 and the second starting  at position 4. If we sent the previous source data 
and expression to a regex engine, it would reply by telling us that it found matches 
at positions 0 and 4:
import java.util.regex.*;
class RegexSmall {
  public static void main(String [] args) {
    Pattern p = Pattern.compile("ab");      // the expression
    Matcher m = p.matcher("abaaaba");       // the source
    while(m.find()) {
      System.out.print(m.start() + " ");
    }  
  }
}
This produces
   0 4
A Search T utorial (Exam Objective 3.5) 489
490 Chapter 6:  Strings, I/O, Formatting, and Parsing 
We're not going to explain this code right now. In a few pages we're going to 
show you a lot more regex code, but first we want to go over some more regex 
syntax. Once you understand a little more regex, the code samples will make a lot 
more sense. Here's a more complicated example of a source and an expression:
source: abababa
index:  0123456
expression: aba
How many occurrences do we get in this case? Well, there is clearly an occurrence 
starting at position 0, and another starting at position 4. But how about starting at 
position 2? In general in the world of regex, the aba string that starts at position 2 
will not be considered a valid occurrence. The first general regex search rule is
In general, a regex search runs from left to right, and once a source's character has 
been used in a match, it cannot be reused. So in our previous example, the first match used positions 0, 1, and 2 to match 
the expression. (Another common term for this is that the first three characters 
of the source were consumed.) Because the character in position 2 was consumed 
in the first match, it couldn't be used again. So the engine moved on, and didn't 
find another occurrence of aba until it reached position 4. This is the typical way 
that a regex matching engine works. However, in a few pages, we'll look at an 
exception to the first rule we stated above. So we've matched a couple of exact strings, but what would we do if we wanted 
to find something a little more dynamic? For instance, what if we wanted to find 
all of the occurrences of hex numbers or phone numbers or ZIP codes? Searches Using Metacharacters
As luck would have it, regex has a powerful mechanism for dealing with the cases 
we described above. At the heart of this mechanism is the idea of a metacharacter. As an easy example, let's say that we want to search through some source data 
looking for all occurrences of numeric digits. In regex, the following expression is 
used to look for numeric digits:
\d
If we change the previous program to apply the expression \d to the following 
source string
source: a12c3e456f
index:  0123456789
regex will tell us that it found digits at positions 1, 2, 4, 6, 7, and 8. (If you want to 
try this at home, you'll need to "escape" the compile method's "\d" argument by 
making it "\\d", more on this a little later.)
Regex provides a rich set of metacharacters that you can find described in the 
API documentation for java.util.regex.Pattern. We won't discuss them all here, but 
we will describe the ones you'll need for the exam:
\d A digit
\s A whitespace character
\w A word character (letters, digits, or "_" (underscore))
So for example, given
source: "a 1 56 _Z"
index:   012345678
pattern: \w
regex will return positions 0, 2, 4, 5, 7, and 8. The only characters in this source that 
don't match the definition of a word character are the whitespaces. (Note: In this 
example we enclosed the source data in quotes to clearly indicate that there was no 
whitespace at either end.) 
You can also specify sets of characters to search for using square brackets and 
ranges of characters to search for using square brackets and a dash:
[abc]    Searches only for a's, b's or c's
[a-f]    Searches only for a, b, c, d, e, or f characters
In addition, you can search across several ranges at once. The following 
expression is looking for occurrences of the letters a - f or A - F, it's NOT looking 
for an fA combination:
[a-fA-F]    Searches for the first six letters of the alphabet, both cases. A Search T utorial (Exam Objective 3.5) 491
492 Chapter 6:  Strings, I/O, Formatting, and Parsing 
So for instance,
source: "cafeBABE"
index:   01234567
pattern: [a-cA-C]
returns positions 0, 1, 4, 5, 6. In addition to the capabilities described for the exam, you can also apply 
the following attributes to sets and ranges within square brackets: " ^" to 
negate the characters specified, nested brackets to create a union of sets, 
and "&&" to specify the intersection of sets. While these constructs are not 
on the exam, they are quite useful, and good examples can be found in the 
API for the java.util.regex.Pattern class. Searches Using Quantifiers
Let's say that we want to create a regex pattern to search for hexadecimal literals. As 
a first step, let's solve the problem for one-digit hexadecimal numbers:
0[xX][0-9a-fA-F]
The preceding expression could be stated: "Find a set of characters in which the 
first character is a "0", the second character is either an "x" or an "X", and the third 
character is either a digit from "0" to "9", a letter from "a" to "f" or an uppercase 
letter from "A" to "F" ". Using the preceding expression, and the following data,
source: "12 0x 0x12 0Xf 0xg"
index:   012345678901234567
regex would return 6 and 11. (Note:  0x and 0xg are not valid hex numbers.) 
As a second step, let's think about an easier problem. What if we just wanted 
regex to find occurrences of integers? Integers can be one or more digits long, so it 
would be great if we could say "one or more" in an expression. There is a set of regex 
constructs called quantifiers that let us specify concepts such as "one or more." In 
fact, the quantifier that represents "one or more" is the "+" character. We'll see the 
others shortly. The other issue this raises is that when we're searching for something whose 
length is variable, getting only a starting position as a return value has limited value. So, in addition to returning starting positions, another bit of information that a 
regex engine can return is the entire match or group that it finds. We're going to 
change the way we talk about what regex returns by specifying each return on its 
own line, remembering that now for each return we're going to get back the starting 
position AND then the group:
source: "1 a12 234b"
pattern: \d+ 
You can read this expression as saying: "Find one or more digits in a row." This 
expression produces the regex output
0 1
3 12
6 234
You can read this as "At position 0 there's an integer with a value of 1, then at 
position 3 there's an integer with a value of 12, then at position 6 there's an integer 
with a value of 234." Returning now to our hexadecimal problem, the last thing we 
need to know is how to specify the use of a quantifier for only part of an expression. In this case we must have exactly one occurrence of 0x or 0X but we can have from 
one to many occurrences of the hex "digits" that follow. The following expression 
adds parentheses to limit the "+" quantifier to only the hex digits:
0[xX]([0-9a-fA-F])+ 
The parentheses and "+" augment the previous find-the-hex expression by 
saying in effect: "Once we've found our 0x or 0X, you can find from one to many 
occurrences of hex digits." Notice that we put the "+" quantifier at the end of the 
expression. It's useful to think of quantifiers as always quantifying the part of the 
expression that precedes them. The other two quantifiers we're going to look at are
* Zero or more occurrences
? Zero or one occurrence
A Search T utorial (Exam Objective 3.5) 493
494 Chapter 6:  Strings, I/O, Formatting, and Parsing 
Let's say you have a text file containing a comma-delimited list of all the file 
names in a directory that contains several very important projects. (BTW , this isn't 
how we'd arrange our directories : ) You want to create a list of all the files whose 
names start with proj1. You might discover .txt files, .java files, .pdf files, who 
knows? What kind of regex expression could we create to find these various proj1 
files? First let's take a look at what a part of this text might look like:
..."proj3.txt,proj1sched.pdf,proj1,proj2,proj1.java"... To solve this problem we're going to use the regex ^ (carat) operator, which we 
mentioned earlier. The regex ^ operator isn't on the exam, but it will help us create 
a fairly clean solution to our problem. The ^ is the negation symbol in regex. For 
instance, if you want to find anything but a's, b's, or c's in a file you could say
[^abc]
So, armed with the ^ operator and the * (zero or more) quantifier we can create 
the following:
proj1([^,])*
If we apply this expression to just the portion of the text file we listed above, 
regex returns
10 proj1sched.pdf
25 proj1
37 proj1.java
The key part of this expression is the "give me zero or more characters that aren't 
a comma."
The last quantifier example we'll look at is the ? (zero or one) quantifier. Let's say 
that our job this time is to search a text file and find anything that might be a local, 
7-digit phone number. We're going to say, arbitrarily, that if we find either seven 
digits in a row, or three digits followed by a dash or a space followed by 4 digits, that 
we have a candidate. Here are examples of "valid" phone numbers:
1234567
123 4567
123-4567
The key to creating this expression is to see that we need "zero or one instance of 
either a space or a dash" in the middle of our digits:
\d\d\d([-\s])?\d\d\d\d
The Predefined Dot
In addition to the \s, \d, and \w metacharacters that we discussed, you also have 
to understand the "." (dot) metacharacter. When you see this character in a regex 
expression, it means "any character can serve here." For instance, the following 
source and pattern
source: "ac abc a c"
pattern: a.c
will produce the output
3 abc
7 a c
The "." was able to match both the "b" and the "  " in the source data. Greedy Quantifiers
When you use the *, +, and ? quantifiers, you can fine tune them a bit to produce 
behavior that's known as "greedy", "reluctant", or "possessive". Although you need 
to understand only the greedy quantifier for the exam, we're also going to discuss the 
reluctant quantifier to serve as a basis for comparison. First the syntax:
? is greedy, ?? is reluctant, for zero or once
* is greedy, *? is reluctant, for zero or more
+ is greedy, +? is reluctant, for one or more 
What happens when we have the following source and pattern? source:  yyxxxyxx
pattern:  .*xx
First off, we're doing something a bit different here by looking for characters that 
prefix the static (xx) portion of the expression. We think we're saying something 
A Search T utorial (Exam Objective 3.5) 495
496 Chapter 6:  Strings, I/O, Formatting, and Parsing 
like: "Find sets of characters that ends with xx". Before we tell what happens, we at 
least want you to consider that there are two plausible results…can you find them? Remember we said earlier that in general, regex engines worked from left to right, 
and consumed characters as they went. So, working from left to right, we might 
predict that the engine would search the first 4 characters (0–3), find xx starting in 
position 2, and have its first match. Then it would proceed and find the second xx 
starting in position 6. This would lead us to a result like this:
0 yyxx
4 xyxx
A plausible second argument is that since we asked for a set of characters that 
ends with xx we might get a result like this:
0 yyxxxyxx
The way to think about this is to consider the name greedy. In order for the 
second answer to be correct, the regex engine would have to look (greedily) at the 
entire source data before it could determine that there was an xx at the end. So in 
fact, the second result is the correct result because in the original example we used 
the greedy quantifier *. The result that finds two different sets can be generated by 
using the reluctant quantifier *?. Let's review:
source:  yyxxxyxx
pattern:  .*xx
is using the greedy quantifier * and produces
0 yyxxxyxx
If we change the pattern to
source:  yyxxxyxx
pattern:  .*?xx
we're now using the reluctant qualifier *?, and we get the following:
0 yyxx
4 xyxx
The greedy quantifier does in fact read the entire source data, and then it works 
backward (from the right) until it finds the rightmost match. At that point, it 
includes everything from earlier in the source data up to and including the data that 
is part of the rightmost match. There are a lot more aspects to regex quantifiers than we've discussed 
here, but we've covered more than enough for the exam. Sun has several 
tutorials that will help you learn more about quantifiers, and turn you into 
the go-to person at your job. When Metacharacters and Strings Collide
So far we've been talking about regex from a theoretical perspective. Before we can 
put regex to work we have to discuss one more gotcha. When it's time to implement 
regex in our code, it will be quite common that our source data and/or our 
expressions will be stored in Strings. The problem is that metacharacters and Strings 
don't mix too well. For instance. let's say we just want to do a simple regex pattern 
that looks for digits. We might try something like
String pattern = "\d";    // compiler error! This line of code won't compile! The compiler sees the \ and thinks, "Ok, here 
comes an escape sequence, maybe it'll be a new line!" But no, next comes the d and 
the compiler says "I've never heard of the \d escape sequence." The way to satisfy 
the compiler is to add another backslash in front of the \d
String pattern = "\\d";    // a compilable metacharacter
The first backslash tells the compiler that whatever comes next should be taken 
literally, not as an escape sequence. How about the dot (.) metacharacter? If we want  
a dot in our expression to be used as a metacharacter, then no problem, but what if 
we're reading some source data that happens to use dots as delimiters? Here's another 
way to look at our options:
String p = "."; // regex sees this as the "." metacharacter
String p = "\."; // the compiler sees this as an illegal
                  // Java escape sequence
A Search T utorial (Exam Objective 3.5) 497
498 Chapter 6:  Strings, I/O, Formatting, and Parsing 
String p = "\\."; // the compiler is happy, and regex sees a 
                  // dot, not a metacharacter
A similar problem can occur when you hand metacharacters to a Java program 
via command-line arguments. If we want to pass the \d metacharacter into our Java 
program, our JVM does the right thing if we say
% java DoRegex "\d"
But your JVM might not. If you have problems running the following examples, you 
might try adding a backslash (i.e., \\d) to your command-line metacharacters. Don't 
worry, you won't see any command-line metacharacters on the exam! The Java language defines several escape sequences, including
 \n = linefeed (which you might see on the exam)  
 \b = backspace
 \t = tab
And others, which you can find in the Java Language Specification. Other 
than perhaps seeing a \n inside a String, you won't have to worry about 
Java's escape sequences on the exam. At this point we've learned enough of the regex language to start using it in our 
Java programs. We'll start by looking at using regex expressions to find stuff, and 
then we'll move to the closely related topic of tokenizing stuff. Locating Data via Pattern Matching
Once you know a little regex, using the java.util.regex.Pattern (Pattern) and 
java.util.regex.Matcher (Matcher) classes is pretty straightforward. The Pattern 
class is used to hold a representation of a regex expression, so that it can be used 
and reused by instances of the Matcher class. The Matcher class is used to invoke 
the regex engine with the intention of performing match operations. The following 
program shows Pattern and Matcher in action, and it's not a bad way for you to do 
your own regex experiments. Note, you might want to modify the following class by 
adding some functionality from the Console class. That way you'll get some practice 
with the Console class, and it'll be easier to run multiple regex experiments. import java.util.regex.*;
class Regex {
  public static void main(String [] args) {
    Pattern p = Pattern.compile(args[0]);
    Matcher m = p.matcher(args[1]);
    System.out.println("Pattern is " + m.pattern());
    while(m.find()) {
      System.out.println(m.start() + " " + m.group());
    }  
  }
}
This program uses the first command-line argument (args[0]) to represent the 
regex expression you want to use, and it uses the second argument (args[1]) to 
represent the source data you want to search. Here's a test run:
% java Regex "\d\w" "ab4 56_7ab"
Produces the output
Pattern is \d\w
4 56
7 7a
(Remember, if you want this expression to be represented in a String, you'd use 
\\d\\w). Because you'll often have special characters or whitespace as part of 
your arguments, you'll probably want to get in the habit of always enclosing your 
argument in quotes.

--- Chunk #1443 ---
Let's take a look at this code in more detail. First off, notice 
that we aren't using new to create a Pattern; if you check the API, you'll find no 
constructors are listed. You'll use the overloaded, static compile() method (that 
takes String expression) to create an instance of Pattern. For the exam, all you'll 
need to know to create a Matcher, is to use the Pattern.matcher() method (that 
takes String sourceData). The important method in this program is the find() method. This is the method 
that actually cranks up the regex engine and does some searching. The find() 
method returns true if it gets a match, and remembers the start position of the 
match. If find() returns true, you can call the start() method to get the starting 
position of the match, and you can call the group() method to get the string that 
represents the actual bit of source data that was matched. Locating Data via Pattern Matching (Exam Objective 3.5) 499
500 Chapter 6:  Strings, I/O, Formatting, and Parsing 
A common reason to use regex is to perform search and replace 
operations. Although replace operations are not on the exam you should 
know that the Matcher class provides several methods that perform search 
and replace operations. See the appendReplacement() , appendTail(), and 
replaceAll() methods in the Matcher API for more details. The Matcher class allows you to look at subsets of your source data by using a 
concept called regions. In real life, regions can greatly improve performance, but you 
won't need to know anything about them for the exam. To provide the most ﬂ exibility, Matcher.ﬁ  nd(), when coupled with the 
greedy quantiﬁ  ers ? or *, allow for (somewhat unintuitively) the idea of a zero-length 
match. As an experiment, modify the previous Regex.java class and add an invocation of 
m.end() to the S.O.P . in the while loop. With that modiﬁ  cation in place, the invocation
java Regex "a?" "aba"
should produce something very similar to this:
Pattern is a? 0 1 a
1 1
2 3 a
3 3
The lines of output 1 1 and 3 3 are examples of zero-length matches. Zero-length matches can occur in several places:
■ After the last character of source data (the 3 3 example)
■  In between characters after a match has been found (the 1 1 example)
■ At the beginning of source data (try java Regex "a?" "baba")
■ At the beginning of zero-length source data
Searching Using the Scanner Class    Although the java.util.Scanner 
class is primarily intended for tokenizing data (which we'll cover next), it can also 
be used to find stuff, just like the Pattern and Matcher classes. While Scanner 
doesn't provide location information or search and replace functionality, you can 
use it to apply regex expressions to source data to tell you how many instances of an 
expression exist in a given piece of source data. The following program uses the first 
command-line argument as a regex expression, then asks for input using System.in. It outputs a message every time a match is found:
import java.util.*;
class ScanIn {
  public static void main(String[] args) {
    System.out.print("input: ");
    System.out.flush();
    try {
      Scanner s = new Scanner(System.in);
      String token;
      do {
        token = s.findInLine(args[0]);
        System.out.println("found " + token);
      } while (token != null);    
    } catch (Exception e) { System.out.println("scan exc"); }
  }
}
The invocation and input
java ScanIn "\d\d"
input: 1b2c335f456 
produce the following:
found 33
found 45
found null
T okenizing
Tokenizing is the process of taking big pieces of source data, breaking them into 
little pieces, and storing the little pieces in variables. Probably the most common 
tokenizing situation is reading a delimited file in order to get the contents of the file 
T okenizing (Exam Objective 3.5) 501
502 Chapter 6:  Strings, I/O, Formatting, and Parsing 
moved into useful places like objects, arrays or collections. We'll look at two classes 
in the API that provide tokenizing capabilities: String (using the split() method) 
and Scanner, which has many methods that are useful for tokenizing. T okens and Delimiters
When we talk about tokenizing, we're talking about data that starts out composed of 
two things: tokens and delimiters. Tokens are the actual pieces of data, and delimit-
ers are the expressions that separate the tokens from each other. When most people 
think of delimiters, they think of single characters, like commas or backslashes or 
maybe a single whitespace. These are indeed very common delimiters, but strictly 
speaking, delimiters can be much more dynamic. In fact, as we hinted at a few sen-
tences ago, delimiters can be anything that qualifies as a regex expression. Let's take 
a single piece of source data and tokenize it using a couple of different delimiters:
source: "ab,cd5b,6x,z4"
If we say that our delimiter is a comma, then our four tokens would be
 
ab
cd5b
6x
z4
If we use the same source, but declare our delimiter to be \d, we get three tokens:
ab,cd
b,
x,z
In general, when we tokenize source data, the delimiters themselves are discarded, 
and all that we are left with are the tokens. So in the second example, we defined 
digits to be delimiters, so the 5, 6, and 4 do not appear in the final tokens. T okenizing with String.split()
The String class's split() method takes a regex expression as its argument, 
and returns a String array populated with the tokens produced by the split (or 
tokenizing) process. This is a handy way to tokenize relatively small pieces of data. The following program uses args[0] to hold a source string, and args[1] to hold 
the regex pattern to use as a delimiter:
import java.util.*;
class SplitTest {
  public static void main(String[] args) {
    String[] tokens = args[0].split(args[1]);
    System.out.println("count " + tokens.length);
    for(String s : tokens)
      System.out.println(">" + s + "<");
  }
}
Everything happens all at once when the split() method is invoked. The source 
string is split into pieces, and the pieces are all loaded into the tokens String array. All the code after that is just there to verify what the split operation generated. The 
following invocation
% java SplitTest "ab5 ccc 45 @" "\d"
produces
count 4
>ab<
> ccc <
><
> @<
(Note: Remember that to represent "\" in a string you may need to use the escape 
sequence "\\". Because of this, and depending on your OS, your second argument 
might have to be "\\d" or even "\\\\d".)
We put the tokens inside "> <" characters to show whitespace. Notice that every 
digit was used as a delimiter, and that contiguous digits created an empty token. One drawback to using the String.split() method is that often you'll want 
to look at tokens as they are produced, and possibly quit a tokenization operation 
early when you've created the tokens you need. For instance, you might be searching 
a large file for a phone number. If the phone number occurs early in the file, you'd 
like to quit the tokenization process as soon as you've got your number. The Scanner 
class provides a rich API for doing just such on-the-fly tokenization operations. T okenizing (Exam Objective 3.5) 503
504 Chapter 6:  Strings, I/O, Formatting, and Parsing 
T okenizing with Scanner
The java.util.Scanner class is the Cadillac of tokenizing. When you need to do some 
serious tokenizing, look no further than Scanner—this beauty has it all. In addition 
to the basic tokenizing capabilities provided by String.split(), the Scanner class 
offers the following features:
■ Scanners can be constructed using files, streams, or Strings as a source. ■ Tokenizing is performed within a loop so that you can exit the process at any 
point. ■ Tokens can be converted to their appropriate primitive types automatically. Let's look at a program that demonstrates several of Scanner's methods and 
capabilities. Scanner's default delimiter is whitespace, which this program uses. Because System.out.println() is so heavily used on the exam, you 
might see examples of escape sequences tucked in with questions on most any topic, 
including regex. Remember that if you need to create a String that contains a double 
quote " or a backslash \ you need to add an escape character ﬁ rst:
System.out.println("\" \\");
This prints
" \
So, what if you need to search for periods (.) in your source data? If you 
just put a period in the regex expression, you get the "any character" behavior. So, what 
if you try \. ? Now the Java compiler thinks you're trying to create an escape sequence 
that doesn’t exist. The correct syntax is
    String s = "ab.cde.fg";
    String[] tokens = s.split("\\.");  
The program makes two Scanner objects: s1 is iterated over with the more generic 
next() method, which returns every token as a String, while s2 is analyzed with 
several of the specialized nextXxx() methods (where Xxx is a primitive type):
import java.util.Scanner;
class ScanNext {
  public static void main(String [] args) {
    boolean b2, b;
    int i;
    String s, hits = " ";
    Scanner s1 = new Scanner(args[0]);
    Scanner s2 = new Scanner(args[0]);    
    while(b = s1.hasNext()) {
      s = s1.next();  hits += "s";
    }
    while(b = s2.hasNext()) {
      if (s2.hasNextInt()) {
        i = s2.nextInt();  hits += "i";
      } else if (s2.hasNextBoolean()) {
        b2 = s2.nextBoolean();  hits += "b";
      } else { 
        s2.next();  hits += "s2";
      }
    } 
    System.out.println("hits " + hits);    
  }
}
If this program is invoked with
% java ScanNext "1 true 34 hi"
it produces
hits  ssssibis2
Of course we're not doing anything with the tokens once we've got them, but you 
can see that s2's tokens are converted to their respective primitives. A key point 
here is that the methods named hasNextXxx() test the value of the next token 
T okenizing (Exam Objective 3.5) 505
506 Chapter 6:  Strings, I/O, Formatting, and Parsing 
but do not actually get the token, nor do they move to the next token in the source 
data. The nextXxx() methods all perform two functions: they get the next token, 
and then they move to the next token. The Scanner class has nextXxx() (for instance nextLong()) and hasNextXxx() 
(for instance hasNextDouble()) methods for every primitive type except char. In 
addition, the Scanner class has a useDelimiter() method that allows you to set 
the delimiter to be any valid regex expression. Formatting with printf() and format()
What fun would accounts receivable reports be if the decimal points didn't line up? Where would you be if you couldn't put negative numbers inside of parentheses? Burning questions like these caused the exam creation team to include formatting 
as a part of the exam. The format() and printf() methods were added to 
java.io.PrintStream in Java 5. These two methods behave exactly the same way, so 
anything we say about one of these methods applies to both of them. (The rumor is 
that Sun added printf() just to make old C programmers happy.) 
Behind the scenes, the format() method uses the java.util.Formatter class 
to do the heavy formatting work. You can use the Formatter class directly if you 
choose, but for the exam all you have to know is the basic syntax of the arguments 
you pass to the format() method. The documentation for these formatting 
arguments can be found in the Formatter API. We're going to take the "nickel tour" 
of the formatting String syntax, which will be more than enough to allow you to do 
a lot of basic formatting work, AND ace all the formatting questions on the exam. Let's start by paraphrasing the API documentation for format strings (for more 
complete, way-past-what-you-need-for-the-exam coverage, check out the 
java.util.Formatter API):
printf("format string", argument(s));
The format string can contain both normal string literal information that isn't 
associated with any arguments, and argument-specific formatting data. The clue to 
determining whether you're looking at formatting data, is that formatting data will 
always start with a percent sign (%). Let's look at an example, and don't panic, we'll 
cover everything that comes after the % next:
System.out.printf("%2$d  +  %1$d", 123, 456);  
This produces
456 + 123
Let's look at what just happened. Inside the double quotes there is a format string, 
then a +, and then a second format string. Notice that we mixed literals in with 
the format strings. Now let's dive in a little deeper and look at the construction of 
format strings:
%[arg_index$][flags][width][.precision]conversion char
The values within [ ] are optional. In other words, the only required elements of 
a format string are the % and a conversion character. In the example above the only 
optional values we used were for argument indexing. The 2$ represents the second 
argument, and the 1$ represents the first argument. (Notice that there's no problem 
switching the order of arguments.) The d after the arguments is a conversion 
character (more or less the type of the argument). Here's a rundown of the format 
string elements you'll need to know for the exam:
arg_index An integer followed directly by a $, this indicates which argument 
should be printed in this position. flags While many flags are available, for the exam you'll need to know:
■ " -" Left justify this argument
■ "+" Include a sign (+ or -) with this argument
■ "0" Pad this argument with zeroes
■ "," Use locale-specific grouping separators (i.e., the comma in 123,456)
■ "(" Enclose negative numbers in parentheses
width This value indicates the minimum number of characters to print. (If you 
want nice even columns, you'll use this value extensively.)
precision For the exam you'll only need this when formatting a floating-point 
number, and in the case of floating point numbers, precision indicates the number of 
digits to print after the decimal point. Formatting with printf() and format() (Exam Objective 3.5) 507
508 Chapter 6:  Strings, I/O, Formatting, and Parsing 
conversion The type of argument you'll be formatting. You'll need to know:
■ b boolean
■ c char
■ d integer
■ f floating point
■ s string
Let's see some of these formatting strings in action:
int i1 = -123;
int i2 = 12345;
System.out.printf(">%1$(7d< \n", i1);
System.out.printf(">%0,7d< \n", i2);
System.out.format(">%+-7d< \n", i2);
System.out.printf(">%2$b + %1$5d< \n", i1, false);
This produces:
>  (123)< 
>012,345< 
>+12345 < 
>false +  -123<
(We added the > and < literals to help show how minimum widths, and zero 
padding and alignments work.) Finally, it's important to remember that if you 
have a mismatch between the type specified in your conversion character and your 
argument, you'll get a runtime exception:
System.out.format("%d", 12.3);
This produces something like
Exception in thread "main" java.util.IllegalFormatConversionEx-
ception: d != java.lang.Double
CERTIFICATION SUMMARY 
Strings The most important thing to remember about Strings is that String 
objects are immutable, but references to Strings are not! You can make a new String 
by using an existing String as a starting point, but if you don't assign a reference 
variable to the new String it will be lost to your program—you will have no way to 
access your new String.

--- Chunk #1444 ---
Review the important methods in the String class. The StringBuilder class was added in Java 5. It has exactly the same methods as 
the old StringBuffer class, except StringBuilder's methods aren't thread-safe. Because 
StringBuilder's methods are not thread safe, they tend to run faster than StringBuffer 
methods, so choose StringBuilder whenever threading is not an issue. Both 
StringBuffer and StringBuilder objects can have their value changed over and over 
without having to create new objects. If you're doing a lot of string manipulation, 
these objects will be more efficient than immutable String objects, which are, more 
or less, "use once, remain in memory forever." Remember, these methods ALWAYS 
change the invoking object's value, even with no explicit assignment. File I/O Remember that objects of type File can represent either files or directo-
ries, but that until you call createNewFile() or mkdir() you haven't actually cre-
ated anything on your hard drive. Classes in the java.io package are designed to be 
chained together. It will be rare that you'll use a FileReader or a FileWriter without 
"wrapping" them with a BufferedReader or BufferedWriter object, which gives you 
access to more powerful, higher-level methods. As of Java 5, the PrintWriter class 
has been enhanced with advanced append(), format(), and printf() methods, 
and when you couple that with new constructors that allow you to create PrintWrit-
ers directly from a String name or a File object, you may use BufferWriters a lot less. The Console class allows you to read non-echoed input (returned in a char[ ]), and is 
instantiated using System.console(). Serialization Serialization lets you save, ship, and restore everything you need 
to know about a live object. And when your object points to other objects, they get 
saved too. The java.io.ObjectOutputStream and java.io.ObjectInputStream classes 
are used to serialize and deserialize objects. Typically you wrap them around instanc-
es of FileOutputStream and FileInputStream, respectively. The key method you invoke to serialize an object is writeObject(), and to 
deserialize an object invoke readObject(). In order to serialize an object, it must 
implement the Serializable interface. Mark instance variables transient if you 
don't want their state to be part of the serialization process. You can augment 
Certiﬁ  cation Summary 509
510 Chapter 6:  Strings, I/O, Formatting, and Parsing 
the serialization process for your class by implementing writeObject() and 
readObject(). If you do that, an embedded call to defaultReadObject() and 
defaultWriteObject() will handle the normal serialization tasks, and you can 
augment those invocations with manual reading from and writing to the stream. If a superclass implements Serializable then all of its subclasses do too. If a 
superclass doesn't implement Serializable, then when a subclass object is deserialized 
the unserializable superclass's constructor runs—be careful! Finally, remember that 
serialization is about instances, so static variables aren't serialized. Dates, Numbers, and Currency Remember that the Sun objective is a bit 
misleading, and that you'll have to understand the basics of five related classes: 
java.util.Date, java.util.Calendar, java.util.Locale, java.text.DateFormat, and java. text.NumberFormat. A Date is the number of milliseconds since Jan 1, 1970, stored 
in a long. Most of Date's methods have been deprecated, so use the Calendar class 
for your date-manipulation tasks. Remember that in order to create instances of 
Calendar, DateFormat, and NumberFormat, you have to use static factory methods 
like getInstance(). The Locale class is used with DateFormat and NumberFormat 
to generate a variety of output styles that are language and/or country specific. Parsing, T okenizing, and Formatting To find specific pieces of data in 
large data sources, Java provides several mechanisms that use the concepts of regular 
expressions (Regex). regex expressions can be used with the java.util.regex package's 
Pattern and Matcher classes, as well as with java.util.Scanner and with the 
String.split() method. When creating regex patterns, you can use literal 
characters for matching or you can use metacharacters, that allow you to match on 
concepts like "find digits" or "find whitespace". Regex provides quantifiers that allow 
you to say things like "find one or more of these things in a row." You won't have to 
understand the Matcher methods that facilitate replacing strings in data. Tokenizing is splitting delimited data into pieces. Delimiters are usually as simple 
as a comma, but they can be as complex as any other regex pattern. The 
java.util.Scanner class provides full tokenizing capabilities using regex, and allows 
you to tokenize in a loop so that you can stop the tokenizing process at any point. String.split() allows full regex patterns for tokenizing, but tokenizing is done in 
one step, hence large data sources can take a long time to process. Formatting data for output can be handled by using the Formatter class, or 
more commonly by using the new PrintStream methods format() and printf(). Remember format() and printf() behave identically. To use these methods, you 
create a format string that is associated with every piece of data you want to format. TWO-MINUTE DRILL
Here are some of the key points from the certification objectives in this chapter. Using String, StringBuffer, and StringBuilder (Objective 3.1)
❑ String objects are immutable, and String reference variables are not. ❑ If you create a new String without assigning it, it will be lost to your program. ❑ If you redirect a String reference to a new String, the old String can be lost. ❑ String methods use zero-based indexes, except for the second argument of 
substring(). ❑ The String class is final—its methods can't be overridden. ❑ When the JVM finds a String literal, it is added to the String literal pool. ❑ Strings have a method: length(); arrays have an attribute named length. ❑ The StringBuffer's API is the same as the new StringBuilder's API, except 
that StringBuilder's methods are not synchronized for thread safety. ❑ StringBuilder methods should run faster than StringBuffer methods. ❑ All of the following bullets apply to both StringBuffer and StringBuilder:
 ❑     They are mutable—they can change without creating a new object. ❑     StringBuffer methods act on the invoking object, and objects can change 
       without an explicit assignment in the statement. ❑     StringBuffer equals() is not overridden; it doesn't compare values. ❑ Remember that chained methods are evaluated from left to right. ❑ String methods to remember: charAt(), concat(), equalsIgnoreCase(), 
length(), replace(), substring(), toLowerCase(), toString(), 
toUpperCase(), and trim(). ❑  StringBuffer methods to remember: append(), delete(), insert(), 
reverse(), and toString(). File I/O (Objective 3.2)
❑  The classes you need to understand in java.io are File, FileReader, 
BufferedReader, FileWriter, BufferedWriter, PrintWriter, and Console. ❑  A new File object doesn't mean there's a new file on your hard drive. ❑  File objects can represent either a file or a directory. T wo-Minute Drill 511
✓
❑  The File class lets you manage (add, rename, and delete) files and directories. ❑  The methods createNewFile() and mkdir() add entries to your file system. ❑  FileWriter and FileReader are low-level I/O classes. You can use them to 
write and read files, but they should usually be wrapped. ❑  Classes in java.io are designed to be "chained" or "wrapped." (This is a 
common use of the decorator design pattern.)
❑  It's very common to "wrap" a BufferedReader around a FileReader 
or a BufferedWriter around a FileWriter, to get access to higher-level 
(more convenient) methods. ❑  PrintWriters can be used to wrap other Writers, but as of Java 5 they can be 
built directly from Files or Strings. ❑  Java 5 PrintWriters have new append(), format(), and printf() methods. ❑  Console objects can read non-echoed input and are instantiated using 
System.console(). Serialization  (Objective 3.3)
❑  The classes you need to understand are all in the java.io package; they 
include: ObjectOutputStream and ObjectInputStream primarily, and 
FileOutputStream and FileInputStream because you will use them to create 
the low-level streams that the ObjectXxxStream classes will use. ❑  A class must implement Serializable before its objects can be serialized. ❑  The ObjectOutputStream.writeObject() method serializes objects, and 
the ObjectInputStream.readObject() method deserializes objects. ❑  If you mark an instance variable transient, it will not be serialized even 
thought the rest of the object's state will be. ❑  You can supplement a class's automatic serialization process by implementing 
the writeObject() and readObject() methods. If you do this, embedding 
calls to defaultWriteObject() and defaultReadObject(), respectively, 
will handle the part of serialization that happens normally. ❑  If a superclass implements Serializable, then its subclasses do automatically. ❑  If a superclass doesn't implement Serializable, then when a subclass object 
is deserialized, the superclass constructor will be invoked, along with its 
superconstructor(s). ❑  DataInputStream and DataOutputStream aren't actually on the exam, in 
spite of what the Sun objectives say. 512 Chapter 6:  Strings, I/O, Formatting, and Parsing 
Dates, Numbers, and Currency (Objective 3.4)
❑  The classes you need to understand are java.util.Date, java.util.Calendar, 
java.text.DateFormat, java.text.NumberFormat, and java.util.Locale. ❑  Most of the Date class's methods have been deprecated. ❑  A Date is stored as a long, the number of milliseconds since January 1, 1970. ❑  Date objects are go-betweens the Calendar and Locale classes. ❑  The Calendar provides a powerful set of methods to manipulate dates, 
performing tasks such as getting days of the week, or adding some number of 
months or years (or other increments) to a date. ❑  Create Calendar instances using static factory methods (getInstance()). ❑  The Calendar methods you should understand are add(), which allows you 
to add or subtract various pieces (minutes, days, years, and so on) of dates, 
and roll(), which works like add() but doesn't increment a date's bigger 
pieces. (For example: adding 10 months to an October date changes the 
month to August, but doesn't increment the Calendar's year value.)
❑  DateFormat instances are created using static factory methods 
(getInstance() and getDateInstance()). ❑  There are several format "styles" available in the DateFormat class. ❑  DateFormat styles can be applied against various Locales to create a wide 
array of outputs for any given date. ❑  The DateFormat.format() method is used to create Strings containing 
properly formatted dates. ❑  The Locale class is used in conjunction with DateFormat and NumberFormat. ❑  Both DateFormat and NumberFormat objects can be constructed with a 
specific, immutable Locale. ❑  For the exam you should understand creating Locales using language, or a 
combination of language and country. Parsing, T okenizing, and Formatting (Objective 3.5)
❑  regex is short for regular expressions, which are the patterns used to search for 
data within large data sources. ❑  regex is a sub-language that exists in Java and other languages (such as Perl). ❑  regex lets you to create search patterns using literal characters or 
metacharacters. Metacharacters allow you to search for slightly more abstract 
data like "digits" or "whitespace". T wo-Minute Drill 513
514 Chapter 6:  Strings, I/O, Formatting, and Parsing 
❑  Study the \d, \s, \w, and . metacharacters
❑  regex provides for quantifiers which allow you to specify concepts like: "look 
for one or more digits in a row."
❑  Study the ?, *, and + greedy quantifiers. ❑  Remember that metacharacters and Strings don't mix well unless you 
remember to "escape" them properly. For instance String s = "\\d";
❑  The Pattern and Matcher classes have Java's most powerful regex capabilities. ❑  You should understand the Pattern compile() method and the Matcher 
matches(), pattern(), find(), start(), and group() methods. ❑  You WON'T need to understand Matcher's replacement-oriented methods. ❑  You can use java.util.Scanner to do simple regex searches, but it is primarily 
intended for tokenizing. ❑  Tokenizing is the process of splitting delimited data into small pieces. ❑  In tokenizing, the data you want is called tokens, and the strings that separate 
the tokens are called delimiters. ❑  Tokenizing can be done with the Scanner class, or with String.split(). ❑  Delimiters are single characters like commas, or complex regex expressions. ❑  The Scanner class allows you to tokenize data from within a loop, which 
allows you to stop whenever you want to. ❑  The Scanner class allows you to tokenize Strings or streams or files. ❑  The String.split() method tokenizes the entire source data all at once, so 
large amounts of data can be quite slow to process. ❑  New to Java 5 are two methods used to format data for output. These 
methods are format() and printf(). These methods are found in the 
PrintStream class, an instance of which is the out in System.out. ❑  The format() and printf() methods have identical functionality. ❑  Formatting data with printf() (or format()) is accomplished using 
formatting strings that are associated with primitive or string arguments. ❑  The format() method allows you to mix literals in with your format strings. ❑  The format string values you should know are
 ❑     Flags: -, +, 0, "," , and (
      ❑     Conversions: b, c, d, f, and s
❑  If your conversion character doesn't match your argument type, an exception 
will be thrown. SELF TEST
 1. Given:
import java.util.regex.*;
class Regex2 {
  public static void main(String[] args) {
    Pattern p = Pattern.compile(args[0]);
    Matcher m = p.matcher(args[1]);
    boolean b = false;
    while(b = m.find()) {
      System.out.print(m.start() + m.group());
    }  
  }
}
  And the command line:
java Regex2 "\d*" ab34ef
      What is the result? A.

--- Chunk #1445 ---
234
  B. 334
  C. 2334
  D. 0123456
  E. 01234456
  F. 12334567
  G.

--- Chunk #1446 ---
Compilation fails
 2. Given:
import java.io.*;
class Player { 
  Player() { System.out.print("p"); }
}
class CardPlayer extends Player implements Serializable {
  CardPlayer() { System.out.print("c"); }
Self T est 515
  public static void main(String[] args) {
    CardPlayer c1 = new CardPlayer();
    try {
      FileOutputStream fos = new FileOutputStream("play.txt");
      ObjectOutputStream os = new ObjectOutputStream(fos);
      os.writeObject(c1);
      os.close();
      FileInputStream fis = new FileInputStream("play.txt");
      ObjectInputStream is = new ObjectInputStream(fis);
      CardPlayer c2 = (CardPlayer) is.readObject();
      is.close();
    } catch (Exception x ) { }
  }
}
  What is the result? A.

--- Chunk #1447 ---
pc
  B. pcc
  C. pcp
  D. pcpc
  E. Compilation fails
  F.

--- Chunk #1448 ---
An exception is thrown at runtime
 3. Given:
class TKO {
  public static void main(String[] args) {
    String s = "-";
    Integer x = 343;
    long L343 = 343L;
    if(x.equals(L343))  s += ".e1 ";
    if(x.equals(343))  s += ".e2 "; 
    Short s1 = (short)((new Short((short)343)) / (new Short((short)49)));
    if(s1 == 7)        s += "=s "; 
    if(s1 < new Integer(7+1))  s += "fly ";
    System.out.println(s);
  }
}
516 Chapter 6:  Strings, I/O, Formatting, and Parsing
  Which of the following will be included in the output String s? (Choose all that apply.)
  A.

--- Chunk #1449 ---
.e1
  B. .e2
  C. =s
  D. fly
  E. None of the above
  F. Compilation fails
  G. An exception is thrown at runtime
 4. Given:
import java.io.*;
class Keyboard { }
public class Computer implements Serializable {
  private Keyboard k = new Keyboard();
  public static void main(String[] args) {
    Computer c = new Computer();
    c.storeIt(c);
  }
  void storeIt(Computer c) {
    try { 
      ObjectOutputStream os = new ObjectOutputStream(
         new FileOutputStream("myFile"));
      os.writeObject(c);
      os.close();
      System.out.println("done");
    } catch (Exception x) {System.out.println("exc"); }
  }
}
  What is the result? (Choose all that apply.)
  A.

--- Chunk #1450 ---
exc
  B. done
  C. Compilation fails
  D. Exactly one object is serialized
  E. Exactly two objects are serialized
Self T est 517
518 Chapter 6:  Strings, I/O, Formatting, and Parsing 
 5. Using the fewest fragments possible (and filling the fewest slots possible), complete the code 
below so that the class builds a directory named "dir3" and creates a file named "file3" inside 
"dir3". Note you can use each fragment either zero or one times. Code:
import java.io.______________
class Maker {
  public static void main(String[] args) {
    ___________  ___________  ___________
    ___________  ___________  ___________
    ___________  ___________  ___________
    ___________  ___________  ___________
    ___________  ___________  ___________
    ___________  ___________  ___________
    ___________  ___________  ___________
  }
} 
  Fragments: 
   File;     FileDescriptor;     FileWriter;    Directory;
   try {     .createNewDir();    File dir       File
   { }       (Exception x)       ("dir3");      file
   file      .createNewFile();   = new File     = new File
   dir       (dir, "file3");     (dir, file);   .createFile();
   } catch   ("dir3", "file3");  .mkdir();      File file
   
       
Self T est 519
 6. Given that 1119280000000L is roughly the number of milliseconds from Jan 1, 1970, to June 
20, 2005, and that you want to print that date in German, using the LONG style such that "June" 
will be displayed as "Juni", complete the code using the fragments below.

--- Chunk #1451 ---
Note: you can use 
each fragment either zero or one times, and you might not need to fill all of the slots. Code:
import java.___________
import java.___________
class DateTwo {
  public static void main(String[] args) {
    Date d = new Date(1119280000000L);
    DateFormat df = ___________________________
                    ________________ , _________________ );
  
    System.out.println(________________ 
  }
}
  Fragments:
  io.*;     new DateFormat(                 Locale.LONG
  nio.*;    DateFormat.getInstance(         Locale.GERMANY
  util.*;   DateFormat.getDateInstance(     DateFormat.LONG
  text.*;   util.regex;                     DateFormat.GERMANY
  date.*;   df.format(d));                  d.format(df));
 7. Given:
import java.io.*;
class Directories {
  static String [] dirs = {"dir1", "dir2"};
  public static void main(String [] args) {
    for (String d : dirs) {
      // insert code 1 here
      File file = new File(path, args[0]);
      // insert code 2 here
    }
  }
}
520 Chapter 6:  Strings, I/O, Formatting, and Parsing 
  and that the invocation
java Directories file2.txt
  is issued from a directory that has two subdirectories, " dir1" and "dir2", and that "dir1" has a file 
"file1.txt" and "dir2" has a file "file2.txt", and the output is "false true"; which set(s) 
of code fragments must be inserted?

--- Chunk #1452 ---
(Choose all that apply.)
  A. String path = d;
System.out.print(file.exists() + " ");
  B. String path = d;
System.out.print(file.isFile() + " ");
  C. String path = File.separator + d;
System.out.print(file.exists() + " ");
  D. String path = File.separator + d;
System.out.print(file.isFile() + " ");
 8. Given:
 
import java.io.*;
public class TestSer {
  public static void main(String[] args) {
    SpecialSerial s = new SpecialSerial();
    try { 
      ObjectOutputStream os = new ObjectOutputStream(
         new FileOutputStream("myFile"));
      os.writeObject(s);  os.close();
      System.out.print(++s.z + " ");
      
      ObjectInputStream is = new ObjectInputStream(
         new FileInputStream("myFile"));
      SpecialSerial s2 = (SpecialSerial)is.readObject();
      is.close();
Self T est 521
      System.out.println(s2.y + " " + s2.z);
    } catch (Exception x) {System.out.println("exc"); }
  }
}
class SpecialSerial implements Serializable {
  transient int y = 7;
  static int z = 9;
}
  Which are true? (Choose all that apply.)
  A.

--- Chunk #1453 ---
Compilation fails
  B. The output is 10 0 9
  C. The output is 10 0 10
  D. The output is 10 7 9
  E. The output is 10 7 10
  F. In order to alter the standard deserialization process you would implement the 
readObject() method in SpecialSerial
  G. In order to alter the standard deserialization process you would implement the 
defaultReadObject() method in SpecialSerial
 9. Given:
 
 3.

--- Chunk #1454 ---
public class Theory {
 4. public static void main(String[] args) {
 5. String s1 = "abc";
 6. String s2 = s1;
 7. s1 += "d";
 8. System.out.println(s1 + " " + s2 + " " + (s1==s2));
 9. 10. StringBuffer sb1 = new StringBuffer("abc");
11. StringBuffer sb2 = sb1;
12. sb1.append("d");
13. System.out.println(sb1 + " " + sb2 + " " + (sb1==sb2));
14. }
15.

--- Chunk #1455 ---
}
  Which are true? (Choose all that apply.)
  A. Compilation fails
  B. The first line of output is abc abc true
  C. The first line of output is abc abc false
  D. The first line of output is abcd abc false
  E. The second line of output is abcd abc false
  F. The second line of output is abcd abcd true
  G. The second line of output is abcd abcd false
 10. Given:
 
 3. import java.io.*;
 4. public class ReadingFor {
 5. public static void main(String[] args) {
 6. String s;
 7. try {
 8. FileReader fr = new FileReader("myfile.txt");
 9. BufferedReader br = new BufferedReader(fr);
10. while((s = br.readLine()) != null)
11. System.out.println(s);
12. br.flush();
13. } catch (IOException e) { System.out.println("io error"); }
16. }
17. }
  And given that myfile.txt contains the following two lines of data:
ab
cd
  What is the result? A.

--- Chunk #1456 ---
ab
  B. abcd
  C. ab
     cd
  D.

--- Chunk #1457 ---
a
     b
     c
     d
  E. Compilation fails
522 Chapter 6:  Strings, I/O, Formatting, and Parsing 
 11. Given:
 
 3.

--- Chunk #1458 ---
import java.io.*;
 4. public class Talker {
 5. public static void main(String[] args) {
 6. Console c = System.console();
 7. String u = c.readLine("%s", "username: ");
 8. System.out.println("hello " + u);
 9. String pw;
10. if(c != null && (pw = c.readPassword("%s", "password: ")) != null) 
11. // check for valid password
12. }
13. }
  If line 6 creates a valid Console object, and if the user enters fred as a username and 1234 as a 
password, what is the result? (Choose all that apply.)
  A. username:
   password:
  B. username: fred
   password:
  C. username: fred
   password: 1234
  D. Compilation fails
  E. An exception is thrown at runtime
 12. Given:
 
 3. import java.io.*;
 4. class Vehicle { }
 5. class Wheels { }
 6. class Car extends Vehicle implements Serializable {  }
 7. class Ford extends Car { }
 8. class Dodge extends Car {
 9. Wheels w = new Wheels();
10. }
  Instances of which class(es) can be serialized? (Choose all that apply.)
  A.

--- Chunk #1459 ---
Car
  B. Ford
Self T est 523
524 Chapter 6:  Strings, I/O, Formatting, and Parsing 
  C. Dodge
  D. Wheels
  E. Vehicle
 13.

--- Chunk #1460 ---
Given:
 
 3. import java.text.*;
 4. public class Slice {
 5. public static void main(String[] args) {
 6. String s = "987.123456";
 7. double d  = 987.123456d;
 8. NumberFormat nf = NumberFormat.getInstance();
 9. nf.setMaximumFractionDigits(5);
10. System.out.println(nf.format(d) + " ");
11. try {
12. System.out.println(nf.parse(s));   
13. } catch (Exception e) { System.out.println("got exc"); }
14. }
15.

--- Chunk #1461 ---
}
  Which are true? (Choose all that apply.)
  A. The output is 987.12345 987.12345
  B. The output is 987.12346 987.12345
  C. The output is 987.12345 987.123456
  D. The output is 987.12346 987.123456
  E. The try/catch block is unnecessary
  F. The code compiles and runs without exception
  G. The invocation of parse() must be placed within a try/catch block
 14. Given:
 
 3. import java.util.regex.*;
 4. public class Archie {
 5. public static void main(String[] args) {
 6. Pattern p = Pattern.compile(args[0]);
 7. Matcher m = p.matcher(args[1]);
 8. int count = 0;
 9. while(m.find())
10. count++;
11. System.out.print(count);
12. }
13. }
  And given the command line invocation:
java Archie "\d+" ab2c4d67
  What is the result? A.

--- Chunk #1462 ---
0
  B. 3
  C. 4
  D. 8
  E. 9
  F. Compilation fails
 15. Given:
 
 3. import java.util.*;
 4. public class Looking {
 5. public static void main(String[] args) {
 6. String input = "1 2 a 3 45 6";
 7. Scanner sc = new Scanner(input);
 8. int x = 0;
 9. do {
10. x = sc.nextInt();
11. System.out.print(x + " ");
12. } while (x!=0);
13. }
14. }
  What is the result? A. 1 2
  B. 1 2 3 45 6
  C. 1 2 3 4 5 6
  D. 1 2 a 3 45 6
  E. Compilation fails
  F. 1 2 followed by an exception
Self T est 525
SELF TEST ANSWERS
 1. Given:
import java.util.regex.*;
class Regex2 {
  public static void main(String[] args) {
    Pattern p = Pattern.compile(args[0]);
    Matcher m = p.matcher(args[1]);
    boolean b = false;
    while(b = m.find()) {
      System.out.print(m.start() + m.group());
    }  
  }
}
  And the command line:
java Regex2 "\d*" ab34ef
  What is the result? A.

--- Chunk #1463 ---
234
  B. 334
  C. 2334
  D. 0123456
  E. 01234456
  F. 12334567
  G. Compilation fails
Answer:
   ✓   E is correct. The \d is looking for digits. The * is a quantifier that looks for 0 to many 
occurrences of the pattern that precedes it. Because we specified *, the group() method 
returns empty Strings until consecutive digits are found, so the only time group() returns 
a value is when it returns 34 when the matcher finds digits starting in position 2. The 
start() method returns the starting position of the previous match because, again, 
we said find 0 to many occurrences.     A, B, C, D, F, and G are incorrect based on the above.

--- Chunk #1464 ---
(Objective 3.5)
526 Chapter 6:  Strings, I/O, Formatting, and Parsing
Self T est Answers 527
 2. Given:
import java.io.*;
class Player { 
  Player() { System.out.print("p"); }
}
class CardPlayer extends Player implements Serializable {
  CardPlayer() { System.out.print("c"); }
  public static void main(String[] args) {
    CardPlayer c1 = new CardPlayer();
    try {
      FileOutputStream fos = new FileOutputStream("play.txt");
      ObjectOutputStream os = new ObjectOutputStream(fos);
      os.writeObject(c1);
      os.close();
      FileInputStream fis = new FileInputStream("play.txt");
      ObjectInputStream is = new ObjectInputStream(fis);
      CardPlayer c2 = (CardPlayer) is.readObject();
      is.close();
    } catch (Exception x ) { }
  }
}
  What is the result? A.

--- Chunk #1465 ---
pc
  B. pcc
  C. pcp
  D. pcpc
  E. Compilation fails
  F. An exception is thrown at runtime
Answer:
   ✓   C is correct. It's okay for a class to implement Serializable even if its superclass doesn't. However, when you deserialize such an object, the non-serializable superclass must run its 
constructor. Remember, constructors don't run on deserialized classes that implement 
Serializable.     A, B, D, E, and F are incorrect based on the above.

--- Chunk #1466 ---
(Objective 3.3)
528 Chapter 6:  Strings, I/O, Formatting, and Parsing 
 3. Given:
class TKO {
  public static void main(String[] args) {
    String s = "-";
    Integer x = 343;
    long L343 = 343L;
    if(x.equals(L343))  s += ".e1 ";
    if(x.equals(343))  s += ".e2 "; 
    Short s1 = (short)((new Short((short)343)) / (new Short((short)49)));
    if(s1 == 7)        s += "=s "; 
    if(s1 < new Integer(7+1))  s += "fly ";
    System.out.println(s);
} }
  Which of the following will be included in the output String s? (Choose all that apply.)
  A.

--- Chunk #1467 ---
.e1
  B. .e2
  C. =s
  D. fly
  E. None of the above
  F. Compilation fails
  G. An exception is thrown at runtime
Answer:
   ✓   B, C, and D are correct. Remember, that the equals() method for the integer wrappers 
will only return true if the two primitive types and the two values are equal. With C, it's 
okay to unbox and use ==. For D, it's okay to create a wrapper object with an expression, 
and unbox it for comparison with a primitive.     A, E, F, and G are incorrect based on the above.

--- Chunk #1468 ---
(Remember that A is using the equals() 
method to try to compare two different types.)  (Objective 3.1)
 4. Given:
import java.io.*;
class Keyboard { }
public class Computer implements Serializable {
  private Keyboard k = new Keyboard();
  public static void main(String[] args) {
    Computer c = new Computer();
    c.storeIt(c);
  }
  void storeIt(Computer c) {
    try { 
      ObjectOutputStream os = new ObjectOutputStream(
         new FileOutputStream("myFile"));
      os.writeObject(c);
      os.close();
      System.out.println("done");
    } catch (Exception x) {System.out.println("exc"); }
  }
}
  What is the result? (Choose all that apply.)
  A.

--- Chunk #1469 ---
exc
  B. done
  C. Compilation fails
  D. Exactly one object is serialized
  E. Exactly two objects are serialized
Answer:
   ✓   A is correct. An instance of type Computer Has-a Keyboard. Because Keyboard doesn't 
implement Serializable, any attempt to serialize an instance of Computer will cause an 
exception to be thrown.     B, C, D, and E are incorrect based on the above. If Keyboard did implement Serializable 
then two objects would have been serialized. (Objective 3.3)
 5. Using the fewest fragments possible (and filling the fewest slots possible), complete the code 
below so that the class builds a directory named "dir3" and creates a file named "file3" inside 
"dir3". Note you can use each fragment either zero or one times. Self T est Answers 529
530 Chapter 6:  Strings, I/O, Formatting, and Parsing 
  Code:
import java.io.______________
class Maker {
  public static void main(String[] args) {
    ___________  ___________  ___________
    ___________  ___________  ___________
    ___________  ___________  ___________
    ___________  ___________  ___________
    ___________  ___________  ___________
    ___________  ___________  ___________
    ___________  ___________  ___________
} } 
  Fragments:
   File;     FileDescriptor;     FileWriter;    Directory;
   try {     .createNewDir();    File dir       File
   { }       (Exception x)       ("dir3");      file
   file      .createNewFile();   = new File     = new File
   dir       (dir, "file3");     (dir, file);   .createFile();
   } catch   ("dir3", "file3");  .mkdir();      File file
   
Answer:
import java.io.File;
class Maker {
  public static void main(String[] args) {
    try {
      File dir = new File("dir3");
      dir.mkdir();
      File file = new File(dir, "file3");
      file.createNewFile();
    } catch (Exception x) { }
} }
  Notes: The new File statements don't make actual files or directories, just objects. You 
need the mkdir() and createNewFile() methods to actually create the directory and 
the file.

--- Chunk #1470 ---
(Objective 3.2)
 6. Given that 1119280000000L is roughly the number of milliseconds from Jan. 1, 1970, to June 
20, 2005, and that you want to print that date in German, using the LONG style such that "June" 
will be displayed as "Juni", complete the code using the fragments below. Note: you can use 
each fragment either zero or one times, and you might not need to fill all of the slots. Code:
import java.___________
import java.___________
class DateTwo {
  public static void main(String[] args) {
    Date d = new Date(1119280000000L);
    DateFormat df = ___________________________
                    ________________ , _________________ );
  
    System.out.println(________________ 
  }
}
  Fragments:
  io.*;     new DateFormat(                 Locale.LONG
  nio.*;    DateFormat.getInstance(         Locale.GERMANY
  util.*;   DateFormat.getDateInstance(     DateFormat.LONG
  text.*;   util.regex;                     DateFormat.GERMANY
  date.*;   df.format(d));                  d.format(df));
Answer:
import java.util.*;
import java.text.*;
class DateTwo {
  public static void main(String[] args) {
    Date d = new Date(1119280000000L);
    DateFormat df = DateFormat.getDateInstance(
                    DateFormat.LONG, Locale.GERMANY);
    System.out.println(df.format(d));
  }
}
Self T est Answers 531
532 Chapter 6:  Strings, I/O, Formatting, and Parsing 
       Notes: Remember that you must build DateFormat objects using static methods. Also 
remember that you must specify a Locale for a DateFormat object at the time of instantiation.

--- Chunk #1471 ---
The getInstance() method does not take a Locale.

--- Chunk #1472 ---
(Objective 3.4)
 7. Given:
import java.io.*;
class Directories {
  static String [] dirs = {"dir1", "dir2"};
  public static void main(String [] args) {
    for (String d : dirs) {
      // insert code 1 here
      File file = new File(path, args[0]);
      // insert code 2 here
    }
  }
}
  and that the invocation
java Directories file2.txt
  is issued from a directory that has two subdirectories, " dir1" and "dir2", and that "dir1" has a file 
"file1.txt" and "dir2" has a file "file2.txt", and the output is "false true", which set(s) 
of code fragments must be inserted? (Choose all that apply.)
  A. String path = d;
System.out.print(file.exists() + " ");
  B. String path = d;
System.out.print(file.isFile() + " ");
  C. String path = File.separator + d;
System.out.print(file.exists() + " ");
  D. String path = File.separator + d;
System.out.print(file.isFile() + " ");
Answer:
   ✓   A and B are correct. Because you are invoking the program from the directory whose 
direct subdirectories are to be searched, you don't start your path with a File.separator 
character. The exists() method tests for either files or directories; the isFile() 
method tests only for files. Since we're looking for a file, both methods work.     C and D are incorrect based on the above.

--- Chunk #1473 ---
(Objective 3.2)
 8. Given:
 
import java.io.*;
public class TestSer {
  public static void main(String[] args) {
    SpecialSerial s = new SpecialSerial();
    try { 
      ObjectOutputStream os = new ObjectOutputStream(
         new FileOutputStream("myFile"));
      os.writeObject(s);  os.close();
      System.out.print(++s.z + " ");
      
      ObjectInputStream is = new ObjectInputStream(
         new FileInputStream("myFile"));
      SpecialSerial s2 = (SpecialSerial)is.readObject();
      is.close();
      System.out.println(s2.y + " " + s2.z);
    } catch (Exception x) {System.out.println("exc"); }
  }
}
class SpecialSerial implements Serializable {
  transient int y = 7;
  static int z = 9;
}
Self T est Answers 533
534 Chapter 6:  Strings, I/O, Formatting, and Parsing 
  Which are true? (Choose all that apply.)
  A.

--- Chunk #1474 ---
Compilation fails
  B. The output is 10 0 9
  C. The output is 10 0 10
  D. The output is 10 7 9
  E. The output is 10 7 10
  F. In order to alter the standard deserialization process you would implement the 
readObject() method in SpecialSerial
  G. In order to alter the standard deserialization process you would implement the 
defaultReadObject() method in SpecialSerial
Answer:
   ✓   C and F are correct. C is correct because static and transient variables are not 
serialized when an object is serialized. F is a valid statement.     A, B, D, and E are incorrect based on the above. G is incorrect because you 
don't implement the defaultReadObject() method, you call it from within the 
readObject()method, along with any custom read operations your class needs. (Objective 3.3)
 9.

--- Chunk #1475 ---
Given:
 
 3. public class Theory {
 4. public static void main(String[] args) {
 5. String s1 = "abc";
 6. String s2 = s1;
 7. s1 += "d";
 8. System.out.println(s1 + " " + s2 + " " + (s1==s2));
 9. 10. StringBuffer sb1 = new StringBuffer("abc");
11. StringBuffer sb2 = sb1;
12. sb1.append("d");
13. System.out.println(sb1 + " " + sb2 + " " + (sb1==sb2));
14. }
15.

--- Chunk #1476 ---
}
  535Self T est Answers 535
  Which are true? (Choose all that apply.)
  A. Compilation fails
  B. The first line of output is abc abc true
  C. The first line of output is abc abc false
  D. The first line of output is abcd abc false
  E. The second line of output is abcd abc false
  F. The second line of output is abcd abcd true
  G. The second line of output is abcd abcd false
Answer:
   ✓   D and F are correct. While String objects are immutable, references to Strings are mutable. The code s1 += "d"; creates a new String object. StringBuffer objects are mutable, so the 
append() is changing the single StringBuffer object to which both StringBuffer references 
refer.     A, B, C, E, and G are incorrect based on the above. (Objective 3.1)
 10.

--- Chunk #1477 ---
Given:
 
 3. import java.io.*;
 4. public class ReadingFor {
 5. public static void main(String[] args) {
 6. String s;
 7. try {
 8. FileReader fr = new FileReader("myfile.txt");
 9. BufferedReader br = new BufferedReader(fr);
10. while((s = br.readLine()) != null)
11. System.out.println(s);
12. br.flush();
13. } catch (IOException e) { System.out.println("io error"); }
16. }
17. }
  And given that myfile.txt contains the following two lines of data:
ab
cd
536 Chapter 6:  Strings, I/O, Formatting, and Parsing 
  What is the result? A.

--- Chunk #1478 ---
ab
  B. abcd
  C. ab
     cd
  D. a
     b
     c
     d
  E. Compilation fails
Answer:
   ✓   E is correct. You need to call flush() only when you're writing data. Readers don't have 
flush() methods. If not for the call to flush(), answer C would be correct.     A, B, C, and D are incorrect based on the above. (Objective 3.2)
 11. Given:
 
 3. import java.io.*;
 4. public class Talker {
 5. public static void main(String[] args) {
 6. Console c = System.console();
 7. String u = c.readLine("%s", "username: ");
 8. System.out.println("hello " + u);
 9. String pw;
10. if(c != null && (pw = c.readPassword("%s", "password: ")) != null) 
11. // check for valid password
12. }
13. }
  If line 6 creates a valid Console object, and if the user enters fred as a username and 1234 as a 
password, what is the result? (Choose all that apply.)
  A. username:
   password:
  B. username: fred
   password:
  537Self T est Answers 537
  C. username: fred
   password: 1234
  D. Compilation fails
  E. An exception is thrown at runtime
Answer:
   ✓   D is correct. The readPassword() method returns a char[]. If a char[] were used, 
answer B would be correct.     A, B, C, and E are incorrect based on the above. (Objective 3.2)
 12. Given:
 
 3. import java.io.*;
 4. class Vehicle { }
 5. class Wheels { }
 6. class Car extends Vehicle implements Serializable {  }
 7. class Ford extends Car { }
 8. class Dodge extends Car {
 9. Wheels w = new Wheels();
10. }
  Instances of which class(es) can be serialized? (Choose all that apply.)
  A.

--- Chunk #1479 ---
Car
  B. Ford
  C. Dodge
  D. Wheels
  E. Vehicle
Answer:
   ✓   A and B are correct. Dodge instances cannot be serialized because they "have" an instance 
of Wheels, which is not serializable. Vehicle instances cannot be serialized even though the 
subclass Car can be.     C, D, and E are incorrect based on the above. (Objective 3.3)
538 Chapter 6:  Strings, I/O, Formatting, and Parsing 
 13. Given:
 
 3. import java.text.*;
 4. public class Slice {
 5. public static void main(String[] args) {
 6. String s = "987.123456";
 7. double d  = 987.123456d;
 8. NumberFormat nf = NumberFormat.getInstance();
 9. nf.setMaximumFractionDigits(5);
10. System.out.println(nf.format(d) + " ");
11. try {
12. System.out.println(nf.parse(s));   
13. } catch (Exception e) { System.out.println("got exc"); }
14. }
15.

--- Chunk #1480 ---
}
  Which are true? (Choose all that apply.)
  A. The output is 987.12345 987.12345
  B. The output is 987.12346 987.12345
  C. The output is 987.12345 987.123456
  D. The output is 987.12346 987.123456
  E. The try/catch block is unnecessary
  F. The code compiles and runs without exception
  G. The invocation of parse() must be placed within a try/catch block
Answer:
   ✓   D, F, and G are correct. The setMaximumFractionDigits() applies to the formatting 
but not the parsing. The try/catch block is placed appropriately. This one might scare you 
into thinking that you'll need to memorize more than you really do. If you can remember 
that you're formatting the number and parsing the string you should be fine for the exam.     A, B, C, and E are incorrect based on the above. (Objective 3.4)
 14.

--- Chunk #1481 ---
Given:
 
 3. import java.util.regex.*;
 4. public class Archie {
 5. public static void main(String[] args) {
 6. Pattern p = Pattern.compile(args[0]);
  539Self T est Answers 539
 7. Matcher m = p.matcher(args[1]);
 8. int count = 0;
 9. while(m.find())
10. count++;
11. System.out.print(count);
12. }
13. }
  And given the command line invocation:
java Archie "\d+" ab2c4d67
  What is the result? A.

--- Chunk #1482 ---
0
  B. 3
  C. 4
  D. 8
  E. 9
  F. Compilation fails
Answer:
   ✓   B is correct. The "\d" metacharacter looks for digits, and the + quantifier says look for 
"one or more" occurrences. The find() method will find three sets of one or more con-
secutive digits: 2, 4, and 67.     A, C, D, E, and F are incorrect based on the above. (Objective 3.5)
 15. Given:
 
 3. import java.util.*;
 4. public class Looking {
 5. public static void main(String[] args) {
 6. String input = "1 2 a 3 45 6";
 7. Scanner sc = new Scanner(input);
 8. int x = 0;
 9. do {
10. x = sc.nextInt();
11. System.out.print(x + " ");
12. } while (x!=0);
13. }
14. }
540 Chapter 6:  Strings, I/O, Formatting, and Parsing 
  What is the result? A.

--- Chunk #1483 ---
1 2
  B. 1 2 3 45 6
  C. 1 2 3 4 5 6
  D. 1 2 a 3 45 6
  E. Compilation fails
  F. 1 2 followed by an exception
Answer:
   ✓   F is correct. The nextXxx() methods are typically invoked after a call to a hasNextXxx(), 
which determines whether the next token is of the correct type.     A, B, C, D, and E are incorrect based on the above. (Objective 3.5)
7
Generics and 
Collections
CERTIFICATION OBJECTIVES
Design Using Collections
    Override equals() and hashCode(), 
       Distinguish == and equals()
    Use Generic Versions of Collections
       Including Set, List, and Map

 Use Type Parameters, 
        Write Generics methods
 Use java.util to Sort and Search 
        Use Comparable and Comparator
 ✓   T wo-Minute Drill
          Q&A Self T est
 
	
542 Chapter 7:  Generics and Collections
G
enerics are possibly the most talked about feature of Java 5. Some people love 'em, 
some people hate 'em, but they're here to stay.

--- Chunk #1484 ---
At their simplest, they can help make 
code easier to write, and more robust. At their most complex, they can be very, 
very hard to create, and maintain. Luckily, the exam creators stuck to the simple end of generics, 
covering the most common and useful features, and leaving out most of the especially tricky bits. Coverage of collections in this exam has expanded in two ways from the previous exam: the use of 
generics in collections, and the ability to sort and search through collections. CERTIFICATION OBJECTIVE
Overriding hashCode() and equals() (Objective 6.2)
6.2 Distinguish between correct and incorrect overrides of corresponding hashCode and 
equals methods, and explain the difference between == and the equals method. You're an object.

--- Chunk #1485 ---
Get used to it. You have state, you have behavior, you have a job. (Or at least your chances of getting one will go up after passing the exam.) If you 
exclude primitives, everything in Java is an object. Not just an object, but an Object 
with a capital O. Every exception, every event, every array extends from 
java.lang.Object. For the exam, you don't need to know every method in Object, but 
you will need to know about the methods listed in Table 7-1. Chapter 9 covers wait(), notify(), and notifyAll(). The finalize() 
method was covered in Chapter 3. So in this section we'll look at just the 
hashCode() and equals() methods. Oh, that leaves out toString(), doesn't it. Okay, we'll cover that right now because it takes two seconds. The toString() Method Override toString() when you want a mere mor-
tal to be able to read something meaningful about the objects of your class. Code can 
call toString() on your object when it wants to read useful details about your ob-
ject. When you pass an object reference to the System.out.println() method, for 
example, the object's toString() method is called, and the return of toString() 
is shown in the following example:
Overriding hashCode() and equals() (Exam Objective 6.2) 543
public class HardToRead {
   public static void main (String [] args) {
     HardToRead h = new HardToRead();
     System.out.println(h);
   }
}
Running the HardToRead class gives us the lovely and meaningful,
% java HardToRead
HardToRead@a47e0
The preceding output is what you get when you don't override the toString() 
method of class Object. It gives you the class name (at least that's meaningful) 
followed by the @ symbol, followed by the unsigned hexadecimal representation of 
the object's hashcode. Trying to read this output might motivate you to override the toString() 
method in your classes, for example,
public class BobTest {
   public static void main (String[] args) {
     Bob f = new Bob("GoBobGo", 19);
 
Method Description
boolean equals (Object obj) Decides whether two objects are meaningfully equivalent. void finalize() Called by garbage collector when the garbage collector sees that 
the object cannot be referenced. int hashCode() Returns a hashcode int value for an object, so that the object can 
be used in Collection classes that use hashing, including Hashtable, 
HashMap, and HashSet. final void notify() Wakes up a thread that is waiting for this object’s lock. final void notifyAll() Wakes up all threads that are waiting for this object’s lock. final void wait() Causes the current thread to wait until another thread calls 
notify() or notifyAll() on this object. String toString() Returns a “text representation” of the object. TABLE 7-1    Methods of Class Object Covered on the Exam
     System.out.println(f);
   }
}
class Bob {
   int shoeSize;
   String nickName;
   Bob(String nickName, int shoeSize) {
     this.shoeSize = shoeSize;
     this.nickName = nickName;
   }
   public String toString() {
      return ("I am a Bob, but you can call me " + nickName +
              ". My shoe size is " + shoeSize);
   }
}
This ought to be a bit more readable:
% java BobTest
I am a Bob, but you can call me GoBobGo. My shoe size is 19
Some people affectionately refer to toString() as the "spill-your-guts method," 
because the most common implementations of toString() simply spit out 
the object's state (in other words, the current values of the important instance 
variables). That's it for toString(). Now we'll tackle equals() and hashCode(). Overriding equals()
You learned about the equals() method in earlier chapters, where we looked at 
the wrapper classes. We discussed how comparing two object references using the 
== operator evaluates to true only when both references refer to the same object 
(because == simply looks at the bits in the variable, and they're either identical or 
they're not). You saw that the String class and the wrapper classes have overridden 
the equals() method (inherited from class Object), so that you could compare 
two different objects (of the same type) to see if their contents are meaningfully 
equivalent. If two different Integer instances both hold the int value 5, as far as 
you're concerned they are equal. The fact that the value 5 lives in two separate 
objects doesn't matter. When you really need to know if two references are identical, use ==. But when 
you need to know if the objects themselves (not the references) are equal, use the 
equals() method. For each class you write, you must decide if it makes sense to 
544 Chapter 7:  Generics and Collections
consider two different instances equal. For some classes, you might decide that 
two objects can never be equal. For example, imagine a class Car that has instance 
variables for things like make, model, year, configuration—you certainly don't want 
your car suddenly to be treated as the very same car as someone with a car that has 
identical attributes. Your car is your car and you don't want your neighbor Billy 
driving off in it just because, "hey, it's really the same car; the equals() method said 
so." So no two cars should ever be considered exactly equal. If two references refer to 
one car, then you know that both are talking about one car, not two cars that have 
the same attributes. So in the case of a Car you might not ever need, or want, to 
override the equals() method. Of course, you know that isn't the end of the story. What It Means If  Y ou Don't Override equals()
There's a potential limitation lurking here: if you don't override a class's equals() 
method, you won't be able to use those objects as a key in a hashtable and you 
probably won't get accurate Sets, such that there are no conceptual duplicates. The equals() method in class Object uses only the == operator for comparisons, 
so unless you override equals(), two objects are considered equal only if the two 
references refer to the same object. Let's look at what it means to not be able to use an object as a hashtable key. Imagine you have a car, a very specific car (say, John's red Subaru Outback as 
opposed to Mary's purple Mini) that you want to put in a HashMap (a type of 
hashtable we'll look at later in this chapter), so that you can search on a particular 
car and retrieve the corresponding Person object that represents the owner. So you 
add the car instance as the key to the HashMap (along with a corresponding Person 
object as the value). But now what happens when you want to do a search? You want 
to say to the HashMap collection, "Here's the car, now give me the Person object 
that goes with this car." But now you're in trouble unless you still have a reference 
to the exact object you used as the key when you added it to the Collection. In other 
words, you can't make an identical Car object and use it for the search. The bottom line is this: if you want objects of your class to be used as keys for a 
hashtable (or as elements in any data structure that uses equivalency for searching 
for—and/or retrieving—an object), then you must override equals() so that two 
different instances can be considered the same. So how would we fix the car? You 
might override the equals() method so that it compares the unique VIN (Vehicle 
Identification Number) as the basis of comparison. That way, you can use one 
instance when you add it to a Collection, and essentially re-create an identical 
instance when you want to do a search based on that object as the key. Of course, 
overriding the equals() method for Car also allows the potential that more than 
one object representing a single unique car can exist, which might not be safe 
Overriding equals() (Exam Objective 6.2) 545
in your design. Fortunately, the String and wrapper classes work well as keys in 
hashtables—they override the equals() method. So rather than using the actual 
car instance as the key into the car/owner pair, you could simply use a String that 
represents the unique identifier for the car. That way, you'll never have more than 
one instance representing a specific car, but you can still use the car—or rather, one 
of the car's attributes—as the search key. Implementing an equals() Method
Let's say you decide to override equals() in your class. It might look like this:
public class EqualsTest {
  public static void main (String [] args) {
     Moof one = new Moof(8);
     Moof two = new Moof(8);
     if (one.equals(two)) {
        System.out.println("one and two are equal");
     }
  }
}
class Moof {
  private int moofValue;
  Moof(int val) {
     moofValue = val;
  }
  public int getMoofValue() {
     return moofValue;
  }
  public boolean equals(Object o) {
    if ((o instanceof Moof) && (((Moof)o).getMoofValue() 
         == this.moofValue)) {
      return true;
    } else {
       return false;
    }
  }
}
Let's look at this code in detail. In the main() method of EqualsTest, we create 
two Moof instances, passing the same value 8 to the Moof constructor. Now look at 
the Moof class and let's see what it does with that constructor argument—it assigns 
the value to the moofValue instance variable. Now imagine that you've decided 
two Moof objects are the same if their moofValue is identical. So you override the 
546 Chapter 7:  Generics and Collections
equals() method and compare the two moofValues. It is that simple. But let's 
break down what's happening in the equals() method:
1. public boolean equals(Object o) {
2. if ((o instanceof Moof) && (((Moof)o).getMoofValue()
           == this.moofValue)) {
3. return true;
4. } else {
5. return false;
6. }
7. }
First of all, you must observe all the rules of overriding, and in line 1 we are 
indeed declaring a valid override of the equals() method we inherited from Object. Line 2 is where all the action is. Logically, we have to do two things in order to 
make a valid equality comparison. First, be sure that the object being tested is of the correct type! It comes in 
polymorphically as type Object, so you need to do an instanceof test on it. Having 
two objects of different class types be considered equal is usually not a good idea, 
but that's a design issue we won't go into here. Besides, you'd still have to do the 
instanceof test just to be sure that you could cast the object argument to the 
correct type so that you can access its methods or variables in order to actually do 
the comparison. Remember, if the object doesn't pass the instanceof test, then 
you'll get a runtime ClassCastException. For example:
public boolean equals(Object o) {
   if (((Moof)o).getMoofValue() == this.moofValue){ 
      // the preceding line compiles, but it's BAD! return true;
   } else {
      return false;
   }
}
The (Moof)o cast will fail if o doesn't refer to something that IS-A Moof. Second, compare the attributes we care about (in this case, just moofValue). Only the developer can decide what makes two instances equal. (For best 
performance, you're going to want to check the fewest number of attributes.)
In case you were a little surprised by the whole ((Moof)o).getMoofValue() 
syntax, we're simply casting the object reference, o, just-in-time as we try to call a 
method that's in the Moof class but not in Object. Remember, without the cast, you 
Overriding equals() (Exam Objective 6.2) 547
can't compile because the compiler would see the object referenced by o as simply, 
well, an Object. And since the Object class doesn't have a getMoofValue() method, 
the compiler would squawk (technical term). But then as we said earlier, even with 
the cast, the code fails at runtime if the object referenced by o isn't something that's 
castable to a Moof. So don't ever forget to use the instanceof test first. Here's 
another reason to appreciate the short circuit && operator—if the instanceof test 
fails, we'll never get to the code that does the cast, so we're always safe at runtime 
with the following:
  if ((o instanceof Moof) && (((Moof)o).getMoofValue()
        == this.moofValue)) {
      return true;
  } else {
      return false;
  }
So that takes care of equals()…
Whoa…not so fast. If you look at the Object class in the Java API spec, you'll 
find what we call a contract specified in the equals() method. A Java contract is a 
set of rules that should be followed, or rather must be followed if you want to provide 
a "correct" implementation as others will expect it to be. Or to put it another way, if 
you don't follow the contract, your code may still compile and run, but your code (or 
someone else's) may break at runtime in some unexpected way. 548 Chapter 7:  Generics and Collections
Remember that the equals(), hashCode(), and toString() methods are 
all public. The following would not be a valid override of the equals() method, although 
it might appear to be if you don’t look closely enough during the exam:
class Foo { boolean equals(Object o) { } }
And watch out for the argument types as well. The following method is an 
overload, but not an override of the equals() method:
class Boo { public boolean equals(Boo b) { } }
The equals() Contract
Pulled straight from the Java docs, the equals() contract says
■ It is reflexive. For any reference value x, x.equals(x) should return true. ■ It is symmetric. For any reference values x and y, x.equals(y) should 
return true if and only if y.equals(x) returns true. ■ It is transitive. For any reference values x, y, and z, if x.equals(y) returns 
true and y.equals(z) returns true, then x.equals(z) must return true. ■ It is consistent. For any reference values x and y, multiple invocations of 
x.equals(y) consistently return true or consistently return false, pro-
vided no information used in equals comparisons on the object is modified. ■ For any non- null reference value x, x.equals(null) should return false. And you're so not off the hook yet. We haven't looked at the hashCode() 
method, but equals() and hashCode() are bound together by a joint contract that 
specifies if two objects are considered equal using the equals() method, then they 
must have identical hashcode values. So to be truly safe, your rule of thumb should 
be, if you override equals(), override hashCode() as well. So let's switch over to 
hashCode() and see how that method ties in to equals(). Overriding hashCode()
Hashcodes are typically used to increase the performance of large collections of 
data. The hashcode value of an object is used by some collection classes (we'll look 
Overriding hashCode() (Exam Objective 6.2) 549
Be sure you’re very comfortable with the rules of overriding so that you 
can identify whether a method from Object is being overridden, overloaded, or illegally 
redeclared in a class. The equals() method in class Boo changes the argument from 
Object to Boo, so it becomes an overloaded method and won’t be called unless it’s from 
your own code that knows about this new, different method that happens to also be 
named equals(). at the collections later in this chapter). Although you can think of it as kind of an 
object ID number, it isn't necessarily unique. Collections such as HashMap and 
HashSet use the hashcode value of an object to determine how the object should 
be stored in the collection, and the hashcode is used again to help locate the object 
in the collection. For the exam you do not need to understand the deep details of 
how the collection classes that use hashing are implemented, but you do need to 
know which collections use them (but, um, they all have "hash" in the name so 
you should be good there). You must also be able to recognize an appropriate or 
correct implementation of hashCode(). This does not mean legal and does not even 
mean efficient. It's perfectly legal to have a terribly inefficient hashcode method 
in your class, as long as it doesn't violate the contract specified in the Object class 
documentation (we'll look at that contract in a moment). So for the exam, if you're 
asked to pick out an appropriate or correct use of hashcode, don't mistake appropriate 
for legal or efficient. Understanding Hashcodes
In order to understand what's appropriate and correct, we have to look at how some 
of the collections use hashcodes. Imagine a set of buckets lined up on the floor. Someone hands you a piece of 
paper with a name on it. You take the name and calculate an integer code from it by 
using A is 1, B is 2, and so on, and adding the numeric values of all the letters in the 
name together. A given name will always result in the same code; see Figure 7-1. We don't introduce anything random, we simply have an algorithm that will 
always run the same way given a specific input, so the output will always be identical 
for any two identical inputs. So far so good? Now the way you use that code (and 
we'll call it a hashcode now) is to determine which bucket to place the piece of 
550 Chapter 7:  Generics and Collections
 FIGURE 7-1 
A simplified 
hashcode 
example
Key Hashcode Algorithm Hashcode
Dirk
Fred
HashMap Collection
Hashcode Buckets 19
“Bob” “Fred” “Alex”
“Dirk”
33 42
Bob
Alex A(1) + L(12) + E(5) + X(24)
B(2) + O(15) + B(2) = 19
D(4) + I(9) + R(18) + K(11) = 42
F(6) + R(18) + E(5) + D(4) = 33
= 42
paper into (imagine that each bucket represents a different code number you might 
get). Now imagine that someone comes up and shows you a name and says, "Please 
retrieve the piece of paper that matches this name." So you look at the name they 
show you, and run the same hashcode-generating algorithm. The hashcode tells you 
in which bucket you should look to find the name. You might have noticed a little flaw in our system, though. T wo different names 
might result in the same value. For example, the names Amy and May have the same 
letters, so the hashcode will be identical for both names. That's acceptable, but 
it does mean that when someone asks you (the bucket-clerk) for the Amy piece of 
paper, you'll still have to search through the target bucket reading each name until 
we find Amy rather than May. The hashcode tells you only which bucket to go into, 
but not how to locate the name once we're in that bucket. So for efficiency, your goal is to have the papers distributed as evenly as possible 
across all buckets. Ideally, you might have just one name per bucket so that when 
someone asked for a paper you could simply calculate the hashcode and just grab the 
one paper from the correct bucket (without having to go flipping through different 
papers in that bucket until you locate the exact one you're looking for). The least 
efficient (but still functional) hashcode generator would return the same hashcode 
(say, 42) regardless of the name, so that all the papers landed in the same bucket 
while the others stood empty. The bucket-clerk would have to keep going to that 
one bucket and flipping painfully through each one of the names in the bucket until 
the right one was found. And if that's how it works, they might as well not use the 
hashcodes at all but just go to the one big bucket and start from one end and look 
through each paper until they find the one they want. This distributed-across-the-buckets example is similar to the way hashcodes are 
used in collections. When you put an object in a collection that uses hashcodes, the 
collection uses the hashcode of the object to decide in which bucket/slot the object 
Overriding hashCode() (Exam Objective 6.2) 551
In real-life hashing, it’s not uncommon to have more than one entry in a 
bucket. Hashing retrieval is a two-step process. 1. Find the right bucket (using hashCode())
 2. Search the bucket for the right element (using equals() ). should land. Then when you want to fetch that object (or, for a hashtable, retrieve 
the associated value for that object), you have to give the collection a reference to 
an object that the collection compares to the objects it holds in the collection. As 
long as the object (stored in the collection, like a paper in the bucket) you're trying 
to search for has the same hashcode as the object you're using for the search (the 
name you show to the person working the buckets), then the object will be found. But…and this is a Big One, imagine what would happen if, going back to our name 
example, you showed the bucket-worker a name and they calculated the code based 
on only half the letters in the name instead of all of them. They'd never find the 
name in the bucket because they wouldn't be looking in the correct bucket! Now can you see why if two objects are considered equal, their hashcodes must 
also be equal? Otherwise, you'd never be able to find the object since the default 
hashcode method in class Object virtually always comes up with a unique number 
for each object, even if the equals() method is overridden in such a way that two 
or more objects are considered equal. It doesn't matter how equal the objects are if 
their hashcodes don't reflect that. So one more time: If two objects are equal, their 
hashcodes must be equal as well. Implementing hashCode()
What the heck does a real hashcode algorithm look like? People get their PhDs on 
hashing algorithms, so from a computer science viewpoint, it's beyond the scope 
of the exam. The part we care about here is the issue of whether you follow the 
contract. And to follow the contract, think about what you do in the equals() 
method. You compare attributes. Because that comparison almost always involves 
instance variable values (remember when we looked at two Moof objects and 
considered them equal if their int moofValues were the same?). Your hashCode() 
implementation should use the same instance variables. Here's an example:
class HasHash {
  public int x;
  HasHash(int xVal) { x = xVal; }
  public boolean equals(Object o) {
    HasHash h = (HasHash) o; // Don't try at home without 
                             // instanceof test
    if (h.x == this.x) {
      return true;
    } else {
      return false;
    }
552 Chapter 7:  Generics and Collections
  }
  public int hashCode() { return (x * 17); }
}
This equals() method says two objects are equal if they have the same x value, 
so objects with the same x value will have to return identical hashcodes. Typically, you'll see hashCode() methods that do some combination of ^-ing 
(XOR-ing) a class's instance variables (in other words, twiddling their bits), along 
with perhaps multiplying them by a prime number. In any case, while the goal 
is to get a wide and random distribution of objects across buckets, the contract 
(and whether or not an object can be found) requires only that two equal objects 
have equal hashcodes. The exam does not expect you to rate the efficiency of a 
hashCode() method, but you must be able to recognize which ones will and will not 
work (work meaning "will cause the object to be found in the collection"). Now that we know that two equal objects must have identical hashcodes, is the 
reverse true? Do two objects with identical hashcodes have to be considered equal? Think about it—you might have lots of objects land in the same bucket because 
their hashcodes are identical, but unless they also pass the equals() test, they won't 
come up as a match in a search through the collection. This is exactly what you'd 
Overriding hashCode() (Exam Objective 6.2) 553
A hashCode() that returns the same value for all instances whether 
they’re equal or not is still a legal—even appropriate—hashCode() method! For example,
public int hashCode() { return 1492; }
This does not violate the contract. Two objects with an x value of 8 will 
have the same hashcode. But then again, so will two unequal objects, one with an x 
value of 12 and the other a value of -920. This hashCode() method is horribly inefﬁ cient, 
remember, because it makes all objects land in the same bucket, but even so, the object 
can still be found as the collection cranks through the one and only bucket—using 
equals()—trying desperately to ﬁ  nally, painstakingly, locate the correct object. In other 
words, the hashcode was really no help at all in speeding up the search, even though 
improving search speed is hashcode’s intended purpose! Nonetheless, this one-hash-ﬁ ts-
all method would be considered appropriate and even correct because it doesn’t violate 
the contract. Once more, correct does not necessarily mean good. get with our very inefficient everybody-gets-the-same-hashcode method. It's legal 
and correct, just slooooow. So in order for an object to be located, the search object and the object in 
the collection must have both identical hashcode values and return true for the 
equals() method. So there's just no way out of overriding both methods to be 
absolutely certain that your objects can be used in Collections that use hashing. The hashCode() Contract
Now coming to you straight from the fabulous Java API documentation for class 
Object, may we present (drum roll) the hashCode() contract:
■ Whenever it is invoked on the same object more than once during an execu-
tion of a Java application, the hashCode() method must consistently return 
the same integer, provided no information used in equals() comparisons 
on the object is modified. This integer need not remain consistent from one 
execution of an application to another execution of the same application. ■ If two objects are equal according to the equals(Object) method, then 
calling the hashCode() method on each of the two objects must produce the 
same integer result. ■ It is NOT required that if two objects are unequal according to the 
equals(java.lang.Object) method, then calling the hashCode() method 
on each of the two objects must produce distinct integer results. However, 
the programmer should be aware that producing distinct integer results for 
unequal objects may improve the performance of hashtables. And what this means to you is…  
554 Chapter 7:  Generics and Collections
 
Condition Required Not Required (But Allowed)
x.equals(y) == true x.hashCode() ==
y.hashCode()
 
x.hashCode() ==
y.hashCode() 
 x.equals(y) == true
x.equals(y) == false  No hashCode()
requirements
x.hashCode() !=
y.hashCode()
x.equals(y) == false
Overriding hashCode() (Exam Objective 6.2) 555
So let's look at what else might cause a hashCode() method to fail. What 
happens if you include a transient variable in your hashCode() method? While 
that's legal (compiler won't complain), under some circumstances an object you 
put in a collection won't be found. As you know, serialization saves an object so 
that it can be reanimated later by deserializing it back to full objectness. But danger 
Will Robinson—remember that transient variables are not saved when an object is 
serialized. A bad scenario might look like this:
class SaveMe implements Serializable{
  transient int x;
  int y;
   SaveMe(int xVal, int yVal) {
      x = xVal;
      y = yVal;
   }
  public int hashCode() {
     return (x ^ y);      // Legal, but not correct to 
                          // use a transient variable
  }
  public boolean equals(Object o) {
     SaveMe test = (SaveMe)o;
     if (test.y == y && test.x == x) { // Legal, not correct
       return true;
     } else {
       return false;
     }
  }
}
Here's what could happen using code like the preceding example:
1. Give an object some state (assign values to its instance variables).

--- Chunk #1486 ---
2. Put the object in a HashMap, using the object as a key. 3. Save the object to a file using serialization without altering any of its state. 4. Retrieve the object from the file through deserialization. 5. Use the deserialized (brought back to life on the heap) object to get the 
object out of the HashMap. Oops. The object in the collection and the supposedly same object brought 
back to life are no longer identical. The object's transient variable will come 
back with a default value rather than the value the variable had at the time it 
was saved (or put into the HashMap). So using the preceding SaveMe code, if 
the value of x is 9 when the instance is put in the HashMap, then since x is used 
in the calculation of the hashcode, when the value of x changes, the hashcode 
changes too. And when that same instance of SaveMe is brought back from 
deserialization, x == 0, regardless of the value of x at the time the object was 
serialized. So the new hashcode calculation will give a different hashcode, and 
the equals() method fails as well since x is used to determine object equality. Bottom line: transient variables can really mess with your equals() and 
hashCode() implementations. Keep variables non- transient or, if they must 
be marked transient, don't use them to determine hashcodes or equality. CERTIFICATION OBJECTIVE
Collections (Exam Objective 6.1)
6.1 Given a design scenario, determine which collection classes and/or interfaces should 
be used to properly implement that design, including the use of the Comparable interface. Can you imagine trying to write object-oriented applications without using data 
structures like hashtables or linked lists? What would you do when you needed 
to maintain a sorted list of, say, all the members in your Simpsons fan club? Obviously you can do it yourself; Amazon.com must have thousands of algorithm 
books you can buy. But with the kind of schedules programmers are under today, 
it's almost too painful to consider. The Collections Framework in Java, which took shape with the release of JDK 1.2 
and was expanded in 1.4 and again in Java 5, and yet again in Java 6, gives you lists, 
sets, maps, and queues to satisfy most of your coding needs. They've been tried, tested, 
and tweaked. Pick the best one for your job and you'll get—at the least—reasonable 
performance. And when you need something a little more custom, the Collections 
Framework in the java.util package is loaded with interfaces and utilities. So What Do Y ou Do with a Collection? There are a few basic operations you'll normally use with collections:
■ Add objects to the collection. ■ Remove objects from the collection. 556 Chapter 7:  Generics and Collections
So What Do Y ou Do with a Collection? (Exam Objective 6.1) 557
■ Find out if an object (or group of objects) is in the collection. ■ Retrieve an object from the collection (without removing it). ■  Iterate through the collection, looking at each element (object) one 
after another. Key Interfaces and Classes of the Collections Framework
For the exam you'll need to know which collection to choose based on a stated 
requirement. The collections API begins with a group of interfaces, but also gives 
you a truckload of concrete classes. The core interfaces you need to know for the 
exam (and life in general) are the following nine:
The core concrete implementation classes you need to know for the exam are the 
following 13 (there are others, but the exam doesn't specifically cover them):
Not all collections in the Collections Framework actually implement the 
Collection interface. In other words, not all collections pass the IS-A test for 
Collection. Specifically, none of the Map-related classes and interfaces extend 
from Collection. So while SortedMap, Hashtable, HashMap, TreeMap, and 
LinkedHashMap are all thought of as collections, none are actually extended 
from Collection-with-a-capital-C (see Figure 7-2). To make things a little more 
confusing, there are really three overloaded uses of the word "collection":
 
Collection Set SortedSet
List Map SortedMap
Queue NavigableSet NavigableMap
 
Maps Sets Lists Queues Utilities
HashMap HashSet ArrayList PriorityQueue Collections
Hashtable LinkedHashSet Vector Arrays
TreeMap TreeSet LinkedList
LinkedHashMap
■ collection (lowercase c), which represents any of the data structures in 
which objects are stored and iterated over. ■ Collection (capital C), which is actually the java.util.Collection interface 
from which Set, List, and Queue extend. (That's right, extend, not imple-
ment. There are no direct implementations of Collection.)
■ Collections (capital C and ends with s ) is the java.util.Collections class 
that holds a pile of static utility methods for use with collections. FIGURE 7-2    The interface and class hierarchy for collections
558 Chapter 7:  Generics and Collections
<<interface>>
Collection
<<interface>>
Set
<<interface>>
List
<<interface>>
Queue
<<interface>>
SortedSet
<<interface>>
NavigableSet
<<interface>>
NavigableMap
LinkedHashSet PriorityQueueLinkedListVectorArrayList
TreeSet
<<interface>>
Map
<<interface>>
SortedMap
LinkedHashMap
Hashtable
TreeMap
HashMapCollectionsArrays
Object
extends
implements
HashSet
Collections come in four basic flavors:
■ Lists Lists of things (classes that implement List). ■ Sets Unique things (classes that implement Set). ■ Maps Things with a unique ID (classes that implement Map). ■ Queues Things arranged by the order in which they are to be processed. Figure 7-3 illustrates the structure of a List, a Set, and a Map. So What Do Y ou Do with a Collection? (Exam Objective 6.1) 559
You can so easily mistake "Collections" for "Collection"—be careful. Keep in mind that Collections is a class, with static utility methods, while Collection 
is an interface with declarations of the methods common to most collections 
including add(), remove(), contains(), size(), and iterator(). FIGURE 7-3 
The structure of 
a List, a Set, and 
a Map
Index:
Value:
012 345
“Boulder” “Ft. Collins” “Greeley”
List: The salesman’s itinerary (Duplicates allowed)
Set: The salesman’s territory (No duplicates allowed)
Hashcode Buckets:
Values: “Sky Hook” “Mon keyWren ch” “Phase In verter” “Warp Core”
“Flux Capacitor”
HashMap: the salesman’s products (Keys generated from product IDs)
Boulder
Ft. Collins 
Dillon
Denver
Idaho Springs
Greeley Vail
“Boulder” “Denver” “Boulder”
But there are sub-flavors within those four flavors of collections: 
An implementation class can be unsorted and unordered, ordered but unsorted, or 
both ordered and sorted. But an implementation can never be sorted but unordered, 
because sorting is a specific type of ordering, as you'll see in a moment. For example, 
a HashSet is an unordered, unsorted set, while a LinkedHashSet is an ordered (but 
not sorted) set that maintains the order in which objects were inserted. Maybe we should be explicit about the difference between sorted and ordered, but 
first we have to discuss the idea of iteration. When you think of iteration, you may 
think of iterating over an array using, say, a for loop to access each element in the 
array in order ([0], [1], [2], and so on). Iterating through a collection usually means 
walking through the elements one after another starting from the first element. Sometimes, though, even the concept of first is a little strange—in a Hashtable there 
really isn't a notion of first, second, third, and so on. In a Hashtable, the elements 
are placed in a (seemingly) chaotic order based on the hashcode of the key. But 
something has to go first when you iterate; thus, when you iterate over a Hashtable, 
there will indeed be an order. But as far as you can tell, it's completely arbitrary and 
can change in apparently random ways as the collection changes. Ordered When a collection is ordered, it means you can iterate through the 
collection in a specific (not-random) order. A Hashtable collection is not ordered. Although the Hashtable itself has internal logic to determine the order (based on 
hashcodes and the implementation of the collection itself), you won't find any order 
when you iterate through the Hashtable. An ArrayList, however, keeps the order es-
tablished by the elements' index position (just like an array). LinkedHashSet keeps 
the order established by insertion, so the last element inserted is the last element in 
the LinkedHashSet (as opposed to an ArrayList, where you can insert an element at 
a specific index position). Finally, there are some collections that keep an order re-
ferred to as the natural order of the elements, and those collections are then not just 
ordered, but also sorted. Let's look at how natural order works for sorted collections. 560 Chapter 7:  Generics and Collections
 
Sorted Unsorted Ordered Unordered
Sorted A sorted collection means that the order in the collection is determined 
according to some rule or rules, known as the sort order. A sort order has nothing 
to do with when an object was added to the collection, or when was the last time it 
was accessed, or what "position" it was added at. Sorting is done based on properties 
of the objects themselves. You put objects into the collection, and the collection 
will figure out what order to put them in, based on the sort order. A collection that 
keeps an order (such as any List, which uses insertion order) is not really considered 
sorted unless it sorts using some kind of sort order. Most commonly, the sort order 
used is something called the natural order. What does that mean? You know how to sort alphabetically—A comes before B, F comes before G, and 
so on. For a collection of String objects, then, the natural order is alphabetical. For 
Integer objects, the natural order is by numeric value—1 before 2, and so on. And 
for Foo objects, the natural order is…um…we don't know. There is no natural 
order for Foo unless or until the Foo developer provides one, through an interface 
(Comparable)that defines how instances of a class can be compared to one another 
(does instance a come before b, or does instance b come before a?). If the developer 
decides that Foo objects should be compared using the value of some instance 
variable (let's say there's one called bar), then a sorted collection will order the 
Foo objects according to the rules in the Foo class for how to use the bar instance 
variable to determine the order. Of course, the Foo class might also inherit a natural 
order from a superclass rather than define its own order, in some cases. Aside from natural order as specified by the Comparable interface, it's also 
possible to define other, different sort orders using another interface: Comparator. We will discuss how to use both Comparable and Comparator to define sort orders 
later in this chapter. But for now, just keep in mind that sort order (including 
natural order) is not the same as ordering by insertion, access, or index. Now that we know about ordering and sorting, we'll look at each of the four 
interfaces, and we'll dive into the concrete implementations of those interfaces. List Interface
A List cares about the index. The one thing that List has that non-lists don't have 
is a set of methods related to the index. Those key methods include things like 
get(int index), indexOf(Object o), add(int index, Object obj), and so 
on. All three List implementations are ordered by index position—a position that 
you determine either by setting an object at a specific index or by adding it without 
specifying position, in which case the object is added to the end. The three List 
implementations are described in the following sections. List Interface (Exam Objective 6.1) 561
ArrayList Think of this as a growable array. It gives you fast iteration and fast 
random access. To state the obvious: it is an ordered collection (by index), but not 
sorted. You might want to know that as of version 1.4, ArrayList now implements 
the new RandomAccess interface—a marker interface (meaning it has no methods) 
that says, "this list supports fast (generally constant time) random access." Choose 
this  over a LinkedList when you need fast iteration but aren't as likely to be doing a 
lot of insertion and deletion. Vector Vector is a holdover from the earliest days of Java; Vector and Hashtable 
were the two original collections, the rest were added with Java 2 versions 1.2 and 
1.4. A Vector is basically the same as an ArrayList, but Vector methods are syn-
chronized for thread safety. You'll normally want to use ArrayList instead of Vector 
because the synchronized methods add a performance hit you might not need. And 
if you do need thread safety, there are utility methods in class Collections that can 
help. Vector is the only class other than ArrayList to implement RandomAccess. LinkedList A LinkedList is ordered by index position, like ArrayList, except 
that the elements are doubly-linked to one another. This linkage gives you new 
methods (beyond what you get from the List interface) for adding and removing 
from the beginning or end, which makes it an easy choice for implementing a stack 
or queue. Keep in mind that a LinkedList may iterate more slowly than an ArrayList, 
but it's a good choice when you need fast insertion and deletion. As of Java 5, the 
LinkedList class has been enhanced to implement the java.util.Queue interface. As 
such, it now supports the common queue methods: peek(), poll(), and offer(). Set Interface
A Set cares about uniqueness—it doesn't allow duplicates. Your good friend the 
equals() method determines whether two objects are identical (in which case only 
one can be in the set). The three Set implementations are described in the following 
sections. HashSet A HashSet is an unsorted, unordered Set. It uses the hashcode 
of the object being inserted, so the more efficient your hashCode() implementation
the better access performance you'll get. Use this class when you want a collection 
with no duplicates and you don't care about order when you iterate through it. 562 Chapter 7:  Generics and Collections
LinkedHashSet A LinkedHashSet is an ordered version of HashSet that 
maintains a doubly-linked List across all elements. Use this class instead of HashSet 
when you care about the iteration order. When you iterate through a HashSet the 
order is unpredictable, while a LinkedHashSet lets you iterate through the elements  
in the order in which they were inserted. TreeSet The TreeSet is one of two sorted collections (the other being TreeMap). It uses a Red-Black tree structure (but you knew that), and guarantees that the 
elements will be in ascending order, according to natural order. Optionally, you can 
construct a TreeSet with a constructor that lets you give the collection your own 
rules for what the order should be (rather than relying on the ordering defined by 
the elements' class) by using a Comparable or Comparator. As of Java 6, TreeSet 
implements NavigableSet. Map Interface
A Map cares about unique identifiers. You map a unique key (the ID) to a specific 
value, where both the key and the value are, of course, objects. You're probably quite 
familiar with Maps since many languages support data structures that use a key/value 
or name/value pair. The Map implementations let you do things like search for a 
value based on the key, ask for a collection of just the values, or ask for a collection 
of just the keys. Like Sets, Maps rely on the equals() method to determine whether 
two keys are the same or different. HashMap The HashMap gives you an unsorted, unordered Map. When you 
need a Map and you don't care about the order (when you iterate through it), then 
HashMap is the way to go; the other maps add a little more overhead. Where the 
keys land in the Map is based on the key's hashcode, so, like HashSet, the more ef-
ficient your hashCode() implementation, the better access performance you'll get. HashMap allows one null key and multiple null values in a collection. Map Interface (Exam Objective 6.1) 563
When using HashSet or LinkedHashSet, the objects you add to them 
must override hashCode(). If they don’t override hashCode(), the default Object. hashCode() method will allow multiple objects that you might consider "meaningfully 
equal" to be added to your "no duplicates allowed" set. Hashtable Like Vector, Hashtable has existed from prehistoric Java times. For fun, don't forget to note the naming inconsistency: HashMap vs. Hashtable. Where's the capitalization of t? Oh well, you won't be expected to spell it. Anyway, 
just as Vector is a synchronized counterpart to the sleeker, more modern ArrayList, 
Hashtable is the synchronized counterpart to HashMap. Remember that you don't 
synchronize a class, so when we say that Vector and Hashtable are synchronized, we 
just mean that the key methods of the class are synchronized. Another difference, 
though, is that while HashMap lets you have null values as well as one null key, a 
Hashtable doesn't let you have anything that's null. LinkedHashMap Like its Set counterpart, LinkedHashSet, the LinkedHash-
Map collection maintains insertion order (or, optionally, access order). Although it 
will be somewhat slower than HashMap for adding and removing elements, you can 
expect faster iteration with a LinkedHashMap. TreeMap You can probably guess by now that a TreeMap is a sorted Map. And you already know that by default, this means "sorted by the natural order of 
the elements." Like TreeSet, TreeMap lets you define a custom sort order (via a 
Comparable or Comparator) when you construct a TreeMap, that specifies how the 
elements should be compared to one another when they're being ordered. As of 
Java 6, TreeMap implements NavigableMap. Queue Interface
A Queue is designed to hold a list of "to-dos," or things to be processed in some way. Although other orders are possible, queues are typically thought of as FIFO (first-in, 
first-out). Queues support all of the standard Collection methods and they also add 
methods to add and subtract elements and review queue elements. PriorityQueue This class is new with Java 5. Since the LinkedList class has 
been enhanced to implement the Queue interface, basic queues can be handled with 
a LinkedList. The purpose of a PriorityQueue is to create a "priority-in, priority out" 
queue as opposed to a typical FIFO queue. A PriorityQueue's elements are ordered 
either by natural ordering (in which case the elements that are sorted first will be 
accessed first) or according to a Comparator. In either case, the elements' ordering 
represents their relative priority. 564 Chapter 7:  Generics and Collections
Table 7-2 summarizes the 11 of the 13 concrete collection-oriented classes you'll 
need to understand for the exam. (Arrays and Collections are coming right up!) 
 You can easily eliminate some answers right away if you recognize 
that, for example, a Map can’t be the class to choose when you need a name/value 
pair collection, since Map is an interface and not a concrete implementation class. The wording on the exam is explicit when it matters, so if you’re asked to choose an 
interface, choose an interface rather than a class that implements that interface. The 
reverse is also true—if you’re asked to choose a class, don’t choose an interface type. Class Map Set List Ordered Sorted
HashMap xN o N o
Hashtable xN o N o
TreeMap x Sorted By natural order or 
custom comparison rules
LinkedHashMap x By insertion order 
or last access order
No
HashSet x No No
TreeSet x Sorted By natural order or 
custom comparison rules
LinkedHashSet x By insertion order No
ArrayList x By index No
Vector x By index No
LinkedList x By index No
PriorityQueue Sorted By to-do order
 TABLE 7-2    Collection Interface Concrete Implementation Classes
Queue Interface (Exam Objective 6.1) 565
CERTIFICATION OBJECTIVE
Using the Collections Framework 
(Objectives 6.3 and 6.5)
6.3 Write code that uses the NavigableSet and NavigableMap interfaces. 6.5 Use capabilities in the java.util package to write code to manipulate a list by sorting, 
performing a binary search, or converting the list to an array. Use capabilities in the 
java.util package to write code to manipulate an array by sorting, performing a binary 
search, or converting the array to a list. Use the java.util.Comparator and java.lang. Comparable interfaces to affect the sorting of lists and arrays. Furthermore, recognize the 
effect of the "natural ordering" of primitive wrapper classes and java.lang.String on sorting. We've taken a high-level, theoretical look at the key interfaces and classes in the 
Collections Framework, now let's see how they work in practice. 566 Chapter 7:  Generics and Collections
Be sure you know how to interpret Table 7-2 in a practical way. For the 
exam, you might be expected to choose a collection based on a particular requirement, 
where that need is expressed as a scenario. For example, which collection would you 
use if you needed to maintain and search on a list of parts, identiﬁ  ed by their unique 
alphanumeric serial number where the part would be of type Part? Would you change 
your answer at all if we modiﬁ  ed the requirement such that you also need to be able to 
print out the parts in order, by their serial number? For the ﬁ  rst question, you can see 
that since you have a Part class, but need to search for the objects based on a serial 
number, you need a Map. The key will be the serial number as a String, and the value 
will be the Part instance. The default choice should be HashMap, the quickest Map for 
access. But now when we amend the requirement to include getting the parts in order 
of their serial number, then we need a TreeMap—which maintains the natural order 
of the keys. Since the key is a String, the natural order for a String will be a standard 
alphabetical sort. If the requirement had been to keep track of which part was last 
accessed, then we’d probably need a LinkedHashMap. But since a LinkedHashMap loses 
the natural order (replacing it with last-accessed order), if we need to list the parts by 
serial number, we’ll have to explicitly sort the collection, using a utility method. ArrayList Basics
The java.util.ArrayList class is one of the most commonly used of all the 
classes in the Collections Framework. It's like an array on vitamins. Some of the 
advantages ArrayList has over arrays are
■ It can grow dynamically. ■ It provides more powerful insertion and search mechanisms than arrays. Let's take a look at using an ArrayList that contains Strings. A key design goal 
of the Collections Framework was to provide rich functionality at the level of the 
main interfaces: List, Set, and Map. In practice, you'll typically want to instantiate 
an ArrayList polymorphically like this:
List myList = new ArrayList();
As of Java 5 you'll want to say
List<String> myList = new ArrayList<String>();
This kind of declaration follows the object oriented programming  principle of 
"coding to an interface", and it makes use of generics. We'll say lots more about 
generics later in this chapter, but for now just know that, as of Java 5, the <String> 
syntax is the way that you declare a collection's type. (Prior to Java 5 there was no 
way to specify the type of a collection, and when we cover generics, we'll talk about 
the implications of mixing Java 5 (typed) and pre-Java 5 (untyped) collections.)
    In many ways, ArrayList<String> is similar to a String[] in that it declares a 
container that can hold only Strings, but it's more powerful than a String[]. Let's 
look at some of the capabilities that an ArrayList has
    List<String> test = new ArrayList<String>();
    String s = "hi";
    test.add("string");
    test.add(s);
    test.add(s+s);
    System.out.println(test.size());
    System.out.println(test.contains(42));
ArrayList Basics (Exam Objectives 6.3 and 6.5) 567
    System.out.println(test.contains("hihi"));
    test.remove("hi");
    System.out.println(test.size());
which produces
3
false
true
2
There's lots going on in this small program. Notice that when we declared the 
ArrayList we didn't give it a size. Then we were able to ask the ArrayList for 
its size, we were able to ask it whether it contained specific objects, we removed an 
object right out from the middle of it, and then we rechecked its size. Autoboxing with Collections
In general, collections can hold Objects but not primitives. Prior to Java 5, a very 
common use for the wrapper classes was to provide a way to get a primitive into a 
collection. Prior to Java 5, you had to wrap a primitive by hand before you could put 
it into a collection. With Java 5, primitives still have to be wrapped, but autoboxing 
takes care of it for you. List myInts = new ArrayList();   // pre Java 5 declaration
myInts.add(new Integer(42));     // had to wrap an int
As of Java 5 we can say
myInts.add(42);                  // autoboxing handles it! In this last example, we are still adding an Integer object to myInts (not an int 
primitive); it's just that autoboxing handles the wrapping for us. Sorting Collections and Arrays
Sorting and searching topics have been added to the exam for Java 5. Both 
collections and arrays can be sorted and searched using methods in the API. 568 Chapter 7:  Generics and Collections
Sorting Collections
Let's start with something simple like sorting an ArrayList of Strings alphabetically. What could be easier? Okay, we'll wait while you go find ArrayList's sort() 
method…got it? Of course, ArrayList doesn't give you any way to sort its contents, 
but the java.util.Collections class does
import java.util.*;
class TestSort1 {
  public static void main(String[] args) {
    ArrayList<String> stuff = new ArrayList<String>(); // #1
    stuff.add("Denver");
    stuff.add("Boulder");
    stuff.add("Vail");
    stuff.add("Aspen");
    stuff.add("Telluride");
    System.out.println("unsorted " + stuff);
    Collections.sort(stuff);                           // #2
    System.out.println("sorted   " + stuff);
  }
}
This produces something like this:
unsorted [Denver, Boulder, Vail, Aspen, Telluride]
sorted   [Aspen, Boulder, Denver, Telluride, Vail]
Line 1 is declaring an ArrayList of Strings, and line 2 is sorting the ArrayList 
alphabetically. We'll talk more about the Collections class, along with the Arrays 
class in a later section, for now let's keep sorting stuff.

--- Chunk #1487 ---
Let's imagine we're building the ultimate home-automation application. Today 
we're focused on the home entertainment center, and more specifically the DVD 
control center. We've already got the file I/O software in place to read and write 
data between the dvdInfo.txt file and instances of class DVDInfo. Here are the key 
aspects of the class:
class DVDInfo {
  String title;
  String genre;
  String leadActor;
  DVDInfo(String t, String g, String a) {
Sorting Collections and Arrays (Exam Objectives 6.3 and 6.5) 569
    title = t;  genre = g;  leadActor = a;
  }
  public String toString() {
    return title + " " + genre + " " + leadActor + "\n";
  }
  // getters and setter go here
}
Here's the DVD data that's in the dvdinfo.txt file:
Donnie Darko/sci-fi/Gyllenhall, Jake
Raiders of the Lost Ark/action/Ford, Harrison
2001/sci-fi/?? Caddy Shack/comedy/Murray, Bill
Star Wars/sci-fi/Ford, Harrison
Lost in Translation/comedy/Murray, Bill
Patriot Games/action/Ford, Harrison
In our home-automation application, we want to create an instance of DVDInfo 
for each line of data we read in from the dvdInfo.txt file. For each instance, we 
will parse the line of data (remember String.split()?) and populate DVDInfo's 
three instance variables. Finally, we want to put all of the DVDInfo instances into an 
ArrayList. Imagine that the populateList() method (below) does all of this. Here 
is a small piece of code from our application:
ArrayList<DVDInfo> dvdList = new ArrayList<DVDInfo>();
populateList();   // adds the file data to the ArrayList 
System.out.println(dvdList);
You might get output like this:
[Donnie Darko sci-fi Gyllenhall, Jake
, Raiders of the Lost Ark action Ford, Harrison
, 2001 sci-fi ?? , Caddy Shack comedy Murray, Bill
, Star Wars sci-fi Ford, Harrison
, Lost in Translation comedy Murray, Bill
, Patriot Games action Ford, Harrison
]
(Note: We overrode DVDInfo's toString() method, so when we invoked 
println() on the ArrayList it invoked toString() for each instance.) 
 
570 Chapter 7:  Generics and Collections
Now that we've got a populated ArrayList, let's sort it: 
Collections.sort(dvdlist);
Oops!, you get something like this:
TestDVD.java:13: cannot find symbol
symbol  : method sort(java.util.ArrayList<DVDInfo>)
location: class java.util.Collections
    Collections.sort(dvdlist);
What's going on here? We know that the Collections class has a sort() method, 
yet this error implies that Collections does NOT have a sort() method that can 
take a dvdlist. That means there must be something wrong with the argument 
we're passing (dvdlist). If you've already figured out the problem, our guess is that you did it without 
the help of the obscure error message shown above…How the heck do you sort 
instances of DVDInfo? Why were we able to sort instances of String? When you 
look up Collections.sort() in the API your first reaction might be to panic. Hang tight, once again the generics section will help you read that weird looking 
method signature. If you read the description of the one-arg sort() method, 
you'll see that the sort() method takes a List argument, and that the objects in 
the List must implement an interface called Comparable. It turns out that String 
implements Comparable, and that's why we were able to sort a list of Strings using 
the Collections.sort() method. The Comparable Interface
The Comparable interface is used by the Collections.sort() method and 
the java.util.Arrays.sort() method to sort Lists and arrays of objects, 
respectively. To implement Comparable, a class must implement a single method, 
compareTo(). Here's an invocation of compareTo():
int x = thisObject.compareTo(anotherObject);
The compareTo() method returns an int with the following characteristics:
■ negative   If thisObject < anotherObject
■ zero  If thisObject == anotherObject
■ positive  If thisObject > anotherObject
Sorting Collections and Arrays (Exam Objectives 6.3 and 6.5) 571
572 Chapter 7:  Generics and Collections
The sort() method uses compareTo() to determine how the List or object array 
should be sorted. Since you get to implement compareTo() for your own classes, 
you can use whatever weird criteria you prefer, to sort instances of your classes. Returning to our earlier example for class DVDInfo, we can take the easy way out 
and use the String class's implementation of compareTo():
class DVDInfo implements Comparable<DVDInfo> {   // #1
  // existing code 
  public int compareTo(DVDInfo d) {             
    return title.compareTo(d.getTitle());        // #2
} }
In line 1 we declare that class DVDInfo implements Comparable in such a way 
that DVDInfo objects can be compared to other DVDInfo objects. In line 2 we 
implement compareTo() by comparing the two DVDInfo object's titles. Since we 
know that the titles are Strings, and that String implements Comparable, this is an 
easy way to sort our DVDInfo objects, by title. Before generics came along in Java 5, 
you would have had to implement Comparable something like this:
class DVDInfo implements Comparable {             
  // existing code
  public int compareTo(Object o) {   // takes an Object rather
                                     // than a specific type           
    DVDInfo d = (DVDInfo)o;                     
    return title.compareTo(d.getTitle());       
} }
This is still legal, but you can see that it's both painful and risky, because  you 
have to do a cast, and you need to verify that the cast will not fail before you try it. It’s important to remember that when you override equals() you MUST 
take an argument of type Object, but that when you override compareTo() you 
should take an argument of the type you’re sorting. Putting it all together, our DVDInfo class should now look like this:
class DVDInfo implements Comparable<DVDInfo> {
  String title;
  String genre;
  String leadActor;
  DVDInfo(String t, String g, String a) {
    title = t;  genre = g;  leadActor = a;
  }
  public String toString() {
    return title + " " + genre + " " + leadActor + "\n";
  }
  public int compareTo(DVDInfo d) {    
    return title.compareTo(d.getTitle());  
  }
  public String getTitle() {
    return title;
  }
  // other getters and setters
}
Now, when we invoke Collections.sort(dvdList); we get
[2001 sci-fi ?? , Caddy Shack comedy Murray, Bill
, Donnie Darko sci-fi Gyllenhall, Jake
, Lost in Translation comedy Murray, Bill
, Patriot Games action Ford, Harrison
, Raiders of the Lost Ark action Ford, Harrison
, Star Wars sci-fi Ford, Harrison
]
Hooray!

--- Chunk #1488 ---
Our ArrayList has been sorted by title.

--- Chunk #1489 ---
Of course, if we want our home 
automation system to really rock, we'll probably want to sort DVD collections in lots 
of different ways. Since we sorted our ArrayList by implementing the compareTo() 
method, we seem to be stuck. We can only implement compareTo() once in a class, 
so how do we go about sorting our classes in an order different than what we specify 
in our compareTo() method? Good question. As luck would have it, the answer is 
coming up next. Sorting Collections and Arrays (Exam Objectives 6.3 and 6.5) 573
574 Chapter 7:  Generics and Collections
Sorting with Comparator
While you were looking up the Collections.sort() method you might have 
noticed that there is an overloaded version of sort() that takes both a List AND 
something called a Comparator. The Comparator interface gives you the capability 
to sort a given collection any number of different ways. The other handy thing about 
the Comparator interface is that you can use it to sort instances of any class—even 
classes you can't modify —unlike the Comparable interface, which forces you to 
change the class whose instances you want to sort. The Comparator interface is also 
very easy to implement, having only one method, compare(). Here's a small class 
that can be used to sort a List of DVDInfo instances, by genre. import java.util.*;
class GenreSort implements Comparator<DVDInfo> {
  public int compare(DVDInfo one, DVDInfo two) {
    return one.getGenre().compareTo(two.getGenre());
  }
}
The Comparator.compare() method returns an int whose meaning is the same 
as the Comparable.compareTo() method's return value. In this case we're taking 
advantage of that by asking compareTo() to do the actual comparison work for 
us. Here's a test program that lets us test both our Comparable code and our new 
Comparator code:
import java.util.*;
import java.io.*;          // populateList() needs this
public class TestDVD {
  ArrayList<DVDInfo> dvdlist = new ArrayList<DVDInfo>();
  public static void main(String[] args) {
    new TestDVD().go();
  }
  public void go() {
    populateList();
    System.out.println(dvdlist);     // output as read from file
    Collections.sort(dvdlist); 
    System.out.println(dvdlist);     // output sorted by title
    GenreSort gs = new GenreSort();
    Collections.sort(dvdlist, gs);
    System.out.println(dvdlist);     // output sorted by genre
  }
  public void populateList() {
     // read the file, create DVDInfo instances, and
     // populate the ArrayList dvdlist with these instances
  }
}
You've already seen the first two output lists, here's the third:
[Patriot Games action Ford, Harrison
, Raiders of the Lost Ark action Ford, Harrison
, Caddy Shack comedy Murray, Bill
, Lost in Translation comedy Murray, Bill
, 2001 sci-fi ?? , Donnie Darko sci-fi Gyllenhall, Jake
, Star Wars sci-fi Ford, Harrison
]
Because the Comparable and Comparator interfaces are so similar, expect the 
exam to try to confuse you.

--- Chunk #1490 ---
For instance you might be asked to implement the 
compareTo() method in the Comparator interface. Study Table 7-3 to burn in the 
differences between these two interfaces. java.lang.Comparable java.util.Comparator
int objOne.compareTo(objTwo) int compare(objOne, objTwo)
Returns
    negative    if  objOne < objTwo
    zero           if  objOne == objTwo
    positive     if  objOne > objTwo
Same as Comparable
You must modify the class whose 
instances you want to sort. You build a class separate from the class whose instances you 
want to sort. Only one sort sequence can be created Many sort sequences can be created
Implemented frequently in the API by:
String, Wrapper classes, Date, Calendar... Meant to be implemented to sort instances of third-party 
classes. TABLE 7-3   Comparing Comparable to Comparator
Sorting Collections and Arrays (Exam Objectives 6.3 and 6.5) 575
576 Chapter 7:  Generics and Collections
Sorting with the Arrays Class
We've been using the java.util.Collections class to sort collections; now let's look 
at using the java.util.Arrays class to sort arrays. The good news is that sorting arrays 
of objects is just like sorting collections of objects. The Arrays.sort() method is 
overridden in the same way the Collections.sort() method is. ■ Arrays.sort(arrayToSort)
■ Arrays.sort(arrayToSort, Comparator)
In addition, the Arrays.sort() method is overloaded about a million times to 
provide a couple of sort methods for every type of primitive. The Arrays.sort() 
methods that sort primitives always sort based on natural order. Don't be fooled by 
an exam question that tries to sort a primitive array using a Comparator. Finally, remember that the sort() methods for both the Collections class and 
the Arrays class are static methods, and that they alter the objects they are sorting, 
instead of returning a different sorted object. Searching Arrays and Collections
The Collections class and the Arrays class both provide methods that allow you 
to search for a specific element. When searching through collections or arrays, the 
following rules apply:
■ Searches are performed using the binarySearch() method. ■ Successful searches return the int index of the element being searched. ■ Unsuccessful searches return an int index that represents the insertion point. The insertion point is the place in the collection/array where the element 
would be inserted to keep the collection/array properly sorted. Because posi-
We’ve talked a lot about sorting by natural order and using Comparators 
to sort. The last rule you’ll need to burn in is that, whenever you want to sort an array 
or a collection, the elements inside must all be mutually comparable. In other words, if you 
have an Object[] and you put Cat and Dog objects into it, you won’t be able to sort 
it. In general, objects of different types should be considered NOT mutually comparable, 
unless speciﬁ  cally stated otherwise. tive return values and 0 indicate successful searches, the binarySearch() 
method uses negative numbers to indicate insertion points. Since 0 is a valid 
result for a successful search, the first available insertion point is -1. There-
fore, the actual insertion point is represented as (-(insertion point) -1). For 
instance, if the insertion point of a search is at element 2, the actual insertion 
point returned will be -3. ■ The collection/array being searched must be sorted before you can search it. ■ If you attempt to search an array or collection that has not already been 
sorted, the results of the search will not be predictable. ■ If the collection/array you want to search was sorted in natural order, it must 
be searched in natural order. (Usually this is accomplished by NOT sending 
a Comparator as an argument to the binarySearch() method.)
■ If the collection/array you want to search was sorted using a Comparator, it 
must be searched using the same Comparator, which is passed as the second 
argument to the binarySearch() method. Remember that Comparators 
cannot be used when searching arrays of primitives. Let's take a look at a code sample that exercises the binarySearch() method:
import java.util.*;
class SearchObjArray {
  public static void main(String [] args) {
    String [] sa = {"one", "two", "three", "four"};
    Arrays.sort(sa);                                      // #1
    for(String s : sa)
      System.out.print(s + " "); 
    System.out.println("\none = " 
                       + Arrays.binarySearch(sa,"one"));  // #2
    System.out.println("now reverse sort");
    ReSortComparator rs = new ReSortComparator();         // #3
    Arrays.sort(sa,rs);                              
    for(String s : sa)
      System.out.print(s + " "); 
    System.out.println("\none = " 
                       + Arrays.binarySearch(sa,"one"));  // #4
    System.out.println("one = " 
                    + Arrays.binarySearch(sa,"one",rs));  // #5
  }
Sorting Collections and Arrays (Exam Objectives 6.3 and 6.5) 577
578 Chapter 7:  Generics and Collections
  static class ReSortComparator 
                  implements Comparator<String> {         // #6
    public int compare(String a, String b) {
      return b.compareTo(a);                              // #7
    }
  }
}
which produces something like this:
four one three two 
one = 1
now reverse sort
two three one four 
one = -1
one = 2
Here's what happened:
Line 1 Sort the sa array, alphabetically (the natural order). Line 2 Search for the location of element "one", which is 1. Line 3  Make a Comparator instance. On the next line we re-sort the array using 
the Comparator. Line 4  Attempt to search the array. We didn't pass the binarySearch() 
method the Comparator we used to sort the array, so we got an incorrect 
(undefined) answer. Line 5  Search again, passing the Comparator to binarySearch(). This time 
we get the correct answer, 2
Line 6  We define the Comparator; it's okay for this to be an inner class. Line 7  By switching the use of the arguments in the invocation of 
compareTo(), we get an inverted sort. When solving searching and sorting questions, two big gotchas are
 1. Searching an array or collection that hasn’t been sorted. 2. Using a Comparator in either the sort or the search, 
 but not both. Converting Arrays to Lists to Arrays
There are a couple of methods that allow you to convert arrays to Lists, and Lists to 
arrays. The List and Set classes have toArray() methods, and the Arrays class has a 
method called asList(). The Arrays.asList() method copies an array into a List. The API says, 
"Returns a fixed-size list backed by the specified array. (Changes to the returned list 
'write through' to the array.)" When you use the asList() method, the array and 
the List become joined at the hip. When you update one of them, the other gets 
updated automatically. Let's take a look:
String[] sa = {"one", "two", "three", "four"};
List sList = Arrays.asList(sa);                // make a List
System.out.println("size  " + sList.size());
System.out.println("idx2  " + sList.get(2));
sList.set(3,"six");                            // change List
sa[1] = "five";                                // change array 
for(String s : sa)
  System.out.print(s + " ");
System.out.println("\nsl[1] " + sList.get(1));
This produces
size 4
idx2 three
one five three six 
sl[1] five
Notice that when we print the final state of the array and the List, they have both 
been updated with each other's changes. Wouldn't something like this behavior 
make a great exam question? Now let's take a look at the toArray() method. There's nothing too fancy going 
on with the toArray() method; it comes in two flavors: one that returns a new 
Object array, and one that uses the array you send it as the destination array:
List<Integer> iL = new ArrayList<Integer>();
for(int x=0; x<3; x++)
  iL.add(x);
Object[] oa = iL.toArray();         // create an Object array
Integer[] ia2 = new Integer[3];
ia2 = iL.toArray(ia2);              // create an Integer array
Sorting Collections and Arrays (Exam Objectives 6.3 and 6.5) 579
580 Chapter 7:  Generics and Collections
Using Lists
Remember that Lists are usually used to keep things in some kind of order. You can 
use a LinkedList to create a first-in, first-out queue. You can use an ArrayList to 
keep track of what locations were visited, and in what order. Notice that in both of 
these examples it's perfectly reasonable to assume that duplicates might occur. In 
addition, Lists allow you to manually override the ordering of elements by adding or 
removing elements via the element's index. Before Java 5, and the enhanced for 
loop, the most common way to examine a List "element by element" was by the use 
of an Iterator. You'll still find Iterators in use in the Java code you encounter, and 
you might just find an Iterator or two on the exam. An Iterator is an object that's 
associated with a specific collection. It lets you loop through the collection step by 
step. The two Iterator methods you need to understand for the exam are
■ boolean hasNext() Returns true if there is at least one more element in 
the collection being traversed. Invoking hasNext() does NOT move you to 
the next element of the collection. ■ Object next() This method returns the next object in the collection, 
AND moves you forward to the element after the element just returned. Let's look at a little code that uses a List and an Iterator:
import java.util.*;
class Dog {
  public String name;
  Dog(String n) { name = n; }
}
class ItTest {
  public static void main(String[] args) {
    List<Dog> d = new ArrayList<Dog>();
    Dog dog = new Dog("aiko");
    d.add(dog);
    d.add(new Dog("clover"));
    d.add(new Dog("magnolia"));
    Iterator<Dog> i3 = d.iterator();  // make an iterator
    while (i3.hasNext()) {
      Dog d2 = i3.next();             // cast not required
      System.out.println(d2.name);
    }
    System.out.println("size " + d.size());
    System.out.println("get1 " + d.get(1).name);
    System.out.println("aiko " + d.indexOf(dog));
    d.remove(2);
    Object[] oa = d.toArray();
    for(Object o : oa) {
      Dog d2 = (Dog)o;
      System.out.println("oa " + d2.name);
    }
  }
}
This produces
aiko
clover
magnolia
size 3
get1 clover
aiko 0
oa aiko
oa clover
First off, we used generics syntax to create the Iterator (an Iterator of type Dog). Because of this, when we used the next() method, we didn't have to cast the 
Object returned by next() to a Dog. We could have declared the Iterator like this:
Iterator i3 = d.iterator();  // make an iterator
But then we would have had to cast the returned value:
Dog d2 = (Dog)i3.next();
The rest of the code demonstrates using the size(), get(), indexOf(), and 
toArray() methods. There shouldn't be any surprises with these methods. In a few 
pages Table 7-5 will list all of the List, Set, and Map methods you should be familiar 
with for the exam. As a last warning, remember that List is an interface! Using Sets
Remember that Sets are used when you don't want any duplicates in your collection. If you attempt to add an element to a set that already exists in the set, the duplicate 
element will not be added, and the add() method will return false. Remember, 
HashSets tend to be very fast because, as we discussed earlier, they use hashcodes. Sorting Collections and Arrays (Exam Objectives 6.3 and 6.5) 581
You can also create a TreeSet, which is a Set whose elements are sorted. You must 
use caution when using a TreeSet (we're about to explain why):
import java.util.*;
class SetTest {
  public static void main(String[] args) {
    boolean[] ba = new boolean[5];
    // insert code here
    ba[0] = s.add("a");
    ba[1] = s.add(new Integer(42));
    ba[2] = s.add("b");
    ba[3] = s.add("a");
    ba[4] = s.add(new Object());
    for(int x=0; x<ba.length; x++)
      System.out.print(ba[x] + " ");
    System.out.println("\n");
    for(Object o : s)
      System.out.print(o + " ");
  }
}
If you insert the following line of code you'll get output something like this:
Set s = new HashSet();       // insert this code
true true true false true 
a java.lang.Object@e09713 42 b
It's important to know that the order of objects printed in the second for loop 
is not predictable: HashSets do not guarantee any ordering. Also, notice that the 
fourth invocation of add() failed, because it attempted to insert a duplicate entry 
(a String with the value a) into the Set. If you insert this line of code you'll get something like this:
Set s = new TreeSet();        // insert this code
Exception in thread "main" java.lang.ClassCastException: java. lang.String
        at java.lang.Integer.compareTo(Integer.java:35)
        at java.util.TreeMap.compare(TreeMap.java:1093)
582 Chapter 7:  Generics and Collections
        at java.util.TreeMap.put(TreeMap.java:465)
        at java.util.TreeSet.add(TreeSet.java:210)
The issue is that whenever you want a collection to be sorted, its elements must 
be mutually comparable. Remember that unless otherwise specified, objects of 
different types are not mutually comparable. Using Maps
Remember that when you use a class that implements Map, any classes that you 
use as a part of the keys for that map must override the hashCode() and equals() 
methods. (Well, you only have to override them if you're interested in retrieving 
stuff from your Map. Seriously, it's legal to use a class that doesn't override equals() 
and hashCode() as a key in a Map; your code will compile and run, you just won't 
find your stuff.) Here's some crude code demonstrating the use of a HashMap:
import java.util.*;
class Dog {
  public Dog(String n) { name = n; }
  public String name;
  public boolean equals(Object o) {
    if((o instanceof Dog) && 
       (((Dog)o).name == name)) {
      return true;
    } else {
      return false;
    }
  }
  public int hashCode() {return name.length(); }
}
class Cat { }
enum Pets {DOG, CAT, HORSE }
class MapTest {
  public static void main(String[] args) {
    Map<Object, Object> m = new HashMap<Object, Object>();
    m.put("k1", new Dog("aiko"));   // add some key/value pairs
    m.put("k2", Pets.DOG);
    m.put(Pets.CAT, "CAT key");
    Dog d1 = new Dog("clover");     // let's keep this reference
Sorting Collections and Arrays (Exam Objectives 6.3 and 6.5) 583
584 Chapter 7:  Generics and Collections
    m.put(d1, "Dog key");
    m.put(new Cat(), "Cat key");
    System.out.println(m.get("k1"));                 // #1
    String k2 = "k2";
    System.out.println(m.get(k2));                   // #2
    Pets p = Pets.CAT;
    System.out.println(m.get(p));                    // #3
    System.out.println(m.get(d1));                   // #4
    System.out.println(m.get(new Cat()));            // #5
    System.out.println(m.size());                    // #6
  }
}
which produces something like this:
Dog@1c
DOG
CAT key
Dog key
null
5
Let's review the output. The first value retrieved is a Dog object (your value 
will vary).

--- Chunk #1491 ---
The second value retrieved is an enum value (DOG). The third value 
retrieved is a String; note that the key was an enum value. Pop quiz: What's the 
implication of the fact that we were able to successfully use an enum as a key? The implication of this is that enums override equals() and hashCode(). And, 
if you look at the java.lang.Enum class in the API, you will see that, in fact, these 
methods have been overridden. The fourth output is a String. The important point about this output is that the 
key used to retrieve the String was made of a Dog object. The fifth output is null. The important point here is that the get() method failed to find the Cat object 
that was inserted earlier. (The last line of output confirms that indeed, 5 key/value 
pairs exist in the Map.) Why didn't we find the Cat key String? Why did it work to 
use an instance of Dog as a key, when using an instance of Cat as a key failed? It's easy to see that Dog overrode equals() and hashCode() while Cat didn't. Let's take a quick look at hashcodes. We used an incredibly simplistic hashcode 
formula in the Dog class—the hashcode of a Dog object is the length of the 
instance's name. So in this example the hashcode = 6. Let's compare the following 
two hashCode() methods:
public int hashCode() {return name.length(); }   // #1
public int hashCode() {return 4; }               // #2
Time for another pop quiz: Are the preceding two hashcodes legal? Will they 
successfully retrieve objects from a Map? Which will be faster?

--- Chunk #1492 ---
The answer to the first two questions is Yes and Yes. Neither of these hashcodes 
will be very efficient (in fact they would both be incredibly inefficient), but they 
are both legal, and they will both work. The answer to the last question is that the 
first hashcode will be a little bit faster than the second hashcode. In general, the 
more unique hashcodes a formula creates, the faster the retrieval will be. The first 
hashcode formula will generate a different code for each name length (for instance 
the name Robert will generate one hashcode and the name Benchley will generate 
a different hashcode). The second hashcode formula will always produce the same 
result, 4, so it will be slower than the first. Our last Map topic is what happens when an object used as a key has its values 
changed? If we add two lines of code to the end of the earlier MapTest.main(),
d1.name = "magnolia";
System.out.println(m.get(d1));
we get something like this:
Dog@4
DOG
CAT key
Dog key
null
5
null
The Dog that was previously found now cannot be found. Because the Dog.name 
variable is used to create the hashcode, changing the name changed the value of the 
hashcode. As a final quiz for hashcodes, determine the output for the following lines 
of code if they're added to the end of MapTest.main():
    d1.name = "magnolia";
    System.out.println(m.get(d1));                  // #1
    d1.name = "clover";
    System.out.println(m.get(new Dog("clover")));   // #2
    d1.name = "arthur";
    System.out.println(m.get(new Dog("clover")));   // #3
Sorting Collections and Arrays (Exam Objectives 6.3 and 6.5) 585
586 Chapter 7:  Generics and Collections
Remember that the hashcode is equal to the length of the name variable. When 
you study a problem like this, it can be useful to think of the two stages of retrieval:
1. Use the hashCode() method to find the correct bucket
2. Use the equals() method to find the object in the bucket
In the first call to get(), the hashcode is 8 (magnolia) and it should be 6 
(clover), so the retrieval fails at step 1 and we get null. In the second call to 
get(), the hashcodes are both 6, so step 1 succeeds. Once in the correct bucket (the 
"length of name = 6" bucket), the equals() method is invoked, and since Dog's 
equals() method compares names, equals() succeeds, and the output is Dog key. In the third invocation of get(), the hashcode test succeeds, but the equals() test 
fails because arthur is NOT equal to clover. Navigating (Searching) TreeSets and TreeMaps
We've talked about searching lists and arrays.

--- Chunk #1493 ---
Let's turn our attention to searching 
TreeSets and TreeMaps. Java 6 introduced (among others) two new interfaces: 
java.util.NavigableSet and java.util.NavigableMap. For the purposes 
of the exam, you’re interested in how TreeSet and TreeMap implement these 
interfaces. Imagine that the Santa Cruz–Monterey ferry has an irregular schedule. Let's 
say that we have the daily Santa Cruz departure times stored, in military time, in a 
TreeSet. Let's look at some code that determines two things:
 1. The last ferry that leaves before 4 
  (1600 hours)
 2. The first ferry that leaves after 8 
  (2000 hours)
import java.util.*;
public class Ferry {
  public static void main(String[] args) {   
    TreeSet<Integer> times = new TreeSet<Integer>();
    times.add(1205);   // add some departure times
    times.add(1505);
    times.add(1545);
    times.add(1830);
    times.add(2010);
    times.add(2100);
    // Java 5 version
    TreeSet<Integer> subset = new TreeSet<Integer>();
    subset = (TreeSet)times.headSet(1600);
    System.out.println("J5 - last before 4pm is: " + subset.last());
    TreeSet<Integer> sub2 = new TreeSet<Integer>();
    sub2 = (TreeSet)times.tailSet(2000);
    System.out.println("J5 - first after 8pm is: " + sub2.first());
    // Java 6 version using the new lower() and higher() methods
    System.out.println("J6 - last before 4pm is: " + times.lower(1600));
    System.out.println("J6 - first after 8pm is: " + times.higher(2000));
  }
}
This should produce the following:
J5 - last before 4pm is: 1545
J5 - first after 8pm is: 2010
J6 - last before 4pm is: 1545
J6 - first after 8pm is: 2010
As you can see in the preceding code, before the addition of the NavigableSet 
interface, zeroing in on an arbitrary spot in a Set—using the methods available in 
Java 5—was a compute-expensive and clunky proposition. On the other hand, using 
the new Java 6 methods lower() and higher(), the code becomes a lot cleaner.

--- Chunk #1494 ---
For the purpose of the exam, the NavigableSet methods related to this type of 
navigation are lower(), floor(), higher(), ceiling(), and the mostly parallel 
NavigableMap methods are lowerKey(), floorKey(), ceilingKey(), and 
higherKey(). The difference between lower() and floor() is that lower() 
returns the element less than the given element, and floor() returns the element 
less than or equal to the given element. Similarly, higher() returns the element 
greater than the given element, and ceiling() returns the element greater than or 
equal to the given element. Table 7-4 summarizes the methods you should know for 
the exam. Other Navigation Methods
In addition to the methods we just discussed there are a few more new Java 6 
methods that could be considered "navigation" methods. (Okay, it's a little stretch 
to call these "navigation" methods, but just play along.)
Other Navigation Methods 587
588 Chapter 7:  Generics and Collections
Polling
Although the idea of polling isn't new to Java 6 (as you'll see in a minute, 
PriorityQueue had a poll() method before Java 6), it is new to TreeSet and 
TreeMap. The idea of polling is that we want both to retrieve and remove an 
element from either the beginning or the end of a collection. In the case of TreeSet, 
pollFirst() returns and removes the first entry in the set, and pollLast() 
returns and removes the last. Similarly, TreeMap now provides pollFirstEntry() 
and pollLastEntry() to retrieve and remove key-value pairs. Descending Order
Also new to Java 6 for TreeSet and TreeMap are methods that return a collection 
in the reverse order of the collection on which the method was invoked. The 
important methods for the exam are TreeSet.descendingSet() and TreeMap
.descendingMap(). Table 7-4 summarizes the "navigation" methods you'll need to know for the exam. TABLE 7-4    Important "Navigation" Related Methods
Method Description
TreeSet.ceiling(e) Returns the lowest element >= e
TreeMap.ceilingKey(key) Returns the lowest key >= key
TreeSet.higher(e) Returns the lowest element > e
TreeMap.higherKey(key) Returns the lowest key > key
TreeSet.floor(e) Returns the highest element <= e
TreeMap.floorKey(key) Returns the highest key <= key
TreeSet.lower(e) Returns the highest element < e
TreeMap.lowerKey(key) Returns the highest key < key
TreeSet.pollFirst() Returns and removes the first entry
TreeMap.pollFirstEntry() Returns and removes the first key-value pair
TreeSet.pollLast() Returns and removes the last entry
TreeMap.pollLastEntry() Returns and removes the last key-value pair
TreeSet.descendingSet() Returns a NavigableSet in reverse order
TreeMap.descendingMap() Returns a NavigableMap in reverse order
Backed Collections
Some of the classes in the java.util package support the concept of "backed collections". We'll use a little code to help explain the idea:
    TreeMap<String, String> map = new TreeMap<String, String>();
    map.put("a", "ant"); map.put("d", "dog"); map.put("h", "horse");
    SortedMap<String, String> submap;
    submap = map.subMap("b", "g");              // #1 create a backed collection
    System.out.println(map + " " + submap);     // #2 show contents
    map.put("b", "bat");                        // #3 add to original
    submap.put("f", "fish");                    // #4 add to copy
    map.put("r", "raccoon");                    // #5 add to original - out of range
    // submap.put("p", "pig");                  // #6 add to copy - out of range
    System.out.println(map + " " + submap);     // #7 show final contents
This should produce something like this:
    {a=ant, d=dog, h=horse} {d=dog}
    {a=ant, b=bat, d=dog, f=fish, h=horse, r=raccoon} {b=bat, d=dog, f=fish}
The important method in this code is the TreeMap.subMap() method. It's easy 
to guess (and it's correct), that the subMap() method is making a copy of a portion 
of the TreeMap named map. The first line of output verifies the conclusions we've 
just drawn. What happens next is powerful and a little bit unexpected (now we're getting to 
why they're called backed collections). When we add key-value pairs to either the 
original TreeMap or the partial-copy SortedMap, the new entries were automatically 
added to the other collection—sometimes. When submap was created, we provided 
a value range for the new collection. This range defines not only what should be 
included when the partial copy is created, but also defines the range of values that 
can be added to the copy. As we can verify by looking at the second line of output, 
we can add new entries to either collection within the range of the copy, and the 
new entries will show up in both collections. In addition, we can add a new entry 
to the original collection, even if it's outside the range of the copy. In this case, the 
new entry will show up only in the original—it won't be added to the copy because 
it's outside the copy's range. Notice that we commented out line #6. If you attempt 
to add an out-of-range entry to the copied collection an exception will be thrown. Backed Collections 589
590 Chapter 7:  Generics and Collections
For the exam, you'll need to understand the basics just explained, plus a few 
more details about three methods from TreeSet—(headSet(), subSet(), and 
tailSet()), and three methods from TreeMap (headMap(), subMap(), and 
tailMap()). As with the navigation-oriented methods we just discussed, we 
can see a lot of parallels between the TreeSet and the TreeMap methods. The 
headSet() / headMap() methods create a subset that starts at the beginning of the 
original collection and ends at the point specified by the method's argument. The 
tailSet() / tailMap() methods create a subset that starts at the point specified 
by the method's argument and goes to the end of the original collection. Finally, the 
subSet() / subMap() methods allow you to specify both the start and end points for 
the subset collection you're creating. As you might expect, the question of whether the subsetted collection's end 
points are inclusive or exclusive is a little tricky. The good news is that for the exam 
you have to remember only that when these methods are invoked with endpoint 
and boolean arguments, the boolean always means "is inclusive?". A little more good 
news is that all you have to know for the exam is that unless specifically indicated by 
a boolean argument, a subset's starting point will always be inclusive. Finally, you'll 
notice when you study the API that all of the methods we've been discussing here 
have an overloaded version that's new to Java 6. The older methods return either a 
SortedSet or a SortedMap, the new Java 6 methods return either a NavigableSet or a 
NavigableMap. Table 7-5 summarizes these methods. *  NOTE: These boolean arguments are optional. If they exist it’s a Java 6 method that lets you specify whether the endpoint 
is exclusive, and these methods return a NavigableXxx. If the boolean argument(s) don’t exist, the method returns either 
a SortedSet or a SortedMap. TABLE 7-5   Important "Backed Collection" Methods for TreeSet and TreeMap
Method Description
headSet(e, b*) Returns a subset ending at element e and exclusive of e
headMap(k, b*) Returns a submap ending at key k and exclusive of key k
tailSet(e, b*) Returns a subset starting at and inclusive of element e
tailMap(k, b*) Returns a submap starting at and inclusive of key k
subSet(s, b*, e, b*) Returns a subset starting at element s and ending just before element e
subMap(s, b*, e, b*) Returns a submap starting at key s and ending just before key s
Using the PriorityQueue Class
The last collection class you'll need to understand for the exam is the PriorityQueue. Unlike basic queue structures that are first-in, first-out by default, a PriorityQueue 
orders its elements using a user-defined priority. The priority can be as simple as 
natural ordering (in which, for instance,  an entry of 1 would be a higher priority 
than an entry of 2). In addition, a PriorityQueue can be ordered using a Comparator, 
which lets you define any ordering you want. Queues have a few methods not found 
in other collection interfaces: peek(), poll(), and offer(). import java.util.*;
class PQ {
  static class PQsort 
          implements Comparator<Integer> {  // inverse sort
    public int compare(Integer one, Integer two) {
      return two - one;                     // unboxing
    }
  }
  public static void main(String[] args) {
    int[] ia = {1,5,3,7,6,9,8 };            // unordered data
    PriorityQueue<Integer> pq1 =
      new PriorityQueue<Integer>();         // use natural order
    for(int x : ia)                         // load queue
Backed Collections 591
Let’s say that you’ve created a backed collection using either a tailXxx() 
or subXxx() method. Typically in these cases the original and copy collections have 
different “ﬁ rst” elements. For the exam it’s important that you remember that the 
pollFirstXxx() methods will always remove the ﬁ  rst entry from the collection on which 
they’re invoked, but they will remove an element from the other collection only if it has 
same value. So it’s most likely that invoking pollFirstXxx() on the copy will remove an 
entry from both collections, but invoking pollFirstXxx() on the original will remove only 
the entry from the original. 592 Chapter 7:  Generics and Collections
      pq1.offer(x);
    for(int x : ia)                         // review queue
      System.out.print(pq1.poll() + " ");    
    System.out.println("");
    PQsort pqs = new PQsort();              // get a Comparator
    PriorityQueue<Integer> pq2 = 
      new PriorityQueue<Integer>(10,pqs);   // use Comparator
    for(int x : ia)                         // load queue
      pq2.offer(x);
    System.out.println("size " + pq2.size());
    System.out.println("peek " + pq2.peek());
    System.out.println("size " + pq2.size());
    System.out.println("poll " + pq2.poll());
    System.out.println("size " + pq2.size());
    for(int x : ia)                         // review queue
      System.out.print(pq2.poll() + " ");  
  }
}
This code produces something like this:
1 3 5 6 7 8 9 
size 7
peek 9
size 7
poll 9
size 6
8 7 6 5 3 1 null
Let's look at this in detail. The first for loop iterates through the ia array, and 
uses the offer() method to add elements to the PriorityQueue named pq1. The 
second for loop iterates through pq1 using the poll() method, which returns 
the highest priority entry in pq1 AND removes the entry from the queue. Notice 
that the elements are returned in priority order (in this case, natural order). Next, 
we create a Comparator—in this case, a Comparator that orders elements in the 
opposite of natural order. We use this Comparator to build a second PriorityQueue, 
pq2, and we load it with the same array we used earlier. Finally, we check the size of 
pq2 before and after calls to peek() and poll(). This confirms that peek() returns 
the highest priority element in the queue without removing it, and poll() returns 
the highest priority element, AND removes it from the queue. Finally, we review the 
remaining elements in the queue. Method Overview for Arrays and Collections
For these two classes, we've already covered the trickier methods you might 
encounter on the exam. Table 7-6 lists a summary of the methods you should be 
aware of. (Note: The T[] syntax will be explained later in this chapter; for now, 
think of it as meaning "any array that's NOT an array of primitives.") 
Backed Collections 593
 
Key Methods in java.util.Arrays Descriptions
static List asList(T[]) Convert an array to a List (and bind them). static int binarySearch(Object[], key)
static int binarySearch(primitive[], key)
Search a sorted array for a given value, return 
an index or insertion point. static int binarySearch(T[], key, Comparator) Search a Comparator-sorted array for a value. static boolean equals(Object[], Object[])
static boolean equals(primitive[], primitive[])
Compare two arrays to determine if their 
contents are equal. public static void sort(Object[ ] )
public static void sort(primitive[ ] )
Sort the elements of an array by natural 
order. public static void sort(T[], Comparator) Sort the elements of an array using a 
Comparator. public static String toString(Object[])
public static String toString(primitive[])
Create a String containing the contents of 
an array. Key Methods in java.util.Collections Descriptions
static int binarySearch(List, key)
static int binarySearch(List, key, Comparator)
Search a "sorted" List for a given value, 
return an index or insertion point. static void reverse(List) Reverse the order of elements in a List. static Comparator reverseOrder() 
static Comparator reverseOrder(Comparator)
Return a Comparator that sorts the reverse of 
the collection’s current sort sequence. static void sort(List)
static void sort(List, Comparator)
Sort a List either by natural order or by a 
Comparator. TABLE 7-6    Key Methods in Arrays and Collections
594 Chapter 7:  Generics and Collections
Method Overview for List, Set, Map, and Queue 
For these four interfaces, we've already covered the trickier methods you might 
encounter on the exam. Table 7-7 lists a summary of the List, Set, and Map methods 
you should be aware of, but don't forget the new "Navigable" methods floor, lower, 
ceiling, and higher that we discussed a few pages back. For the exam, the PriorityQueue methods that are important to understand are 
offer() (which is similar to add()), peek() (which retrieves the element at the 
head of the queue, but doesn't delete it), and poll() (which retrieves the head 
element and removes it from the queue). TABLE 7-7    Key Methods in List, Set, and Map
 
Key Interface Methods List Set Map Descriptions
boolean add(element)
boolean add(index, element)
X
X
X Add an element. For Lists, optionally 
add the element at an index point. boolean contains(object)
boolean containsKey(object key)
boolean containsValue(object value)
XX
X
X
Search a collection for an object (or, 
optionally for Maps a key), return the 
result as a boolean. object get(index)
object get(key)
X
X
Get an object from a collection, via an 
index or a key. int indexOf(object) X Get the location of an object in a List. Iterator iterator() XX Get an Iterator for a List or a Set. Set keySet() X Return a Set containing a Map’s keys. put(key, value) X Add a key/value pair to a Map. remove(index)
remove(object)
remove(key)
X
X X
X
Remove an element via an index, or 
via the element’s value, or via a key. int size() XXX Return the number of elements in a 
collection. Object[] toArray()
T[] toArray(T[])
XX Return an array containing the 
elements of the collection. CERTIFICATION OBJECTIVE
Generic T ypes (Objectives 6.3 and 6.4)
6.3 Write code that uses the generic versions of the Collections API, in particular the Set, 
List, and Map interfaces and implementation classes. Recognize the limitations of the non-
generic Collections API and how to refactor code to use the generic versions. 6.4 Develop code that makes proper use of type parameters in class/interface declarations, 
instance variables, method arguments, and return types; and write generic methods or 
methods that make use of wildcard types and understand the similarities and differences 
between these two approaches. Write code that uses the NavigableSet and NavigableMap 
interfaces. Generics Type (Exam Objectives 6.3 and 6.4) 595
It’s important to know some of the details of natural ordering. The 
following code will help you understand the relative positions of uppercase characters, 
lowercase characters, and spaces in a natural ordering:
String[] sa = {">ff<", "> f<", ">f <", ">FF<" }; // ordered? PriorityQueue<String> pq3 = new PriorityQueue<String>();
for(String s : sa)
  pq3.offer(s);
for(String s : sa)
  System.out.print(pq3.poll() + " ");
This produces
> f< >FF< >f < >ff<
If you remember that spaces sort before characters and that uppercase 
letters sort before lowercase characters, you should be good to go for the exam. 596 Chapter 7:  Generics and Collections
Arrays in Java have always been type safe—an array declared as type String (String 
[]) can't accept Integers (or ints), Dogs, or anything other than Strings. But 
remember that before Java 5 there was no syntax for declaring a type safe collection. To make an ArrayList of Strings, you said,
ArrayList myList = new ArrayList();
or, the polymorphic equivalent
List myList = new ArrayList();
There was no syntax that let you specify that myList will take Strings and only 
Strings. And with no way to specify a type for the ArrayList, the compiler couldn't 
enforce that you put only things of the specified type into the list. As of Java 5, 
we can use generics, and while they aren't only for making type safe collections, 
that's just about all most developers use generics for. So, while generics aren't just 
for collections, think of collections as the overwhelming reason and motivation for 
adding generics to the language. And it was not an easy decision, nor has it been an entirely welcome addition. Because along with all the nice happy type safety, generics come with a lot of 
baggage—most of which you'll never see or care about, but there are some gotchas 
that come up surprisingly quickly. We'll cover the ones most likely to show up in 
your own code, and those are also the issues that you'll need to know for the exam. The biggest challenge for Sun in adding generics to the language (and the 
main reason it took them so long) was how to deal with legacy code built without 
generics. Sun's Java engineers obviously didn't want to break everyone's existing 
Java code, so they had to find a way for Java classes with both type safe (generic) 
and non-type safe (non-generic/pre-Java 5) collections to still work together. Their 
solution isn't the friendliest, but it does let you use older non-generic code, as well 
as use generic code that plays with non-generic code. But notice we said "plays," and 
not "plays WELL."
While you can integrate Java 5 and Java 6 generic code with legacy non-generic 
code, the consequences can be disastrous, and unfortunately, most of the disasters 
happen at runtime, not compile time. Fortunately, though, most compilers will 
generate warnings to tell you when you're using unsafe (meaning non-generic) 
collections. The Java 5 exam covers both pre-Java 5 (non-generic) and Java 5 style 
collections, and you'll see questions that expect you to understand the tricky 
problems that can come from mixing non-generic and generic code together. And 
like some of the other topics in this book, you could fill an entire book if you really 
wanted to cover every detail about generics, but the exam (and this book) covers 
more than most developers will ever need to use. The Legacy Way to Do Collections
Here's a review of a pre-Java 5 ArrayList intended to hold Strings. (We say 
"intended" because that's about all you had—good intentions—to make sure that 
the ArrayList would hold only Strings). List myList = new ArrayList();  // can't declare a type
myList.add("Fred");             // OK, it will hold Strings
myList.add(new Dog());          // and it will hold Dogs too
myList.add(new Integer(42));    // and Integers... A non-generic collection can hold any kind of object! A non-generic collection 
is quite happy to hold anything that is NOT a primitive. This meant it was entirely up to the programmer to be…careful. Having no way 
to guarantee collection type wasn't very programmer-friendly for such a strongly 
typed language. We're so used to the compiler stopping us from, say, assigning an int 
to a boolean reference or a String to a Dog reference, but with collections, it was, 
"Come on in! The door is always open! All objects are welcome here any time!"
And since a collection could hold anything, the methods that get objects out 
of the collection could have only one kind of return type—java.lang.Object. That 
meant that getting a String back out of our only-Strings-intended list required a cast:
String s = (String) myList.get(0);
And since you couldn't guarantee that what was coming out really was a String 
(since you were allowed to put anything in the list), the cast could fail at runtime. So, generics takes care of both ends (the putting in and getting out) by enforcing 
the type of your collections. Let's update the String list:
List<String> myList = new ArrayList<String>();
myList.add("Fred");        // OK, it will hold Strings
myList.add(new Dog());     // compiler error!! Generics Type (Exam Objectives 6.3 and 6.4) 597
598 Chapter 7:  Generics and Collections
Perfect. That's exactly what we want. By using generics syntax—which means 
putting the type in angle brackets <String>, we're telling the compiler that this 
collection can hold only String objects. The type in angle brackets is referred to as 
either the "parameterized type," "type parameter," or of course just old-fashioned 
"type." In this chapter, we'll refer to it both new ways. So, now that what you put IN is guaranteed, you can also guarantee what comes 
OUT, and that means you can get rid of the cast when you get something from the 
collection. Instead of
String s = (String)myList.get(0);  // pre-generics, when a
                                   // String wasn't guaranteed
we can now just say
String s = myList.get(0);
The compiler already knows that myList contains only things that can be 
assigned to a String reference, so now there's no need for a cast. So far, it seems 
pretty simple. And with the new for loop, you can of course iterate over the 
guaranteed-to-be-String list:
for (String s : myList) {
   int x = s.length();
   // no need for a cast before calling a String method! The
   // compiler already knew "s" was a String coming from MyList
}
And of course you can declare a type parameter for a method argument, which 
then makes the argument a type safe reference:
void takeListOfStrings(List<String> strings) {
    strings.add("foo");  // no problem adding a String
}
The method above would NOT compile if we changed it to
void takeListOfStrings(List<String> strings) {
   strings.add(new Integer(42)); // NO!! strings is type safe
}
Return types can obviously be declared type safe as well:
public List<Dog> getDogList() {
    List<Dog> dogs = new ArrayList<Dog>();
    // more code to insert dogs
    return dogs;
}
The compiler will stop you from returning anything not compatible with a 
List<Dog> (although what is and is not compatible is going to get very interesting 
in a minute). And since the compiler guarantees that only a type safe Dog List is 
returned, those calling the method won't need a cast to take Dogs from the List:
Dog d = getDogList().get(0);  // we KNOW a Dog is coming out
With pre-Java 5, non-generic code, the getDogList() method would be
public List getDogList() {
    List dogs = new ArrayList();
     // code to add only Dogs... fingers crossed... return dogs; // a List of ANYTHING will work here
}
and the caller would need a cast:
Dog d = (Dog) getDogList().get(0);
(The cast in this example applies to what comes from the List's get() method; we 
aren't casting what is returned from the getDogList() method, which is a List.)
But what about the benefit of a completely heterogeneous collection? In other 
words, what if you liked the fact that before generics you could make an ArrayList 
that could hold any kind of object? List myList = new ArrayList();  // old-style, non-generic
is almost identical to
List<Object> myList = new 
                 ArrayList<Object>(); // holds ANY object type
Generics Type (Exam Objectives 6.3 and 6.4) 599
600 Chapter 7:  Generics and Collections
Declaring a List with a type parameter of <Object> makes a collection that works 
in almost the same way as the original pre-Java 5, non-generic collection—you can 
put ANY Object type into the collection. You'll see a little later that non-generic 
collections and collections of type <Object> aren't entirely the same, but most of 
the time the differences do not matter. Oh, if only this were the end of the story...but there are still a few tricky issues 
with methods arguments, polymorphism, and integrating generic and non-generic 
code, so we're just getting warmed up here. Generics and Legacy Code
The easiest generics thing you'll need to know for the exam is how to update 
non-generic code to make it generic. You just add a type in angle brackets (<>) 
immediately following the collection type in BOTH the variable declaration and the 
constructor call, including any place you declare a variable (so that means arguments 
and return types too). A pre-Java 5 List meant to hold only Integers:
List myList = new ArrayList();
becomes
List<Integer> myList = new ArrayList<Integer>();
and a list meant to hold only Strings goes from
public List changeStrings(ArrayList s) { }
to this:
public List<String> changeStrings(ArrayList<String> s) { }
Easy. And if there's code that used the earlier non-generic version and performed 
a cast to get things out, that won't break anyone's code:
Integer i = (Integer) list.get(0); // cast no longer needed, 
                                   // but it won't hurt
Mixing Generic and Non-generic Collections
Now here's where it starts to get interesting…imagine we have an ArrayList, of type 
Integer, and we're passing it into a method from a class whose source code we don't 
have access to. Will this work? // a Java 5 class using a generic collection
import java.util.*;
public class TestLegacy {
    public static void main(String[] args) {
        List<Integer> myList = new ArrayList<Integer>(); 
                                     // type safe collection
        myList.add(4);
        myList.add(6);
        Adder adder = new Adder();
        int total = adder.addAll(myList); 
                              // pass it to an untyped argument
        System.out.println(total);
    }
}
The older, non-generics class we want to use:
import java.util.*;
class Adder {
   int addAll(List list) {
      // method with a non-generic List argument,
      // but assumes (with no guarantee) that it will be Integers
      Iterator it = list.iterator();
      int total = 0;
      while (it.hasNext()) {
        int i = ((Integer)it.next()).intValue();
        total += i;
      }
      return total;
   }
}
Yes, this works just fine. You can mix correct generic code with older non-generic 
code, and everyone is happy. In the previous example, the addAll() legacy method assumed (trusted? hoped?) 
that the list passed in was indeed restricted to Integers, even though when the code 
was written, there was no guarantee. It was up to the programmers to be careful. Mixing Generic and Non-generic Collections (Exam Objectives 6.3 and 6.4) 601
602 Chapter 7:  Generics and Collections
Since the addAll() method wasn't doing anything except getting the Integer 
(using a cast) from the list and accessing its value, there were no problems. In that 
example, there was no risk to the caller's code, but the legacy method might have 
blown up if the list passed in contained anything but Integers (which would cause a 
ClassCastException). But now imagine that you call a legacy method that doesn't just read a value but 
adds something to the ArrayList? Will this work? import java.util.*;
public class TestBadLegacy {
    public static void main(String[] args) {
        List<Integer> myList = new ArrayList<Integer>();
        myList.add(4);
        myList.add(6);
        Inserter in  = new Inserter();
        in.insert(myList);  // pass List<Integer> to legacy code
      }
}
class Inserter {
     // method with a non-generic List argument
     void insert(List list) {
       list.add(new Integer(42)); // adds to the incoming list
    }
}
Sure, this code works. It compiles, and it runs. The insert() method puts an 
Integer into the list that was originally typed as <Integer>, so no problem. But…what if we modify the insert() method like this:
void insert(List list) {
   list.add(new String("42"));  // put a String in the list 
                                // passed in
}
Will that work? Yes, sadly, it does!

--- Chunk #1495 ---
It both compiles and runs. No runtime 
exception. Yet, someone just stuffed a String into a supposedly type safe ArrayList of 
type <Integer>. How can that be? Remember, the older legacy code was allowed to put anything at all (except 
primitives) into a collection. And in order to support legacy code, Java 5 and Java 6 
allows your newer type safe code to make use of older code (the last thing Sun wanted 
to do was ask several million Java developers to modify all their existing code). So, the Java 5 or Java 6 compiler is forced into letting you compile your new type 
safe code even though your code invokes a method of an older class that takes a 
non-type safe argument and does who knows what with it. However, just because the Java 5 compiler allows this code to compile doesn't 
mean it has to be HAPPY about it. In fact the compiler will warn you that you're 
taking a big, big risk sending your nice protected ArrayList<Integer> into a 
dangerous method that can have its way with your list and put in Floats, Strings, or 
even Dogs. When you called the addAll() method in the earlier example, it didn't insert 
anything to the list (it simply added up the values within the collection), so there 
was no risk to the caller that his list would be modified in some horrible way. It 
compiled and ran just fine. But in the second version, with the legacy insert() 
method that adds a String, the compiler generated a warning:
javac TestBadLegacy.java
Note: TestBadLegacy.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. Remember that compiler warnings are NOT considered a compiler failure. The 
compiler generated a perfectly valid class file from the compilation, but it was 
kind enough to tell you by saying, in so many words, "I seriously hope you know 
what you are doing because this old code has NO respect (or even knowledge) of 
your <Integer> typing, and can do whatever the heck it wants to your precious 
ArrayList<Integer>."
Back to our example with the legacy code that does an insert, keep in mind that 
for BOTH versions of the insert() method (one that adds an Integer and one that 
adds a String) the compiler issues warnings. The compiler does NOT know whether 
Mixing Generic and Non-generic Collections (Exam Objectives 6.3 and 6.4) 603
Be sure you know the difference between "compilation fails" 
and "compiles without error" and "compiles without warnings" and "compiles 
with warnings." In most questions on the exam, you care only about compiles vs. compilation fails—compiler warnings don’t matter for most of the exam. But when 
you are using generics, and mixing both typed and untyped code, warnings matter. 604 Chapter 7:  Generics and Collections
the insert() method is adding the right thing (Integer) or wrong thing (String). The reason the compiler produces a warning is because the method is ADDING 
something to the collection! In other words, the compiler knows there's a chance 
the method might add the wrong thing to a collection the caller thinks is type safe. So far, we've looked at how the compiler will generate warnings if it sees that 
there's a chance your type safe collection could be harmed by older, non-type-safe 
code. But one of the questions developers often ask is, "Okay, sure, it compiles, but 
why does it RUN? Why does the code that inserts the wrong thing into my list 
work at runtime?" In other words, why does the JVM let old code stuff a String into 
your ArrayList<Integer>, without any problems at all? No exceptions, nothing. Just 
a quiet, behind-the-scenes, total violation of your type safety that you might not 
discover until the worst possible moment. There's one Big Truth you need to know to understand why it runs without 
problems—the JVM has no idea that your ArrayList was supposed to hold only 
Integers. The typing information does not exist at runtime! All your generic code 
is strictly for the compiler. Through a process called "type erasure," the compiler 
does all of its verifications on your generic code and then strips the type information 
out of the class bytecode. At runtime, ALL collection code—both legacy and new 
Java 5 code you write using generics—looks exactly like the pre-generic version of 
collections. None of your typing information exists at runtime. In other words, even 
though you WROTE
List<Integer> myList = new ArrayList<Integer>();
For the purposes of the exam,  unless the question includes an answer that 
mentions warnings, then even if you know compilation will produce warnings, that is still a 
successful compile! Compiling with warnings is NEVER considered a compilation failure. One more time—if you see code that you know will compile with 
warnings, you must NOT choose "Compilation fails." as an answer. The bottom line is 
this: code that compiles with warnings is still a successful compile. If the exam question 
wants to test your knowledge of whether code will produce a warning (or what you can 
do to the code to ELIMINATE warnings), the question (or answer) will explicitly include 
the word "warnings."
By the time the compiler is done with it, the JVM sees what it always saw before 
Java 5 and generics:
List myList = new ArrayList();
The compiler even inserts the casts for you—the casts you had to do to get things 
out of a pre-Java 5 collection. Think of generics as strictly a compile-time protection. The compiler uses generic 
type information (the <type> in the angle brackets) to make sure that your code 
doesn't put the wrong things into a collection, and that you do not assign what you 
get from a collection to the wrong reference type. But NONE of this protection 
exists at runtime. This is a little different from arrays, which give you BOTH compile-time 
protection and runtime protection. Why did they do generics this way? Why is there 
no type information at runtime? To support legacy code. At runtime, collections 
are collections just like the old days. What you gain from using generics is compile-
time protection that guarantees that you won't put the wrong thing into a typed 
collection, and it also eliminates the need for a cast when you get something out, 
since the compiler already knows that only an Integer is coming out of an Integer list. The fact is, you don't NEED runtime protection…until you start mixing up 
generic and non-generic code, as we did in the previous example. Then you can 
have disasters at runtime. The only advice we have is to pay very close attention to 
those compiler warnings:
javac TestBadLegacy.java
Note: TestBadLegacy.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. This compiler warning isn't very descriptive, but the second note suggests that 
you recompile with -Xlint:unchecked. If you do, you'll get something like this:
javac -Xlint:unchecked TestBadLegacy.java
TestBadLegacy.java:17: warning: [unchecked] unchecked call to 
add(E) as a member of the raw type java.util.List
       list.add(new String("42"));
               ^
1 warning
When you compile with the -Xlint:unchecked flag, the compiler shows you 
exactly which method(s) might be doing something dangerous. In this example, 
Mixing Generic and Non-generic Collections (Exam Objectives 6.3 and 6.4) 605
606 Chapter 7:  Generics and Collections
since the list argument was not declared with a type, the compiler treats it as legacy 
code and assumes no risk for what the method puts into the "raw" list. On the exam, you must be able to recognize when you are compiling code that 
will produce warnings but still compile. And any code that compiles (even with 
warnings) will run! No type violations will be caught at runtime by the JVM, until 
those type violations mess with your code in some other way. In other words, the act 
of adding a String to an <Integer> list won't fail at runtime until you try to treat that 
String-you-think-is-an-Integer as an Integer. For example, imagine you want your code to pull something out of your supposedly 
type safe ArrayList<Integer> that older code put a String into. It compiles (with 
warnings). It runs...or at least the code that actually adds the String to the list runs. But when you take the String-that-wasn't-supposed-to-be-there out of the list, and 
try to assign it to an Integer reference or invoke an Integer method, you're dead. Keep in mind, then, that the problem of putting the wrong thing into a typed 
(generic) collection does not show up at the time you actually do the add() to the 
collection. It only shows up later, when you try to use something in the list and it 
doesn't match what you were expecting. In the old (pre-Java 5) days, you always 
assumed that you might get the wrong thing out of a collection (since they were all 
non-type safe), so you took appropriate defensive steps in your code. The problem 
with mixing generic with non-generic code is that you won't be expecting those 
problems if you have been lulled into a false sense of security by having written type 
safe code. Just remember that the moment you turn that type safe collection over to 
older, non-type safe code, your protection vanishes. Again, pay very close attention to compiler warnings, and be prepared to see 
issues like this come up on the exam. When using legacy (non-type safe) collections—watch out for unboxing 
problems! If you declare a non-generic collection, the get() method ALWAYS returns a 
reference of type java.lang.Object. Remember that unboxing can’t convert a plain old 
Object to a primitive, even if that Object reference refers to an Integer (or some other 
wrapped primitive) on the heap. Unboxing converts only from a wrapper class reference 
(like an Integer or a Long) to a primitive. Polymorphism and Generics
Generic collections give you the same benefits of type safety that you've always had 
with arrays, but there are some crucial differences that can bite you if you aren't 
prepared. Most of these have to do with polymorphism. You've already seen that polymorphism applies to the "base" type of the 
collection:
List<Integer> myList = new ArrayList<Integer>();
In other words, we were able to assign an ArrayList to a List reference, because 
List is a supertype of ArrayList. Nothing special there—this polymorphic assignment 
works the way it always works in Java, regardless of the generic typing. But what about this? class Parent { }
class Child extends Parent { }
List<Parent> myList = new ArrayList<Child>();
Think about it for a minute. Keep thinking... Polymorphism and Generics (Exam Objectives 6.3 and 6.4) 607
Unboxing gotcha, continued:
List test = new ArrayList();
test.add(43);
int x = (Integer)test.get(0);    // you must cast !! List<Integer> test2 = new ArrayList<Integer>();
test2.add(343);
int x2 = test2.get(0);           // cast not necessary
Watch out for missing casts associated with pre-Java 5,  
non-generic collections. 608 Chapter 7:  Generics and Collections
No, it doesn't work. There's a very simple rule here—the type of the variable 
declaration must match the type you pass to the actual object type. If you declare 
List<Foo> foo then whatever you assign to the foo reference MUST be of the 
generic type <Foo>. Not a subtype of <Foo>. Not a supertype of <Foo>. Just <Foo>. These are wrong:
List<Object> myList = new ArrayList<JButton>();  // NO! List<Number> numbers = new ArrayList<Integer>(); // NO! // remember that Integer is a subtype of Number
But these are fine:
List<JButton> myList = new ArrayList<JButton>(); // yes
List<Object> myList = new ArrayList<Object>();   // yes
List<Integer> myList = new ArrayList<Integer>(); // yes
So far so good. Just keep the generic type of the reference and the generic type 
of the object to which it refers identical. In other words, polymorphism applies here 
to only the "base" type. And by "base," we mean the type of the collection class 
itself—the class that can be customized with a type. In this code,
List<JButton> myList = new ArrayList<JButton>();
List and ArrayList are the base type and JButton is the generic type. So an ArrayList 
can be assigned to a List, but a collection of <JButton> cannot be assigned to a 
reference of <Object>, even though JButton is a subtype of Object. The part that feels wrong for most developers is that this is NOT how it works 
with arrays, where you are allowed to do this,
import java.util.*;
class Parent { }
class Child extends Parent { }
public class TestPoly {
    public static void main(String[] args) {
        Parent[] myArray = new Child[3];  // yes
    }
}
which means you're also allowed to do this
Object[] myArray = new JButton[3];  // yes
but not this:
List<Object> list = new ArrayList<JButton>();  // NO! Why are the rules for typing of arrays different from the rules for generic 
typing? We'll get to that in a minute. For now, just burn it into your brain that 
polymorphism does not work the same way for generics as it does with arrays. Generic Methods
If you weren't already familiar with generics, you might be feeling very 
uncomfortable with the implications of the previous no-polymorphic-assignment-
for-generic-types thing. And why shouldn't you be uncomfortable? One of the 
biggest benefits of polymorphism is that you can declare, say, a method argument of a 
particular type and at runtime be able to have that argument refer to any subtype—
including those you'd never known about at the time you wrote the method with the 
supertype argument. For example, imagine a classic (simplified) polymorphism example of a 
veterinarian (AnimalDoctor) class with a method checkup(). And right now, 
you have three Animal subtypes—Dog, Cat, and Bird—each implementing the 
abstract checkup() method from Animal:
abstract class Animal {
    public abstract void checkup();
}
class Dog extends Animal {
    public void checkup() {   // implement Dog-specific code
      System.out.println("Dog checkup");
    }
}
class Cat extends Animal {
    public void checkup() {   // implement Cat-specific code
      System.out.println("Cat checkup");
    }
}
class Bird extends Animal {
    public void checkup() {   // implement Bird-specific code
      System.out.println("Bird checkup");
}   }
Generic Methods (Exam Objectives 6.3 and 6.4) 609
610 Chapter 7:  Generics and Collections
Forgetting collections/arrays for a moment, just imagine what the AnimalDoctor 
class needs to look like in order to have code that takes any kind of Animal and 
invokes the Animal checkup() method. Trying to overload the AnimalDoctor 
class with checkup() methods for every possible kind of animal is ridiculous, and 
obviously not extensible. You'd have to change the AnimalDoctor class every time 
someone added a new subtype of Animal. So in the AnimalDoctor class, you'd probably have a polymorphic method:
public void checkAnimal(Animal a) {
     a.checkup(); // does not matter which animal subtype each
                  // Animal's overridden checkup() method runs
}
And of course we do want the AnimalDoctor to also have code that can take 
arrays of Dogs, Cats, or Birds, for when the vet comes to the dog, cat, or bird kennel. Again, we don't want overloaded methods with arrays for each potential Animal 
subtype, so we use polymorphism in the AnimalDoctor class:
  public void checkAnimals(Animal[] animals) {
      for(Animal a : animals) {
        a.checkup();
      }
    }
Here is the entire example, complete with a test of the array polymorphism that 
takes any type of animal array (Dog[], Cat[], Bird[]). import java.util.*;
abstract class Animal {
     public abstract void checkup();
}
class Dog extends Animal {
    public void checkup() {   // implement Dog-specific code
      System.out.println("Dog checkup");
    }
}
class Cat extends Animal {
   public void checkup() {    // implement Cat-specific code
      System.out.println("Cat checkup");
   }
}
class Bird extends Animal {
   public void checkup() {     // implement Bird-specific code
      System.out.println("Bird checkup");
   }
}
public class AnimalDoctor  {
    // method takes an array of any animal subtype
    public void checkAnimals(Animal[] animals) {
      for(Animal a : animals) {
        a.checkup();
      }
    }
    public static void main(String[] args) {
        // test it
       Dog[] dogs = {new Dog(), new Dog()};
       Cat[] cats = {new Cat(), new Cat(), new Cat()};
       Bird[] birds = {new Bird()};
       AnimalDoctor doc = new AnimalDoctor();
       doc.checkAnimals(dogs);  // pass the Dog[]
       doc.checkAnimals(cats);  // pass the Cat[]
       doc.checkAnimals(birds); // pass the Bird[]
   }
}
This works fine, of course (we know, we know, this is old news). But here's why 
we brought this up as refresher—this approach does NOT work the same way with 
type safe collections! In other words, a method that takes, say, an ArrayList<Animal> will NOT be 
able to accept a collection of any Animal subtype! That means ArrayList<Dog> 
cannot be passed into a method with an argument of ArrayList<Animal>, even 
though we already know that this works just fine with plain old arrays. Obviously this difference between arrays and ArrayList is consistent with the 
polymorphism assignment rules we already looked at—the fact that you cannot 
assign an object of type ArrayList<JButton> to a List<Object>. But this is where 
you really start to feel the pain of the distinction between typed arrays and typed 
collections. We know it won't work correctly, but let's try changing the AnimalDoctor code 
to use generics instead of arrays:
public class AnimalDoctorGeneric  {
Generic Methods (Exam Objectives 6.3 and 6.4) 611
612 Chapter 7:  Generics and Collections
    // change the argument from Animal[] to ArrayList<Animal>
    public void checkAnimals(ArrayList<Animal> animals) {
      for(Animal a : animals) {
        a.checkup();
      }
    }
    public static void main(String[] args) {
       // make ArrayLists instead of arrays for Dog, Cat, Bird
       List<Dog> dogs = new ArrayList<Dog>();
       dogs.add(new Dog());
       dogs.add(new Dog());
       List<Cat> cats = new ArrayList<Cat>();
       cats.add(new Cat());
       cats.add(new Cat());
       List<Bird> birds = new ArrayList<Bird>();
       birds.add(new Bird());
       // this code is the same as the Array version
       AnimalDoctorGeneric doc = new AnimalDoctorGeneric();
       // this worked when we used arrays instead of ArrayLists
       doc.checkAnimals(dogs);  // send a List<Dog>
       doc.checkAnimals(cats);  // send a List<Cat>
       doc.checkAnimals(birds); // send a List<Bird>
    }
}
So what does happen? javac AnimalDoctorGeneric.java
AnimalDoctorGeneric.java:51: checkAnimals(java.util. ArrayList<Animal>) in AnimalDoctorGeneric cannot be applied to 
(java.util.List<Dog>)
       doc.checkAnimals(dogs);
          ^
AnimalDoctorGeneric.java:52: checkAnimals(java.util. ArrayList<Animal>) in AnimalDoctorGeneric cannot be applied to 
(java.util.List<Cat>)
       doc.checkAnimals(cats);
          ^
AnimalDoctorGeneric.java:53: checkAnimals(java.util. ArrayList<Animal>) in AnimalDoctorGeneric cannot be applied to 
(java.util.List<Bird>)
       doc.checkAnimals(birds);
          ^
3 errors
The compiler stops us with errors, not warnings. You simply CANNOT assign 
the individual ArrayLists of Animal subtypes (<Dog>, <Cat>, or <Bird>) to an 
ArrayList of the supertype <Animal>, which is the declared type of the argument. This is one of the biggest gotchas for Java programmers who are so familiar with 
using polymorphism with arrays, where the same scenario (Animal[] can refer to 
Dog[], Cat[], or Bird[]) works as you would expect. So we have two real issues:
1.

--- Chunk #1496 ---
Why doesn't this work? 2.

--- Chunk #1497 ---
How do you get around it? You'd hate us and all of the Sun engineers if we told you that there wasn't a way 
around it—that you had to accept it and write horribly inflexible code that tried to 
anticipate and code overloaded methods for each specific <type>. Fortunately, there 
is a way around it. But first, why can't you do it if it works for arrays? Why can't you pass an 
ArrayList<Dog> into a method with an argument of ArrayList<Animal>? We'll get there, but first let's step way back for a minute and consider this 
perfectly legal scenario:
Animal[] animals = new Animal[3];
animals[0] = new Cat();
animals[1] = new Dog();
Part of the benefit of declaring an array using a more abstract supertype is that the 
array itself can hold objects of multiple subtypes of the supertype, and then you can 
manipulate the array assuming everything in it can respond to the Animal interface 
(in other words, everything in the array can respond to method calls defined in the 
Animal class). So here, we're using polymorphism not for the object that the array 
reference points to, but rather what the array can actually HOLD—in this case, any 
subtype of Animal. You can do the same thing with generics:
List<Animal> animals = new ArrayList<Animal>();
animals.add(new Cat());  // OK
animals.add(new Dog());  // OK
So this part works with both arrays and generic collections—we can add an 
instance of a subtype into an array or collection declared with a supertype. You 
can add Dogs and Cats to an Animal array (Animal[]) or an Animal collection 
(ArrayList<Animal>). Generic Methods (Exam Objectives 6.3 and 6.4) 613
614 Chapter 7:  Generics and Collections
And with arrays, this applies to what happens within a method:
public void addAnimal(Animal[] animals) {
      animals[0] = new Dog();  // no problem, any Animal works 
                               // in Animal[]
}
So if this is true, and if you can put Dogs into an ArrayList<Animal>, then why 
can't you use that same kind of method scenario? Why can't you do this? public void addAnimal(ArrayList<Animal> animals) {
     animals.add(new Dog()); // sometimes allowed... }
Actually, you CAN do this under certain conditions. The code above WILL 
compile just fine IF what you pass into the method is also an ArrayList<Animal>. This is the part where it differs from arrays, because in the array version, you 
COULD pass a Dog[] into the method that takes an Animal[]. The ONLY thing you can pass to a method argument of ArrayList<Animal> is 
an ArrayList<Animal>! (Assuming you aren't trying to pass a subtype of ArrayList, 
since remember—the "base" type can be polymorphic.)
The question is still out there—why is this bad? And why is it bad for ArrayList 
but not arrays? Why can't you pass an ArrayList<Dog> to an argument of 
ArrayList<Animal>? Actually, the problem IS just as dangerous whether you're 
using arrays or a generic collection. It's just that the compiler and JVM behave 
differently for arrays vs. generic collections. The reason it is dangerous to pass a collection (array or ArrayList) of a subtype 
into a method that takes a collection of a supertype, is because you might add 
something. And that means you might add the WRONG thing! This is probably 
really obvious, but just in case (and to reinforce), let's walk through some scenarios. The first one is simple:
public void foo() {
  Dog[] dogs = {new Dog(), new Dog()};
  addAnimal(dogs);  // no problem, send the Dog[] to the method
}
public void addAnimal(Animal[] animals) {
  animals[0] = new Dog();  // ok, any Animal subtype works
}
This is no problem. We passed a Dog[] into the method, and added a Dog to the 
array (which was allowed since the method parameter was type Animal[], which 
can hold any Animal subtype). But what if we changed the calling code to
public void foo() {
  Cat[] cats = {new Cat(), new Cat()};
  addAnimal(cats);  // no problem, send the Cat[] to the method
}
and the original method stays the same:
public void addAnimal(Animal[] animals) {
   animals[0] = new Dog();  // Eeek! We just put a Dog 
                            // in a Cat array! }
The compiler thinks it is perfectly fine to add a Dog to an Animal[] array, since 
a Dog can be assigned to an Animal reference. The problem is, if you passed in an 
array of an Animal subtype (Cat, Dog, or Bird), the compiler does not know. The 
compiler does not realize that out on the heap somewhere is an array of type Cat[], 
not Animal[], and you're about to try to add a Dog to it. To the compiler, you have 
passed in an array of type Animal, so it has no way to recognize the problem. THIS is the scenario we're trying to prevent, regardless of whether it's an array or 
an ArrayList. The difference is, the compiler lets you get away with it for arrays, but 
not for generic collections. The reason the compiler won't let you pass an ArrayList<Dog> into a method 
that takes an ArrayList<Animal>, is because within the method, that parameter is 
of type ArrayList<Animal>, and that means you could put any kind of Animal into 
it. There would be no way for the compiler to stop you from putting a Dog into a 
List that was originally declared as <Cat>, but is now referenced from the <Animal> 
parameter. We still have two questions…how do you get around it and why the heck does 
the compiler allow you to take that risk for arrays but not for ArrayList (or any other 
generic collection)? The reason you can get away with compiling this for arrays is because there is a 
runtime exception (ArrayStoreException) that will prevent you from putting the 
wrong type of object into an array. If you send a Dog array into the method that takes 
an Animal array, and you add only Dogs (including Dog subtypes, of course) into the 
array now referenced by Animal, no problem. But if you DO try to add a Cat to the 
object that is actually a Dog array, you'll get the exception. Generic Methods (Exam Objectives 6.3 and 6.4) 615
616 Chapter 7:  Generics and Collections
But there IS no equivalent exception for generics, because of type erasure! In other words, at runtime the JVM KNOWS the type of arrays, but does NOT 
know the type of a collection. All the generic type information is removed during 
compilation, so by the time it gets to the JVM, there is simply no way to recognize 
the disaster of putting a Cat into an ArrayList<Dog> and vice versa (and it becomes 
exactly like the problems you have when you use legacy, non-type safe code). So this actually IS legal code:
  public void addAnimal(List<Animal> animals) {
      animals.add(new Dog());  // this is always legal, 
                               // since Dog can
                               // be assigned to an Animal 
                               // reference
   }
    public static void main(String[] args) {
       List<Animal> animals = new ArrayList<Animal>();
       animals.add(new Dog());
       animals.add(new Dog());
       AnimalDoctorGeneric doc = new AnimalDoctorGeneric();
       doc.addAnimal(animals); // OK, since animals matches 
                               // the method arg
    }
As long as the only thing you pass to the addAnimals(List<Animal>) is an 
ArrayList<Animal>, the compiler is pleased—knowing that any Animal subtype 
you add will be valid (you can always add a Dog to an Animal collection, yada, yada, 
yada). But if you try to invoke addAnimal() with an argument of any OTHER 
ArrayList type, the compiler will stop you, since at runtime the JVM would have no 
way to stop you from adding a Dog to what was created as a Cat collection. For example, this code that changes the generic type to <Dog>, but without 
changing the addAnimal() method, will NOT compile:
public void addAnimal(List<Animal> animals) {
  animals.add(new Dog());  // still OK as always
}
public static void main(String[] args) {
  List<Dog> animals = new ArrayList<Dog>();
  animals.add(new Dog());
  animals.add(new Dog());
  AnimalDoctorGeneric doc = new AnimalDoctorGeneric();
  doc.addAnimal(animals); // THIS is where it breaks! }
The compiler says something like:
javac AnimalDoctorGeneric.java
AnimalDoctorGeneric.java:49: addAnimal(java.util.List<Animal>) 
in AnimalDoctorGeneric cannot be applied to (java.util. List<Dog>)
       doc.addAnimal(animals);
          ^
1 error
Notice that this message is virtually the same one you'd get trying to invoke 
any method with the wrong argument. It's saying that you simply cannot invoke 
addAnimal(List<Animal>) using something whose reference was declared as 
List<Dog>. (It's the reference type, not the actual object type that matters—but 
remember—the generic type of an object is ALWAYS the same as the generic 
type declared on the reference. List<Dog> can refer ONLY to collections that are 
subtypes of List, but which were instantiated as generic type <Dog>.)
Once again, remember that once inside the addAnimals() method, all that 
matters is the type of the parameter—in this case, List<Animal>. (We changed it 
from ArrayList to List to keep our "base" type polymorphism cleaner.)
Back to the key question—how do we get around this? If the problem is related 
only to the danger of adding the wrong thing to the collection, what about the 
checkup() method that used the collection passed in as read-only? In other words, 
what about methods that invoke Animal methods on each thing in the collection, 
which will work regardless of which kind of ArrayList subtype is passed in? And that's a clue! It's the add() method that is the problem, so what we need 
is a way to tell the compiler, "Hey, I'm using the collection passed in just to invoke 
methods on the elements—and I promise not to ADD anything into the collection." 
And there IS a mechanism to tell the compiler that you can take any generic 
subtype of the declared argument type because you won't be putting anything in the 
collection. And that mechanism is the wildcard <?>. The method signature would change from
public void addAnimal(List<Animal> animals)
to
public void addAnimal(List<? extends Animal> animals)
Generic Methods (Exam Objectives 6.3 and 6.4) 617
618 Chapter 7:  Generics and Collections
By saying <? extends Animal>, we're saying, "I can be assigned a collection 
that is a subtype of List and typed for <Animal> or anything that extends Animal. And oh yes, I SWEAR that I will not ADD anything into the collection."  (There's 
a little more to the story, but we'll get there.)
So of course the addAnimal() method above won't actually compile even with 
the wildcard notation, because that method DOES add something. public void addAnimal(List<? extends Animal> animals) {
      animals.add(new Dog());  // NO! Can't add if we 
                               // use <? extends Animal>
}
You'll get a very strange error that might look something like this:
javac AnimalDoctorGeneric.java
AnimalDoctorGeneric.java:38: cannot find symbol
symbol  : method add(Dog)
location: interface java.util.List<capture of ? extends Animal>
      animals.add(new Dog());
             ^
1 error
which basically says, "you can't add a Dog here." If we change the method so that it 
doesn't add anything, it works. But wait—there's more. (And by the way, everything we've covered in this 
generics section is likely to be tested for on the exam, with the exception of "type 
erasure," for which you aren't required to know any details.)
First, the <? extends Animal> means that you can take any subtype of Animal; 
however, that subtype can be EITHER a subclass of a class (abstract or concrete) 
OR a type that implements the interface after the word extends. In other words, 
the keyword extends in the context of a wildcard represents BOTH subclasses and 
interface implementations. There is no <? implements Serializable> syntax. If 
you want to declare a method that takes anything that is of a type that implements 
Serializable, you'd still use extends like this:
void foo(List<? extends Serializable> list) // odd, but correct 
                                            // to use "extends"
    This looks strange since you would never say this in a class declaration because 
Serializable is an interface, not a class. But that's the syntax, so burn it in! One more time—there is only ONE wildcard keyword that represents both 
interface implementations and subclasses. And that keyword is extends. But when 
you see it, think "Is-a", as in something that passes the instanceof test. However, there is another scenario where you can use a wildcard AND still add to 
the collection, but in a safe way—the keyword super. Imagine, for example, that you declared the method this way:
public void addAnimal(List<? super Dog> animals) {
  animals.add(new Dog());  // adding is sometimes OK with super
}
public static void main(String[] args) {
  List<Animal> animals = new ArrayList<Animal>();
  animals.add(new Dog());
  animals.add(new Dog());
  AnimalDoctorGeneric doc = new AnimalDoctorGeneric();
  doc.addAnimal(animals); // passing an Animal List
}
Now what you've said in this line
public void addAnimal(List<? super Dog> animals)
is essentially, "Hey compiler, please accept any List with a generic type that is of type 
Dog, or a supertype of Dog. Nothing lower in the inheritance tree can come in, but 
anything higher than Dog is OK."
You probably already recognize why this works. If you pass in a list of type 
Animal, then it's perfectly fine to add a Dog to it. If you pass in a list of type Dog, it's 
perfectly fine to add a Dog to it. And if you pass in a list of type Object, it's STILL 
fine to add a Dog to it. When you use the <? super ...> syntax, you are telling 
the compiler that you can accept the type on the right-hand side of super or any 
of its supertypes, since—and this is the key part that makes it work—a collection 
declared as any supertype of Dog will be able to accept a Dog as an element. List<Object> can take a Dog. List<Animal> can take a Dog. And List<Dog> can 
take a Dog. So passing any of those in will work. So the super keyword in wildcard 
notation lets you have a restricted, but still possible way to add to a collection. So, the wildcard gives you polymorphic assignments, but with certain restrictions 
that you don't have for arrays. Quick question: are these two identical? public void foo(List<?> list) { }
public void foo(List<Object> list) { }
Generic Methods (Exam Objectives 6.3 and 6.4) 619
620 Chapter 7:  Generics and Collections
If there IS a difference (and we're not yet saying there is), what is it? There IS a huge difference. List<?>, which is the wildcard <?> without the 
keywords extends or super, simply means "any type." So that means any type of 
List can be assigned to the argument. That could be a List of <Dog>, <Integer>, 
<JButton>, <Socket>, whatever. And using the wildcard alone, without the 
keyword super (followed by a type), means that you cannot ADD anything to the 
list referred to as List<?>. List<Object> is completely different from List<?>. List<Object> means that 
the method can take ONLY a List<Object>. Not a List<Dog>, or a List<Cat>. It does, however, mean that you can add to the list, since the compiler has already 
made certain that you're passing only a valid List<Object> into the method. Based on the previous explanations, figure out if the following will work:
import java.util.*;
public class TestWildcards {
  public static void main(String[] args) {
     List<Integer> myList = new ArrayList<Integer>();
     Bar bar = new Bar();
     bar.doInsert(myList);
  }
}
class Bar {
  void doInsert(List<?> list) {
     list.add(new Dog());
  }
}
If not, where is the problem? The problem is in the list.add() method within doInsert(). The <?> 
wildcard allows a list of ANY type to be passed to the method, but the add() 
method is not valid, for the reasons we explored earlier (that you could put the 
wrong kind of thing into the collection). So this time, the TestWildcards class is 
fine, but the Bar class won't compile because it does an add() in a method that uses 
a wildcard (without super). What if we change the doInsert() method to this:
public class TestWildcards {
  public static void main(String[] args) {
     List<Integer> myList = new ArrayList<Integer>();
     Bar bar = new Bar();
     bar.doInsert(myList);
  }
}
class Bar {
   void doInsert(List<Object> list) {
     list.add(new Dog());
   }
}
Now will it work? If not, why not? This time, class Bar, with the doInsert() method, compiles just fine. The 
problem is that the TestWildcards code is trying to pass a List<Integer> into a 
method that can take ONLY a List<Object>. And nothing else can be substituted for 
<Object>. By the way, List<? extends Object> and List<?> are absolutely identical! They both say, "I can refer to any type of object." But as you can see, neither of 
them are the same as List<Object>. One way to remember this is that if you see 
the wildcard notation (a question mark ?), this means "many possibilities". If you 
do NOT see the question mark, then it means the <type> in the brackets, and 
absolutely NOTHING ELSE. List<Dog> means List<Dog> and not List<Beagle>, 
List<Poodle>, or any other subtype of Dog. But List<? extends Dog> could mean 
List<Beagle>, List<Poodle>, and so on. Of course List<?> could be... anything at all. Keep in mind that the wildcards can be used only for reference declarations 
(including arguments, variables, return types, and so on). They can't be used as the 
type parameter when you create a new typed collection. Think about that—while 
a reference can be abstract and polymorphic, the actual object created must be of a 
specific type. You have to lock down the type when you make the object using new. As a little review before we move on with generics, look at the following 
statements and figure out which will compile:
1) List<?> list = new ArrayList<Dog>();
2) List<? extends Animal> aList = new ArrayList<Dog>();
3) List<?> foo = new ArrayList<? extends Animal>();
4) List<? extends Dog> cList = new ArrayList<Integer>();
5) List<? super Dog> bList = new ArrayList<Animal>();
6) List<? super Animal> dList = new ArrayList<Dog>();
The correct answers (the statements that compile) are 1, 2, and 5. The three that won't compile are
■ Statement: List<?> foo = new ArrayList<? extends Animal>();
 Problem: you cannot use wildcard notation in the object creation. So the 
new ArrayList<? extends Animal>() will not compile. Generic Methods (Exam Objectives 6.3 and 6.4) 621
622 Chapter 7:  Generics and Collections
■ Statement: List<? extends Dog> cList = 
                                new ArrayList<Integer>();
 Problem: You cannot assign an Integer list to a reference that takes only a 
Dog (including any subtypes of Dog, of course). ■ Statement: List<? super Animal> dList = new ArrayList<Dog>();
 Problem: You cannot assign a Dog to <? super Animal>. The Dog is too "low" 
in the class hierarchy. Only <Animal> or <Object> would have been legal. Generic Declarations
Until now, we've talked about how to create type safe collections, and how to 
declare reference variables including arguments and return types using generic 
syntax. But here are a few questions: How do we even know that we're allowed/
supposed to specify a type for these collection classes? And does generic typing work 
with any other classes in the API? And finally, can we declare our own classes as 
generic types? In other words, can we make a class that requires that someone pass a 
type in when they declare it and instantiate it? First, the one you obviously know the answer to—the API tells you when a 
parameterized type is expected. For example, this is the API declaration for the 
java.util.List interface:
public interface List<E>
The <E> is a placeholder for the type you pass in. The List interface is behaving 
as a generic "template" (sort of like C++ templates), and when you write your code, 
you change it from a generic List to a List<Dog> or List<Integer>, and so on. The E, by the way, is only a convention. Any valid Java identifier would work 
here, but E stands for "Element," and it's used when the template is a collection. The 
other main convention is T (stands for "type"), used for, well, things that are NOT 
collections. Now that you've seen the interface declaration for List, what do you think the 
add() method looks like? boolean add(E o)
In other words, whatever E is when you declare the List, that's what you can add to 
it. So imagine this code:
List<Animal> list = new ArrayList<Animal>();
The E in the List API suddenly has its waveform collapsed, and goes from the 
abstract <your type goes here>, to a List of Animals. And if it's a List of Animals, 
then the add() method of List must obviously behave like this:
boolean add(Animal a)
When you look at an API for a generics class or interface, pick a type parameter 
(Dog, JButton, even Object) and do a mental find and replace on each instance of E 
(or whatever identifier is used as the placeholder for the type parameter). Making Y our Own Generic Class
Let's try making our own generic class, to get a feel for how it works, and then we'll 
look at a few remaining generics syntax details. Imagine someone created a class 
Rental, that manages a pool of rentable items. public class Rental {
   private List rentalPool;
   private int maxNum;
   public Rental(int maxNum, List rentalPool) {
      this.maxNum = maxNum;
      this.rentalPool = rentalPool;
   }
   public Object getRental() {
      // blocks until there's something available
      return rentalPool.get(0);
   }
   public void returnRental(Object o) {
      rentalPool.add(o);
   }
}
Now imagine you wanted to make a subclass of Rental that was just for renting 
cars. You might start with something like this:
import java.util.*;
public class CarRental extends Rental {
   public CarRental(int maxNum, List<Car> rentalPool) {
      super(maxNum, rentalPool);
   }
   public Car getRental() {
      return (Car) super.getRental();
   }
Generic Declarations (Exam Objectives 6.3 and 6.4) 623
624 Chapter 7:  Generics and Collections
   public void returnRental(Car c) {
      super.returnRental(c);
   }
   public void returnRental(Object o) {
     if (o instanceof Car) {
       super.returnRental(o);
     } else {
        System.out.println("Cannot add a non-Car");
        // probably throw an exception
}  } }
But then the more you look at it, the more you realize:
 1. You are doing your own type checking in the returnRental() method. You can't change the argument type of returnRental() to take a Car, 
 since it's an override (not an overload) of the method from class Rental. (Overloading would take away your polymorphic flexibility with Rental). 2. You really don't want to make separate subclasses for every possible kind of
 rentable thing (cars, computers, bowling shoes, children, and so on). But given your natural brilliance (heightened by this contrived scenario), you 
quickly realize that you can make the Rental class a generic type—a template for any 
kind of Rentable thing—and you're good to go. (We did say contrived…since in reality, you might very well want to have 
different behaviors for different kinds of rentable things, but even that could be 
solved cleanly through some kind of behavior composition as opposed to inheritance 
(using the Strategy design pattern, for example). And no, design patterns aren't on 
the exam, but we still think you should read our design patterns book. Think of the 
kittens.) So here's your new and improved generic Rental class:
import java.util.*;
public class RentalGeneric<T> {  // "T" is for the type 
                                 // parameter
   private List<T> rentalPool;   // Use the class type for the
                                 // List type
   private int maxNum;
   public RentalGeneric(
     int maxNum, List<T> rentalPool) { // constructor takes a
                                       // List of the class type
     this.maxNum = maxNum;
     this.rentalPool = rentalPool;
   }
   public T getRental() {                    // we rent out a T
     // blocks until there's something available
     return rentalPool.get(0);
   }
   public void returnRental(T returnedThing) { // and the renter
                                               // returns a T
     rentalPool.add(returnedThing);
   }
}
Let's put it to the test:
class TestRental {
  public static void main (String[] args) {
     //make some Cars for the pool
     Car c1 = new Car();
     Car c2 = new Car();
     List<Car> carList = new ArrayList<Car>();
     carList.add(c1);
     carList.add(c2);
     RentalGeneric<Car> carRental = new 
                         RentalGeneric<Car>(2, carList);
     // now get a car out, and it won't need a cast
     Car carToRent = carRental.getRental();
     carRental.returnRental(carToRent);
     // can we stick something else in the original carList? carList.add(new Cat("Fluffy"));
  }
}
We get one error:
kathy% javac1.5 RentalGeneric.java
RentalGeneric.java:38: cannot find symbol
symbol  : method add(Cat)
location: interface java.util.List<Car>
     carList.add(new Cat("Fluffy"));
            ^
1 error
Now we have a Rental class that can be typed to whatever the programmer 
chooses, and the compiler will enforce it. In other words, it works just as the 
Generic Declarations (Exam Objectives 6.3 and 6.4) 625 
626 Chapter 7:  Generics and Collections
Collections classes do. Let's look at more examples of generic syntax you might find 
in the API or source code. Here's another simple class that uses the parameterized 
type of the class in several ways:
public class TestGenerics<T> {  // as the class type
   T anInstance;                // as an instance variable type
   T [] anArrayOfTs;            // as an array type
   TestGenerics(T anInstance) {     // as an argument type
      this.anInstance = anInstance;
   }
   T getT() {                       // as a return type
      return anInstance;
   }
}
Obviously this is a ridiculous use of generics, and in fact you'll see generics only 
rarely outside of collections. But, you do need to understand the different kinds of 
generic syntax you might encounter, so we'll continue with these examples until 
we've covered them all. You can use more than one parameterized type in a single class definition:
public class UseTwo<T, X> {
  T one;
  X two;
  UseTwo(T one, X two) {
    this.one = one;
    this.two = two;
  }
  T getT() { return one; }
  X getX() { return two; }
  
// test it by creating it with <String, Integer>
  public static void main (String[] args) {
    UseTwo<String, Integer> twos = 
                    new UseTwo<String, Integer>("foo", 42);
    String theT = twos.getT(); // returns a String
    int theX = twos.getX();   // returns Integer, unboxes to int
  }
}
And you can use a form of wildcard notation in a class definition, to specify a 
range (called "bounds") for the type that can be used for the type parameter:
public class AnimalHolder<T extends Animal> { // use "T" instead
                                              // of "?"
 T animal;
 public static void main(String[] args) {
   AnimalHolder<Dog> dogHolder = new AnimalHolder<Dog>(); // OK
   AnimalHolder<Integer> x = new AnimalHolder<Integer>(); // NO! }
}
Creating Generic Methods
Until now, every example we've seen uses the class parameter type—the type 
declared with the class name. For example, in the UseT wo<T,X> declaration, we 
used the T and X placeholders throughout the code. But it's possible to define a 
parameterized type at a more granular level—a method. Imagine you want to create a method that takes an instance of any type, 
instantiates an ArrayList of that type, and adds the instance to the ArrayList. The class 
itself doesn't need to be generic; basically we just want a utility method that we can 
pass a type to and that can use that type to construct a type safe collection. Using a 
generic method, we can declare the method without a specific type and then get the 
type information based on the type of the object passed to the method. For example:
import java.util.*;
public class CreateAnArrayList {
  public <T> void makeArrayList(T t) { // take an object of an
                                    // unknown type and use a
                                    // "T" to represent the type
    List<T> list = new ArrayList<T>(); // now we can create the
                                       // list using "T"
    list.add(t);
   }
}
In the preceding code, if you invoke the makeArrayList() method with a Dog 
instance, the method will behave as though it looked like this all along:
  public void makeArrayList(Dog t) {
     List<Dog> list = new ArrayList<Dog>();
     list.add(t);
  }
Generic Declarations (Exam Objectives 6.3 and 6.4) 627
628 Chapter 7:  Generics and Collections
And of course if you invoke the method with an Integer, then the T is replaced by 
Integer (not in the bytecode, remember—we're describing how it appears to behave, 
not how it actually gets it done). The strangest thing about generic methods is that you must declare the type 
variable BEFORE the return type of the method:
public <T> void makeArrayList(T t)
The <T> before void simply defines what T is before you use it as a type in the 
argument. You MUST declare the type like that unless the type is specified for the 
class. In CreateAnArrayList, the class is not generic, so there's no type parameter 
placeholder we can use. You're also free to put boundaries on the type you declare, for example, if you 
want to restrict the makeArrayList() method to only Number or its subtypes 
(Integer, Float, and so on) you would say
public <T extends Number> void makeArrayList(T t)
It’s tempting to forget that the method argument is NOT where you 
declare the type parameter variable T. In order to use a type variable like T, you must 
have declared it either as the class parameter type or in the method, before the return 
type. The following might look right,
public void makeList(T t) { }
But the only way for this to be legal is if there is actually a class 
named T, in which case the argument is like any other type declaration for a variable. And what about constructor arguments? They, too, can be declared with a generic type, 
but then it looks even stranger since constructors have no return type at all:
public class Radio {
   public <T> Radio(T t) { }  // legal constructor
}
98% of what you're likely to do with generics is simply declare and use type safe 
collections, including using (and passing) them as arguments. But now you know 
much more (but by no means everything) about the way generics works. Generic Declarations (Exam Objectives 6.3 and 6.4) 629 
If you REALLY want to get ridiculous (or ﬁ  red), you can declare a class 
with a name that is the same as the type parameter placeholder:
class X { public <X> X(X x) { } }
Yes, this works. The X that is the constructor name has no relationship 
to the <X> type declaration, which has no relationship to the constructor 
argument identiﬁ er, which is also, of course, X. The compiler is able to parse this 
and treat each of the different uses of X independently. So there is no naming conﬂ ict 
between class names, type parameter placeholders, and variable identiﬁ ers. One of the most common mistakes programmers make when creating 
generic classes or methods is to use a <?> in the wildcard syntax rather than a type 
variable <T>, <E>, and so on. This code might look right, but isn’t:
public class NumberHolder<? extends Number> { }
While the question mark works when declaring a reference for a variable, 
it does NOT work for generic class and method declarations. This code is not legal:
public class NumberHolder<?> { ? aNum; }    // NO! But if you replace the <?> with a legal identiﬁ  er, you’re good:
public class NumberHolder<T> { T aNum; }    // Yes
630 Chapter 7:  Generics and Collections
If this was clear and easy for you, that's excellent. If it was…painful…just know 
that adding generics to the Java language very nearly caused a revolt among some 
of the most experienced Java developers. Most of the outspoken critics are simply 
unhappy with the complexity, or aren't convinced that gaining type safe collections 
is worth the ten million little rules you have to learn now. It's true that with Java 5, 
learning Java just got harder. But trust us…we've never seen it take more than two 
days to "get" generics. That's 48 consecutive hours. CERTIFICATION SUMMARY
We began with a quick review of the toString() method. The toString() 
method is automatically called when you ask System.out.println() to print an 
object—you override it to return a String of meaningful data about your objects. Next we reviewed the purpose of == (to see if two reference variables refer to 
the same object) and the equals() method (to see if two objects are meaningfully 
equivalent). You learned the downside of not overriding equals()—you may not be 
able to find the object in a collection. We discussed a little bit about how to write a good 
equals() method—don't forget to use instanceof and refer to the object's significant 
attributes. We reviewed the contracts for overriding equals() and hashCode(). We learned about the theory behind hashcodes, the difference between legal, 
appropriate, and efficient hashcoding. We also saw that even though wildly 
inefficient, it's legal for a hashCode() method to always return the same value. Next we turned to collections, where we learned about Lists, Sets, and Maps, and 
the difference between ordered and sorted collections. We learned the key attributes 
of the common collection classes, and when to use which. We covered the ins and outs of the Collections and Arrays classes: how to sort, 
and how to search. We learned about converting arrays to Lists and back again. Finally we tackled generics. Generics let you enforce compile-time type-safety 
on collections or other classes. Generics help assure you that when you get an item 
from a collection it will be of the type you expect, with no casting required. You 
can mix legacy code with generics code, but this can cause exceptions. The rules for 
polymorphism change when you use generics, although by using wildcards you can 
still create polymorphic collections. Some generics declarations allow reading of a 
collection, but allow very limited updating of the collection. All in all, one fascinating chapter.

--- Chunk #1498 ---
TWO-MINUTE DRILL
Here are some of the key points from this chapter. Overriding hashCode() and equals() (Objective 6.2)
❑ equals(), hashCode(), and toString() are public. ❑    Override toString() so that System.out.println() or other 
methods can see something useful, like your object's state. ❑ Use == to determine if two reference variables refer to the same object. ❑ Use equals() to determine if two objects are meaningfully equivalent. ❑ If you don't override equals(), your objects won't be useful hashing keys. ❑ If you don't override equals(), different objects can't be considered equal. ❑ Strings and wrappers override equals() and make good hashing keys. ❑ When overriding equals(), use the instanceof operator to be sure you're 
evaluating an appropriate class. ❑ When overriding equals(), compare the objects' significant attributes. ❑ Highlights of the equals() contract:
 ❑ Reflexive: x.equals(x) is true. ❑ Symmetric: If x.equals(y) is true, then y.equals(x) must be true. ❑  Transitive: If x.equals(y) is true, and y.equals(z) is true, 
then z.equals(x) is true. ❑ Consistent: Multiple calls to x.equals(y) will return the same result. ❑ Null: If x is not null, then x.equals(null) is false. ❑ If x.equals(y) is true, then x.hashCode() == y.hashCode() is true. ❑ If you override equals(), override hashCode(). ❑ HashMap, HashSet, Hashtable, LinkedHashMap, & LinkedHashSet use hashing. ❑ An appropriate hashCode() override sticks to the hashCode() contract. ❑ An efficient hashCode() override distributes keys evenly across its buckets. ❑ An overridden equals() must be at least as precise as its hashCode() mate. ❑ To reiterate: if two objects are equal, their hashcodes must be equal. ❑ It's legal for a hashCode() method to return the same value for all instances 
(although in practice it's very inefficient). T wo-Minute Drill 631
✓
632 Chapter 7:  Generics and Collections
❑ Highlights of the hashCode() contract:
 ❑ Consistent: multiple calls to x.hashCode() return the same integer. ❑ If x.equals(y) is true,  x.hashCode() == y.hashCode() is true. ❑  If x.equals(y) is false, then x.hashCode() == y.hashCode() can 
be either true or false, but false will tend to create better efficiency. ❑ transient variables aren't appropriate for equals() and hashCode(). Collections (Objective 6.1)
❑ Common collection activities include adding objects, removing objects, veri-
fying object inclusion, retrieving objects, and iterating. ❑ Three meanings for "collection":
 ❑   collection Represents the data structure in which objects are stored
 ❑   Collection java.util  interface from which Set and List extend
 ❑   Collections A class that holds static collection utility methods
❑ Four basic flavors of collections include Lists, Sets, Maps, Queues:
 ❑   Lists of things Ordered, duplicates allowed, with an index. ❑   Sets of things May or may not be ordered and/or sorted; duplicates 
      not allowed. ❑   Maps of things with keys May or may not be ordered and/or sorted; 
      duplicate keys are not allowed. ❑   Queues of things to process Ordered by FIFO or by priority. ❑ Four basic sub-flavors of collections Sorted, Unsorted, Ordered, Unordered. ❑   Ordered Iterating through a collection in a specific, non-random order. ❑   Sorted Iterating through a collection in a sorted order. ❑ Sorting can be alphabetic, numeric, or programmer-defined. Key Attributes of Common Collection Classes (Objective 6.1)
❑ ArrayList: Fast iteration and fast random access. ❑ Vector: It's like a slower ArrayList, but it has synchronized methods. ❑ LinkedList: Good for adding elements to the ends, i.e., stacks and queues. ❑ HashSet: Fast access, assures no duplicates, provides no ordering. ❑ LinkedHashSet: No duplicates; iterates by insertion order. ❑ TreeSet: No duplicates; iterates in sorted order. ❑ HashMap: Fastest updates (key/values); allows one null key, many 
null values. ❑ Hashtable: Like a slower HashMap (as with Vector, due to its synchronized 
methods). No null values or null keys allowed. ❑ LinkedHashMap: Faster iterations; iterates by insertion order or last accessed; 
allows one null key, many null values. ❑ TreeMap: A sorted map. ❑ PriorityQueue: A to-do list ordered by the elements' priority. Using Collection Classes (Objective 6.3)
❑ Collections hold only Objects, but primitives can be autoboxed. ❑ Iterate with the enhanced for, or with an Iterator via hasNext() & next(). ❑ hasNext() determines if more elements exist; the Iterator does NOT move. ❑ next() returns the next element AND moves the Iterator forward. ❑ To work correctly, a Map's keys must override equals() and hashCode(). ❑ Queues use offer() to add an element, poll() to remove the head of the 
queue, and peek() to look at the head of a queue. ❑ As of Java 6 TreeSets and TreeMaps have new navigation methods like 
floor() and higher(). ❑ You can create/extend "backed" sub-copies of TreeSets and TreeMaps. Sorting and Searching Arrays and Lists (Objective 6.5)
❑ Sorting can be in natural order, or via a Comparable or many Comparators. ❑ Implement Comparable using compareTo(); provides only one sort order. ❑ Create many Comparators to sort a class many ways; implement compare(). ❑ To be sorted and searched, a List's elements must be comparable. ❑ To be searched, an array or List must first be sorted. Utility Classes: Collections and Arrays (Objective 6.5)
❑ Both of these java.util classes provide
 ❑   A sort() method. Sort using a Comparator or sort using natural order. ❑   A binarySearch() method. Search a pre-sorted array or List. T wo-Minute Drill 633
634 Chapter 7:  Generics and Collections
❑ Arrays.asList() creates a List from an array and links them together. ❑ Collections.reverse() reverses the order of elements in a List. ❑ Collections.reverseOrder() returns a Comparator that sorts in reverse. ❑ Lists and Sets have a toArray() method to create arrays. Generics (Objective 6.4)
❑ Generics let you enforce compile-time type safety on Collections (or other 
classes and methods declared using generic type parameters). ❑ An ArrayList<Animal> can accept references of type Dog, Cat, or any other 
subtype of Animal (subclass, or if Animal is an interface, implementation). ❑ When using generic collections, a cast is not needed to get (declared type) el-
ements out of the collection. With non-generic collections, a cast is required:
  List<String> gList = new ArrayList<String>();
   List list = new ArrayList();
    // more code
  String s = gList.get(0);           // no cast needed
  String s = (String)list.get(0);    // cast required
❑ You can pass a generic collection into a method that takes a non-generic col-
lection, but the results may be disastrous. The compiler can't stop the method 
from inserting the wrong type into the previously type safe collection. ❑ If the compiler can recognize that non-type-safe code is potentially endanger-
ing something you originally declared as type-safe, you will get a compiler 
warning. For instance, if you pass a List<String> into a method declared as 
  void foo(List aList) { aList.add(anInteger); }
You'll get a warning because add() is potentially "unsafe". ❑ "Compiles without error" is not the same as "compiles without warnings." 
A compilation warning is not considered a compilation error or failure. ❑ Generic type information does not exist at runtime—it is for compile-time 
safety only. Mixing generics with legacy code can create compiled code that 
may throw an exception at runtime. ❑ Polymorphic assignments applies only to the base type, not the generic type 
parameter. You can say
  List<Animal> aList = new ArrayList<Animal>();   // yes
 You can't say
  List<Animal> aList = new ArrayList<Dog>();      // no
❑ The polymorphic assignment rule applies everywhere an assignment can be 
made. The following are NOT allowed:
 void foo(List<Animal> aList) { }  // cannot take a List<Dog> 
List<Animal> bar() { }          // cannot return a List<Dog> 
❑ Wildcard syntax allows a generic method, accept subtypes (or supertypes) of 
the declared type of the method argument:
 void addD(List<Dog> d) {}  // can take only <Dog>
void addD(List<? extends Dog>) {} // take a <Dog> or <Beagle>
❑ The wildcard keyword extends is used to mean either  "extends" or "imple-
ments." So in <? extends Dog>, Dog can be a class or an interface. ❑ When using a wildcard,  List<? extends Dog>, the collection can be 
accessed but not modified. ❑ When using a wildcard,  List<?>, any generic type can be assigned to the 
reference, but for access only, no modifications. ❑ List<Object> refers only to a List<Object>, while List<?> or 
List<? extends Object> can hold any type of object, but for access only. ❑ Declaration conventions for generics use T for type and E for element:
 public interface List<E>  // API declaration for List
boolean add(E o)          // List.add() declaration
❑ The generics type identifier can be used in class, method, and variable 
declarations:
 class Foo<t> { } // a class
 T anInstance;  // an instance variable
 Foo(T aRef) {}  // a constructor argument
 void bar(T aRef) {} // a method argument
 T baz() {}  // a return type
 The compiler will substitute the actual type. ❑ You can use more than one parameterized type in a declaration:
 public class UseTwo<T, X> { }
❑ You can declare a generic method using a type not defined in the class:
 public <T> void makeList(T t) { }
 is NOT using T as the return type. This method has a void return type, but 
to use T within the method's argument you must declare the <T>, which 
happens before the return type. T wo-Minute Drill 635
SELF TEST
 1. Given:
public static void main(String[] args) {
  // INSERT DECLARATION HERE  
  for (int i = 0; i <= 10; i++) {
    List<Integer> row = new ArrayList<Integer>();
    for (int j = 0; j <= 10; j++)
      row.add(i * j);
    table.add(row);
  }
  for (List<Integer> row : table)
    System.out.println(row);
  }
  Which statements could be inserted at // INSERT DECLARATION HERE to allow this code to 
compile and run? (Choose all that apply.)
  A. List<List<Integer>> table = new List<List<Integer>>();
  B. List<List<Integer>> table = new ArrayList<List<Integer>>();
  C. List<List<Integer>> table = new ArrayList<ArrayList<Integer>>();
  D. List<List, Integer> table = new List<List, Integer>();
  E. List<List, Integer> table = new ArrayList<List, Integer>();
  F. List<List, Integer> table = new ArrayList<ArrayList, Integer>();
  G. None of the above
 2. Which statements are true about comparing two instances of the same class, given that the 
equals() and hashCode() methods have been properly overridden? (Choose all that apply.)
  A. If the equals() method returns true, the hashCode() comparison == might return false
  B. If the equals() method returns false, the hashCode() comparison == might return true
  C. If the hashCode() comparison == returns true, the equals() method must return true
  D. If the hashCode() comparison == returns true, the equals() method might return true
  E. If the hashCode() comparison != returns true, the equals() method might return true
636 Chapter 7:  Generics and Collections
 3. Given:
public static void before() {
  Set set = new TreeSet();
  set.add("2");
  set.add(3);
  set.add("1");
  Iterator it = set.iterator();
    while (it.hasNext())
  System.out.print(it.next() + " ");
}
  Which statements are true? A. The before() method will print 1 2
  B. The before() method will print 1 2 3
  C. The before() method will print three numbers, but the order cannot be determined
  D. The before() method will not compile
  E. The before() method will throw an exception at runtime
 4. Given:
import java.util.*;
class MapEQ {
  public static void main(String[] args) {
    Map<ToDos, String> m = new HashMap<ToDos, String>();
    ToDos t1 = new ToDos("Monday");
    ToDos t2 = new ToDos("Monday");
    ToDos t3 = new ToDos("Tuesday");
    m.put(t1, "doLaundry");
    m.put(t2, "payBills");
    m.put(t3, "cleanAttic");
    System.out.println(m.size());
  }
}
class ToDos{
  String day;
  ToDos(String d) { day = d; }
  public boolean equals(Object o) {
    return ((ToDos)o).day == this.day;
  }
  // public int hashCode() { return 9; }
}
Self T est 637
638 Chapter 7:  Generics and Collections
  Which is correct? (Choose all that apply.)
  A.

--- Chunk #1499 ---
As the code stands it will not compile
  B. As the code stands the output will be 2
  C. As the code stands the output will be 3
  D. If the hashCode() method is uncommented the output will be 2
  E. If the hashCode() method is uncommented the output will be 3
  F. If the hashCode() method is uncommented the code will not compile
 5. Given:
12. public class AccountManager { 
13. private Map accountTotals = new HashMap();
14. private int retirementFund;
15. 16. public int getBalance(String accountName) {
17. Integer total = (Integer) accountTotals.get(accountName);
18. if (total == null)
19. total = Integer.valueOf(0);
20. return total.intValue();
21. } 
23. public void setBalance(String accountName, int amount) {
24. accountTotals.put(accountName, Integer.valueOf(amount));
25. } 
26.

--- Chunk #1500 ---
}
  This class is to be updated to make use of appropriate generic types, with no changes in behavior 
(for better or worse). Which of these steps could be performed?

--- Chunk #1501 ---
(Choose three.)
  A. Replace line 13 with
    private Map<String, int> accountTotals = new HashMap<String, int>();
  B. Replace line 13 with
    private Map<String, Integer> accountTotals = new HashMap<String, Integer>();
  C. Replace line 13 with
    private Map<String<Integer>> accountTotals = new HashMap<String<Integer>>();
  D. Replace lines 17–20 with
    int total = accountTotals.get(accountName);
    if (total == null)
        total = 0;
    return total;    
  E. Replace lines 17–20 with
    Integer total = accountTotals.get(accountName);
    if (total == null)
        total = 0;
    return total;
  F. Replace lines 17–20 with
    return accountTotals.get(accountName);
  G. Replace line 24 with
    accountTotals.put(accountName, amount);
  H. Replace line 24 with
    accountTotals.put(accountName, amount.intValue());
 6. Given:
interface Hungry<E> { void munch(E x); }
interface Carnivore<E extends Animal> extends Hungry<E> {}
interface Herbivore<E extends Plant> extends Hungry<E> {}
abstract class Plant {}
class Grass extends Plant {}
abstract class Animal {}
class Sheep extends Animal implements Herbivore<Sheep> {
  public void munch(Sheep x) {}
}
class Wolf extends Animal implements Carnivore<Sheep> {
  public void munch(Sheep x) {}
}
  Which of the following changes (taken separately) would allow this code to compile? (Choose all that apply.)
  A. Change the Carnivore interface to 
    interface Carnivore<E extends Plant> extends Hungry<E> {}
  B. Change the Herbivore interface to 
    interface Herbivore<E extends Animal> extends Hungry<E> {}
  C. Change the Sheep class to 
    class Sheep extends Animal implements Herbivore<Plant> {
        public void munch(Grass x) {}
    }
  D. Change the Sheep class to
    class Sheep extends Plant implements Carnivore<Wolf> {
        public void munch(Wolf x) {}
    }
Self T est 639
640 Chapter 7:  Generics and Collections
  E. Change the Wolf class to
    class Wolf extends Animal implements Herbivore<Grass> {
        public void munch(Grass x) {}
    }
  F. No changes are necessary
 7. Which collection class(es) allows you to grow or shrink its size and provides indexed access to 
its elements, but whose methods are not synchronized? (Choose all that apply.)
  A. java.util.HashSet
  B. java.util.LinkedHashSet
  C. java.util.List
  D. java.util.ArrayList
  E. java.util.Vector
  F. java.util.PriorityQueue
 8. Given a method declared as
    public static <E extends Number> List<E> process(List<E> nums) 
  A programmer wants to use this method like this
    // INSERT DECLARATIONS HERE
    output = process(input);
  Which pairs of declarations could be placed at // INSERT DECLARATIONS HERE to allow the 
code to compile? (Choose all that apply.)
  A. ArrayList<Integer> input = null;
ArrayList<Integer> output = null;
  B. ArrayList<Integer> input = null;
List<Integer> output = null; 
  C. ArrayList<Integer> input = null;
List<Number> output = null;
  D. List<Number> input = null;
ArrayList<Integer> output = null;
  E. List<Number> input = null;
List<Number> output = null;
  F. List<Integer> input = null;
List<Integer> output = null;
  G. None of the above
 9. Given the proper import statement(s), and
13. PriorityQueue<String> pq = new PriorityQueue<String>();
14. pq.add("2");
15. pq.add("4");
16. System.out.print(pq.peek() + " ");
17. pq.offer("1");
18. pq.add("3");
19. pq.remove("1");
20. System.out.print(pq.poll() + " ");
21. if(pq.remove("2")) System.out.print(pq.poll() + " ");
22. System.out.println(pq.poll() + " " + pq.peek());
  What is the result? A.

--- Chunk #1502 ---
2 2 3 3
  B. 2 2 3 4
  C. 4 3 3 4
  D. 2 2 3 3 3
  E. 4 3 3 3 3
  F. 2 2 3 3 4
  G. Compilation fails
  H. An exception is thrown at runtime
 10. Given:
 3.

--- Chunk #1503 ---
import java.util.*;
 4. public class Mixup {
 5. public static void main(String[] args) {
Self T est 641
 6. Object o = new Object();
 7. // insert code here
 8. s.add("o");
 9. s.add(o);
10. }
11. }
  And these three fragments:
I. Set s = new HashSet();
II. TreeSet s = new TreeSet();
III. LinkedHashSet s = new LinkedHashSet();
  When fragments I, II, or III are inserted, independently, at line 7, which are true? (Choose all that apply.)
  A. Fragment I compiles
  B. Fragment II compiles
  C. Fragment III compiles
  D. Fragment I executes without exception
  E. Fragment II executes without exception
  F. Fragment III executes without exception
 11. Given:
 3.

--- Chunk #1504 ---
import java.util.*;
 4. class Turtle {
 5. int size;
 6. public Turtle(int s) { size = s; }
 7. public boolean equals(Object o) { return (this.size == ((Turtle)o).size); }
 8. // insert code here
 9. }
10. public class TurtleTest {
11. public static void main(String[] args) {
12. LinkedHashSet<Turtle> t = new LinkedHashSet<Turtle>();
13. t.add(new Turtle(1));   t.add(new Turtle(2));   t.add(new Turtle(1));
14. System.out.println(t.size());
15. }
16. }
642 Chapter 7:  Generics and Collections
  And these two fragments:
I. public int hashCode() { return size/5; }
II. // no hashCode method declared
  If fragment I or II is inserted, independently, at line 8, which are true? (Choose all that apply.)
  A. If fragment I is inserted, the output is 2
  B. If fragment I is inserted, the output is 3
  C. If fragment II is inserted, the output is 2
  D. If fragment II is inserted, the output is 3
  E. If fragment I is inserted, compilation fails
  F. If fragment II is inserted, compilation fails
 12. Given the proper import statement(s), and:
13. TreeSet<String> s = new TreeSet<String>();
14. TreeSet<String> subs = new TreeSet<String>();
15. s.add("a"); s.add("b"); s.add("c"); s.add("d"); s.add("e");
16. 17. subs = (TreeSet)s.subSet("b", true, "d", true);
18. s.add("g");
19. s.pollFirst();
20. s.pollFirst();
21. s.add("c2");
22. System.out.println(s.size() +" "+ subs.size());
  Which are true? (Choose all that apply.)
  A. The size of s is 4
  B. The size of s is 5
  C. The size of s is 7
  D. The size of subs is 1
  E. The size of subs is 2
  F. The size of subs is 3
  G. The size of subs is 4
  H. An exception is thrown at runtime
Self T est 643
644 Chapter 7:  Generics and Collections
 13. Given:
 3.

--- Chunk #1505 ---
import java.util.*;
 4. public class Magellan {
 5. public static void main(String[] args) {
 6. TreeMap<String, String> myMap = new TreeMap<String, String>();
 7. myMap.put("a", "apple"); myMap.put("d", "date");
 8. myMap.put("f", "fig"); myMap.put("p", "pear");
 9. System.out.println("1st after mango: " +   // sop 1
10. myMap.higherKey("f"));
11. System.out.println("1st after mango: " +   // sop 2
12. myMap.ceilingKey("f"));
13. System.out.println("1st after mango: " +   // sop 3
14. myMap.floorKey("f"));
15. SortedMap<String, String> sub = new TreeMap<String, String>();
16. sub = myMap.tailMap("f");
17. System.out.println("1st after mango: " +   // sop 4
18. sub.firstKey());
19. }
20. }
  Which of the System.out.println statements will produce the output 1st after mango: p? (Choose all that apply.)
  A.

--- Chunk #1506 ---
sop 1
  B. sop 2
  C. sop 3
  D. sop 4
  E. None; compilation fails
  F. None; an exception is thrown at runtime
 14. Given:
 3. import java.util.*;
 4. class Business { }
 5. class Hotel extends Business { }
 6. class Inn extends Hotel { }
 7. public class Travel {
 8. ArrayList<Hotel> go() {
 9. // insert code here
10.

--- Chunk #1507 ---
}
11. }
Self T est 645
  Which, inserted independently at line 9, will compile? (Choose all that apply.)
  A. return new ArrayList<Inn>();
  B. return new ArrayList<Hotel>();
  C. return new ArrayList<Object>();
  D. return new ArrayList<Business>();
 15. Given:
 3. import java.util.*;
 4. class Dog { int size; Dog(int s) { size = s; } }
 5. public class FirstGrade {
 6. public static void main(String[] args) {
 7. TreeSet<Integer> i = new TreeSet<Integer>();
 8. TreeSet<Dog> d = new TreeSet<Dog>();
 9. 10. d.add(new Dog(1));   d.add(new Dog(2));   d.add(new Dog(1));
11. i.add(1);            i.add(2);            i.add(1);
12. System.out.println(d.size() + " " + i.size());
13. }
14. }
  What is the result? A. 1 2
  B. 2 2
  C. 2 3
  D. 3 2
  E. 3 3
  F. Compilation fails
  G. An exception is thrown at runtime
 16. Given:
 3.

--- Chunk #1508 ---
import java.util.*;
 4. public class GeoCache {
 5. public static void main(String[] args) {
 6. String[] s = {"map", "pen", "marble", "key"};
 7. Othello o = new Othello();
646 Chapter 7:  Generics and Collections
 8. Arrays.sort(s,o);
 9. for(String s2: s) System.out.print(s2 + " ");
10. System.out.println(Arrays.binarySearch(s, "map"));
11. }
12. static class Othello implements Comparator<String> {
13. public int compare(String a, String b) { return b.compareTo(a); }
14. }
15.

--- Chunk #1509 ---
}
  Which are true? (Choose all that apply.)
  A. Compilation fails
  B. The output will contain a 1
  C. The output will contain a 2
  D. The output will contain a –1
  E. An exception is thrown at runtime
  F. The output will contain "key map marble pen"
  G. The output will contain "pen marble map key"
SELF TEST ANSWERS
 1. Given:
public static void main(String[] args) {
  // INSERT DECLARATION HERE  
  for (int i = 0; i <= 10; i++) {
    List<Integer> row = new ArrayList<Integer>();
    for (int j = 0; j <= 10; j++)
      row.add(i * j);
    table.add(row);
  }
  for (List<Integer> row : table)
    System.out.println(row);
  }
  Which statements could be inserted at // INSERT DECLARATION HERE to allow this code to 
compile and run? (Choose all that apply.)
  A. List<List<Integer>> table = new List<List<Integer>>();
  B. List<List<Integer>> table = new ArrayList<List<Integer>>();
  C. List<List<Integer>> table = new ArrayList<ArrayList<Integer>>();
  D. List<List, Integer> table = new List<List, Integer>();
  E. List<List, Integer> table = new ArrayList<List, Integer>();
  F. List<List, Integer> table = new ArrayList<ArrayList, Integer>();
  G. None of the above
Answer:
   ✓ B is correct.     A is incorrect because List is an interface, so you can't say new List() regardless of 
any generic types. D, E, and F are incorrect because List only takes one type parameter 
(a Map would take two, not a List). C is tempting, but incorrect. The type argument 
<List<Integer>> must be the same for both sides of the assignment, even though the 
constructor new ArrayList() on the right side is a subtype of the declared type List on 
the left. (Objective 6.4)
Self T est Answers 647
648 Chapter 7:  Generics and Collections
 2. Which statements are true about comparing two instances of the same class, given that the 
equals() and hashCode() methods have been properly overridden? (Choose all that apply.)
  A. If the equals() method returns true, the hashCode() comparison == might return false
  B. If the equals() method returns false, the hashCode() comparison == might return true
  C. If the hashCode() comparison == returns true, the equals() method must return true
  D. If the hashCode() comparison == returns true, the equals() method might return true
  E. If the hashCode() comparison != returns true, the equals() method might return true
Answer:
   ✓  B and D. B is true because often two dissimilar objects can return the same hashcode 
value. D is true because if the hashCode() comparison returns ==, the two objects might 
or might not be equal.     A, C, and E are incorrect. C is incorrect because the hashCode() method is very flexible 
in its return values, and often two dissimilar objects can return the same hash code value. A and E are a negation of the hashCode() and equals() contract. (Objective 6.2)
 3. Given:
public static void before() {
  Set set = new TreeSet();
  set.add("2");
  set.add(3);
  set.add("1");
  Iterator it = set.iterator();
    while (it.hasNext())
  System.out.print(it.next() + " ");
}
  Which statements are true? A. The before() method will print 1 2
  B. The before() method will print 1 2 3
  C. The before() method will print three numbers, but the order cannot be determined
  D. The before() method will not compile
  E. The before() method will throw an exception at runtime
Answer:
   ✓   E is correct. You can't put both Strings and ints into the same TreeSet. Without generics, 
the compiler has no way of knowing what type is appropriate for this TreeSet, so it allows 
everything to compile. At runtime, the TreeSet will try to sort the elements as they're 
added, and when it tries to compare an Integer with a String it will throw a 
ClassCastException. Note that although the before() method does not use generics, 
it does use autoboxing. Watch out for code that uses some new features and some old 
features mixed together.     A, B, C, and D are incorrect based on the above.

--- Chunk #1510 ---
(Objective 6.5)
 4. Given:
import java.util.*;
class MapEQ {
  public static void main(String[] args) {
    Map<ToDos, String> m = new HashMap<ToDos, String>();
    ToDos t1 = new ToDos("Monday");
    ToDos t2 = new ToDos("Monday");
    ToDos t3 = new ToDos("Tuesday");
    m.put(t1, "doLaundry");
    m.put(t2, "payBills");
    m.put(t3, "cleanAttic");
    System.out.println(m.size());
} }
class ToDos{
  String day;
  ToDos(String d) { day = d; }
  public boolean equals(Object o) {
    return ((ToDos)o).day == this.day;
  }
  // public int hashCode() { return 9; }
}
  Which is correct? (Choose all that apply.)
  A.

--- Chunk #1511 ---
As the code stands it will not compile
  B. As the code stands the output will be 2
  C. As the code stands the output will be 3
  D. If the hashCode() method is uncommented the output will be 2
  E. If the hashCode() method is uncommented the output will be 3
  F. If the hashCode() method is uncommented the code will not compile
Self T est Answers 649
650 Chapter 7:  Generics and Collections
Answer:
   ✓   C and D are correct. If hashCode() is not overridden then every entry will go into its own 
bucket, and the overridden equals() method will have no effect on determining equivalency. If hashCode() is overridden, then the overridden equals() method will view t1 and 
t2 as duplicates.     A, B, E, and F are incorrect based on the above.

--- Chunk #1512 ---
(Objective 6.2)
 5.

--- Chunk #1513 ---
Given:
12. public class AccountManager { 
13. private Map accountTotals = new HashMap();
14. private int retirementFund;
15. 16. public int getBalance(String accountName) {
17. Integer total = (Integer) accountTotals.get(accountName);
18. if (total == null)
19. total = Integer.valueOf(0);
20. return total.intValue();
21. } 
23. public void setBalance(String accountName, int amount) {
24. accountTotals.put(accountName, Integer.valueOf(amount));
25. }  } 
  This class is to be updated to make use of appropriate generic types, with no changes in  behavior 
(for better or worse). Which of these steps could be performed?

--- Chunk #1514 ---
(Choose three.)
  A. Replace line 13 with
    private Map<String, int> accountTotals = new HashMap<String, int>();
  B. Replace line 13 with
    private Map<String, Integer> accountTotals = new HashMap<String, Integer>();
  C. Replace line 13 with
    private Map<String<Integer>> accountTotals = new HashMap<String<Integer>>();
  D. Replace lines 17–20 with
    int total = accountTotals.get(accountName);
    if (total == null)  total = 0;
    return total;    
  E. Replace lines 17–20 with
    Integer total = accountTotals.get(accountName);
    if (total == null)  total = 0;
    return total;
  F. Replace lines 17–20 with
    return accountTotals.get(accountName);
  G. Replace line 24 with
    accountTotals.put(accountName, amount);
  H. Replace line 24 with
    accountTotals.put(accountName, amount.intValue());
Answer:
   ✓   B, E, and G are correct.     A is wrong because you can't use a primitive type as a type parameter. C is wrong because 
a Map takes two type parameters separated by a comma. D is wrong because an int can't 
autobox to a null, and F is wrong because a null can't unbox to 0. H is wrong because you 
can't autobox a primitive just by trying to invoke a method with it. (Objective 6.4)
 6. Given:
interface Hungry<E> { void munch(E x); }
interface Carnivore<E extends Animal> extends Hungry<E> {}
interface Herbivore<E extends Plant> extends Hungry<E> {}
abstract class Plant {}
class Grass extends Plant {}
abstract class Animal {}
class Sheep extends Animal implements Herbivore<Sheep> {
  public void munch(Sheep x) {}
}
class Wolf extends Animal implements Carnivore<Sheep> {
  public void munch(Sheep x) {}
}
  Which of the following changes (taken separately) would allow this code to compile? (Choose all that apply.)
  A. Change the Carnivore interface to 
    interface Carnivore<E extends Plant> extends Hungry<E> {}
  B. Change the Herbivore interface to 
    interface Herbivore<E extends Animal> extends Hungry<E> {}
  C. Change the Sheep class to 
    class Sheep extends Animal implements Herbivore<Plant> {
        public void munch(Grass x) {}
    }
Self T est Answers 651
652 Chapter 7:  Generics and Collections
  D. Change the Sheep class to
    class Sheep extends Plant implements Carnivore<Wolf> {
        public void munch(Wolf x) {}
    }
  E. Change the Wolf class to
    class Wolf extends Animal implements Herbivore<Grass> {
        public void munch(Grass x) {}
    }
  F. No changes are necessary
Answer: 
   ✓  B is correct. The problem with the original code is that Sheep tries to implement 
Herbivore<Sheep> and Herbivore declares that its type parameter E can be any type that 
extends Plant. Since a Sheep is not a Plant, Herbivore<Sheep> makes no sense— 
the type Sheep is outside the allowed range of Herbivore's parameter E. Only solutions 
that either alter the definition of a Sheep or alter the definition of Herbivore will be able 
to fix this. So A, E, and F are eliminated. B works, changing the definition of an Herbivore 
to allow it to eat Sheep solves the problem. C doesn't work because an Herbivore<Plant> 
must have a munch(Plant) method, not munch(Grass). And D doesn't work, because 
in D we made Sheep extend Plant, now the Wolf class breaks because its munch(Sheep) 
method no longer fulfills the contract of Carnivore. (Objective 6.4)
 7. Which collection class(es) allows you to grow or shrink its size and provides indexed access to 
its elements, but whose methods are not synchronized? (Choose all that apply.)
  A. java.util.HashSet
  B. java.util.LinkedHashSet
  C. java.util.List
  D. java.util.ArrayList
  E. java.util.Vector
  F. java.util.PriorityQueue
Answer:
   ✓  D is correct. All of the collection classes allow you to grow or shrink the size of your 
collection. ArrayList provides an index to its elements. The newer collection classes 
tend not to have synchronized methods. Vector is an older implementation of ArrayList
functionality and has synchronized methods; it is slower than ArrayList.      A, B, C, E, and F are incorrect based on the logic described above; Notes: C, List is an 
interface, and F, PriorityQueue does not offer access by index. (Objective 6.1)
 8. Given a method declared as
    public static <E extends Number> List<E> process(List<E> nums) 
  A programmer wants to use this method like this
    // INSERT DECLARATIONS HERE
    output = process(input);
  Which pairs of declarations could be placed at // INSERT DECLARATIONS HERE to allow 
the code to compile? (Choose all that apply.)
  A. ArrayList<Integer> input = null;
ArrayList<Integer> output = null;
  B. ArrayList<Integer> input = null;
List<Integer> output = null; 
  C. ArrayList<Integer> input = null;
List<Number> output = null;
  D. List<Number> input = null;
ArrayList<Integer> output = null;
  E. List<Number> input = null;
List<Number> output = null;
  F. List<Integer> input = null;
List<Integer> output = null;
  G. None of the above
Answer: 
   ✓  B, E, and F are correct.     The return type of process is definitely declared as a List, not an ArrayList, so A and D 
are wrong. C is wrong because the return type evaluates to List<Integer>, and that can't 
be assigned to a variable of type List<Number>. Of course all these would probably cause a 
NullPointerException since the variables are still null—but the question only asked us 
to get the code to compile. (Objective 6.4)
 9.

--- Chunk #1515 ---
Given the proper import statement(s), and
13. PriorityQueue<String> pq = new PriorityQueue<String>();
14. pq.add("2");
15. pq.add("4");
Self T est Answers 653
654 Chapter 7:  Generics and Collections
16. System.out.print(pq.peek() + " ");
17. pq.offer("1");
18. pq.add("3");
19. pq.remove("1");
20. System.out.print(pq.poll() + " ");
21. if(pq.remove("2")) System.out.print(pq.poll() + " ");
22. System.out.println(pq.poll() + " " + pq.peek());
  What is the result? A.

--- Chunk #1516 ---
2 2 3 3
  B. 2 2 3 4
  C. 4 3 3 4
  D. 2 2 3 3 3
  E. 4 3 3 3 3
  F. 2 2 3 3 4
  G. Compilation fails
  H. An exception is thrown at runtime
Answer: 
   ✓  B is correct. For the sake of the exam, add() and offer() both add to (in this case), 
naturally sorted queues. The calls to poll() both return and then remove the first item 
from the queue, so the if test fails.     A, C, D, E, F, G, and H are incorrect based on the above.

--- Chunk #1517 ---
(Objective 6.1)
 10.

--- Chunk #1518 ---
Given:
 3. import java.util.*;
 4. public class Mixup {
 5. public static void main(String[] args) {
 6. Object o = new Object();
 7. // insert code here
 8. s.add("o");
 9. s.add(o);
10. }
11. }
  And these three fragments:
I. Set s = new HashSet();
II. TreeSet s = new TreeSet();
III. LinkedHashSet s = new LinkedHashSet();
  When fragments I, II, or III are inserted, independently, at line 7, which are true? (Choose all that apply.)
  A. Fragment I compiles
  B. Fragment II compiles
  C. Fragment III compiles
  D. Fragment I executes without exception
  E. Fragment II executes without exception
  F. Fragment III executes without exception
Answer: 
   ✓  A, B, C, D, and F are all correct.     Only E is incorrect. Elements of a TreeSet must in some way implement Comparable. (Objective 6.1)
 11.

--- Chunk #1519 ---
Given:
 3. import java.util.*;
 4. class Turtle {
 5. int size;
 6. public Turtle(int s) { size = s; }
 7. public boolean equals(Object o) { return (this.size == ((Turtle)o).size); }
 8. // insert code here
 9. }
10. public class TurtleTest {
11. public static void main(String[] args) {
12. LinkedHashSet<Turtle> t = new LinkedHashSet<Turtle>();
13. t.add(new Turtle(1));   t.add(new Turtle(2));   t.add(new Turtle(1));
14. System.out.println(t.size());
15. }
16. }
 Self T est Answers 655
656 Chapter 7:  Generics and Collections
  And these two fragments:
I. public int hashCode() { return size/5; }
II. // no hashCode method declared
  If fragment I or II is inserted, independently, at line 8, which are true? (Choose all that apply.)
  A. If fragment I is inserted, the output is 2
  B. If fragment I is inserted, the output is 3
  C. If fragment II is inserted, the output is 2
  D. If fragment II is inserted, the output is 3
  E. If fragment I is inserted, compilation fails
  F. If fragment II is inserted, compilation fails
Answer: 
   ✓  A and D are correct. While fragment II wouldn’t fulfill the hashCode() contract (as you 
can see by the results), it is legal Java. For the purpose of the exam, if you don’t override 
hashCode(), every object will have a unique hashcode.     B, C, E, and F are incorrect based on the above. (Objective 6.2)
 12. Given the proper import statement(s), and:
13. TreeSet<String> s = new TreeSet<String>();
14. TreeSet<String> subs = new TreeSet<String>();
15. s.add("a"); s.add("b"); s.add("c"); s.add("d"); s.add("e");
16. 17. subs = (TreeSet)s.subSet("b", true, "d", true);
18. s.add("g");
19. s.pollFirst();
20. s.pollFirst();
21. s.add("c2");
22. System.out.println(s.size() +" "+ subs.size());
  Which are true? (Choose all that apply.)
  A. The size of s is 4
  B. The size of s is 5
  C. The size of s is 7
  D. The size of subs is 1
  E. The size of subs is 2
  F. The size of subs is 3
  G. The size of subs is 4
  H. An exception is thrown at runtime
Answer: 
   ✓  B and F are correct. After "g" is added, TreeSet s contains six elements and TreeSet subs 
contains three (b, c, d), because "g" is out of the range of subs. The first pollFirst() 
finds and removes only the "a". The second pollFirst() finds and removes the "b" from 
both TreeSets (remember they are backed). The final add() is in range of both TreeSets. The final contents are [c,c2,d,e,g] and [c,c2,d].     A, C, D, E, G, and H are incorrect based on the above. (Objective 6.3)
 13. Given:
 3. import java.util.*;
 4. public class Magellan {
 5. public static void main(String[] args) {
 6. TreeMap<String, String> myMap = new TreeMap<String, String>();
 7. myMap.put("a", "apple"); myMap.put("d", "date");
 8. myMap.put("f", "fig"); myMap.put("p", "pear");
 9. System.out.println("1st after mango: " +   // sop 1
10. myMap.higherKey("f"));
11. System.out.println("1st after mango: " +   // sop 2
12. myMap.ceilingKey("f"));
13. System.out.println("1st after mango: " +   // sop 3
14. myMap.floorKey("f"));
15. SortedMap<String, String> sub = new TreeMap<String, String>();
16. sub = myMap.tailMap("f");
17. System.out.println("1st after mango: " +   // sop 4
18. sub.firstKey());
19. }
20. }
  Which of the System.out.println statements will produce the output 1st after mango: p? (Choose all that apply.)
  A.

--- Chunk #1520 ---
sop 1
  B.

--- Chunk #1521 ---
sop 2
  C. sop 3
 Self T est Answers 657
658 Chapter 7:  Generics and Collections
  D. sop 4
  E. None; compilation fails
  F. None; an exception is thrown at runtime
Answer: 
   ✓  A is correct. The ceilingKey() method's argument is inclusive. The floorKey() method 
would be used to find keys before the specified key. The firstKey() method's argument is 
also inclusive.     B, C, D, E, and F are incorrect based on the above. (Objective 6.3)
 14.

--- Chunk #1522 ---
Given:
 3. import java.util.*;
 4. class Business { }
 5. class Hotel extends Business { }
 6. class Inn extends Hotel { }
 7. public class Travel {
 8. ArrayList<Hotel> go() {
 9. // insert code here
10.

--- Chunk #1523 ---
}
11. }
  Which, inserted independently at line 9, will compile? (Choose all that apply.)
  A. return new ArrayList<Inn>();
  B. return new ArrayList<Hotel>();
  C. return new ArrayList<Object>();
  D. return new ArrayList<Business>();
Answer: 
   ✓  B is correct.     A is incorrect because polymorphic assignments don't apply to generic type parameters. C 
and D are incorrect because they don't follow basic polymorphism rules. (Objective 6.4)
 15. Given:
 3.

--- Chunk #1524 ---
import java.util.*;
 4. class Dog { int size; Dog(int s) { size = s; } }
 5. public class FirstGrade {
 6. public static void main(String[] args) {
 7. TreeSet<Integer> i = new TreeSet<Integer>();
 8. TreeSet<Dog> d = new TreeSet<Dog>();
 9. 10. d.add(new Dog(1));   d.add(new Dog(2));   d.add(new Dog(1));
11. i.add(1);            i.add(2);            i.add(1);
12. System.out.println(d.size() + " " + i.size());
13. }
14. }
  What is the result? A. 1 2
  B. 2 2
  C. 2 3
  D. 3 2
  E. 3 3
  F. Compilation fails
  G. An exception is thrown at runtime
Answer: 
   ✓  G is correct. Class Dog needs to implement Comparable in order for a TreeSet (which 
keeps its elements sorted) to be able to contain Dog objects.     A, B, C, D, E, and F are incorrect based on the above.

--- Chunk #1525 ---
(Objective 6.5)
 16.

--- Chunk #1526 ---
Given:
 3. import java.util.*;
 4. public class GeoCache {
 5. public static void main(String[] args) {
 6. String[] s = {"map", "pen", "marble", "key"};
 7. Othello o = new Othello();
 8. Arrays.sort(s,o);
 Self T est Answers 659
660 Chapter 7:  Generics and Collections
 9. for(String s2: s) System.out.print(s2 + " ");
10. System.out.println(Arrays.binarySearch(s, "map"));
11. }
12. static class Othello implements Comparator<String> {
13. public int compare(String a, String b) { return b.compareTo(a); }
14. }
15.

--- Chunk #1527 ---
}
  Which are true? (Choose all that apply.)
  A. Compilation fails
  B. The output will contain a 1
  C. The output will contain a 2
  D. The output will contain a –1
  E. An exception is thrown at runtime
  F. The output will contain "key map marble pen"
  G. The output will contain "pen marble map key"
Answer: 
   ✓  D and G are correct. First, the compareTo() method will reverse the normal sort. Second, the sort() is valid. Third, the binarySearch() gives –1 because it needs to be 
invoked using the same Comparator (o), as was used to sort the array. Note that when the 
binarySearch() returns an "undefined result" it doesn’t officially have to be a -1, but it 
usually is, so if you selected only G, you get full credit!     A, B, C, E, and F are incorrect based on the above. (Objective 6.5)
8
Inner Classes
CERTIFICATION OBJECTIVES
Inner Classes
 Method-Local Inner Classes 
 Anonymous Inner Classes
       

 Static Nested Classes  ✓   T wo-Minute Drill
          Q&A Self T est
 
	
662 Chapter 8:  Inner Classes
I
nner classes (including static nested classes) appear throughout the exam. Although there 
are no official exam objectives specifically about inner classes, Objective 1.1 includes inner 
(a.k.a. nested) classes. More important, the code used to represent questions on virtually any 
topic on the exam can involve inner classes. Unless you deeply understand the rules and syntax 
for inner classes, you're likely to miss questions you'd otherwise be able to answer. As if the exam 
weren't already tough enough. This chapter looks at the ins and outs (inners and outers?) of inner classes, 
and exposes you to the kinds of (often strange-looking) syntax examples you'll 
see scattered throughout the entire exam. So you've really got two goals for this 
chapter—to learn what you'll need to answer questions testing your inner class 
knowledge, and to learn how to read and understand inner class code so that you 
can correctly process questions testing your knowledge of other topics. So what's all the hoopla about inner classes? Before we get into it, we have to 
warn you (if you don't already know) that inner classes have inspired passionate love 
‘em or hate ‘em debates since first introduced in version 1.1 of the language. For 
once, we're going to try to keep our opinions to ourselves here and just present the 
facts as you'll need to know them for the exam. It's up to you to decide how—and 
to what extent—you should use inner classes in your own development. We mean 
it. We believe they have some powerful, efficient uses in very specific situations, 
including code that's easier to read and maintain, but they can also be abused and 
lead to code that's as clear as a cornfield maze, and to the syndrome known as 
"reuseless": code that's useless over and over again. Inner classes let you define one class within another. They provide a type of 
scoping for your classes since you can make one class a member of another class. Just 
as classes have member variables and methods, a class can also have member classes. They come in several flavors, depending on how and where you define the inner 
class, including a special kind of inner class known as a "top-level nested class" (an 
inner class marked static), which technically isn't really an inner class. Because a 
static nested class is still a class defined within the scope of another class, we're still 
going to cover them in this chapter on inner classes. Unlike the other chapters in this book, the certification objectives for inner 
classes don't have official exam objective numbers since they're part of other 
objectives covered elsewhere. So for this chapter, the Certification Objective 
headings in the following list represent the four inner class topics discussed in this 
chapter, rather than four official exam objectives:
Inner Classes 663
■  Inner classes
■  Method-local inner classes
■  Anonymous inner classes
■  Static nested classes
CERTIFICATION OBJECTIVE
Inner Classes
You're an OO programmer, so you know that for reuse and flexibility/extensibility 
you need to keep your classes specialized. In other words, a class should have code 
only for the things an object of that particular type needs to do; any other behavior 
should be part of another class better suited for that job. Sometimes, though, you 
find yourself designing a class where you discover you need behavior that belongs 
in a separate, specialized class, but also needs to be intimately tied to the class
you're designing. Event handlers are perhaps the best example of this (and are, in fact, one of the 
main reasons inner classes were added to the language in the first place). If you have 
a GUI class that performs some job like, say, a chat client, you might want the 
chat-client–specific methods (accept input, read new messages from server, send user 
input back to server, and so on) to be in the class. But how do those methods get 
invoked in the first place? A user clicks a button. Or types some text in the input 
field. Or a separate thread doing the I/O work of getting messages from the server 
has messages that need to be displayed in the GUI. So you have chat-client–specific 
methods, but you also need methods for handling the "events" (button presses, 
keyboard typing, I/O available, and so on) that drive the calls on those chat-
client methods. The ideal scenario—from an OO perspective—is to keep the chat-
client–specific methods in the ChatClient class, and put the event-handling code in a 
separate event-handling class. Nothing unusual about that so far; after all, that's how you're supposed to design 
OO classes. As specialists. But here's the problem with the chat-client scenario: the 
event-handling code is intimately tied to the chat-client–specific code! Think about 
it: when the user presses a Send button (indicating that they want their typed-in 
message to be sent to the chat server), the chat-client code that sends the message
needs to read from a particular text field. In other words, if the user clicks Button A, 
the program is supposed to extract the text from the TextField B, of a particular 
ChatClient instance. Not from some other text field from some other object, but 
specifically the text field that a specific instance of the ChatClient class has a 
reference to. So the event-handling code needs access to the members of the 
ChatClient object, to be useful as a "helper" to a particular ChatClient instance. And what if the ChatClient class needs to inherit from one class, but the event 
handling code is better off inheriting from some other class? You can't make a 
class extend more than one class, so putting all the code (the chat-client– specific 
code and the event-handling code) in one class won't work in that case. So what 
you'd really like to have is the benefit of putting your event code in a separate class 
(better OO, encapsulation, and the ability to extend a class other than the class the 
ChatClient extends) but still allow the event-handling code to have easy access 
to the members of the ChatClient (so the event-handling code can, for example, 
update the ChatClient's private instance variables). You could manage it by making 
the members of the ChatClient accessible to the event-handling class by, for 
example, marking them public. But that's not a good solution either. You already know where this is going—one of the key benefits of an inner class 
is the "special relationship" an inner class instance shares with an instance of 
the outer class. That "special relationship" gives code in the inner class access to 
members of the enclosing (outer) class, as if the inner class were part of the outer 
class. In fact, that's exactly what it means: the inner class is a part of the outer class. Not just a "part" but a full-fledged, card-carrying member of the outer class. Yes, an 
inner class instance has access to all members of the outer class, even those marked 
private. (Relax, that's the whole point, remember? We want this separate inner 
class instance to have an intimate relationship with the outer class instance, but we 
still want to keep everyone else out. And besides, if you wrote the outer class, then 
you also wrote the inner class! So you're not violating encapsulation; you 
designed it this way.)
Coding a "Regular" Inner Class
We use the term regular here to represent inner classes that are not
■  Static
■  Method-local
■  Anonymous
For the rest of this section, though, we'll just use the term "inner class" and drop 
the "regular". (When we switch to one of the other three types in the preceding list, 
you'll know it.) You define an inner class within the curly braces of the outer class:
664 Chapter 8:  Inner Classes
class MyOuter {
   class MyInner { }
}
Piece of cake. And if you compile it,
%javac MyOuter.java
you'll end up with two class files:
MyOuter.class
MyOuter$MyInner.class
The inner class is still, in the end, a separate class, so a separate class file is generated 
for it. But the inner class file isn't accessible to you in the usual way. You can't say
%java MyOuter$MyInner
in hopes of running the main() method of the inner class, because a regular inner class 
can't have static declarations of any kind. The only way you can access the inner class 
is through a live instance of the outer class! In other words, only at runtime when 
there's already an instance of the outer class to tie the inner class instance to. You'll see 
all this in a moment. First, let's beef up the classes a little:
class MyOuter {
   private int x = 7; 
   // inner class definition
   class MyInner {
      public void seeOuter() {
         System.out.println("Outer x is " + x);
      }
   } // close inner class definition
} // close outer class
The preceding code is perfectly legal. Notice that the inner class is indeed 
accessing a private member of the outer class. That's fine, because the inner  
class is also a member of the outer class. So just as any member of the outer class 
(say, an instance method) can access any other member of the outer class, private 
or not, the inner class—also a member—can do the same. OK, so now that we know how to write the code giving an inner class access to 
members of the outer class, how do you actually use it? Coding a "Regular" Inner Class 665
Instantiating an Inner Class 
To create an instance of an inner class, you must have an instance of the outer class  
to tie to the inner class. There are no exceptions to this rule: an inner class instance 
can never stand alone without a direct relationship to an instance of the outer class. Instantiating an Inner Class from Within the Outer Class    Most often, it 
is the outer class that creates instances of the inner class, since it is usually the outer 
class wanting to use the inner instance as a helper for its own personal use. We'll 
modify the MyOuter class to create an instance of MyInner:
class MyOuter {
   private int x = 7;
   public void makeInner() {
      MyInner in = new MyInner();  // make an inner instance
      in.seeOuter();
   }
   class MyInner {
      public void seeOuter() {
         System.out.println("Outer x is " + x);
      }
   }
}
You can see in the preceding code that the MyOuter code treats MyInner just as 
though MyInner were any other accessible class—it instantiates it using the class 
name (new MyInner()), and then invokes a method on the reference variable 
(in.seeOuter()). But the only reason this syntax works is because the outer class 
instance method code is doing the instantiating. In other words, there's already an 
instance of the outer class—the instance running the makeInner() method. So how 
do you instantiate a MyInner object from somewhere outside the MyOuter class? Is 
it even possible? (Well, since we're going to all the trouble of making a whole new 
subhead for it, as you'll see next, there's no big mystery here.)
Creating an Inner Class Object from Outside the Outer Class 
Instance Code    Whew. Long subhead there, but it does explain what we're 
trying to do. If we want to create an instance of the inner class, we must have 
an instance of the outer class. You already know that, but think about the 
666 Chapter 8:  Inner Classes
implications…it means that, without a reference to an instance of the outer class, 
you can't instantiate the inner class from a static method of the outer class (be-
cause, don't forget, in static code there is no this reference), or from any other 
code in any other class. Inner class instances are always handed an implicit reference 
to the outer class. The compiler takes care of it, so you'll never see anything but the 
end result—the ability of the inner class to access members of the outer class. The 
code to make an instance from anywhere outside nonstatic code of the outer class 
is simple, but you must memorize this for the exam! public static void main(String[] args) {
  MyOuter mo = new MyOuter();     // gotta get an instance! MyOuter.MyInner inner = mo.new MyInner();
  inner.seeOuter();
}
The preceding code is the same regardless of whether the main() method is within 
the MyOuter class or some other class (assuming the other class has access to 
MyOuter, and since MyOuter has default access, that means the code must be in a 
class within the same package as MyOuter). If you're into one-liners, you can do it like this:
public static void main(String[] args) {
  MyOuter.MyInner inner = new MyOuter().new MyInner();
  inner.seeOuter();
}
You can think of this as though yo u're invoking a method on the outer instance, 
but the method happens to be a special inner class instantiation method, and it's 
invoked using the keyword new. Instantiating an inner class is the only scenario 
in which you'll invoke new on an instance as opposed to invoking new to 
construct an instance. Here's a quick summary of the differences between inner class instantiation code 
that's within the outer class (but not static), and inner class instantiation code 
that's outside the outer class:
■  From inside the outer class instance code, use the inner class name in the 
   normal way:
  MyInner mi = new MyInner();
Coding a "Regular" Inner Class 667
■  From outside the outer class instance code (including static method code 
within the outer class), the inner class name must now include the outer 
class's name:
  MyOuter.MyInner
 
   To instantiate it, you must use a reference to the outer class:
  new MyOuter().new MyInner(); or outerObjRef.new MyInner();
   if you already have an instance of the outer class. Referencing the Inner or Outer Instance 
from Within the Inner Class
How does an object refer to itself normally? By using the this reference. Here is a 
quick review of this:
■  The keyword this can be used only from within instance code. In other words, not within static code. ■  The this reference is a reference to the currently executing object. In other 
words, the object whose reference was used to invoke the currently running 
method. ■  The this reference is the way an object can pass a reference to itself to some 
other code, as a method argument:
  public void myMethod() {
   MyClass mc = new MyClass();
   mc.doStuff(this);  // pass a ref to object running myMethod 
  }
Within an inner class code, the this reference refers to the instance of the inner 
class, as you'd probably expect, since this always refers to the currently executing 
object. But what if the inner class code wants an explicit reference to the outer class 
instance that the inner instance is tied to? In other words, how do you reference the 
"outer this"? Although normally the inner class code doesn't need a reference to 
the outer class, since it already has an implicit one it's using to access the members 
of the outer class, it would need a reference to the outer class if it needed to pass that 
reference to some other code as follows:
 
668 Chapter 8:  Inner Classes
class MyInner {
   public void seeOuter() {
      System.out.println("Outer x is " + x);
      System.out.println("Inner class ref is " + this);
      System.out.println("Outer class ref is " + MyOuter.this);
   }
}
If we run the complete code as follows:
class MyOuter {
   private int x = 7;
   public void makeInner() {
      MyInner in = new MyInner();
      in.seeOuter();
   }
   class MyInner {
      public void seeOuter() {
         System.out.println("Outer x is " + x);
         System.out.println("Inner class ref is " + this);
         System.out.println("Outer class ref is " + MyOuter.this);
      }
   }
   public static void main (String[] args) {
      MyOuter.MyInner inner = new MyOuter().new MyInner();
      inner.seeOuter();
   }
}
the output is something like this:
Outer x is 7
Inner class ref is MyOuter$MyInner@113708
Outer class ref is MyOuter@33f1d7
So the rules for an inner class referencing itself or the outer instance are as follows:
■ To reference the inner class instance itself, from within the inner class code, 
use this. ■ To reference the "outer this" (the outer class instance) from within the inner 
class code, use NameOfOuterClass.this (example, MyOuter.this). Referencing the Inner or Outer Instance from Within the Inner Class 669
Member Modifiers Applied to Inner Classes    A regular inner class is a 
member of the outer class just as instance variables and methods are, so the 
following modifiers can be applied to an inner class:
■ final
■   abstract
■   public
■  private
■  protected
■  static—but static turns it into a static nested class not an inner class
■  strictfp
CERTIFICATION OBJECTIVE
Method-Local Inner Classes
A regular inner class is scoped inside another class's curly braces, but outside 
any method code (in other words, at the same level that an instance variable is 
declared). But you can also define an inner class within a method:
class MyOuter2 {
     private String x = "Outer2";
     void doStuff() {
        class MyInner {
           public void seeOuter() {
             System.out.println("Outer x is " + x);
           } // close inner class method
        } // close inner class definition
      } // close outer class method doStuff()
} // close outer class
The preceding code declares a class, MyOuter2, with one method, doStuff(). But inside doStuff(), another class, MyInner, is declared, and it has a method of 
its own, seeOuter(). The code above is completely useless, however, because it 
670 Chapter 8:  Inner Classes
never instantiates the inner class! Just because you declared the class doesn't mean 
you created an instance of it. So to use the inner class you must make an instance 
of it somewhere within the method but below the inner class definition (or the 
compiler won't be able to find the inner class). The following legal code shows 
how to instantiate and use a method-local inner class:
class MyOuter2 {
     private String x = "Outer2";
     void doStuff() {       
        class MyInner {
           public void seeOuter() {
             System.out.println("Outer x is " + x);
           } // close inner class method
        } // close inner class definition
        MyInner mi = new MyInner();  // This line must come
                                     // after the class
        mi.seeOuter();
     } // close outer class method doStuff()
} // close outer class
What a Method-Local Inner Object Can and Can't Do
A method-local inner class can be instantiated only within the method where the inner 
class is defined. In other words, no other code running in any other method—inside 
or outside the outer class—can ever instantiate the method-local inner class. Like 
regular inner class objects, the method-local inner class object shares a special 
relationship with the enclosing (outer) class object, and can access its private (or 
any other) members. However, the inner class object cannot use the local variables 
of the method the inner class is in. Why not? Think about it. The local variables of the method live on the stack, and exist only for 
the lifetime of the method. You already know that the scope of a local variable is 
limited to the method the variable is declared in. When the method ends, the stack 
frame is blown away and the variable is history. But even after the method 
completes, the inner class object created within it might still be alive on the heap if, 
for example, a reference to it was passed into some other code and then stored in an 
instance variable. Because the local variables aren't guaranteed to be alive as long 
as the method-local inner class object, the inner class object can't use them. Unless 
the local variables are marked final! The following code attempts to access a local 
variable from within a method-local inner class. What a Method-Local Inner Object Can and Can't Do 671
class MyOuter2 {
   private String x = "Outer2";
   void doStuff() {
     String z = "local variable";
     class MyInner {
       public void seeOuter() {
         System.out.println("Outer x is " + x);
         System.out .println("Local variable z is " + z);   // Won't Compile! } // close inner class method
     }   // close inner class definition
   }     // close outer class method doStuff()
}        // close outer class
Compiling the preceding code really upsets the compiler:
MyOuter2.java:8: local variable z is accessed from within inner class;
needs to be declared final
           System.out.println("Local variable z is " + z);
                                                      ^
Marking the local variable z as final fixes the problem:
final String z = "local variable";  // Now inner object can use it
And just a reminder about modifiers within a method: the same rules apply to 
method-local inner classes as to local variable declarations. You can't, for example, 
mark a method-local inner class public, private, protected, static, transient, 
and the like. For the purpose of the exam, the only modifiers you can apply to a 
method-local inner class are abstract and final, but as always, never both at the 
same time. Remember that a local class declared in a static method has access 
to only static members of the enclosing class, since there is no associated instance of the 
enclosing class. If you're in a static method there is no this, so an inner class in a static 
method is subject to the same restrictions as the static method. In other words, no access 
to instance variables. 672 Chapter 8:  Inner Classes
CERTIFICATION OBJECTIVE
Anonymous Inner Classes
So far we've looked at defining a class within an enclosing class (a regular inner 
class) and within a method (a method-local inner class). Finally, we're going to look 
at the most unusual syntax you might ever see in Java; inner classes declared without 
any class name at all (hence the word anonymous). And if that's not weird enough, 
you can define these classes not just within a method, but even within an argument 
to a method. We'll look first at the plain-old (as if there is such a thing as a plain-old 
anonymous inner class) version (actually, even the plain-old version comes in two 
flavors), and then at the argument-declared anonymous inner class. Perhaps your most important job here is to learn to not be thrown when you see 
the syntax. The exam is littered with anonymous inner class code: you might 
see it on questions about threads, wrappers, overriding, garbage collection, and... well, you get the idea. Plain-Old Anonymous Inner Classes, Flavor One
Check out the following legal-but-strange-the-first-time-you-see-it code:
class Popcorn {
   public void pop() {
      System.out.println("popcorn");
    }
}
class Food {
   Popcorn p = new Popcorn() {
     public void pop() {
        System.out.println("anonymous popcorn");
     }
   };
}
Let's look at what's in the preceding code:
■  We define two classes, Popcorn and Food. ■  Popcorn has one method,  pop(). ■  Food has one instance variable, declared as type Popcorn . That's it for Food. Food has no methods. Plain-Old Anonymous Inner Classes, Flavor One 673
And here's the big thing to get
The Popcorn reference variable refers not to an instance of Popcorn, but to an 
instance of an anonymous (unnamed) subclass of Popcorn. Let's look at just the anonymous class code:
2. Popcorn p = new Popcorn() {
3. public void pop() {
4. System.out.println("anonymous popcorn");
5. }
6. };
Line 2     Line 2 starts out as an instance variable declaration of type Popcorn. But 
instead of looking like this:
Popcorn p = new Popcorn(); // notice the semicolon at the end
there's a curly brace at the end of line 2, where a semicolon would normally be. Popcorn p = new Popcorn() { // a curly brace, not a semicolon
You can read line 2 as saying, 
Declare a reference variable, p, of type Popcorn. Then declare a new class that 
has no name, but that is a subclass of Popcorn. And here's the curly brace that 
opens the class definition…
Line 3     Line 3, then, is actually the first statement within the new class 
definition. And what is it doing? Overriding the pop() method of the superclass 
Popcorn. This is the whole point of making an anonymous inner class—to override 
one or more methods of the superclass! (Or to implement methods of an interface, 
but we'll save that for a little later.)
Line 4     Line 4 is the first (and in this case only) statement within the overriding 
pop() method. Nothing special there. Line 5     Line 5 is the closing curly brace of the pop() method. Nothing special. Line 6     Here's where you have to pay attention: line 6 includes a curly brace 
closing off the anonymous class definition (it's the companion brace to the one 
674 Chapter 8:  Inner Classes
on line 2), but there's more! Line 6 also has the semicolon that ends the statement 
started on line 2—the statement where it all began—the statement declaring and 
initializing the Popcorn reference variable. And what you're left with is a Popcorn 
reference to a brand-new instance of a brand-new, just-in-time, anonymous (no 
name) subclass of Popcorn. Polymorphism is in play when anonymous inner classes are involved. Remember 
that, as in the preceding Popcorn example, we're using a superclass reference 
variable type to refer to a subclass object. What are the implications? You can 
only call methods on an anonymous inner class reference that are defined in the 
reference variable type! This is no different from any other polymorphic references, 
for example,
class Horse extends Animal{
   void buck() { }
}
class Animal {
   void eat() { }
}
Plain-Old Anonymous Inner Classes, Flavor One 675
The closing semicolon is hard to spot. Watch for code like this:
2.

--- Chunk #1528 ---
Popcorn p = new Popcorn() {
3. public void pop() {
4. System.out.println("anonymous popcorn");
5. }
6.

--- Chunk #1529 ---
}                 //  Missing the semicolon needed to end 
                     //  the statement started on 2! 7. Foo f = new Foo();
You'll need to be especially careful about the syntax when inner 
classes are involved, because the code on line 6 looks perfectly natural. It's rare to see 
semicolons following curly braces. class Test {
   public static void main (String[] args) {
      Animal h = new Horse();
      h.eat();  // Legal, class Animal has an eat() method
      h.buck();  // Not legal! Class Animal doesn't have buck()
   }
}
So on the exam, you must be able to spot an anonymous inner class that— 
rather than overriding a method of the superclass—defines its own new method. The 
method definition isn't the problem, though; the real issue is how do you invoke 
that new method? The reference variable type (the superclass) won't know anything 
about that new method (defined in the anonymous subclass), so the compiler will 
complain if you try to invoke any method on an anonymous inner class reference that 
is not in the superclass class definition. Check out the following, illegal code:
class Popcorn {
   public void pop() {
      System.out.println("popcorn");
   }
}
class Food {
   Popcorn p = new Popcorn() {
      public void sizzle() {
        System.out.println("anonymous sizzling popcorn");
      }
      public void pop() {
         System.out.println("anonymous popcorn");
      }
   };
   public void popIt() {
      p.pop();     // OK, Popcorn has a pop() method
      p.sizzle();  // Not Legal! Popcorn does not have sizzle()
   }
}
Compiling the preceding code gives us something like,
Anon.java:19: cannot resolve symbol
symbol  : method sizzle  ()
676 Chapter 8:  Inner Classes
location: class Popcorn
      p.sizzle();
       ^
which is the compiler's way of saying, "I can't find method sizzle() in class 
Popcorn," followed by, "Get a clue."
Plain-Old Anonymous Inner Classes, Flavor T wo
The only difference between flavor one and flavor two is that flavor one creates 
an anonymous subclass of the specified class type, whereas flavor two creates an 
anonymous implementer of the specified interface type. In the previous examples, 
we defined a new anonymous subclass of type Popcorn as follows:
Popcorn p = new Popcorn() {
But if Popcorn were an interface type instead of a class type, then the new 
anonymous class would be an implementer of the interface rather than a subclass of 
the class. Look at the following example:
interface Cookable {
   public void cook();
}
class Food {
   Cookable c = new Cookable() {
     public void cook() {
        System.out.println("anonymous cookable implementer");
     }
   };
}
The preceding code, like the Popcorn example, still creates an instance of an 
anonymous inner class, but this time the new just-in-time class is an implementer of the 
Cookable interface. And note that this is the only time you will ever see the syntax
new Cookable()
where Cookable is an interface rather than a non abstract class type. Because 
think about it, you can't instantiate an interface, yet that's what the code looks  
like it's doing. But of course it's not instantiating a Cookable object, it's creating an 
instance of a new, anonymous, implementer of Cookable. You can read this line:
Plain-Old Anonymous Inner Classes, Flavor T wo 677
Cookable c = new Cookable() {
as, "Declare a reference variable of type Cookable that, obviously, will refer to an 
object from a class that implements the Cookable interface. But, oh yes, we don't 
yet have a class that implements Cookable, so we're going to make one right here, 
right now. We don't need a name for the class, but it will be a class that implements 
Cookable, and this curly brace starts the definition of the new implementing class." 
One more thing to keep in mind about anonymous interface implementers—they 
can implement only one interface. There simply isn't any mechanism to say that 
your anonymous inner class is going to implement multiple interfaces. In fact, an 
anonymous inner class can't even extend a class and implement an interface at the 
same time. The inner class has to choose either to be a subclass of a named class— 
and not directly implement any interfaces at all—or to implement a single interface. By directly, we mean actually using the keyword implements as part of the class 
declaration. If the anonymous inner class is a subclass of a class type, it automatically 
becomes an implementer of any interfaces implemented by the superclass. Argument-Deﬁ  ned Anonymous Inner Classes
If you understood what we've covered so far in this chapter, then this last part will 
be simple. If you are still a little fuzzy on anonymous classes, however, then you 
should reread the previous sections. If they're not completely clear, we'd like to take 
full responsibility for the confusion. But we'll be happy to share. 678 Chapter 8:  Inner Classes
Don't be fooled by any attempts to instantiate an interface except in the 
case of an anonymous inner class. The following is not legal,
  Runnable r = new Runnable(); // can't instantiate interface
whereas the following is legal, because it's instantiating an implementer of the 
Runnable interface (an anonymous implementation class):
  Runnable r = new Runnable() {  // curly brace, not semicolon
      public void run() { }
  } ;
Okay, if you've made it to this sentence, then we're all going to assume you 
understood the preceding section, and now we're just going to add one new twist. Imagine the following scenario. You're typing along, creating the Perfect Class, when 
you write code calling a method on a Bar object, and that method takes an object of 
type Foo (an interface). class MyWonderfulClass {
   void go() {
      Bar b = new Bar();
      b.doStuff(ackWeDoNotHaveAFoo!); // Don't try to compile this at home
   }
}
interface Foo {
   void foof(); 
}
class Bar {
   void doStuff(Foo f) { }
}
No problemo, except that you don't have an object from a class that implements 
Foo, and you can't instantiate one, either, because you don't even have a class that 
implements Foo, let alone an instance of one. So you first need a class that 
implements Foo, and then you need an instance of that class to pass to the Bar class's 
doStuff() method. Savvy Java programmer that you are, you simply define an 
anonymous inner class, right inside the argument. That's right, just where you least 
expect to find a class. And here's what it looks like:
 1. class MyWonderfulClass {
 2. void go() {
 3. Bar b = new Bar();
 4. b.doStuff(new Foo() {
 5. public void foof() {
 6. System.out.println("foofy");
 7. } // end foof method
 8. }); // end inner class def, arg, and b.doStuff stmt. 9. } // end go()
10. } // end class
11. 12. interface Foo {
13. void foof();
14. }
15. class Bar {
16. void doStuff(Foo f) { }
17. }
Argument-Deﬁ  ned Anonymous Inner Classes 679
All the action starts on line 4. We're calling doStuff() on a Bar object, but 
the method takes an instance that IS-A Foo, where Foo is an interface. So we must 
make both an implementation class and an instance of that class, all right here in the 
argument to doStuff(). So that's what we do. We write
 new Foo() {
to start the new class definition for the anonymous class that implements the Foo 
interface. Foo has a single method to implement, foof(), so on lines 5, 6, and 7 
we implement the foof() method. Then on line 8—whoa!—more strange syntax 
appears. The first curly brace closes off the new anonymous class definition. But 
don't forget that this all happened as part of a method argument, so the close 
parenthesis, ), finishes off the method invocation, and then we must still end the 
statement that began on line 4, so we end with a semicolon. Study this syntax! You 
will see anonymous inner classes on the exam, and you'll have to be very, very picky 
about the way they're closed. If they're argument local, they end like this:
});
but if they're just plain-old anonymous classes, then they end like this:
};
Regardless, the syntax is not what you use in virtually any other part of Java, so 
be careful. Any question from any part of the exam might involve anonymous inner 
classes as part of the code. CERTIFICATION OBJECTIVE
Static Nested Classes
We saved the easiest for last, as a kind of treat : )
You'll sometimes hear static nested classes referred to as static inner classes, but 
they really aren't inner classes at all, by the standard definition of an inner class. While an inner class (regardless of the flavor) enjoys that special relationship with 
the outer class (or rather the instances of the two classes share a relationship), a 
static nested class does not. It is simply a non-inner (also called "top-level") class 
scoped within another. So with static classes it's really more about name-space 
resolution than about an implicit relationship between the two classes. 680 Chapter 8:  Inner Classes
A static nested class is simply a class that's a static member of the enclosing class :
class BigOuter {
   static class Nested { }
}
The class itself isn't really "static"; there's no such thing as a static class. The 
static modifier in this case says that the nested class is a static member of the outer 
class. That means it can be accessed, as with other static members, without having 
an instance of the outer class. Instantiating and Using Static Nested Classes
You use standard syntax to access a static nested class from its enclosing class. The 
syntax for instantiating a static nested class from a non-enclosing class is a little 
different from a normal inner class, and looks like this:
class BigOuter {
  static class Nest {void go() { System.out.println("hi"); } }
}
class Broom {
  static class B2 {void goB2() { System.out.println("hi 2"); } }
  public static void main(String[] args) {
    BigOuter.Nest n = new BigOuter.Nest();   // both class names
    n.go();
    B2 b2 = new B2();     // access the enclosed class
    b2.goB2();
  }
} 
Which produces
hi
hi 2
Instantiating and Using Static Nested Classes 681
Just as a static method does not have access to the instance variables and 
nonstatic methods of the class, a static nested class does not have access to the instance 
variables and nonstatic methods of the outer class. Look for static nested classes with 
code that behaves like a nonstatic (regular inner) class. CERTIFICATION SUMMARY
Inner classes will show up throughout the exam, in any topic, and these are some of 
the exam's hardest questions. You should be comfortable with the sometimes bizarre 
syntax, and know how to spot legal and illegal inner class definitions. We looked first at "regular" inner classes, where one class is a member of another. You learned that coding an inner class means putting the class definition of the 
inner class inside the curly braces of the enclosing (outer) class, but outside of 
any method or other code block. You learned that an inner class instance shares a 
special relationship with a specific instance of the outer class, and that this special 
relationship lets the inner class access all members of the outer class, including those 
marked private. You learned that to instantiate an inner class, you must have a 
reference to an instance of the outer class. Next we looked at method-local inner classes—classes defined inside a method. The code for a method-local inner class looks virtually the same as the code for any 
other class definition, except that you can't apply an access modifier the way you 
can with a regular inner class. You learned why method-local inner classes cannot 
use non-final local variables declared within the method—the inner class instance 
may outlive the stack frame, so the local variable might vanish while the inner class 
object is still alive. You saw that to use the inner class you need to instantiate it, and 
that the instantiation must come after the class declaration in the method. We also explored the strangest inner class type of all—the anonymous inner class. You learned that they come in two forms, normal and argument-defined. Normal, 
ho-hum, anonymous inner classes are created as part of a variable assignment, while 
argument-defined inner classes are actually declared, defined, and automatically 
instantiated all within the argument to a method! We covered the way anonymous 
inner classes can be either a subclass of the named class type, or an implementer of 
the named interface. Finally, we looked at how polymorphism applies to anonymous 
inner classes: you can invoke on the new instance only those methods defined in 
the named class or interface type. In other words, even if the anonymous inner class 
defines its own new method, no code from anywhere outside the inner class will be 
able to invoke that method. As if we weren't already having enough fun for one day, we pushed on to static 
nested classes, which really aren't inner classes at all. Known as static nested classes, 
a nested class marked with the static modifier is quite similar to any other non-
inner class, except that to access it, code must have access to both the nested 
and enclosing class. We saw that because the class is static, no instance of the 
enclosing class is needed, and thus the static nested class does not share a special 
relationship with any instance of the enclosing class. Remember, static inner classes 
can't access instance methods or variables. 682 Chapter 8: Inner Classes
TWO-MINUTE DRILL
Here are some of the key points from this chapter. Inner Classes
❑ A "regular" inner class is declared inside the curly braces of another class, but 
outside any method or other code block. ❑ An inner class is a full-fledged member of the enclosing (outer) class, so it 
can be marked with an access modifier as well as the abstract or final 
modifiers. (Never both abstract and final together— remember that 
abstract must be subclassed, whereas final cannot be subclassed). ❑ An inner class instance shares a special relationship with an instance of the 
enclosing class. This relationship gives the inner class access to all of the 
outer class's members, including those marked private. ❑ To instantiate an inner class, you must have a reference to an instance of the 
outer class. ❑ From code within the enclosing class, you can instantiate the inner class 
using only the name of the inner class, as follows:
MyInner mi = new MyInner(); 
❑ From code outside the enclosing class's instance methods, you can 
instantiate the inner class only by using both the inner and outer class names, 
and a reference to the outer class as follows:
MyOuter mo = new MyOuter();
MyOuter.MyInner inner = mo.new MyInner(); 
❑ From code within the inner class, the keyword this holds a reference to 
the inner class instance. To reference the outer this (in other words, the 
instance of the outer class that this inner instance is tied to) precede the 
keyword this with the outer class name as follows:   MyOuter.this;
Method-Local Inner Classes
❑ A method-local inner class is defined within a method of the enclosing class. ❑ For the inner class to be used, you must instantiate it, and that instantiation 
must happen within the same method, but after the class definition code. ❑ A method-local inner class cannot use variables declared within the method 
(including parameters) unless those variables are marked final. T wo-Minute Drill 683
✓
❑ The only modifiers you can apply to a method-local inner class are abstract 
and final. (Never both at the same time, though.)
Anonymous Inner Classes
❑ Anonymous inner classes have no name, and their type must be either a 
subclass of the named type or an implementer of the named interface. ❑ An anonymous inner class is always created as part of a statement; don't 
forget to close the statement after the class definition with a curly brace. This 
is a rare case in Java, a curly brace followed by a semicolon. ❑ Because of polymorphism, the only methods you can call on an anonymous 
inner class reference are those defined in the reference variable class (or 
interface), even though the anonymous class is really a subclass or imple-
menter of the reference variable type. ❑ An anonymous inner class can extend one subclass or implement one 
interface. Unlike non-anonymous classes (inner or otherwise), an anonymous 
inner class cannot do both. In other words, it cannot both extend a class and 
implement an interface, nor can it implement more than one interface. ❑ An argument-defined inner class is declared, defined, and automatically 
instantiated as part of a method invocation. The key to remember is that the 
class is being defined within a method argument, so the syntax will end the 
class definition with a curly brace, followed by a closing parenthesis to end 
the method call, followed by a semicolon to end the statement:   });
Static Nested Classes
❑ Static nested classes are inner classes marked with the static modifier. ❑  A static nested class is not an inner class, it's a top-level nested class. ❑  Because the nested class is static, it does not share any special relationship 
with an instance of the outer class. In fact, you don't need an instance of the 
outer class to instantiate a static nested class. ❑  Instantiating a static nested class requires using both the outer and nested 
class names as follows:
BigOuter.Nested n = new BigOuter.Nested();
❑  A static nested class cannot access non-static members of the outer class, 
since it does not have an implicit reference to any outer instance (in other 
words, the nested class instance does not get an outer this reference). 684 Chapter 8:  Inner Classes
SELF TEST
The following questions will help you measure your understanding of the dynamic and life-altering 
material presented in this chapter. Read all of the choices carefully.

--- Chunk #1530 ---
Take your time. Breathe.

--- Chunk #1531 ---
1. Which are true about a static nested class? (Choose all that apply.)
  A. You must have a reference to an instance of the enclosing class in order to instantiate it
  B. It does not have access to non-static members of the enclosing class
  C . Its variables and methods must be static
  D . If the outer class is named MyOuter, and the nested class is named MyInner, it can be 
       instantiated using new MyOuter.MyInner();
  E . It must extend the enclosing class
 2. Given:
class Boo {
   Boo(String s) { }
   Boo() { }
}
class Bar extends Boo {
   Bar() { }
   Bar(String s) {super(s);}
   void zoo() {
   // insert code here
   }
}
  Which create an anonymous inner class from within class Bar? (Choose all that apply.)
  A. Boo f = new Boo(24) { };
  B . Boo f = new Bar() { };
  C . Boo f = new Boo() {String s; };
  D . Bar f = new Boo(String s) { };
  E . Boo f = new Boo.Bar(String s) { };
 3. Which are true about a method-local inner class? (Choose all that apply.)
  A. It must be marked final
  B . It can be marked abstract
Self T est 685
  C . It can be marked public
  D . It can be marked static
  E . It can access private members of the enclosing class
 4. Given:
 1. public class TestObj {
 2. public static void main(String[] args) {
 3. Object o = new Object() {
 4. public boolean equals(Object obj) {
 5. return true;
 6.

--- Chunk #1532 ---
}
 7.

--- Chunk #1533 ---
}
 8. System.out.println(o.equals("Fred"));
 9. }
10. }
  What is the result?

--- Chunk #1534 ---
A. An exception occurs at runtime
  B. true
  C. Fred
  D. Compilation fails because of an error on line 3
  E. Compilation fails because of an error on line 4
  F. Compilation fails because of an error on line 8
  G. Compilation fails because of an error on a line other than 3, 4, or 8
 5. Given:
 1. public class HorseTest {
 2. public static void main(String[] args) {
 3. class Horse {
 4. public String name;
 5. public Horse(String s) {
 6. name = s;
 7. }
 8.

--- Chunk #1535 ---
}
 9. Object obj = new Horse("Zippo");
10. System.out.println(obj.name);
11. }
12. }
686 Chapter 8:  Inner Classes
  What is the result? A. An exception occurs at runtime at line 10
  B. Zippo
  C. Compilation fails because of an error on line 3
  D. Compilation fails because of an error on line 9
  E. Compilation fails because of an error on line 10
 6. Given:
public abstract class AbstractTest {
   public int getNum() {
      return 45;
   }
   public abstract class Bar {
     public int getNum() {
       return 38;
     }
   }
   public static void main(String[] args) {
      AbstractTest t = new AbstractTest() {
         public int getNum() {
           return 22;
        }
      };
      AbstractTest.Bar f = t.new Bar() {
         public int getNum() {
           return 57;
         }
      };
      System.out.println(f.getNum() + " " + t.getNum());
   }
}
  What is the result? A.

--- Chunk #1536 ---
57 22
  B. 45 38
  C. 45 57
  D. An exception occurs at runtime
  E. Compilation fails
Self T est 687
 7. Given:
 3. public class Tour {
 4. public static void main(String[] args) {
 5. Cathedral c = new Cathedral();
 6. // insert code here
 7. s.go();
 8. }
 9.

--- Chunk #1537 ---
}
10. class Cathedral {
11. class Sanctum {
12. void go() { System.out.println("spooky"); }
13. }
14. }
  Which, inserted independently at line 6, compile and produce the output "spooky"? (Choose all 
that apply.)
  A. Sanctum s = c.new Sanctum();
  B. c.Sanctum s = c.new Sanctum();
  C. c.Sanctum s = Cathedral.new Sanctum();
  D. Cathedral.Sanctum s = c.new Sanctum();
  E. Cathedral.Sanctum s = Cathedral.new Sanctum();
 8. Given:
 5. class A { void m() { System.out.println("outer"); } }
 6. 7. public class TestInners {
 8. public static void main(String[] args) {
 9. new TestInners().go();
10. }
11. void go() {
12. new A().m();
13. class A { void m() { System.out.println("inner"); } }
14. }
15. class A { void m() { System.out.println("middle"); } }
16. }
  What is the result?

--- Chunk #1538 ---
A. inner
  B. outer
688 Chapter 8:  Inner Classes
  C. middle
  D. Compilation fails
  E. An exception is thrown at runtime
 9. Given:
 3. public class Car {
 4. class Engine {
 5. // insert code here
 6.

--- Chunk #1539 ---
}
 7. public static void main(String[] args) {
 8. new Car().go();
 9. }
10. void go() {
11. new Engine();
12. }
13. void drive() { System.out.println("hi"); }
14. }
  Which, inserted independently at line 5, produce the output "hi"? (Choose all that apply.)
  A. { Car.drive(); } 
  B. { this.drive(); }
  C. { Car.this.drive(); }
  D. { this.Car.this.drive(); }
  E. Engine() { Car.drive(); }
  F. Engine() { this.drive(); }
  G. Engine() { Car.this.drive(); }
10. Given:
 3. public class City {
 4. class Manhattan { 
 5. void doStuff() throws Exception { System.out.print("x "); }
 6. }
 7. class TimesSquare extends Manhattan {
 8. void doStuff() throws Exception { }
 9. }
10. public static void main(String[] args) throws Exception {
11. new City().go();
12. }
13. void go() throws Exception { new TimesSquare().doStuff(); }
14. }
Self T est 689
  What is the result? A.

--- Chunk #1540 ---
x
  B. x x 
  C. No output is produced
  D. Compilation fails due to multiple errors
  E. Compilation fails due only to an error on line 4
  F. Compilation fails due only to an error on line 7
  G. Compilation fails due only to an error on line 10
  H. Compilation fails due only to an error on line 13
 11. Given:
 3. public class Navel {
 4. private int size = 7;
 5. private static int length = 3;
 6. public static void main(String[] args) {
 7. new Navel().go();
 8. }
 9. void go() {
10. int size = 5;
11. System.out.println(new Gazer().adder());
12. }
13. class Gazer {
14. int adder() { return size * length; }
15. }
16. }
  What is the result? A. 15
  B. 21
  C. An exception is thrown at runtime
  D. Compilation fails due to multiple errors
  E. Compilation fails due only to an error on line 4
  F. Compilation fails due only to an error on line 5
690 Chapter 8:  Inner Classes
 12. Given:
 3. import java.util.*;
 4. public class Pockets {
 5. public static void main(String[] args) {
 6. String[] sa = {"nickel", "button", "key", "lint"};
 7. Sorter s = new Sorter();
 8. for(String s2: sa) System.out.print(s2 + " ");
 9. Arrays.sort(sa,s);
10. System.out.println();
11. for(String s2: sa) System.out.print(s2 + " ");
12. }
13. class Sorter implements Comparator<String> { 
14. public int compare(String a, String b) { 
15. return b.compareTo(a);
16. } 
17. }
18. }
  What is the result?

--- Chunk #1541 ---
A. Compilation fails
  B. button key lint nickel
 nickel lint key button
  C. nickel button key lint 
 button key lint nickel
  D. nickel button key lint 
 nickel button key lint
  E. nickel button key lint 
 nickel lint key button
  F. An exception is thrown at runtime
Self T est 691
SELF TEST ANSWERS
 1. Which are true about a static nested class? (Choose all that apply.)
  A. You must have a reference to an instance of the enclosing class in order to instantiate it
  B. It does not have access to non-static members of the enclosing class
  C . Its variables and methods must be static
  D . If the outer class is named MyOuter, and the nested class is named MyInner, it can be 
       instantiated using new MyOuter.MyInner();
  E . It must extend the enclosing class
  Answer:
   ✓  B and D. B is correct because a static nested class is not tied to an instance of the 
enclosing class, and thus can't access the non-static members of the class (just as a 
static method can't access non-static members of a class). D uses the correct syntax 
for instantiating a static nested class.     A is incorrect because static nested classes do not need (and can't use) a reference to an 
instance of the enclosing class. C is incorrect because static nested classes can declare and 
define non-static members. E is wrong because…it just is. There's no rule that says an 
inner or nested class has to extend anything. 2. Given:
class Boo {
   Boo(String s) { }
   Boo() { }
}
class Bar extends Boo {
   Bar() { }
   Bar(String s) {super(s);}
   void zoo() {
   // insert code here
   }
}
  Which create an anonymous inner class from within class Bar? (Choose all that apply.)
  A. Boo f = new Boo(24) { };
  B . Boo f = new Bar() { };
692 Chapter 8:  Inner Classes
  C . Boo f = new Boo() {String s; };
  D . Bar f = new Boo(String s) { };
  E . Boo f = new Boo.Bar(String s) { };
  Answer:
   ✓  B and C. B is correct because anonymous inner classes are no different from any other 
class when it comes to polymorphism. That means you are always allowed to declare a 
reference variable of the superclass type and have that reference variable refer to an 
instance of a subclass type, which in this case is an anonymous subclass of Bar. Since Bar 
is a subclass of Boo, it all works. C uses correct syntax for creating an instance of Boo.     A is incorrect because it passes an int to the Boo constructor, and there is no matching 
constructor in the Boo class. D is incorrect because it violates the rules of polymorphism; 
you cannot refer to a superclass type using a reference variable declared as the subclass 
type. The superclass doesn't have everything the subclass has. E uses incorrect syntax. 3. Which are true about a method-local inner class? (Choose all that apply.)
  A. It must be marked final
  B . It can be marked abstract
  C . It can be marked public
  D . It can be marked static
  E . It can access private members of the enclosing class
  Answer:
   ✓  B and E. B is correct because a method-local inner class can be abstract, although it
means a subclass of the inner class must be created if the abstract class is to be used (so 
an abstract method-local inner class is probably not useful). E is correct because a 
method-local inner class works like any other inner class—it has a special relationship to
an instance of the enclosing class, thus it can access all members of the enclosing class.    A is incorrect because a method-local inner class does not have to be declared final 
(although it is legal to do so). C and D are incorrect because a method-local inner class 
cannot be made public (remember—local variables can't be public) or static. 4. Given:
 1. public class TestObj {
 2. public static void main(String[] args) {
 3. Object o = new Object() {
Self T est Answers 693
 4. public boolean equals(Object obj) {
 5. return true;
 6.

--- Chunk #1542 ---
}
 7.

--- Chunk #1543 ---
}
 8. System.out.println(o.equals("Fred"));
 9. }
10. }
  What is the result?

--- Chunk #1544 ---
A. An exception occurs at runtime
  B. true
  C. fred
  D. Compilation fails because of an error on line 3
  E. Compilation fails because of an error on line 4
  F. Compilation fails because of an error on line 8
  G. Compilation fails because of an error on a line other than 3, 4, or 8
  Answer:
   ✓  G. This code would be legal if line 7 ended with a semicolon. Remember that line 3 is a
statement that doesn't end until line 7, and a statement needs a closing semicolon!    A, B, C, D, E, and F are incorrect based on the program logic described above. If the
semicolon were added at line 7, then answer B would be correct—the program would 
print true, the return from the equals() method overridden by the anonymous 
subclass of Object. 5. Given:
 1. public class HorseTest {
 2. public static void main(String[] args) {
 3. class Horse {
 4. public String name;
 5. public Horse(String s) {
 6. name = s;
 7. }
 8.

--- Chunk #1545 ---
}
 9. Object obj = new Horse("Zippo");
10. System.out.println(obj.name);
11. }
12. }
694 Chapter 8:  Inner Classes
  What is the result? A. An exception occurs at runtime at line 10
  B. Zippo
  C. Compilation fails because of an error on line 3
  D. Compilation fails because of an error on line 9
  E. Compilation fails because of an error on line 10
  Answer:
   ✓  E. If you use a reference variable of type Object, you can access only those members 
defined in class Object.    A, B, C, and D are incorrect based on the program logic described above. 6. Given:
public abstract class AbstractTest {
   public int getNum() {
      return 45;
   }
   public abstract class Bar {
     public int getNum() {
       return 38;
     }
   }
   public static void main(String[] args) {
      AbstractTest t = new AbstractTest() {
         public int getNum() {
           return 22;
         }
      };
      AbstractTest.Bar f = t.new Bar() {
         public int getNum() {
           return 57;
         }
      };
      System.out.println(f.getNum() + " " + t.getNum());
}  }
  What is the result? A.

--- Chunk #1546 ---
57 22
  B. 45 38
  C. 45 57
  D. An exception occurs at runtime
  E. Compilation fails
Self T est Answers 695
  Answer:
   ✓  A. You can define an inner class as abstract, which means you can instantiate only
concrete subclasses of the abstract inner class. The object referenced by the variable t 
is an instance of an anonymous subclass of AbstractTest, and the anonymous class 
overrides the getNum() method to return 22. The variable referenced by f  is an instance
of an anonymous subclass of Bar, and the anonymous Bar subclass also overrides the 
getNum() method (to return 57). Remember that to create a Bar instance, we need an
instance of the enclosing AbstractTest class to tie to the new Bar inner class instance. AbstractTest can't be instantiated because it's abstract, so we created an anonymous 
subclass (non-abstract) and then used the instance of that anonymous subclass to tie  
to the new Bar subclass instance.    B, C, D, and E are incorrect based on the program logic described above.

--- Chunk #1547 ---
7.

--- Chunk #1548 ---
Given:
 3. public class Tour {
 4. public static void main(String[] args) {
 5. Cathedral c = new Cathedral();
 6. // insert code here
 7. s.go();
 8. }
 9.

--- Chunk #1549 ---
}
10. class Cathedral {
11. class Sanctum {
12. void go() { System.out.println("spooky"); }
13. }
14. }
  Which, inserted independently at line 6, compile and produce the output "spooky"? (Choose all 
that apply.)
  A. Sanctum s = c.new Sanctum();
  B. c.Sanctum s = c.new Sanctum();
  C. c.Sanctum s = Cathedral.new Sanctum();
  D. Cathedral.Sanctum s = c.new Sanctum();
  E. Cathedral.Sanctum s = Cathedral.new Sanctum();
  Answer:
   ✓  D is correct. It is the only code that uses the correct inner class instantiation syntax.     A, B, C, and E are incorrect based on the above. (Objective 1.1)
696 Chapter 8:  Inner Classes
 8. Given:
 5. class A { void m() { System.out.println("outer"); } }
 6. 7. public class TestInners {
 8. public static void main(String[] args) {
 9. new TestInners().go();
10. }
11. void go() {
12. new A().m();
13. class A { void m() { System.out.println("inner"); } }
14. }
15. class A { void m() { System.out.println("middle"); } }
16. }
  What is the result?

--- Chunk #1550 ---
A. inner
  B. outer
  C. middle
  D. Compilation fails
  E. An exception is thrown at runtime
  Answer:
   ✓  C is correct. The "inner" version of class A isn't used because its declaration comes 
after the instance of class A is created in the go() method.     A, B, D, and E are incorrect based on the above. (Objective 1.1)
 9. Given:
 3. public class Car {
 4. class Engine {
 5. // insert code here
 6.

--- Chunk #1551 ---
}
 7. public static void main(String[] args) {
 8. new Car().go();
 9. }
10. void go() {
11. new Engine();
12. }
13. void drive() { System.out.println("hi"); }
14. }
Self T est Answers 697
  Which, inserted independently at line 5, produce the output "hi"? (Choose all that apply.)
  A. { Car.drive(); } 
  B. { this.drive(); }
  C. { Car.this.drive(); }
  D. { this.Car.this.drive(); }
  E. Engine() { Car.drive(); }
  F. Engine() { this.drive(); }
  G. Engine() { Car.this.drive(); }
  Answer:
   ✓  C and G are correct. C is the correct syntax to access an inner class’s outer instance 
method from an initialization block, and G is the correct syntax to access it from 
a constructor.     A, B, D, E, and F are incorrect based on the above. (Objectives 1.1, 1.4)
10. Given:
 3. public class City {
 4. class Manhattan { 
 5. void doStuff() throws Exception { System.out.print("x "); }
 6. }
 7. class TimesSquare extends Manhattan {
 8. void doStuff() throws Exception { }
 9. }
10. public static void main(String[] args) throws Exception {
11. new City().go();
12. }
13. void go() throws Exception { new TimesSquare().doStuff(); }
14. }
  What is the result?

--- Chunk #1552 ---
A. x
  B. x x 
  C. No output is produced
  D. Compilation fails due to multiple errors
  E. Compilation fails due only to an error on line 4
  F. Compilation fails due only to an error on line 7
  G. Compilation fails due only to an error on line 10
  H. Compilation fails due only to an error on line 13
698 Chapter 8:  Inner Classes
Self T est Answers 699
  Answer:
   ✓  C is correct. The inner classes are valid, and all the methods (including main()), correctly 
throw an Exception, given that doStuff() throws an Exception. The doStuff() in class 
TimesSquare overrides class Manhattan's doStuff() and produces no output.     A, B, D, E, F, G, and H are incorrect based on the above.

--- Chunk #1553 ---
(Objectives 1.1, 2.4)
 11.

--- Chunk #1554 ---
Given:
 3. public class Navel {
 4. private int size = 7;
 5. private static int length = 3;
 6. public static void main(String[] args) {
 7. new Navel().go();
 8. }
 9. void go() {
10. int size = 5;
11. System.out.println(new Gazer().adder());
12. }
13. class Gazer {
14. int adder() { return size * length; }
15. }
16. }
  What is the result? A. 15
  B. 21
  C. An exception is thrown at runtime
  D. Compilation fails due to multiple errors
  E. Compilation fails due only to an error on line 4
  F. Compilation fails due only to an error on line 5
  Answer:
   ✓  B is correct. The inner class Gazer has access to Navel's private static and private 
instance variables.     A, C, D, E, and F are incorrect based on the above.

--- Chunk #1555 ---
(Objectives 1.1, 1.4)
 12. Given:
 3. import java.util.*;
 4. public class Pockets {
 5. public static void main(String[] args) {
 6. String[] sa = {"nickel", "button", "key", "lint"};
 7. Sorter s = new Sorter();
 8. for(String s2: sa) System.out.print(s2 + " ");
 9. Arrays.sort(sa,s);
10. System.out.println();
11. for(String s2: sa) System.out.print(s2 + " ");
12. }
13. class Sorter implements Comparator<String> { 
14. public int compare(String a, String b) { 
15. return b.compareTo(a);
16. } 
17. }
18. }
  What is the result?

--- Chunk #1556 ---
A. Compilation fails
  B. button key lint nickel
 nickel lint key button
  C. nickel button key lint 
 button key lint nickel
  D. nickel button key lint 
 nickel button key lint
  E. nickel button key lint 
 nickel lint key button
  F. An exception is thrown at runtime
  Answer:
   ✓  A is correct, the inner class Sorter must be declared static to be called from the static 
method main(). If Sorter had been static, answer E would be correct.     B, C, D, E, and F are incorrect based on the above. (Objectives 1.1, 1.4, 6.5)
700 Chapter 8:  Inner Classes
9
Threads
CERTIFICATION OBJECTIVES
Start New Threads
 Recognize Thread States and 
        Transitions
 Use Object Locking to Avoid
       Concurrent Access

Write Code That Uses wait(), 
        notify(), or notifyAll()
 ✓   T wo-Minute Drill
          Q&A Self T est
 
	
702 Chapter 9:  Threads
CERTIFICATION OBJECTIVE
Defining, Instantiating, and Starting Threads 
(Objective 4.1)
4.1 Write code to define, instantiate, and start new threads using both java.lang.Thread 
and java.lang.Runnable. Imagine a stockbroker application with a lot of complex capabilities. One of 
its functions is "download last stock option prices," another is "check prices for 
warnings," and a third time-consuming operation is "analyze historical data for 
company XYZ."
In a single-threaded runtime environment, these actions execute one after 
another. The next action can happen only when the previous one is finished. If a 
historical analysis takes half an hour, and the user selects to perform a download and 
check afterward, the warning may come too late to, say, buy or sell stock as a result. We just imagined the sort of application that cries out for multithreading. Ideally, 
the download should happen in the background (that is, in another thread). That 
way, other processes could happen at the same time so that, for example, a warning 
could be communicated instantly. All the while, the user is interacting with other 
parts of the application. The analysis, too, could happen in a separate thread, so the 
user can work in the rest of the application while the results are being calculated. So what exactly is a thread? In Java, "thread" means two different things:
■  An instance of class java.lang.Thread
■  A thread of execution
An instance of Thread is just…an object. Like any other object in Java, it has 
variables and methods, and lives and dies on the heap. But a thread of execution is 
an individual process (a "lightweight" process) that has its own call stack. In Java, 
there is one thread per call stack—or, to think of it in reverse, one call stack per 
thread. Even if you don't create any new threads in your program, threads are back 
there running. The main() method, that starts the whole ball rolling, runs in one thread, called 
(surprisingly) the main thread. If you looked at the main call stack (and you can, any 
time you get a stack trace from something that happens after main begins, but not 
within another thread), you'd see that main() is the first method on the stack—
Deﬁ  ning, Instantiating, and Starting Threads (Exam Objective 4.1) 703
the method at the bottom. But as soon as you create a new thread, a new stack 
materializes and methods called from that thread run in a call stack that's separate 
from the main() call stack. That second new call stack is said to run concurrently 
with the main thread, but we'll refine that notion as we go through this chapter. You might find it confusing that we're talking about code running concurrently—
as if in parallel—given that there's only one CPU on most of the machines running 
Java. What gives? The JVM, which gets its turn at the CPU by whatever scheduling 
mechanism the underlying OS uses, operates like a mini-OS and schedules its own 
threads regardless of the underlying operating system. In some JVMs, the Java 
threads are actually mapped to native OS threads, but we won't discuss that here; 
native threads are not on the exam. Nor is it required to understand how threads 
behave in different JVM environments. In fact, the most important concept to 
understand from this entire chapter is this:
When it comes to threads, very little is guaranteed. So be very cautious about interpreting the behavior you see on one machine 
as "the way threads work." The exam expects you to know what is and is not 
guaranteed behavior, so that you can design your program in such a way that it will 
work regardless of the underlying JVM. That's part of the whole point of Java. Don't make the mistake of designing your program to be dependent on a 
particular implementation of the JVM. As you'll learn a little later, different 
JVMs can run threads in profoundly different ways. For example, one JVM 
might be sure that all threads get their turn, with a fairly even amount of time 
allocated for each thread in a nice, happy, round-robin fashion. But in other 
JVMs, a thread might start running and then just hog the whole show, never 
stepping out so others can have a turn. If you test your application on the 
"nice turn-taking" JVM, and you don't know what is and is not guaranteed in 
Java, then you might be in for a big shock when you run it under a JVM with a 
different thread scheduling mechanism. The thread questions are among the most difficult questions on the exam. In fact, for most people they are the toughest questions on the exam, and with 
four objectives for threads you'll be answering a lot of thread questions. If you're 
not already familiar with threads, you'll probably need to spend some time 
experimenting. Also, one final disclaimer: This chapter makes almost no attempt to 
teach you how to design a good, safe, multithreaded application. We only scratch 
the surface of that huge topic in this chapter! You're here to learn the basics of 
threading, and what you need to get through the thread questions on the exam. Before you can write decent multithreaded code, however, you really need to study 
more on the complexities and subtleties of multithreaded code. (Note: The topic of daemon threads is NOT on the exam. All of the threads 
discussed in this chapter are "user" threads. You and the operating system can create 
a second kind of thread called a daemon thread. The difference between these two 
types of threads (user and daemon) is that the JVM exits an application only when 
all user threads are complete—the JVM doesn't care about letting daemon threads 
complete, so once all user threads are complete, the JVM will shut down, regardless 
of the state of any daemon threads. Once again, this topic is NOT on the exam.)
Making a Thread
A thread in Java begins as an instance of java.lang.Thread. You'll find methods 
in the Thread class for managing threads including creating, starting, and pausing 
them. For the exam, you'll need to know, at a minimum, the following methods:
start()
yield()
sleep()
run()
The action happens in the run() method. Think of the code you want to execute 
in a separate thread as the job to do. In other words, you have some work that needs 
to be done, say, downloading stock prices in the background while other things 
are happening in the program, so what you really want is that job to be executed 
in its own thread. So if the work you want done is the job, the one doing the work 
(actually executing the job code) is the thread. And the job always starts from a 
run() method as follows:
public void run() {
  // your job code goes here
}
You always write the code that needs to be run in a separate thread in a run() 
method. The run() method will call other methods, of course, but the thread of 
execution—the new call stack—always begins by invoking run(). So where does 
the run() method go? In one of the two classes you can use to define your thread job. You can define and instantiate a thread in one of two ways:
704 Chapter 9:  Threads
■ Extend the java.lang.Thread class. ■ Implement the Runnable interface. You need to know about both for the exam, although in the real world you're 
much more likely to implement Runnable than extend Thread. Extending the 
Thread class is the easiest, but it's usually not a good OO practice. Why? Because 
subclassing should be reserved for specialized versions of more general superclasses. So the only time it really makes sense (from an OO perspective) to extend Thread is 
when you have a more specialized version of a Thread class. In other words, because 
you have more specialized thread-specific behavior. Chances are, though, that the 
thread work you want is really just a job to be done by a thread. In that case, you 
should design a class that implements the Runnable interface, which also leaves your 
class free to extend some other class. Deﬁ ning a Thread
To define a thread, you need a place to put your run() method, and as we just 
discussed, you can do that by extending the Thread class or by implementing the 
Runnable interface. We'll look at both in this section. Extending java.lang.Thread
The simplest way to define code to run in a separate thread is to
■ Extend the java.lang.Thread class. ■ Override the run() method. It looks like this:
class MyThread extends Thread {
   public void run() {
     System.out.println("Important job running in MyThread");
   }
 }
The limitation with this approach (besides being a poor design choice in most 
cases) is that if you extend Thread, you can't extend anything else. And it's not as if 
you really need that inherited Thread class behavior, because in order to use a thread 
you'll need to instantiate one anyway. Deﬁ  ning a Thread (Exam Objective 4.1) 705
Keep in mind that you're free to overload the run() method in your Thread 
subclass:
class MyThread extends Thread {
  public void run() {
    System.out.println("Important job running in MyThread");
  }
  public void run(String s) {
    System.out.println("String in run is " + s);
  }
}
But know this: The overloaded run(String s) method will be ignored by the 
Thread class unless you call it yourself. The Thread class expects a run() method 
with no arguments, and it will execute this method for you in a separate call stack 
after the thread has been started. With a run(String s)  method, the Thread 
class won't call the method for you, and even if you call the method directly 
yourself, execution won't happen in a new thread of execution with a separate 
call stack. It will just happen in the same call stack as the code that you made the 
call from, just like any other normal method call. Implementing java.lang.Runnable
Implementing the Runnable interface gives you a way to extend any class you like, 
but still define behavior that will be run by a separate thread. It looks like this:
class MyRunnable implements Runnable {
   public void run() {
     System.out.println("Important job running in MyRunnable");
   }
}
Regardless of which mechanism you choose, you've now got yourself some code 
that can be run by a thread of execution. So now let's take a look at instantiating your 
thread-capable class, and then we'll figure out how to actually get the thing running. Instantiating a Thread
Remember, every thread of execution begins as an instance of class Thread. Regardless of whether your run() method is in a Thread subclass or a Runnable 
implementation class, you still need a Thread object to do the work. 706 Chapter 9:  Threads
If you extended the Thread class, instantiation is dead simple (we'll look at some 
additional overloaded constructors in a moment):
MyThread t = new MyThread()
If you implement Runnable, instantiation is only slightly less simple. To have 
code run by a separate thread, you still need a Thread instance. But rather than 
combining both the thread and the job (the code in the run()method) into one 
class, you've split it into two classes—the Thread class for the thread-specific code 
and your Runnable implementation class for your job-that-should-be-run-by-a-
thread code. (Another common way to think about this is that the Thread is the 
"worker," and the Runnable is the "job" to be done.)
First, you instantiate your Runnable class:
MyRunnable r = new MyRunnable();
Next, you get yourself an instance of java.lang.Thread (somebody has to run your 
job…), and you give it your job! Thread t = new Thread(r);  // Pass your Runnable to the Thread
If you create a thread using the no-arg constructor, the thread will call its own 
run() method when it's time to start working. That's exactly what you want when 
you extend Thread, but when you use Runnable, you need to tell the new thread to 
use your run()method rather than its own. The Runnable you pass to the Thread 
constructor is called the target or the target Runnable. You can pass a single Runnable instance to multiple Thread objects, so that the 
same Runnable becomes the target of multiple threads, as follows:
public class TestThreads {
   public static void main (String [] args) {
     MyRunnable r = new MyRunnable();
     Thread foo = new Thread(r);
     Thread bar = new Thread(r);
     Thread bat = new Thread(r);
   }
}
Giving the same target to multiple threads means that several threads of 
execution will be running the very same job (and that the same job will be done 
multiple times). Instantiating a Thread (Exam Objective 4.1) 707
Besides the no-arg constructor and the constructor that takes a Runnable (the 
target, i.e., the instance with the job to do), there are other overloaded constructors 
in class Thread. The constructors we care about are
■ Thread()
■ Thread(Runnable target)
■ Thread(Runnable target, String name)
■ Thread(String name)
You need to recognize all of them for the exam! A little later, we'll discuss some of 
the other constructors in the preceding list. So now you've made yourself a Thread instance, and it knows which run() 
method to call. But nothing is happening yet. At this point, all we've got is a plain 
old Java object of type Thread. It is not yet a thread of execution. To get an actual 
thread—a new call stack—we still have to start the thread. When a thread has been instantiated but not started (in other words, the 
start() method has not been invoked on the Thread instance), the thread is 
said to be in the new state. At this stage, the thread is not yet considered to be 
alive. Once the start() method is called, the thread is considered to be alive 
(even though the run() method may not have actually started executing yet). A 
thread is considered dead (no longer alive) after the run() method completes. The 
isAlive() method is the best way to determine if a thread has been started but has 
not yet completed its run() method. (Note: The getState() method is very useful 
for debugging, but you won't have to know it for the exam.)
708 Chapter 9:  Threads
The Thread class itself implements Runnable. (After all, it has a run() 
method that we were overriding.) This means that you could pass a Thread to another 
Thread’s constructor:
Thread t = new Thread(new MyThread());
This is a bit silly, but it’s legal. In this case, you really just need a 
Runnnable, and creating a whole other Thread is overkill. Starting a Thread
You've created a Thread object and it knows its target (either the passed-in 
Runnable or itself if you extended class Thread). Now it's time to get the whole 
thread thing happening—to launch a new call stack. It's so simple it hardly deserves 
its own subheading:
t.start();
Prior to calling start() on a Thread instance, the thread (when we use 
lowercase t, we're referring to the thread of execution rather than the Thread class) 
is said to be in the new state as we said. The new state means you have a Thread 
object but you don't yet have a true thread. So what happens after you call start()? The good stuff:
■ A new thread of execution starts (with a new call stack). ■ The thread moves from the new state to the runnable state. ■  When the thread gets a chance to execute, its target run() method will run. Be sure you remember the following: You start a Thread, not a Runnable. You call 
start() on a Thread instance, not on a Runnable instance. The following example 
demonstrates what we've covered so far—defining, instantiating, and starting a 
thread:
class FooRunnable implements Runnable {
   public void run() {
      for(int x = 1; x < 6; x++) {  
        System.out.println("Runnable running");
      }
   }
}
public class TestThreads {
   public static void main (String [] args) {
     FooRunnable r = new FooRunnable();
     Thread t = new Thread(r);
     t.start();     
   }
}
Starting a Thread (Exam Objective 4.1) 709
Running the preceding code prints out exactly what you'd expect:
% java TestThreads
Runnable running
Runnable running
Runnable running
Runnable running
Runnable running
(If this isn't what you expected, go back and re-read everything in this objective.)
So what happens if we start multiple threads? We'll run a simple example in a 
moment, but first we need to know how to print out which thread is executing. We can use the getName() method of class Thread, and have each Runnable print 
out the name of the thread executing that Runnable object's run() method. The 
following example instantiates a thread and gives it a name, and then the name is 
printed out from the run() method:
class NameRunnable implements Runnable {
   public void run() {
       System.out.println("NameRunnable running");
       System.out.println("Run by " 
         + Thread.currentThread().getName());
710 Chapter 9:  Threads
There’s nothing special about the run() method as far as Java is 
concerned. Like main(), it just happens to be the name (and signature) of the method 
that the new thread knows to invoke. So if you see code that calls the run() method on 
a Runnable (or even on a Thread instance), that’s perfectly legal. But it doesn’t mean the 
run() method will run in a separate thread! Calling a run() method directly just means 
you’re invoking a method from whatever thread is currently executing, and the run() 
method goes onto the current call stack rather than at the beginning of a new call stack. The following code does not start a new thread of execution:
  Thread t = new Thread();
  t.run();  // Legal, but does not start a new thread
   }
}
public class NameThread {
   public static void main (String [] args) {
     NameRunnable nr = new NameRunnable();
     Thread t = new Thread(nr);
     t.setName("Fred");
     t.start();     
   }
}
Running this code produces the following, extra special, output:
% java NameThread 
NameRunnable running
Run by Fred
To get the name of a thread you call—who would have guessed—getName() on 
the Thread instance. But the target Runnable instance doesn't even have a reference 
to the Thread instance, so we first invoked the static Thread.currentThread() 
method, which returns a reference to the currently executing thread, and then we 
invoked getName() on that returned reference. Even if you don't explicitly name a thread, it still has a name. Let's look at the 
previous code, commenting out the statement that sets the thread's name:
public class NameThread {
   public static void main (String [] args) {
     NameRunnable nr = new NameRunnable();
     Thread t = new Thread(nr);
     // t.setName("Fred"); 
     t.start();     
   }
}
Running the preceding code now gives us
% java NameThread
NameRunnable running
Run by Thread-0
And since we're getting the name of the current thread by using the static 
Thread.currentThread() method, we can even get the name of the thread 
running our main code,
Starting a Thread (Exam Objective 4.1) 711
public class NameThreadTwo {
   public static void main (String [] args) {
     System.out.println("thread is " 
      + Thread.currentThread().getName());
   }
}
which prints out
% java NameThreadTwo
thread is main
That's right, the main thread already has a name—main. (Once again, what are 
the odds?) Figure 9-1 shows the process of starting a thread. 712 Chapter 9:  Threads
 FIGURE 9-1  
Starting a thread
public static void main(String [] args) {
// running
// some code
// in main()
// running
//
//
more code
static void method2() {
Runnable r = new MyRunnable();
Thread t = new Thread(r);
t.start();
do more stuff
}
}
method2();
1) main() begins
main
main
run
method2
stack A
stack A
main
method2
stack Astack B
(thread t) (main thread)
3) method2() starts a new thread
2) main() invokes method2()
Starting and Running Multiple Threads 
Enough playing around here; let's actually get multiple threads going (more than 
two, that is). We already had two threads, because the main() method starts in a 
thread of its own, and then t.start() started a second thread. Now we'll do more. The following code creates a single Runnable instance and three Thread instances. All three Thread instances get the same Runnable instance, and each thread is 
given a unique name. Finally, all three threads are started by invoking start() on 
the Thread instances. class NameRunnable implements Runnable {
    public void run() {
        for (int x = 1; x <= 3; x++) {
            System.out.println("Run by "
                    + Thread.currentThread().getName()
                    + ", x is " + x);
        }
    }
}
public class ManyNames {
    public static void main(String [] args) {
        // Make one Runnable
        NameRunnable nr = new NameRunnable();
        Thread one = new Thread(nr);
        Thread two = new Thread(nr);
        Thread three = new Thread(nr);
        one.setName("Fred");
        two.setName("Lucy");
        three.setName("Ricky");
        one.start();
        two.start();
        three.start();
    }
}
Running this code might produce the following: 
% java ManyNames
Run by Fred, x is 1
Run by Fred, x is 2
Run by Fred, x is 3
Starting a Thread (Exam Objective 4.1) 713
Run by Lucy, x is 1
Run by Lucy, x is 2
Run by Lucy, x is 3
Run by Ricky, x is 1
Run by Ricky, x is 2
Run by Ricky, x is 3
Well, at least that's what it printed when we ran it—this time, on our machine. But the behavior you see above is not guaranteed. This is so crucial that you need 
to stop right now, take a deep breath, and repeat after me, "The behavior is not 
guaranteed." You need to know, for your future as a Java programmer as well as for 
the exam, that there is nothing in the Java specification that says threads will start 
running in the order in which they were started (in other words, the order in which 
start() was invoked on each thread). And there is no guarantee that once a thread 
starts executing, it will keep executing until it's done. Or that a loop will complete 
before another thread begins. No siree Bob. Nothing is guaranteed in the preceding 
code except this: 
Each thread will start, and each thread will run to completion. Within each thread, things will happen in a predictable order. But the actions 
of different threads can mix together in unpredictable ways. If you run the program 
multiple times, or on multiple machines, you may see different output. Even if 
you don't see different output, you need to realize that the behavior you see is not 
guaranteed. Sometimes a little change in the way the program is run will cause a 
difference to emerge. Just for fun we bumped up the loop code so that each run() 
method ran the for loop 400 times rather than 3, and eventually we did start to see 
some wobbling: 
public void run() {
    for (int x = 1; x <= 400; x++) {
        System.out.println("Run by "
                + Thread.currentThread().getName()
                + ", x is " + x);
    }
}
Running the preceding code, with each thread executing its run loop 400 times, 
started out fine but then became nonlinear. Here's just a snip from the command-
714 Chapter 9:  Threads
Starting a Thread (Exam Objective 4.1) 715
line output of running that code. To make it easier to distinguish each thread, we 
put Fred's output in italics and Lucy's in bold, and left Ricky's alone: 
Run by Fred, x is 345
Run by Ricky, x is 313
Run by Lucy, x is 341
Run by Ricky, x is 314
Run by Lucy, x is 342
Run by Ricky, x is 315
Run by Fred, x is 346
Run by Lucy, x is 343
Run by Fred, x is 347
Run by Lucy, x is 344
... it continues on ... Notice that there's not really any clear pattern here. If we look at only the output 
from Fred, we see the numbers increasing one at a time, as expected:
Run by Fred, x is 345
Run by Fred, x is 346
Run by Fred, x is 347
And similarly if we look only at the output from Lucy, or Ricky. Each one 
individually is behaving in a nice orderly manner. But together—chaos! In the 
fragment above we see Fred, then Lucy, then Ricky (in the same order we originally 
started the threads), but then Lucy butts in when it was Fred's turn. What nerve! And then Ricky and Lucy trade back and forth for a while until finally Fred gets 
another chance. They jump around like this for a while after this. Eventually 
(after the part shown above) Fred finishes, then Ricky, and finally Lucy finishes 
with a long sequence of output. So even though Ricky was started third, he actually 
completed second. And if we run it again, we'll get a different result. Why? Because 
it's up to the scheduler, and we don't control the scheduler! Which brings up 
another key point to remember: Just because a series of threads are started in a 
particular order doesn't mean they'll run in that order. For any group of started 
threads, order is not guaranteed by the scheduler. And duration is not guaranteed. You don't know, for example, if one thread will run to completion before the others 
have a chance to get in or whether they'll all take turns nicely, or whether they'll do 
a combination of both. There is a way, however, to start a thread but tell it not to 
run until some other thread has finished. You can do this with the join() method, 
which we'll look at a little later. A thread is done being a thread when its target run() method completes. When a thread completes its run() method, the thread ceases to be a thread of 
execution. The stack for that thread dissolves, and the thread is considered dead. (Technically the API calls a dead thread "terminated", but we'll use "dead" in this 
chapter.) Not dead and gone, however, just dead. It's still a Thread object, just not a 
thread of execution. So if you've got a reference to a Thread instance, then even when 
that Thread instance is no longer a thread of execution, you can still call methods 
on the Thread instance, just like any other Java object. What you can't do, though, 
is call start() again. Once a thread has been started, it can never be started again. If you have a reference to a Thread, and you call start(), it's started. If you call 
start() a second time, it will cause an exception (an IllegalThreadStateException, 
which is a kind of RuntimeException, but you don't need to worry about the exact 
type). This happens whether or not the run() method has completed from the first 
start() call. Only a new thread can be started, and then only once. A runnable 
thread or a dead thread cannot be restarted. So far, we've seen three thread states: new, runnable, and dead. We'll look at more 
thread states before we're done with this chapter. 716 Chapter 9:  Threads
In addition to using setName() and getName to identify threads, you 
might see getld(). The getld() method returns a positive, unique, long number, and that 
number will be that thread's only ID number for the thread's entire life. Starting a Thread (Exam Objective 4.1) 717
The Thread Scheduler
The thread scheduler is the part of the JVM (although most JVMs map Java threads 
directly to native threads on the underlying OS) that decides which thread should 
run at any given moment, and also takes threads out of the run state. Assuming a 
single processor machine, only one thread can actually run at a time. Only one stack 
can ever be executing at one time. And it's the thread scheduler that decides which  
thread—of all that are eligible—will actually run. When we say eligible, we really 
mean in the runnable state. Any thread in the runnable state can be chosen by the scheduler to be the one and 
only running thread. If a thread is not in a runnable state, then it cannot be chosen to be 
the currently running thread. And just so we're clear about how little is guaranteed here:
The order in which runnable threads are chosen to run is not guaranteed. Although queue behavior is typical, it isn't guaranteed. Queue behavior means 
that when a thread has finished with its "turn," it moves to the end of the line of the 
runnable pool and waits until it eventually gets to the front of the line, where it can 
be chosen again. In fact, we call it a runnable pool, rather than a runnable queue, to 
help reinforce the fact that threads aren't all lined up in some guaranteed order. Although we don't control the thread scheduler (we can't, for example, tell a 
specific thread to run), we can sometimes influence it. The following methods give us 
some tools for influencing the scheduler. Just don't ever mistake influence for control. Methods from the java.lang.Thread Class    Some of the methods that can 
help us influence thread scheduling are as follows:
public static void sleep(long millis) throws InterruptedException
public static void yield()
public final void join() throws InterruptedException
public final void setPriority(int newPriority)
Note that both sleep() and join() have overloaded versions not shown here. Expect to see exam questions that look for your understanding of 
what is and is not guaranteed! You must be able to look at thread code and determine 
whether the output is guaranteed to run in a particular way or is indeterminate. Methods from the java.lang.Object Class    Every class in Java inherits the 
following three thread-related methods:
    public final void wait() throws InterruptedException
public final void notify()
public final void notifyAll()
The wait() method has three overloaded versions (including the one listed here). We'll look at the behavior of each of these methods in this chapter. First, though, 
we're going to look at the different states a thread can be in. CERTIFICATION OBJECTIVE
Thread States and Transitions (Objective 4.2)
4.2 Recognize the states in which a thread can exist, and identify ways in which a thread 
can transition from one state to another. We've already seen three thread states— new, runnable, and dead—but wait! There's more! The thread scheduler's job is to move threads in and out of the 
running state. While the thread scheduler can move a thread from the running state 
back to runnable, other factors can cause a thread to move out of running, but not 
back to runnable. One of these is when the thread's run()method completes, in 
which case the thread moves from the running state directly to the dead state. Next 
we'll look at some of the other ways in which a thread can leave the running state, 
and where the thread goes. Thread States
A thread can be only in one of five states (see Figure 9-2):
■     New This is the state the thread is in after the Thread instance has been 
created, but the start() method has not been invoked on the thread. It is 
a live Thread object, but not yet a thread of execution. At this point, the 
thread is considered not alive. 718 Chapter 9:  Threads
■     Runnable  This is the state a thread is in when it's eligible to run, but the 
scheduler has not selected it to be the running thread. A thread first enters 
the runnable state when the start() method is invoked, but a thread can 
also return to the runnable state after either running or coming back from a 
blocked, waiting, or sleeping state. When the thread is in the runnable state, 
it is considered alive. ■     Running  This is it. The "big time." Where the action is. This is the state a 
thread is in when the thread scheduler selects it (from the runnable pool) to 
be the currently executing process. A thread can transition out of a running 
state for several reasons, including because "the thread scheduler felt like it." 
We'll look at those other reasons shortly. Note that in Figure 9-2, there are 
several ways to get to the runnable state, but only one way to get to the running 
state: the scheduler chooses a thread from the runnable pool. ■   Waiting/blocked/sleeping  This is the state a thread is in when it's not
eligible to run. Okay, so this is really three states combined into one, 
but they all have one thing in common: the thread is still alive, but is 
currently not eligible to run. In other words, it is not runnable, but it might 
return to a runnable state later if a particular event occurs. A thread may be 
blocked waiting for a resource (like I/O or an object's lock), in which case the 
event that sends it back to runnable is the availability of the resource—for 
example, if data comes in through the input stream the thread code is reading 
from, or if the object's lock suddenly becomes available. A thread may be 
sleeping because the thread's run code tells it to sleep for some period of time, 
in which case the event that sends it back to runnable is that it wakes up 
because its sleep time has expired. Or the thread may be waiting, because the 
thread's run code causes it to wait, in which case the event that sends it back 
to runnable is that another thread sends a notification that it may no longer 
be necessary for the thread to wait. The important point is that one thread 
Thread States (Exam Objective 4.2) 719
 FIGURE 9-2  
Transitioning 
between 
thread states
Waiting/
blocking
New Runnable Running Dead
does not tell another thread to block. Some methods may look like they tell 
another thread to block, but they don't. If you have a reference t to another 
thread, you can write something like this:
   t.sleep();   or     t.yield()
But those are actually static methods of the Thread class—they don't affect the 
instance t; instead they are defined to always affect the thread that's currently 
executing. (This is a good example of why it's a bad idea to use an instance 
variable to access a static method—it's misleading. There is a method, 
suspend(), in the Thread class, that lets one thread tell another to suspend, 
but the suspend() method has been deprecated and won't be on the exam 
(nor will its counterpart resume()). There is also a stop() method, but 
it too has been deprecated and we won't even go there. Both suspend() 
and stop() turned out to be very dangerous, so you shouldn't use them and 
again, because they're deprecated, they won't appear on the exam. Don't 
study 'em, don't use 'em. Note also that a thread in a blocked state is still 
considered to be alive. ■    Dead  A thread is considered dead when its run() method completes. It 
may still be a viable Thread object, but it is no longer a separate thread of 
execution. Once a thread is dead, it can never be brought back to life! (The 
whole "I see dead threads" thing.) If you invoke start() on a dead Thread 
instance, you'll get a runtime (not compiler) exception. And it probably 
doesn't take a rocket scientist to tell you that if a thread is dead, it is no 
longer considered to be alive. Preventing Thread Execution
A thread that's been stopped usually means a thread that's moved to the dead state. But Objective 4.2 is also looking for your ability to recognize when a thread will get 
kicked out of running but not be sent back to either runnable or dead. For the purpose of the exam, we aren't concerned with a thread blocking on I/O 
(say, waiting for something to arrive from an input stream from the server). We are 
concerned with the following:
720 Chapter 9:  Threads
■ Sleeping
■ Waiting
■ Blocked because it needs an object's lock
Sleeping
The sleep() method is a static method of class Thread. You use it in your code 
to "slow a thread down" by forcing it to go into a sleep mode before coming back to 
runnable (where it still has to beg to be the currently running thread). When a thread 
sleeps, it drifts off somewhere and doesn't return to runnable until it wakes up. So why would you want a thread to sleep? Well, you might think the thread is 
moving too quickly through its code. Or you might need to force your threads to 
take turns, since reasonable turn-taking isn't guaranteed in the Java specification. Or imagine a thread that runs in a loop, downloading the latest stock prices and 
analyzing them. Downloading prices one after another would be a waste of time, as 
most would be quite similar—and even more important, it would be an incredible 
waste of precious bandwidth. The simplest way to solve this is to cause a thread to 
pause (sleep) for five minutes after each download. You do this by invoking the static Thread.sleep() method, giving it a time in 
milliseconds as follows:
try {
  Thread.sleep(5*60*1000);  // Sleep for 5 minutes
} catch (InterruptedException ex) { }
Notice that the sleep() method can throw a checked InterruptedException 
(you'll usually know if that is a possibility, since another thread has to explicitly do 
the interrupting), so you must acknowledge the exception with a handle or declare. Typically, you wrap calls to sleep() in a try/catch , as in the preceding code. Let's modify our Fred, Lucy, Ricky code by using sleep() to try to force the 
threads to alternate rather than letting one thread dominate for any period of time. Where do you think the sleep() method should go? class NameRunnable implements Runnable {
   public void run() {
      for (int x = 1; x < 4; x++) {
            System.out.println("Run by " 
          + Thread.currentThread().getName());
Sleeping (Exam Objective 4.2) 721
         try {
           Thread.sleep(1000);
         } catch (InterruptedException ex) { }
      }
   }
}
public class ManyNames {
   public static void main (String [] args) {
     // Make one Runnable 
     NameRunnable nr = new NameRunnable(); 
     Thread one = new Thread(nr);
     one.setName("Fred");
     Thread two = new Thread(nr);
     two.setName("Lucy");
     Thread three = new Thread(nr);
     three.setName("Ricky"); 
     one.start();   
     two.start();
     three.start();  
   }
}
Running this code shows Fred, Lucy, and Ricky alternating nicely:
% java ManyNames
Run by Fred
Run by Lucy
Run by Ricky
Run by Fred
Run by Lucy
Run by Ricky
Run by Fred
Run by Lucy
Run by Ricky
Just keep in mind that the behavior in the preceding output is still not guaranteed. You can't be certain how long a thread will actually run before it gets put to sleep, 
so you can't know with certainty that only one of the three threads will be in the 
runnable state when the running thread goes to sleep. In other words, if there are 
722 Chapter 9:  Threads
two threads awake and in the runnable pool, you can't know with certainty that 
the least recently used thread will be the one selected to run. Still, using sleep() 
is the best way to help all threads get a chance to run! Or at least to guarantee that 
one thread doesn't get in and stay until it's done. When a thread encounters a sleep 
call, it must go to sleep for at least the specified number of milliseconds (unless 
it is interrupted before its wake-up time, in which case it immediately throws the 
InterruptedException). Remember that sleep() is a static method, so don't be fooled into thinking that 
one thread can put another thread to sleep. You can put sleep() code anywhere, 
since all code is being run by some thread. When the executing code (meaning the 
currently running thread's code) hits a sleep() call, it puts the currently running 
thread to sleep. EXERCISE 9-1
 Creating a Thread and Putting It to Sleep
In this exercise we will create a simple counting thread. It will count to 100, pausing 
one second between each number. Also, in keeping with the counting theme, it will 
output a string every ten numbers. Sleeping (Exam Objective 4.2) 723
Just because a thread’s sleep() expires, and it wakes up, does not mean 
it will return to running! Remember, when a thread wakes up, it simply goes back to 
the runnable state. So the time speciﬁ ed in sleep() is the minimum duration in which 
the thread won’t run, but it is not the exact duration in which the thread won’t run. So 
you can’t, for example, rely on the sleep() method to give you a perfectly accurate 
timer. Although in many applications using sleep() as a timer is certainly good enough, 
you must know that a sleep() time is not a guarantee that the thread will start running 
again as soon as the time expires and the thread wakes. 1. Create a class and extend the Thread class. As an option, you can implement
          the Runnable interface. 2. Override the run() method of Thread. This is where the code will go that will
          output the numbers. 3. Create a for loop that will loop 100 times. Use the modulo operation to 
          check whether there are any remainder numbers when divided by 10. 4. Use the static method Thread.sleep() to pause. (Remember, the one-arg 
version of sleep() specifies the amount of time of sleep in milliseconds.)
Thread Priorities and yield( )
To understand yield(), you must understand the concept of thread priorities. Threads always run with some priority, usually represented as a number between 1 
and 10 (although in some cases the range is less than 10). The scheduler in most 
JVMs uses preemptive, priority-based scheduling (which implies some sort 
of time slicing). This does not mean that all JVMs use time slicing. The JVM 
specification does not require a VM to implement a time-slicing scheduler, where 
each thread is allocated a fair amount of time and then sent back to runnable to give 
another thread a chance. Although many JVMs do use time slicing, some may use 
a scheduler that lets one thread stay running until the thread completes its run() 
method. In most JVMs, however, the scheduler does use thread priorities in one important 
way: If a thread enters the runnable state, and it has a higher priority than any of 
the threads in the pool and a higher priority than the currently running thread, 
the lower-priority running thread usually will be bumped back to runnable and the 
highest-priority thread will be chosen to run. In other words, at any given time the 
currently running thread usually will not have a priority that is lower than any of 
the threads in the pool. In most cases, the running thread will be of equal or greater 
priority than the highest priority threads in the pool. This is as close to a guarantee 
about scheduling as you'll get from the JVM specification, so you must never rely on 
thread priorities to guarantee the correct behavior of your program. Don't rely on thread priorities when designing your multithreaded application. Because thread-scheduling priority behavior is not guaranteed, use thread 
priorities as a way to improve the efﬁ  ciency of your program, but just be sure 
your program doesn't depend on that behavior for correctness. 724 Chapter 9:  Threads
What is also not guaranteed is the behavior when threads in the pool are of equal 
priority, or when the currently running thread has the same priority as threads in the 
pool. All priorities being equal, a JVM implementation of the scheduler is free to do 
just about anything it likes. That means a scheduler might do one of the following 
(among other things):
■   Pick a thread to run, and run it there until it blocks or completes. ■  Time slice the threads in the pool to give everyone an equal opportunity to run. Setting a Thread's Priority A thread gets a default priority that is the priority 
of the thread of execution that creates it. For example, in the code
public class TestThreads {
  public static void main (String [] args) {
    MyThread t = new MyThread();
  }
}
the thread referenced by t will have the same priority as the main thread, since the 
main thread is executing the code that creates the MyThread instance. You can also set a thread's priority directly by calling the setPriority() method 
on a Thread instance as follows:
FooRunnable r = new FooRunnable();
Thread t = new Thread(r);
t.setPriority(8);
t.start();
Priorities are set using a positive integer, usually between 1 and 10, and the JVM 
will never change a thread's priority. However, the values 1 through 10 are not 
guaranteed. Some JVM's might not recognize ten distinct values. Such a JVM might 
merge values from 1 to 10 down to maybe values from 1 to 5, so if you have, say, ten 
threads each with a different priority, and the current application is running in a 
JVM that allocates a range of only five priorities, then two or more threads might be 
mapped to one priority. Although the default priority is 5, the Thread class has the three following 
constants (static final variables) that define the range of thread priorities:
Thread Priorities and yield( ) (Exam Objective 4.2) 725
Thread.MIN_PRIORITY  (1)
Thread.NORM_PRIORITY  (5)
Thread.MAX_PRIORITY  (10)
The yield( ) Method So what does the static Thread.yield() have to 
do with all this? Not that much, in practice. What yield() is supposed to do is 
make the currently running thread head back to runnable to allow other threads of 
the same priority to get their turn. So the intention is to use yield() to promote 
graceful turn-taking among equal-priority threads. In reality, though, the yield() 
method isn't guaranteed to do what it claims, and even if yield() does cause a 
thread to step out of running and back to runnable, there's no guarantee the yielding 
thread won't just be chosen again over all the others! So while yield() might—and 
often does—make a running thread give up its slot to another runnable thread of the 
same priority, there's no guarantee. A yield() won't ever cause a thread to go to the waiting/sleeping/ blocking 
state. At most, a yield() will cause a thread to go from running to runnable, but 
again, it might have no effect at all. The join( ) Method
The non-static join() method of class Thread lets one thread "join onto the end" 
of another thread. If you have a thread B that can't do its work until another thread 
A has completed its work, then you want thread B to "join" thread A. This means that 
thread B will not become runnable until A has finished (and entered the dead state). Thread t = new Thread();
t.start();
t.join();
The preceding code takes the currently running thread (if this were in the 
main() method, then that would be the main thread) and joins it to the end of the 
thread referenced by t. This blocks the current thread from becoming runnable 
until after the thread referenced by t is no longer alive. In other words, the 
code t.join() means "Join me (the current thread) to the end of t, so that t 
must finish before I (the current thread) can run again." You can also call one 
of the overloaded versions of join() that takes a timeout duration, so that 
you're saying, "wait until thread t is done, but if it takes longer than 5,000 
milliseconds, then stop waiting and become runnable anyway." Figure 9-3 shows 
the effect of the join() method. 726 Chapter 9:  Threads
So far we've looked at three ways a running thread could leave the running state:
■  A call to sleep()  Guaranteed to cause the current thread to stop execut-
ing for at least the specified sleep duration (although it might be interrupted  
before its specified time). ■  A call to yield()  Not guaranteed to do much of anything, although 
typically it will cause the currently running thread to move back to runnable 
so that a thread of the same priority can have a chance. ■  A call to join()  Guaranteed to cause the current thread to stop execut-
ing until the thread it joins with (in other words, the thread it calls join() 
Thread Priorities and yield( ) (Exam Objective 4.2) 727
 FIGURE 9-3     The join() method
Key Events in the Threads’ Code
doStuff()
doStuff() doOther()
Stack A is
running
Stack B is
running
Stack A is
running
Stack B
doOther()
doStuff()
Stack A joined
to Stack B
Stack A
Output
A is running
Thread b = new Thread(aRunnable);
b.start();
b.join();  // A joins to the end
// of B
// Thread B completes !! // Thread A starts again ! // Threads bounce back and forth
A is running
A is running
A is running
A is running
A is running
A is running
A is running
A is running
A is running
A is running
B is running
B is running
B is running
B is running
B is running
B is running
B is running
B is running
B is running
B is running
B is running
B is running
B is running
A is running
A is running
A is running
A is running
A is running
A is running
A is running
B is running
on) completes, or if the thread it's trying to join with is not alive, however, 
the current thread won't need to back out. Besides those three, we also have the following scenarios in which a thread might 
leave the running state:
■   The thread's run() method completes. Duh. ■   A call to wait() on an object (we don't call wait() on a thread, as we'll 
  see in a moment). ■   A thread can't acquire the lock on the object whose method code it's 
  attempting to run. ■   The thread scheduler can decide to move the current thread from running  
  to runnable in order to give another thread a chance to run. No reason is 
  needed—the thread scheduler can trade threads in and out whenever it likes. CERTIFICATION OBJECTIVE
Synchronizing Code (Objective 4.3)
4.3 Given a scenario, write code that makes appropriate use of object locking to 
protect static or instance variables from concurrent access problems. Can you imagine the havoc that can occur when two different threads have access 
to a single instance of a class, and both threads invoke methods on that object…and 
those methods modify the state of the object? In other words, what might happen 
if two different threads call, say, a setter method on a single object? A scenario 
like that might corrupt an object's state (by changing its instance variable values in 
an inconsistent way), and if that object's state is data shared by other parts of the 
program, well, it's too scary to even visualize. But just because we enjoy horror, let's look at an example of what might happen. The following code demonstrates what happens when two different threads are 
accessing the same account data. Imagine that two people each have a checkbook 
for a single checking account (or two people each have ATM cards, but both cards 
are linked to only one account). 728 Chapter 9:  Threads
In this example, we have a class called Account that represents a bank account. To keep the code short, this account starts with a balance of 50, and can be used 
only for withdrawals. The withdrawal will be accepted even if there isn't enough 
money in the account to cover it. The account simply reduces the balance by the 
amount you want to withdraw:
class Account {
   private int balance = 50;
   public int getBalance() {
      return balance;
   }
   public void withdraw(int amount) {
      balance = balance - amount;
   }
}
Now here's where it starts to get fun. Imagine a couple, Fred and Lucy, who both 
have access to the account and want to make withdrawals. But they don't want the 
account to ever be overdrawn, so just before one of them makes a withdrawal, he or 
she will first check the balance to be certain there's enough to cover the withdrawal. Also, withdrawals are always limited to an amount of 10, so there must be at least 10 
in the account balance in order to make a withdrawal. Sounds reasonable. But that's 
a two-step process:
1. Check the balance. 2. If there's enough in the account (in this example, at least 10), make the 
withdrawal. What happens if something separates step 1 from step 2? For example, imagine 
what would happen if Lucy checks the balance and sees that there's just exactly 
enough in the account, 10. But before she makes the withdrawal, Fred checks the 
balance and also sees that there's enough for his withdrawal. Since Lucy has verified 
the balance, but not yet made her withdrawal, Fred is seeing "bad data." He is seeing 
the account balance before Lucy actually debits the account, but at this point that 
debit is certain to occur. Now both Lucy and Fred believe there's enough to make 
their withdrawals. So now imagine that Lucy makes her withdrawal, and now there 
isn't enough in the account for Fred's withdrawal, but he thinks there is since when 
he checked, there was enough! Yikes. In a minute we'll see the actual banking code, 
with Fred and Lucy, represented by two threads, each acting on the same Runnable, 
and that Runnable holds a reference to the one and only account instance—so, two 
threads, one account. Synchronizing Code (Exam Objective 4.3) 729
The logic in our code example is as follows:
1. The Runnable object holds a reference to a single account. 2. T wo threads are started, representing Lucy and Fred, and each thread is 
given a reference to the same Runnable (which holds a reference to the 
actual account)
3. The initial balance on the account is 50, and each withdrawal is exactly 10. 4. In the run() method, we loop 5 times, and in each loop we
■  Make a withdrawal (if there's enough in the account). ■  Print a statement if the account is overdrawn (which it should never be, 
   since we check the balance before making a withdrawal). 5. The makeWithdrawal() method in the test class (representing the behavior 
of Fred or Lucy) will do the following:
■  Check the balance to see if there's enough for the withdrawal. ■  If there is enough, print out the name of the one making the withdrawal. ■   Go to sleep for 500 milliseconds—just long enough to give the other 
partner a chance to get in before you actually make the withdrawal. ■   Upon waking up, complete the withdrawal and print that fact. ■   If there wasn't enough in the first place, print a statement showing who you 
are and the fact that there wasn't enough. So what we're really trying to discover is if the following is possible: for one partner 
to check the account and see that there's enough, but before making the actual 
withdrawal, the other partner checks the account and also sees that there's enough. When the account balance gets to 10, if both partners check it before making the 
withdrawal, both will think it's OK to withdraw, and the account will overdraw by 10! Here's the code:
public class AccountDanger implements Runnable {
   private Account acct = new Account();
   public static void main (String [] args) {
      AccountDanger r = new AccountDanger();
      Thread one = new Thread(r);
      Thread two = new Thread(r);
      one.setName("Fred");
      two.setName("Lucy");
730 Chapter 9:  Threads
      one.start();
      two.start();
    }
  public void run() {
    for (int x = 0; x < 5; x++) {
      makeWithdrawal(10);
      if (acct.getBalance() < 0) {
        System.out.println("account is overdrawn!");
      }
    }
  }
  private void makeWithdrawal(int amt) {
     if (acct.getBalance() >= amt) {
        System.out.println(Thread.currentThread().getName() 
                     + " is going to withdraw");
        try {
          Thread.sleep(500);
        } catch(InterruptedException ex) { }
        acct.withdraw(amt);
        System.out.println(Thread.currentThread().getName() 
                     + " completes the withdrawal");
     } else {
        System.out.println("Not enough in account for " 
                     + Thread.currentThread().getName() 
                     + " to withdraw " + acct.getBalance());
     }
   }
}
So what happened? Is it possible that, say, Lucy checked the balance, fell asleep, 
Fred checked the balance, Lucy woke up and completed her withdrawal, then Fred 
completes his withdrawal, and in the end they overdraw the account? Look at the 
(numbered) output:
% java AccountDanger
 1. Fred is going to withdraw
 2. Lucy is going to withdraw
 3. Fred completes the withdrawal
 4. Fred is going to withdraw
 5. Lucy completes the withdrawal
 6. Lucy is going to withdraw
 7. Fred completes the withdrawal
 8. Fred is going to withdraw
 9. Lucy completes the withdrawal
Synchronizing Code (Exam Objective 4.3) 731
732 Chapter 9:  Threads
10. Lucy is going to withdraw
11. Fred completes the withdrawal
12. Not enough in account for Fred to withdraw 0
13. Not enough in account for Fred to withdraw 0
14. Lucy completes the withdrawal
15. account is overdrawn! 16. Not enough in account for Lucy to withdraw -10
17. account is overdrawn! 18. Not enough in account for Lucy to withdraw -10
19. account is overdrawn! Although each time you run this code the output might be a little different, let's 
walk through this particular example using the numbered lines of output. For the 
first four attempts, everything is fine. Fred checks the balance on line 1, and finds 
it's OK. At line 2, Lucy checks the balance and finds it OK. At line 3, Fred makes 
his withdrawal. At this point, the balance Lucy checked for (and believes is still 
accurate) has actually changed since she last checked. And now Fred checks the 
balance again, before Lucy even completes her first withdrawal. By this point, even 
Fred is seeing a potentially inaccurate balance, because we know Lucy is going to 
complete her withdrawal. It is possible, of course, that Fred will complete his before 
Lucy does, but that's not what happens here. On line 5, Lucy completes her withdrawal and then before Fred completes his, 
Lucy does another check on the account on line 6. And so it continues until we 
get to line 8, where Fred checks the balance and sees that it's 20. On line 9, Lucy 
completes a withdrawal (that she had checked for earlier), and this takes the balance 
to 10. On line 10, Lucy checks again, sees that the balance is 10, so she knows 
she can do a withdrawal. But she didn't know that Fred, too, has already checked 
the balance on line 8 so he thinks it's safe to do the withdrawal! On line 11, Fred 
completes the withdrawal he approved on line 8. This takes the balance to zero. But 
Lucy still has a pending withdrawal that she got approval for on line 10! You know 
what's coming. On lines 12 and 13, Fred checks the balance and finds that there's not enough 
in the account. But on line 14, Lucy completes her withdrawal and BOOM! The 
account is now overdrawn by 10—something we thought we were preventing by 
doing a balance check prior to a withdrawal. Figure 9-4 shows the timeline of what can happen when two threads concurrently 
access the same object. This problem is known as a "race condition," where multiple threads can access 
the same resource (typically an object's instance variables), and can produce 
corrupted data if one thread "races in" too quickly before an operation that should be 
"atomic" has completed. Preventing the Account Overdraw      So what can be done? The solution 
is actually quite simple. We must guarantee that the two steps of the withdrawal—
checking the balance and making the withdrawal—are never split apart. We need 
them to always be performed as one operation, even when the thread falls asleep in 
between step 1 and step 2! We call this an "atomic operation" (although the physics 
is a little outdated, in this case "atomic" means "indivisible") because the operation, 
regardless of the number of actual statements (or underlying byte code instructions), 
is completed before any other thread code that acts on the same data. You can't guarantee that a single thread will stay running throughout the entire 
atomic operation. But you can guarantee that even if the thread running the atomic 
operation moves in and out of the running state, no other running thread will be 
able to act on the same data. In other words, If Lucy falls asleep after checking the 
balance, we can stop Fred from checking the balance until after Lucy wakes up and 
completes her withdrawal. So how do you protect the data? You must do two things:
■   Mark the variables private. ■   Synchronize the code that modifies the variables. FIGURE 9-4  
Problems with 
concurrent access
Synchronizing Code (Exam Objective 4.3) 733
Object 1
Time
Thread A will access Object 2 only
Thread B will access Object 1, and then Object 2
AAA BBB
Object 2
734 Chapter 9:  Threads
Remember, you protect the variables in the normal way—using an access control 
modifier. It's the method code that you must protect, so that only one thread at a 
time can be executing that code. You do this with the synchronized keyword. We can solve all of Fred and Lucy's problems by adding one word to the code. We 
mark the makeWithdrawal() method synchronized as follows:
private synchronized void makeWithdrawal(int amt) {
  if (acct.getBalance() >= amt) {
    System.out.println(Thread.currentThread().getName() + 
                         " is going to withdraw"); 
    try {
      Thread.sleep(500);
    } catch(InterruptedException ex) { }
    acct.withdraw(amt);
    System.out.println(Thread.currentThread().getName() + 
                          " completes the withdrawal");
  } else {
    System.out.println("Not enough in account for " 
                         + Thread.currentThread().getName() 
                         + " to withdraw " + acct.getBalance());
  }
}
Now we've guaranteed that once a thread (Lucy or Fred) starts the withdrawal 
process (by invoking makeWithdrawal()), the other thread cannot enter that 
method until the first one completes the process by exiting the method. The new 
output shows the benefit of synchronizing the makeWithdrawal() method:
% java AccountDanger
Fred is going to withdraw
Fred completes the withdrawal
Lucy is going to withdraw
Lucy completes the withdrawal
Fred is going to withdraw
Fred completes the withdrawal
Lucy is going to withdraw
Lucy completes the withdrawal
Fred is going to withdraw
Fred completes the withdrawal
Not enough in account for Lucy to withdraw 0
Not enough in account for Fred to withdraw 0
Not enough in account for Lucy to withdraw 0
Not enough in account for Fred to withdraw 0
Not enough in account for Lucy to withdraw 0
Notice that now both threads, Lucy and Fred, always check the account balance 
and complete the withdrawal before the other thread can check the balance. Synchronization and Locks 
How does synchronization work? With locks. Every object in Java has a built-in lock 
that only comes into play when the object has synchronized method code. When 
we enter a synchronized non-static method, we automatically acquire the lock 
associated with the current instance of the class whose code we're executing (the 
this instance). Acquiring a lock for an object is also known as getting the lock, 
or locking the object, locking on the object, or synchronizing on the object. We 
may also use the term monitor to refer to the object whose lock we're acquiring. Technically the lock and the monitor are two different things, but most people talk 
about the two interchangeably, and we will too. Since there is only one lock per object, if one thread has picked up the lock, no 
other thread can pick up the lock until the first thread releases (or returns) the lock. This means no other thread can enter the synchronized code (which means it can't 
enter any synchronized method of that object) until the lock has been released. Typically, releasing a lock means the thread holding the lock (in other words, the 
thread currently in the synchronized method) exits the synchronized method. At that point, the lock is free until some other thread enters a synchronized 
method on that object. Remember the following key points about locking and 
synchronization: 
■ Only methods (or blocks) can be synchronized, not variables or classes. ■ Each object has just one lock. ■ Not all methods in a class need to be synchronized. A class can have both  
synchronized and non-synchronized methods. ■ If two threads are about to execute a synchronized method in a class, and 
both threads are using the same instance of the class to invoke the method, 
only one thread at a time will be able to execute the method. The other 
thread will need to wait until the first one finishes its method call. In other 
words, once a thread acquires the lock on an object, no other thread can 
enter any of the synchronized methods in that class (for that object). Synchronization and Locks (Exam Objective 4.3) 735
736 Chapter 9:  Threads
■ If a class has both synchronized and non-synchronized methods, multiple
threads can still access the class's non-synchronized methods! If you have 
methods that don't access the data you're trying to protect, then you don't  
need to synchronize them. Synchronization can cause a hit in some cases (or 
even deadlock if used incorrectly), so you should be careful not to overuse it. ■ If a thread goes to sleep, it holds any locks it has—it doesn't release them. ■ A thread can acquire more than one lock. For example, a thread can enter a 
synchronized method, thus acquiring a lock, and then immediately invoke 
a synchronized method on a different object, thus acquiring that lock as 
well. As the stack unwinds, locks are released again. Also, if a thread acquires 
a lock and then attempts to call a synchronized method on that same 
object, no problem. The JVM knows that this thread already has the lock for 
this object, so the thread is free to call other synchronized methods on the 
same object, using the lock the thread already has. ■ You can synchronize a block of code rather than a method. Because synchronization does hurt concurrency, you don't want to synchronize 
any more code than is necessary to protect your data. So if the scope of a method is 
more than needed, you can reduce the scope of the synchronized part to something 
less than a full method—to just a block. We call this, strangely, a synchronized block, 
and it looks like this: 
class SyncTest { 
  public void doStuff() { 
    System.out.println("not synchronized"); 
    synchronized(this) {
      System.out.println("synchronized"); 
    } 
  }
}
When a thread is executing code from within a synchronized block, including 
any method code invoked from that synchronized block, the code is said to be 
executing in a synchronized context. The real question is, synchronized on what? Or, 
synchronized on which object's lock? When you synchronize a method, the object used to invoke the method is the 
object whose lock must be acquired. But when you synchronize a block of code, you 
specify which object's lock you want to use as the lock, so you could, for example, 
use some third-party object as the lock for this piece of code. That gives you the 
ability to have more than one lock for code synchronization within a single object. Or you can synchronize on the current instance (this) as in the code above. Since that's the same instance that synchronized methods lock on, it means that 
you could always replace a synchronized method with a non-synchronized 
method containing a synchronized block. In other words, this:
public synchronized void doStuff() {
    System.out.println("synchronized"); 
}
is equivalent to this:
public void doStuff() {
    synchronized(this) {
        System.out.println("synchronized"); 
    }
}
These methods both have the exact same effect, in practical terms. The compiled 
bytecodes may not be exactly the same for the two methods, but they could be—and 
any differences are not really important. The first form is shorter and more familiar 
to most people, but the second can be more flexible. So What About Static Methods? Can They Be Synchronized? static methods can be synchronized. There is only one copy of the static data 
you're trying to protect, so you only need one lock per class to synchronize static 
methods—a lock for the whole class. There is such a lock; every class loaded in Java 
has a corresponding instance of java.lang.Class representing that class. It's that 
java.lang.Class instance whose lock is used to protect the static methods of 
the class (if they're synchronized). There's nothing special you have to do to 
synchronize a static method: 
public static synchronized int getCount() {
    return count;
} 
Synchronization and Locks (Exam Objective 4.3) 737
738 Chapter 9:  Threads
Again, this could be replaced with code that uses a synchronized block. If the 
method is defined in a class called MyClass, the equivalent code is as follows:
public static int getCount() {
    synchronized(MyClass.class) {
        return count;
    }
} 
Wait—what's that MyClass.class thing? That's called a class literal. It's a 
special feature in the Java language that tells the compiler (who tells the JVM): go 
and find me the instance of Class that represents the class called MyClass. You can 
also do this with the following code:
public static void classMethod() {
    Class cl = Class.forName("MyClass");
    synchronized (cl) {
        // do stuff
    }
}
However that's longer, ickier, and most important, not on the SCJP exam. But 
it's quick and easy to use a class literal—just write the name of the class, and add 
.class at the end. No quotation marks needed. Now you've got an expression for 
the Class object you need to synchronize on. EXERCISE 9-2 
Synchronizing a Block of Code 
In this exercise we will attempt to synchronize a block of code. Within that block of 
code we will get the lock on an object, so that other threads cannot modify it while 
the block of code is executing. We will be creating three threads that will all attempt 
to manipulate the same object. Each thread will output a single letter 100 times, and 
then increment that letter by one. The object we will be using is StringBuffer. We could synchronize on a String object, but strings cannot be modified once 
they are created, so we would not be able to increment the letter without generating 
a new String object. The final output should have 100 As, 100 Bs, and 100 Cs all in 
unbroken lines. 1. Create a class and extend the Thread class. 2. Override the run() method of Thread. This is where the synchronized 
   block of code will go. 3. For our three thread objects to share the same object, we will need to create 
  a constructor that accepts a StringBuffer object in the argument. 4. The synchronized block of code will obtain a lock on the StringBuffer 
   object from step 3. 5. Within the block, output the StringBuffer 100 times and then increment 
  the letter in the StringBuffer. You can check Chapter 6 for StringBuffer 
  methods that will help with this. 6. Finally, in the main() method, create a single StringBuffer object using the 
  letter A, then create three instances of our class and start all three of them. What Happens If a Thread Can't Get the Lock? If a thread tries to enter a synchronized method and the lock is already taken, the 
thread is said to be blocked on the object's lock. Essentially, the thread goes into a 
kind of pool for that particular object and has to sit there until the lock is released 
and the thread can again become runnable/running. Just because a lock is released 
doesn't mean any particular thread will get it. There might be three threads waiting 
for a single lock, for example, and there's no guarantee that the thread that has 
waited the longest will get the lock first. When thinking about blocking, it's important to pay attention to which objects 
are being used for locking. ■ Threads calling non- static synchronized methods in the same class will 
only block each other if they're invoked using the same instance. That's 
because they each lock on this instance, and if they're called using two dif-
ferent instances, they get two locks, which do not interfere with each other. ■ Threads calling static synchronized methods in the same class will always 
block each other—they all lock on the same Class instance. ■ A static synchronized method and a non-static synchronized method 
will not block each other, ever. The static method locks on a Class 
instance while the non-static method locks on the this instance—these 
actions do not interfere with each other at all. Synchronization and Locks (Exam Objective 4.3) 739
740 Chapter 9:  Threads
■ For synchronized blocks, you have to look at exactly what object has been 
used for locking. (What's inside the parentheses after the word synchro-
nized?)  Threads that synchronize on the same object will block each other. Threads that synchronize on different objects will not. Table 9-1 lists the thread-related methods and whether the thread gives up its 
lock as a result of the call. So When Do I Need to Synchronize? Synchronization can get pretty complicated, and you may be wondering why you 
would want to do this at all if you can help it. But remember the earlier "race 
conditions" example with Lucy and Fred making withdrawals from their account. When we use threads, we usually need to use some synchronization somewhere to 
make sure our methods don't interrupt each other at the wrong time and mess up our 
data. Generally, any time more than one thread is accessing mutable (changeable) 
data, you synchronize to protect that data, to make sure two threads aren't changing 
it at the same time (or that one isn't changing it at the same time the other is 
reading it, which is also confusing). You don't need to worry about local variables—
each thread gets its own copy of a local variable. T wo threads executing the same 
method at the same time will use different copies of the local variables, and they 
won't bother each other. However, you do need to worry about static and non-
static fields, if they contain data that can be changed. For changeable data in a non-static field, you usually use a non-static method 
to access it. By synchronizing that method, you will ensure that any threads trying 
 
Give Up Locks Keep Locks
Class Defining
the Method
wait () notify() (Although the thread will probably 
exit the synchronized code shortly after this call, 
and thus give up its locks.)
java.lang.Object
 join() java.lang.Thread
 sleep() java.lang.Thread
yield() java.lang.Thread
 TABLE 9-1    Methods and Lock Status
to run that method using the same instance will be prevented from simultaneous 
access. But a thread working with a different instance will not be affected, because 
it's acquiring a lock on the other instance. That's what we want—threads working 
with the same data need to go one at a time, but threads working with different data 
can just ignore each other and run whenever they want to; it doesn't matter. For changeable data in a static field, you usually use a static method to access it. And again, by synchronizing the method you ensure that any two threads trying to 
access the data will be prevented from simultaneous access, because both threads will 
have to acquire locks on the Class object for the class the static method's defined 
in. Again, that's what we want. However—what if you have a non-static method that accesses a static field? Or a static method that accesses a non-static field (using an instance)? In 
these cases things start to get messy quickly, and there's a very good chance that 
things will not work the way you want. If you've got a static method accessing a 
non-static field, and you synchronize the method, you acquire a lock on the Class 
object. But what if there's another method that also accesses the non-static field, 
this time using a non-static method? It probably synchronizes on the current 
instance (this) instead. Remember that a static synchronized method and a 
non-static synchronized method will not block each other—they can run at 
the same time. Similarly, if you access a static field using a non-static method, 
two threads might invoke that method using two different this instances. Which 
means they won't block each other, because they use different locks. Which means 
two threads are simultaneously accessing the same static field—exactly the sort of 
thing we're trying to prevent. It gets very confusing trying to imagine all the weird things that can happen here. To keep things simple: in order to make a class thread-safe, methods that access 
changeable fields need to be synchronized. Access to static fields should be done from static synchronized methods. Access 
to non-static fields should be done from non-static synchronized methods. For 
example:
public class Thing {
    private static int staticField;
    private int nonstaticField;
    public static synchronized int getStaticField() {
        return staticField;
    }
    public static synchronized void setStaticField(
                                           int staticField) {
Synchronization and Locks (Exam Objective 4.3) 741
742 Chapter 9:  Threads
        Thing.staticField = staticField;
    }
    public synchronized int getNonstaticField() {
        return nonstaticField;
    }
    public synchronized void setNonstaticField(
                                          int nonstaticField) {
        this.nonstaticField = nonstaticField;
    }
}
What if you need to access both static and non-static fields in a method? Well, there are ways to do that, but it's beyond what you need for the exam.

--- Chunk #1557 ---
You 
will live a longer, happier life if you JUST DON'T DO IT.

--- Chunk #1558 ---
Really.

--- Chunk #1559 ---
Would we lie? Thread-Safe Classes
When a class has been carefully synchronized to protect its data (using the rules 
just given, or using more complicated alternatives), we say the class is "thread-safe."  
Many classes in the Java APIs already use synchronization internally in order to 
make the class "thread-safe."  For example, StringBuffer and StringBuilder are nearly 
identical classes, except that all the methods in StringBuffer are synchronized 
when necessary, while those in StringBuilder are not. Generally, this makes 
StringBuffer safe to use in a multithreaded environment, while StringBuilder is not. (In return, StringBuilder is a little bit faster because it doesn't bother synchronizing.)  
However, even when a class is "thread-safe," it is often dangerous to rely on these 
classes to  provide the thread protection you need. (C'mon, the repeated quotes 
used around "thread-safe" had to be a clue, right?)  You still need to think carefully 
about how you use these classes, As an example, consider the following class. import java.util.*;
public class NameList {
    private List names = Collections.synchronizedList(
                                           new LinkedList());
    public void add(String name) {
        names.add(name);
    }
    public String removeFirst() {
        if (names.size() > 0)
            return (String) names.remove(0);
        else
            return null;
    }
}
The method Collections.synchronizedList() returns a List whose methods 
are all synchronized and "thread-safe" according to the documentation  (like a 
Vector—but since this is the 21st century, we're not going to use a Vector here). The question is, can the NameList class be used safely from multiple threads? It's 
tempting to think that yes, since the data in names is in a synchronized collection, 
the NameList class is "safe" too. However that's not the case—the removeFirst() 
may sometimes throw a NoSuchElementException. What's the problem? Doesn't it 
correctly check the size() of names before removing anything, to make sure there's 
something there? How could this code fail? Let's try to use NameList like this:
public static void main(String[] args) {
    final NameList nl = new NameList();
    nl.add("Ozymandias");
    class NameDropper extends Thread {
        public void run() {
            String name = nl.removeFirst();
            System.out.println(name);
        }
    }
    Thread t1 = new NameDropper();
    Thread t2 = new NameDropper();
    t1.start();
    t2.start();
}
What might happen here is that one of the threads will remove the one name 
and print it, then the other will try to remove a name and get null. If we think just 
about the calls to names.size() and names.get(0), they occur in this order:
Thread t1 executes names.size(), which returns 1. Thread t1 executes names.remove(0), which returns Ozymandias. Thread t2 executes names.size(), which returns 0. Thread t2 does not call remove(0). The output here is
Ozymandias
null
Synchronization and Locks (Exam Objective 4.3) 743
744 Chapter 9:  Threads
However, if we run the program again something different might happen:
Thread t1 executes names.size(), which returns 1. Thread t2 executes names.size(), which returns 1. Thread t1 executes names.remove(0), which returns Ozymandias. Thread t2 executes names.remove(0), which throws an exception because the 
     list is now empty. The thing to realize here is that in a "thread-safe" class like the one returned by 
synchronizedList(), each individual method is synchronized. So names.size() 
is synchronized, and names.remove(0) is synchronized. But nothing prevents 
another thread from doing something else to the list in between those two calls. And 
that's where problems can happen. There's a solution here: don't rely on Collections.synchronizedList(). Instead, synchronize the code yourself:
import java.util.*;
public class NameList {
    private List names = new LinkedList();
    public synchronized void add(String name) {
        names.add(name);
    }
    public synchronized String removeFirst() {
        if (names.size() > 0)
            return (String) names.remove(0);
        else
            return null;
    }
}
Now the entire removeFirst() method is synchronized, and once one thread 
starts it and calls names.size(), there's no way the other thread can cut in and 
steal the last name. The other thread will just have to wait until the first thread 
completes the removeFirst() method. The moral here is that just because a class is described as "thread-safe" doesn't 
mean it is always thread-safe. If individual methods are synchronized, that may not 
be enough—you may be better off putting in synchronization at a higher level (i.e., 
put it in the block or method that calls the other methods). Once you do that, the 
original synchronization (in this case, the synchronization inside the object returned 
by Collections.synchronizedList()) may well become redundant. Thread Deadlock 
Perhaps the scariest thing that can happen to a Java program is deadlock. Deadlock 
occurs when two threads are blocked, with each waiting for the other's lock. Neither 
can run until the other gives up its lock, so they'll sit there forever. This can happen, for example, when thread A hits synchronized code, acquires 
a lock B, and then enters another method (still within the synchronized code it 
has the lock on) that's also synchronized. But thread A can't get the lock to enter 
this synchronized code—block C—because another thread D has the lock already. So thread A goes off to the waiting-for-the-C-lock pool, hoping that thread D will 
hurry up and release the lock (by completing the synchronized method). But 
thread A will wait a very long time indeed, because while thread D picked up lock 
C, it then entered a method synchronized on lock B. Obviously, thread D can't 
get the lock B because thread A has it. And thread A won't release it until thread D 
releases lock C. But thread D won't release lock C until after it can get lock B and 
continue. And there they sit. The following example demonstrates deadlock:
 1. public class DeadlockRisk { 
 2. private static class Resource { 
 3. public int value; 
 4. } 
 5. private Resource resourceA = new Resource(); 
 6. private Resource resourceB = new Resource(); 
 7. public int read() { 
 8. synchronized(resourceA) { // May deadlock here 
 9. synchronized(resourceB) { 
10. return resourceB.value + resourceA.value; 
11. } 
12.

--- Chunk #1560 ---
} 
13. } 
14.

--- Chunk #1561 ---
15. public void write(int a, int b) { 
16. synchronized(resourceB) { // May deadlock here 
17. synchronized(resourceA) { 
18. resourceA.value = a; 
19. resourceB.value = b; 
20. } 
21.

--- Chunk #1562 ---
} 
22.

--- Chunk #1563 ---
} 
23. } 
Thread Deadlock (Exam Objective 4.3) 745
746 Chapter 9:  Threads
Assume that read() is started by one thread and write() is started by another. If there are two different threads that may read and write independently, there is a 
risk of deadlock at line 8 or 16. The reader thread will have resourceA, the writer 
thread will have resourceB, and both will get stuck waiting for the other. Code like this almost never results in deadlock because the CPU has to switch 
from the reader thread to the writer thread at a particular point in the code, and the 
chances of deadlock occurring are very small. The application may work fine 99.9 
percent of the time. The preceding simple example is easy to fix; just swap the order of locking for 
either the reader or the writer at lines 16 and 17 (or lines 8 and 9). More complex 
deadlock situations can take a long time to figure out. Regardless of how little chance there is for your code to deadlock, the bottom 
line is, if you deadlock, you're dead. There are design approaches that can help avoid 
deadlock, including strategies for always acquiring locks in a predetermined order. But that's for you to study and is beyond the scope of this book.

--- Chunk #1564 ---
We're just trying 
to get you through the exam. If you learn everything in this chapter, though, you'll 
still know more about threads than most experienced Java programmers. CERTIFICATION OBJECTIVE
Thread Interaction (Objective 4.4)
4.4 Given a scenario, write code that makes appropriate use of wait, notify. or notifyAll. The last thing we need to look at is how threads can interact with one another 
to communicate about—among other things—their locking status. The Object 
class has three methods, wait(), notify(), and notifyAll() that help threads 
communicate about the status of an event that the threads care about. For example, 
if one thread is a mail-delivery thread and one thread is a mail-processor thread, 
the mail-processor thread has to keep checking to see if there's any mail to process. Using the wait and notify mechanism, the mail-processor thread could check for 
mail, and if it doesn't find any it can say, "Hey, I'm not going to waste my time 
checking for mail every two seconds. I'm going to go hang out, and when the mail 
deliverer puts something in the mailbox, have him notify me so I can go back to 
runnable and do some work." In other words, using wait() and notify() lets one 
thread put itself into a "waiting room" until some other thread notifies it that there's 
a reason to come back out. One key point to remember (and keep in mind for the exam) about wait/notify 
is this:
 wait(), notify(), and notifyAll() must be called from within a synchronized 
context! A thread can't invoke a wait or notify method on an object unless it owns 
that object's lock. Here we'll present an example of two threads that depend on each other to 
proceed with their execution, and we'll show how to use wait() and notify() to 
make them interact safely and at the proper moment. Think of a computer-controlled machine that cuts pieces of fabric into different 
shapes and an application that allows users to specify the shape to cut. The current 
version of the application has one thread, which loops, first asking the user for 
instructions, and then directs the hardware to cut the requested shape:
public void run(){
   while(true){
      // Get shape from user
      // Calculate machine steps from shape
      // Send steps to hardware
   }
}
This design is not optimal because the user can't do anything while the machine 
is busy and while there are other shapes to define. We need to improve the situation. A simple solution is to separate the processes into two different threads, one of 
them interacting with the user and another managing the hardware. The user thread 
sends the instructions to the hardware thread and then goes back to interacting with 
the user immediately. The hardware thread receives the instructions from the user 
thread and starts directing the machine immediately. Both threads use a common 
object to communicate, which holds the current design being processed. The following pseudocode shows this design:
public void userLoop(){
   while(true){
      // Get shape from user
      // Calculate machine steps from shape
      // Modify common object with new machine steps
Thread Interaction (Exam Objective 4.4) 747
748 Chapter 9:  Threads
   }
}
public void hardwareLoop(){
   while(true){
      // Get steps from common object
      // Send steps to hardware
   }
}
The problem now is to get the hardware thread to process the machine steps as 
soon as they are available. Also, the user thread should not modify them until they 
have all been sent to the hardware. The solution is to use wait() and notify(), 
and also to synchronize some of the code. The methods wait() and notify(), remember, are instance methods of Object. In the same way that every object has a lock, every object can have a list of threads 
that are waiting for a signal (a notification) from the object. A thread gets on 
this waiting list by executing the wait() method of the target object. From that 
moment, it doesn't execute any further instructions until the notify() method of 
the target object is called. If many threads are waiting on the same object, only one 
will be chosen (in no guaranteed order) to proceed with its execution. If there are 
no threads waiting, then no particular action is taken. Let's take a look at some real 
code that shows one object waiting for another object to notify it (take note, it is 
somewhat complex):
 1. class ThreadA {
 2. public static void main(String [] args) {
 3. ThreadB b = new ThreadB();
 4. b.start();
 5. 6. synchronized(b) {
 7. try {
 8. System.out.println("Waiting for b to complete...");
 9. b.wait();
10. } catch (InterruptedException e) {}
11. System.out.println("Total is: " + b.total);
12. }
13.

--- Chunk #1565 ---
}
14. }
15.

--- Chunk #1566 ---
16. class ThreadB extends Thread {   
17. int total;
18. 19. public void run() {
20. synchronized(this) {
21. for(int i=0;i<100;i++) {
22. total += i;
23. }
24. notify();
25. }
26.

--- Chunk #1567 ---
}
27. }
This program contains two objects with threads: ThreadA contains the main 
thread and ThreadB has a thread that calculates the sum of all numbers from 0 
through 99. As soon as line 4 calls the start() method, ThreadA will continue 
with the next line of code in its own class, which means it could get to line 11 
before ThreadB has finished the calculation. To prevent this, we use the wait() 
method in line 9. Notice in line 6 the code synchronizes itself with the object b—this is because in 
order to call wait() on the object, ThreadA must own a lock on b. For a thread to 
call wait() or notify(), the thread has to be the owner of the lock for that object. When the thread waits, it temporarily releases the lock for other threads to use, but 
it will need it again to continue execution. It's common to find code like this:
synchronized(anotherObject) { // this has the lock on anotherObject
   try {
      anotherObject.wait(); 
      // the thread releases the lock and waits
      // To continue, the thread needs the lock,
      // so it may be blocked until it gets it. } catch(InterruptedException e){}
}
The preceding code waits until notify() is called on anotherObject . synchronized(this) { notify(); }
This code notifies a single thread currently waiting on the this object. The 
lock can be acquired much earlier in the code, such as in the calling method. Note that if the thread calling wait() does not own the lock, it will throw an 
IllegalMonitorStateException. This exception is not a checked exception,      
Thread Interaction (Exam Objective 4.4) 749
750 Chapter 9:  Threads
so you don't have to catch it explicitly. You should always be clear whether a thread 
has the lock of an object in any given block of code. Notice in lines 7–10 there is a try/catch block around the wait() method. A waiting thread can be interrupted in the same way as a sleeping thread, so you 
have to take care of the exception:
try {
   wait();
} catch(InterruptedException e) {
   // Do something about it
}
In the fabric example, the way to use these methods is to have the hardware 
thread wait on the shape to be available and the user thread to notify after it has 
written the steps. The machine steps may comprise global steps, such as moving the 
required fabric to the cutting area, and a number of substeps, such as the direction 
and length of a cut. As an example they could be
int fabricRoll;
int cuttingSpeed;
Point startingPoint;
float[] directions;
float[] lengths;
etc.. It is important that the user thread does not modify the machine steps while the 
hardware thread is using them, so this reading and writing should be synchronized. The resulting code would look like this:
class Operator extends Thread {
   public void run(){
      while(true){
         // Get shape from user
         synchronized(this){
            // Calculate new machine steps from shape
            notify();
         }
      }
   }
}
class Machine extends Thread {
   Operator operator; // assume this gets initialized
   public void run(){
      while(true){
         synchronized(operator){
            try {
               operator.wait();
            } catch(InterruptedException ie) {}
            // Send machine steps to hardware
         }
      }
   }
}
The machine thread, once started, will immediately go into the waiting state and 
will wait patiently until the operator sends the first notification. At that point it is 
the operator thread that owns the lock for the object, so the hardware thread gets 
stuck for a while. It's only after the operator thread abandons the synchronized 
block that the hardware thread can really start processing the machine steps. While one shape is being processed by the hardware, the user may interact 
with the system and specify another shape to be cut. When the user is finished 
with the shape and it is time to cut it, the operator thread attempts to enter the 
synchronized block, maybe blocking until the machine thread has finished with 
the previous machine steps. When the machine thread has finished, it repeats the 
loop, going again to the waiting state (and therefore releasing the lock). Only then 
can the operator thread enter the synchronized block and overwrite the machine 
steps with the new ones. Having two threads is definitely an improvement over having one, although in 
this implementation there is still a possibility of making the user wait. A further 
improvement would be to have many shapes in a queue, thereby reducing the 
possibility of requiring the user to wait for the hardware. There is also a second form of wait() that accepts a number of milliseconds 
as a maximum time to wait. If the thread is not interrupted, it will continue 
normally whenever it is notified or the specified timeout has elapsed. This normal 
continuation consists of getting out of the waiting state, but to continue execution it 
will have to get the lock for the object:
     synchronized(a){ // The thread gets the lock on 'a'
       a.wait(2000); // Thread releases the lock and waits for notify
       // only for a maximum of two seconds, then goes back to Runnable
       // The thread reacquires the lock
       // More instructions here
         }
Thread Interaction (Exam Objective 4.4) 751
752 Chapter 9:  Threads
Using notifyAll( ) When Many Threads May Be Waiting
In most scenarios, it's preferable to notify all of the threads that are waiting on a 
particular object. If so, you can use notifyAll() on the object to let all the threads 
rush out of the waiting area and back to runnable. This is especially important if you 
have several threads waiting on one object, but for different reasons, and you want 
to be sure that the right thread (along with all of the others) gets notified. notifyAll(); // Will notify all waiting threads
All of the threads will be notified and start competing to get the lock. As the lock 
is used and released by each thread, all of them will get into action without a need 
for further notification. As we said earlier, an object can have many threads waiting on it, and using 
notify() will affect only one of them. Which one, exactly, is not specified and 
depends on the JVM implementation, so you should never rely on a particular 
thread being notified in preference to another. In cases in which there might be a lot more waiting, the best way to do this is by 
using notifyAll(). Let's take a look at this in some code. In this example, there is 
one class that performs a calculation and many readers that are waiting to receive 
the completed calculation. At any given moment many readers may be waiting. 1. class Reader extends Thread {
 2. Calculator c;
 3. 4. public Reader(Calculator calc) {
 5. c = calc;
When the wait() method is invoked on an object, the thread executing 
that code gives up its lock on the object immediately. However, when notify() is called, 
that doesn’t mean the thread gives up its lock at that moment. If the thread is still 
completing synchronized code, the lock is not released until the thread moves out of 
synchronized code. So just because notify() is called doesn’t mean the lock becomes 
available at that moment. 6.

--- Chunk #1568 ---
}
 7.

--- Chunk #1569 ---
8. public void run() {
 9. synchronized(c) {
10. try {
11. System.out.println("Waiting for calculation...");
12. c.wait();
13. } catch (InterruptedException e) {}
14. System.out.println("Total is: " + c.total);
15. }
16.

--- Chunk #1570 ---
}
17.

--- Chunk #1571 ---
18. public static void main(String [] args) {
19. Calculator calculator = new Calculator();
20. new Reader(calculator).start();
21. new Reader(calculator).start();
22. new Reader(calculator).start();
23. calculator.start();
24. }
25. }
26.

--- Chunk #1572 ---
27. class Calculator extends Thread {
28. int total;
29. 30. public void run() {
31. synchronized(this) {
32. for(int i=0;i<100;i++) {
33. total += i;
34. }
35. notifyAll();
36. }
37.

--- Chunk #1573 ---
}
38. }
The program starts three threads that are all waiting to receive the finished 
calculation (lines 18–24), and then starts the calculator with its calculation. Note 
that if the run() method at line 30 used notify() instead of notifyAll(), only 
one reader would be notified instead of all the readers. Using wait( ) in a Loop
Actually both of the previous examples (Machine/Operator and Reader/Calculator) 
had a common problem. In each one, there was at least one thread calling wait(), 
and another thread calling notify() or notifyAll(). This works well enough 
Using notifyAll( ) When Many Threads May Be Waiting (Exam Objective 4.4) 753
754 Chapter 9:  Threads
as long as the waiting threads have actually started waiting before the other thread 
executes the notify() or notifyAll(). But what happens if, for example, the 
Calculator runs first and calls notify() before the Readers have started waiting? This could happen, since we can't guarantee what order the different parts of the 
thread will execute in. Unfortunately, when the Readers run, they just start waiting 
right away. They don't do anything to see if the event they're waiting for has already 
happened. So if the Calculator has already called notifyAll(), it's not going to 
call notifyAll() again—and the waiting Readers will keep waiting forever. This 
is probably not what the programmer wanted to happen. Almost always, when 
you want to wait for something, you also need to be able to check if it has already 
happened. Generally the best way to solve this is to put in some sort of loop that 
checks on some sort of conditional expressions, and only waits if the thing you're 
waiting for has not yet happened. Here's a modified, safer version of the earlier 
fabric-cutting machine example:
class Operator extends Thread {
  Machine machine; // assume this gets initialized
  public void run() {
    while (true) {
      Shape shape = getShapeFromUser();
      MachineInstructions job = 
                          calculateNewInstructionsFor(shape);
      machine.addJob(job);
    }
  }
}
The operator will still keep on looping forever, getting more shapes from users, 
calculating new instructions for those shapes, and sending them to the machine. But now the logic for notify() has been moved into the addJob() method in the 
Machine class:
class Machine extends Thread {
  List<MachineInstructions> jobs = 
                        new ArrayList<MachineInstructions>();
  public void addJob(MachineInstructions job) {
    synchronized (jobs) {
      jobs.add(job);
      jobs.notify();
    }
  }
  public void run() {
    while (true) {
      synchronized (jobs) {
        // wait until at least one job is available
        while (jobs.isEmpty()) {
          try {
            jobs.wait();
          } catch (InterruptedException ie) { }
        }
        // If we get here, we know that jobs is not empty 
        MachineInstructions instructions = jobs.remove(0);
        // Send machine steps to hardware
      }
    }
  }
}
 A machine keeps a list of the jobs it's scheduled to do. Whenever an operator 
adds a new job to the list, it calls the addJob() method and adds the new job to 
the list. Meanwhile the run() method just keeps looping, looking for any jobs on 
the list. If there are no jobs, it will start waiting. If it's notified, it will stop waiting 
and then recheck the loop condition: is the list still empty? In practice this double-
check is probably not necessary, as the only time a notify() is ever sent is when a 
new job has been added to the list. However, it's a good idea to require the thread to 
recheck the isEmpty() condition whenever it's been woken up, because it's possible 
that a thread has accidentally sent an extra notify() that was not intended. There's also a possible situation called spontaneous wakeup that may exist in some 
situations—a thread may wake up even though no code has called notify() 
or notifyAll(). (At least, no code you know about has called these methods. Sometimes the JVM may call notify() for reasons of its own, or code in some other 
class calls it for reasons you just don't know.)  What this means is, when your thread 
wakes up from a wait(), you don't know for sure why it was awakened. By putting 
the wait() method in a while loop and re-checking the condition that represents 
what we were waiting for, we ensure that whatever the reason we woke up, we will 
re-enter the wait() if (and only if) the thing we were waiting for has not happened 
yet. In the Machine class, the thing we were waiting for is for the jobs list to not be 
empty. If it's empty, we wait, and if it's not, we don't. Using notifyAll( ) When Many Threads May Be Waiting (Exam Objective 4.4) 755
756 Chapter 9:  Threads
 Note also that both the run() method and the addJob() method synchronize 
on the same object—the jobs list. This is for two reasons. One is because we're 
calling wait() and notify() on this instance, so we need to synchronize in order 
to avoid an IllegalThreadState exception. The other reason is, the data in the jobs 
list is changeable data stored in a field that is accessed by two different threads. We 
need to synchronize in order to access that changeable data safely. Fortunately, the 
same synchronized blocks that allow us to wait() and notify() also provide 
the required thread safety for our other access to changeable data. In fact this is a 
main reason why synchronization is required to use wait() and notify() in the 
first place—you almost always need to share some mutable data between threads 
at the same time, and that means you need synchronization. Notice that the 
synchronized block in addJob() is big enough to also include the call to 
jobs.add(job)—which modifies shared data. And the synchronized block in 
run() is large enough to include the whole while loop—which includes the call to 
jobs.isEmpty(), which accesses shared data. The moral here is that when you use wait() and notify() or notifyAll(), 
you should almost always also have a while loop around the wait() that checks a 
condition and forces continued waiting until the condition is met. And you should 
also make use of the required synchronization for the wait() and notify() calls, 
to also protect whatever other data you're sharing between threads. If you see code 
which fails to do this, there's usually something wrong with the code—even if you 
have a hard time seeing what exactly the problem is. The methods wait() , notify(), and notifyAll() are methods of only 
java.lang.Object, not of java.lang.Thread or java.lang.Runnable. Be sure you know which 
methods are deﬁ  ned in Thread, which in Object, and which in Runnable (just run(), so 
that’s an easy one). Of the key methods in Thread, be sure you know which are static—
sleep() and yield(), and which are not static—join() and start(). Table 9-2 lists the 
key methods you’ll need to know for the exam, with the static methods shown in italics. CERTIFICATION SUMMARY
This chapter covered the required thread knowledge you'll need to apply on the 
certification exam. Threads can be created by either extending the Thread class or 
implementing the Runnable interface. The only method that must be overridden in 
the Runnable interface is the run() method, but the thread doesn't become a thread 
of execution until somebody calls the Thread object's start() method. We also 
looked at how the sleep() method can be used to pause a thread, and we saw that 
when an object goes to sleep, it holds onto any locks it acquired prior to sleeping. We looked at five thread states: new, runnable, running, blocked/waiting/sleeping, 
and dead. You learned that when a thread is dead, it can never be restarted even if 
it's still a valid object on the heap. We saw that there is only one way a thread can 
transition to running, and that's from runnable. However, once running, a thread 
can become dead, go to sleep, wait for another thread to finish, block on an object's 
lock, wait for a notification, or return to runnable. You saw how two threads acting on the same data can cause serious problems 
(remember Lucy and Fred's bank account?). We saw that, to let one thread execute 
a method, but prevent other threads from running the same object's method, we use 
the synchronized keyword. To coordinate activity between different threads, use 
the wait(), notify(), and notifyAll() methods. Class Object Class Thread Interface Runnable
wait () start() run() 
notify() yield()
notifyAll() sleep()
join()
 TABLE 9-2    Key Thread Methods
   
Certiﬁ  cation Summary 757
758 Chapter 9:  Threads
TWO-MINUTE DRILL
Here are some of the key points from each certification objective in this chapter. Photocopy it and sleep with it under your pillow for complete absorption. Defining, Instantiating, and Starting Threads (Objective 4.1)
❑  Threads can be created by extending Thread and overriding the 
public void run() method. ❑  Thread objects can also be created by calling the Thread constructor that 
takes a Runnable argument. The Runnable object is said to be the target of 
the thread. ❑  You can call start() on a Thread object only once. If start() is called 
more than once on a Thread object, it will throw a RuntimeException. ❑ It is legal to create many Thread objects using the same Runnable object as 
            the target. ❑  When a Thread object is created, it does not become a thread of execution  
until its start() method is invoked. When a Thread object exists but hasn't 
been started, it is in the new state and is not considered alive. Transitioning Between Thread States (Objective 4.2)
❑  Once a new thread is started, it will always enter the runnable state. ❑  The thread scheduler can move a thread back and forth between the 
runnable state and the running state. ❑  For a typical single-processor machine, only one thread can be running at a 
time, although many threads may be in the runnable state. ❑  There is no guarantee that the order in which threads were started 
determines the order in which they'll run. ❑  There's no guarantee that threads will take turns in any fair way. It's up 
to the thread scheduler, as determined by the particular virtual machine 
implementation. If you want a guarantee that your threads will take turns 
regardless of the underlying JVM, you can use the sleep() method. This 
prevents one thread from hogging the running process while another thread 
starves. (In most cases, though, yield() works well enough to encourage 
your threads to play together nicely.)
❑  A running thread may enter a blocked/waiting state by a wait(), sleep(), 
or join() call. ✓
❑  A running thread may enter a blocked/waiting state because it can't acquire 
the lock for a synchronized block of code. ❑  When the sleep or wait is over, or an object's lock becomes available, the 
thread can only reenter the runnable state. It will go directly from waiting to 
running (well, for all practical purposes anyway). ❑  A dead thread cannot be started again. Sleep, Yield, and Join (Objective 4.2)
❑  Sleeping is used to delay execution for a period of time, and no locks are 
released when a thread goes to sleep. ❑  A sleeping thread is guaranteed to sleep for at least the time specified in 
the argument to the sleep() method (unless it's interrupted), but there is 
no guarantee as to when the newly awakened thread will actually return to 
running. ❑  The sleep() method is a static method that sleeps the currently executing 
thread's state. One thread cannot tell another thread to sleep. ❑  The setPriority() method is used on Thread objects to give threads 
a priority of between 1 (low) and 10 (high), although priorities are not 
guaranteed, and not all JVMs recognize 10 distinct priority levels—some 
levels may be treated as effectively equal. ❑  If not explicitly set, a thread's priority will have the same priority as the 
priority of the thread that created it. ❑  The yield() method may cause a running thread to back out if there are 
runnable threads of the same priority. There is no guarantee that this will 
happen, and there is no guarantee that when the thread backs out there 
will be a different thread selected to run. A thread might yield and then 
immediately reenter the running state. ❑  The closest thing to a guarantee is that at any given time, when a thread 
is running it will usually not have a lower priority than any thread in the 
runnable state. If a low-priority thread is running when a high-priority thread 
enters runnable, the JVM will usually preempt the running low-priority 
thread and put the high-priority thread in. ❑  When one thread calls the  join() method of another thread, the currently 
running thread will wait until the thread it joins with has completed. Think 
of the join() method as saying, "Hey thread, I want to join on to the end 
of you. Let me know when you're done, so I can enter the runnable state."
T wo-Minute Drill 759
760 Chapter 9:  Threads
Concurrent Access Problems and Synchronized Threads 
(Objective 4.3)
❑  synchronized methods prevent more than one thread from accessing an 
object's critical method code simultaneously. ❑  You can use the synchronized keyword as a method modifier, or to start a 
synchronized block of code. ❑  To synchronize a block of code (in other words, a scope smaller than the 
whole method), you must specify an argument that is the object whose lock 
you want to synchronize on. ❑  While only one thread can be accessing synchronized code of a particular 
instance, multiple threads can still access the same object's unsynchronized code. ❑  When a thread goes to sleep, its locks will be unavailable to other threads. ❑  static methods can be synchronized, using the lock from the
java.lang.Class instance representing that class. Communicating with Objects by Waiting and Notifying 
(Objective 4.4)
❑  The wait() method lets a thread say, "there's nothing for me to do now, so 
put me in your waiting pool and notify me when something happens that I 
care about." Basically, a wait() call means "wait me in your pool," or "add 
me to your waiting list."
❑  The notify() method is used to send a signal to one and only one of the 
threads that are waiting in that same object's waiting pool. ❑  The notify() method can NOT specify which waiting thread to notify. ❑  The method notifyAll() works in the same way as notify(), only it sends 
the signal to all of the threads waiting on the object. ❑  All three methods— wait(), notify(), and notifyAll()—must be 
called from within a synchronized context! A thread invokes wait() or 
notify() on a particular object, and the thread must currently hold the lock 
on that object. Deadlocked Threads (Objective 4.3)
❑  Deadlocking is when thread execution grinds to a halt because the code is 
waiting for locks to be removed from objects. ❑  Deadlocking can occur when a locked object attempts to access another 
locked object that is trying to access the first locked object. In other words, 
both threads are waiting for each other's locks to be released; therefore, the 
locks will never be released! ❑  Deadlocking is bad. Don't do it.

--- Chunk #1574 ---
SELF TEST
The following questions will help you measure your understanding of the material presented in this 
chapter. If you have a rough time with some of these at first, don't beat yourself up. Some of these 
questions are long and intricate, expect long and intricate questions on the real exam too!

--- Chunk #1575 ---
1. The following block of code creates a Thread using a Runnable target:
Runnable target = new MyRunnable();
Thread myThread = new Thread(target);
  Which of the following classes can be used to create the target, so that the preceding code 
compiles correctly? A. public class MyRunnable extends Runnable{public void run(){}}
  B. public class MyRunnable extends Object{public void run(){}}
  C. public class MyRunnable implements Runnable{public void run(){}}
  D. public class MyRunnable implements Runnable{void run(){}}
  E. public class MyRunnable implements Runnable{public void start(){}}
 2. Given:
 3. class MyThread extends Thread {     
 4. public static void main(String [] args) {
 5. MyThread t = new MyThread();
 6. Thread x = new Thread(t);
 7. x.start();
 8. }     
 9. public void run() {
10. for(int i=0;i<3;++i) {
11. System.out.print(i + "..");
12. }
13. }
14. } 
  What is the result of this code? A. Compilation fails
  B. 1..2..3..

--- Chunk #1576 ---
C. 0..1..2..3.. D. 0..1..2..

--- Chunk #1577 ---
E. An exception occurs at runtime
Self T est 761
762 Chapter 9:  Threads
 3. Given:
 3.

--- Chunk #1578 ---
class Test {     
 4. public static void main(String [] args) {
 5. printAll(args);
 6. }    
 7. public static void printAll(String[] lines) {
 8. for(int i=0;i<lines.length;i++){
 9. System.out.println(lines[i]); 
10. Thread.currentThread().sleep(1000);
11. }
12. }
13. }
  The static method Thread.currentThread() returns a reference to the currently executing 
Thread object. What is the result of this code?

--- Chunk #1579 ---
A. Each String in the array lines will output, with a 1-second pause between lines
  B. Each String in the array lines will output, with no pause in between because this method 
is not executed in a Thread
  C. Each String in the array lines will output, and there is no guarantee there will be a pause 
because currentThread() may not retrieve this thread
  D. This code will not compile
  E. Each String in the lines array will print, with at least a one-second pause between lines
 4. Assume you have a class that holds two private variables: a and b. Which of the following 
pairs can prevent concurrent access problems in that class? (Choose all that apply.)
  A. public int read(){return a+b;}
public void set(int a, int b){this.a=a;this.b=b;}
  B. public synchronized int read(){return a+b;}
public synchronized void set(int a, int b){this.a=a;this.b=b;}
  C. public int read(){synchronized(a){return a+b;}}
public void set(int a, int b){synchronized(a){this.a=a;this.b=b;}} 
  D. public int read(){synchronized(a){return a+b;}}
public void set(int a, int b){synchronized(b){this.a=a;this.b=b;}} 
  E. public synchronized(this) int read(){return a+b;}
public synchronized(this) void set(int a, int b){this.a=a;this.b=b;} 
  F. public int read(){synchronized(this){return a+b;}}
public void set(int a, int b){synchronized(this){this.a=a;this.b=b;}} 
 5. Given:
 1. public class WaitTest {
 2. public static void main(String [] args) {
 3. System.out.print("1 ");
 4. synchronized(args){
 5. System.out.print("2 ");
 6. try {
 7. args.wait();
 8. }
 9. catch(InterruptedException e){}
10. }
11. System.out.print("3 ");
12. }
13. }
  What is the result of trying to compile and run this program? A. It fails to compile because the IllegalMonitorStateException of wait() is not dealt 
with in line 7 
  B. 1 2 3 
  C.

--- Chunk #1580 ---
1 3
  D.

--- Chunk #1581 ---
1 2
  E. At runtime, it throws an IllegalMonitorStateException when trying to wait
  F. It will fail to compile because it has to be synchronized on the this object 
 6. Assume the following method is properly synchronized and called from a thread  A on an object  B:
wait(2000);
  After calling this method, when will the thread A become a candidate to get another turn at 
the CPU? A. After object B is notified, or after two seconds
  B. After the lock on B is released, or after two seconds
  C. T wo seconds after object B is notified
  D. T wo seconds after lock B is released
Self T est 763
764 Chapter 9:  Threads
 7. Which are true?

--- Chunk #1582 ---
(Choose all that apply.)
  A. The notifyAll() method must be called from a synchronized context
  B. To call wait(), an object must own the lock on the thread
  C. The notify() method is defined in class java.lang.Thread
  D. When a thread is waiting as a result of wait(), it releases its lock
  E. The notify() method causes a thread to immediately release its lock
  F. The difference between notify() and notifyAll() is that notifyAll() notifies all 
waiting threads, regardless of the object they're waiting on
 8 . Given the scenario: This class is intended to allow users to write a series of messages, so that 
each message is identified with a timestamp and the name of the thread that wrote the message:
public class Logger {
    private StringBuilder contents = new StringBuilder();
    public void log(String message) {
        contents.append(System.currentTimeMillis());
        contents.append(": ");
        contents.append(Thread.currentThread().getName());
        contents.append(message);
        contents.append("\n");
    }
    public String getContents() { return contents.toString(); }
}
  How can we ensure that instances of this class can be safely used by multiple threads? A. This class is already thread-safe
  B. Replacing StringBuilder with StringBuffer will make this class thread-safe
  C. Synchronize the log() method only
  D. Synchronize the getContents() method only
  E. Synchronize both log() and getContents()
  F. This class cannot be made thread-safe
 9 . Given:
public static synchronized void main(String[] args) throws 
InterruptedException {
    Thread t = new Thread();
    t.start();
    System.out.print("X");
    t.wait(10000);
    System.out.print("Y");
}
   
  What is the result of this code? A. It prints X and exits
  B. It prints X and never exits
  C. It prints XY and exits almost immeditately
  D. It prints XY with a 10-second delay between X and Y
  E. It prints XY with a 10000-second delay between X and Y
  F. The code does not compile
  G. An exception is thrown at runtime
 10. Given:
class MyThread extends Thread {
   MyThread() {
     System.out.print(" MyThread");
   }
   public void run() {
     System.out.print(" bar");
   }
   public void run(String s) {
      System.out.print(" baz");
  }
}
public class TestThreads {
  public static void main (String [] args) {
    Thread t = new MyThread() {
      public void run() {
        System.out.print(" foo");
      }
    };
    t.start();
} }
Self T est 765
766 Chapter 9:  Threads
  What is the result? A. foo 
  B. MyThread foo
  C. MyThread bar
  D. foo bar
  E. foo bar baz
  F. bar foo
  G. Compilation fails
  H. An exception is thrown at runtime
 11. Given:
public class ThreadDemo {
    synchronized void a() { actBusy(); }
    static synchronized void b() { actBusy(); }
    static void actBusy() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {}
    }
    public static void main(String[] args) {
        final ThreadDemo x = new ThreadDemo();
        final ThreadDemo y = new ThreadDemo();
        Runnable runnable = new Runnable() {
            public void run() {
                int option = (int) (Math.random() * 4);
                switch (option) {
                    case 0: x.a(); break;
                    case 1: x.b(); break;
                    case 2: y.a(); break;
                    case 3: y.b(); break;
                }
            }
        };
        Thread thread1 = new Thread(runnable);
        Thread thread2 = new Thread(runnable);
        thread1.start();
        thread2.start();
    }
}
  Which of the following pairs of method invocations could NEVER be executing at the same time? (Choose all that apply.) 
  A. x.a() in thread1, and x.a() in thread2
  B. x.a() in thread1, and x.b() in thread2
  C. x.a() in thread1, and y.a() in thread2
  D. x.a() in thread1, and y.b() in thread2
  E. x.b() in thread1, and x.a() in thread2
  F. x.b() in thread1, and x.b() in thread2
  G. x.b() in thread1, and y.a() in thread2
  H. x.b() in thread1, and y.b() in thread2
 12. Given: 
public class TwoThreads {
    static Thread laurel, hardy;
    public static void main(String[] args) {
        laurel = new Thread() {
            public void run() {
                System.out.println("A");
                try {
                    hardy.sleep(1000);
                } catch (Exception e) {
                    System.out.println("B");
                }
                System.out.println("C");
            }
        };
        hardy = new Thread() {
            public void run() {
                System.out.println("D");
                try {
                    laurel.wait();
                } catch (Exception e) {
                    System.out.println("E");
                }
                System.out.println("F");
            }
        };
        laurel.start();
        hardy.start();
    }
}
Self T est 767
768 Chapter 9:  Threads
  Which letters will eventually appear somewhere in the output? (Choose all that apply.)
  A.

--- Chunk #1583 ---
A
  B. B
  C. C
  D. D
  E. E
  F. F
  G. The answer cannot be reliably determined
  H. The code does not compile
 13.

--- Chunk #1584 ---
Given: 
 3. public class Starter implements Runnable {
 4. void go(long id) { 
 5. System.out.println(id); 
 6. }
 7. public static void main(String[] args) {
 8. System.out.print(Thread.currentThread().getId() + " ");
 9. // insert code here
10. }
11. public void run() { go(Thread.currentThread().getId()); }
12. }
  And given the following five fragments:
I. new Starter().run();  
II. new Starter().start();  
III. new Thread(new Starter());    
IV. new Thread(new Starter()).run();  
V. new Thread(new Starter()).start();
  When the five fragments are inserted, one at a time at line 9, which are true? (Choose all that apply.)
  A. All five will compile
  B. Only one might produce the output 4 4
  C. Only one might produce the output 4 2
  D. Exactly two might produce the output 4 4
  E. Exactly two might produce the output 4 2
  F. Exactly three might produce the output 4 4
  G. Exactly three might produce the output 4 2
 14. Given: 
 3. public class Leader implements Runnable {
 4. public static void main(String[] args) {
 5. Thread t = new Thread(new Leader());
 6. t.start();
 7. System.out.print("m1 ");
 8. t.join();
 9. System.out.print("m2 ");
10. }
11. public void run() {
12. System.out.print("r1 ");
13. System.out.print("r2 ");
14. }
15. }
  Which are true? (Choose all that apply.)
  A. Compilation fails
  B. The output could be r1 r2 m1 m2
  C. The output could be m1 m2 r1 r2
  D. The output could be m1 r1 r2 m2
  E. The output could be m1 r1 m2 r2
  F. An exception is thrown at runtime
 15. Given: 
 3. class Dudes {
 4. static long flag = 0;
 5. // insert code here
 6. if(flag == 0) flag = id;
 7. for(int x = 1; x < 3; x++) {
 8. if(flag == id) System.out.print("yo ");
 9. else System.out.print("dude ");
10. }
11.

--- Chunk #1585 ---
}
12.

--- Chunk #1586 ---
}
13. public class DudesChat implements Runnable {
14. static Dudes d;
15. public static void main(String[] args) {
16. new DudesChat().go();
17. }
18. void go() {
19. d = new Dudes();
Self T est 769
770 Chapter 9:  Threads
20. new Thread(new DudesChat()).start();
21. new Thread(new DudesChat()).start();
22. }
23. public void run() {
24. d.chat(Thread.currentThread().getId());
25. }
26. }
  And given these two fragments:
I. synchronized void chat(long id) {
II. void chat(long id) {
  When fragment I or fragment II is inserted at line 5, which are true? (Choose all that apply.)
  A. An exception is thrown at runtime
  B. With fragment I, compilation fails
  C. With fragment II, compilation fails
  D. With fragment I, the output could be yo dude dude yo
  E. With fragment I, the output could be dude dude yo yo
  F. With fragment II, the output could be yo dude dude yo
 16. Given: 
 3. class Chicks {
 4. synchronized void yack(long id) {
 5. for(int x = 1; x < 3; x++) {
 6. System.out.print(id + " ");
 7. Thread.yield();
 8. }
 9.

--- Chunk #1587 ---
}
10.

--- Chunk #1588 ---
}
11. public class ChicksYack implements Runnable {
12. Chicks c;
13. public static void main(String[] args) {
14. new ChicksYack().go();
15. }
16. void go() {
17. c = new Chicks();
18. new Thread(new ChicksYack()).start();
19. new Thread(new ChicksYack()).start();
20. }
21. public void run() {
22. c.yack(Thread.currentThread().getId());
23. }
24.

--- Chunk #1589 ---
}
  Which are true?

--- Chunk #1590 ---
(Choose all that apply.)
  A. Compilation fails
  B. The output could be 4 4 2 3
  C. The output could be 4 4 2 2
  D. The output could be 4 4 4 2
  E. The output could be 2 2 4 4
  F. An exception is thrown at runtime
 17. Given: 
 3. public class Chess implements Runnable {
 4. public void run() {
 5. move(Thread.currentThread().getId());
 6. }
 7.

--- Chunk #1591 ---
// insert code here
 8. System.out.print(id + " ");   
 9. System.out.print(id + " ");
10. }
11. public static void main(String[] args) {
12. Chess ch = new Chess();
13. new Thread(ch).start();
14. new Thread(new Chess()).start();
15. }
16. }
  And given these two fragments:
I. synchronized void move(long id) { 
II. void move(long id) {
  When either fragment I or fragment II is inserted at line 7, which are true? (Choose all that apply.)
  A. Compilation fails
  B. With fragment I, an exception is thrown
  C. With fragment I, the output could be 4 2 4 2
  D. With fragment I, the output could be 4 4 2 3
  E. With fragment II, the output could be 2 4 2 4
Self T est 771
SELF TEST ANSWERS
 1. The following block of code creates a Thread using a Runnable target:
Runnable target = new MyRunnable();
Thread myThread = new Thread(target);
  Which of the following classes can be used to create the target, so that the preceding code 
compiles correctly? A. public class MyRunnable extends Runnable{public void run(){}}
  B. public class MyRunnable extends Object{public void run(){}}
  C. public class MyRunnable implements Runnable{public void run(){}}
  D. public class MyRunnable implements Runnable{void run(){}}
  E. public class MyRunnable implements Runnable{public void start(){}}
Answer:
   ✓   C is correct. The class implements the Runnable interface with a legal run() method.     A is incorrect because interfaces are implemented, not extended. B is incorrect because 
even though the class has a valid public void run() method, it does not implement 
the Runnable interface. D is incorrect because the run() method must be public. E is 
incorrect because the method to implement is run(), not start(). (Objective 4.1)
 2. Given:
 3. class MyThread extends Thread {     
 4. public static void main(String [] args) {
 5. MyThread t = new MyThread();
 6. Thread x = new Thread(t);
 7. x.start();
 8. }     
 9. public void run() {
10. for(int i=0;i<3;++i) {
11. System.out.print(i + "..");
12. }  }  }   
772 Chapter 9:  Threads
  What is the result of this code? A. Compilation fails
  B. 1..2..3..

--- Chunk #1592 ---
C. 0..1..2..3.. D. 0..1..2.. E. An exception occurs at runtime
Answer:
   ✓   D is correct. The thread MyThread will start and loop three times (from 0 to 2).     A is incorrect because the Thread class implements the Runnable interface; therefore, 
in line 5, Thread can take an object of type Thread as an argument in the constructor  
(this is NOT recommended). B and C are incorrect because the variable i in the for 
loop starts with a value of 0 and ends with a value of 2. E is incorrect based on the above. (Objective 4.1)
 3. Given:
 3. class Test {     
 4. public static void main(String [] args) {
 5. printAll(args);
 6. }    
 7. public static void printAll(String[] lines) {
 8. for(int i=0;i<lines.length;i++){
 9. System.out.println(lines[i]); 
10. Thread.currentThread().sleep(1000);
11. }  }  } 
  The static method Thread.currentThread() returns a reference to the currently executing 
Thread object. What is the result of this code?

--- Chunk #1593 ---
A. Each String in the array lines will print, with exactly a 1-second pause between lines
  B. Each String in the array lines will print, with no pause in between because this method is 
not executed in a Thread
  C. Each String in the array lines will print, and there is no guarantee there will be a pause 
because currentThread() may not retrieve this thread
  D. This code will not compile
  E. Each String in the lines array will print, with at least a one-second pause between lines
Self T est Answers 773
774 Chapter 9:  Threads
Answer:
   ✓   D is correct. The sleep() method must be enclosed in a try/catch block, or the method 
printAll() must declare it throws the InterruptedException.     E is incorrect, but it would be correct if the InterruptedException was dealt with (A is 
too precise). B is incorrect (even if the InterruptedException was dealt with) because 
all Java code, including the main() method, runs in threads. C is incorrect. The sleep() 
method is static, it always affects the currently executing thread. (Objective 4.2)
 4. Assume you have a class that holds two private variables: a and b. Which of the following 
pairs can prevent concurrent access problems in that class? (Choose all that apply.)
  A. public int read(){return a+b;}
public void set(int a, int b){this.a=a;this.b=b;}
  B. public synchronized int read(){return a+b;}
public synchronized void set(int a, int b){this.a=a;this.b=b;}
  C. public int read(){synchronized(a){return a+b;}}
public void set(int a, int b){synchronized(a){this.a=a;this.b=b;}} 
  D. public int read(){synchronized(a){return a+b;}}
public void set(int a, int b){synchronized(b){this.a=a;this.b=b;}} 
  E. public synchronized(this) int read(){return a+b;}
public synchronized(this) void set(int a, int b){this.a=a;this.b=b;} 
  F. public int read(){synchronized(this){return a+b;}}
public void set(int a, int b){synchronized(this){this.a=a;this.b=b;}} 
Answer:
   ✓   B and F are correct. By marking the methods as synchronized, the threads will get the 
lock of the this object before proceeding. Only one thread will be setting or reading at any 
given moment, thereby assuring that read() always returns the addition of a valid pair.     A is incorrect because it is not synchronized; therefore, there is no guarantee that the values 
added by the read() method belong to the same pair. C and D are incorrect; only objects 
can be used to synchronize on. E fails —it is not possible to select other objects (even this) 
to synchronize on when declaring a method as synchronized. (Objective 4.3)
 5. Given:
 1. public class WaitTest {
 2. public static void main(String [] args) {
 3. System.out.print("1 ");
 4. synchronized(args){
 5. System.out.print("2 ");
 6. try {
 7. args.wait();
 8. }
 9. catch(InterruptedException e){}
10. }
11. System.out.print("3 ");
12. }  }
  What is the result of trying to compile and run this program? A. It fails to compile because the IllegalMonitorStateException of wait() is not dealt 
with in line 7 
  B. 1 2 3 
  C.

--- Chunk #1594 ---
1 3
  D.

--- Chunk #1595 ---
1 2
  E. At runtime, it throws an IllegalMonitorStateException when trying to wait
  F. It will fail to compile because it has to be synchronized on the this object
Answer:
   ✓   D is correct. 1 and 2 will be printed, but there will be no return from the wait call because 
no other thread will notify the main thread, so 3 will never be printed. It's frozen at line 7.     A is incorrect; IllegalMonitorStateException is an unchecked exception. B and C 
are incorrect; 3 will never be printed, since this program will wait forever. E is incorrect 
because IllegalMonitorStateException will never be thrown because the wait() 
is done on args within a block of code synchronized on args. F is incorrect because any 
object can be used to synchronize on and this and static don't mix. (Objective 4.4)
 6. Assume the following method is properly synchronized and called from a thread A on an object B:
wait(2000);
  After calling this method, when will the thread A become a candidate to get another turn at 
the CPU? A. After object B is notified, or after two seconds
  B. After the lock on B is released, or after two seconds
  C. T wo seconds after object B is notified
  D. T wo seconds after lock B is released
Self T est Answers 775
776 Chapter 9:  Threads
Answer:
   ✓   A is correct. Either of the two events will make the thread a candidate for running again.     B is incorrect because a waiting thread will not return to runnable when the lock is 
released, unless a notification occurs. C is incorrect because the thread will become a 
candidate immediately after notification. D is also incorrect because a thread will not come 
out of a waiting pool just because a lock has been released. (Objective 4.4)
 7. Which are true?

--- Chunk #1596 ---
(Choose all that apply.)
  A. The notifyAll() method must be called from a synchronized context
  B. To call wait(), an object must own the lock on the thread
  C. The notify() method is defined in class java.lang.Thread
  D. When a thread is waiting as a result of wait(), it releases its lock
  E. The notify() method causes a thread to immediately release its lock
  F. The difference between notify() and notifyAll() is that notifyAll() notifies all 
waiting threads, regardless of the object they're waiting on
Answer:
   ✓   A is correct because notifyAll() (and wait() and notify()) must be called from within 
a synchronized context. D is a correct statement.     B is incorrect because to call wait(), the thread must own the lock on the object that 
wait() is being invoked on, not the other way around. C is wrong because notify() is 
defined in java.lang.Object. E is wrong because notify() will not cause a thread to 
release its locks. The thread can only release its locks by exiting the synchronized code. F is 
wrong because notifyAll() notifies all the threads waiting on a particular locked object, 
not all threads waiting on any object. (Objective 4.4)
 8. Given the scenario:  This class is intended to allow users to write a series of messages, so that 
each message is identified with a timestamp and the name of the thread that wrote the message:
public class Logger {
    private StringBuilder contents = new StringBuilder();
    public void log(String message) {
        contents.append(System.currentTimeMillis());
        contents.append(": ");
        contents.append(Thread.currentThread().getName());
        contents.append(message);
        contents.append("\n");
    }
    public String getContents() { return contents.toString(); }
}
  How can we ensure that instances of this class can be safely used by multiple threads? A. This class is already thread-safe
  B. Replacing StringBuilder with StringBuffer will make this class thread-safe
  C. Synchronize the log() method only
  D. Synchronize the getContents() method only
  E. Synchronize both log() and getContents()
  F. This class cannot be made thread-safe
Answer:
   ✓   E is correct. Synchronizing the public methods is sufficient to make this safe, so F is false. This class is not thread-safe unless some sort of synchronization protects the changing data.     B is not correct because although a StringBuffer is synchonized internally, we call 
append() multiple times, and nothing would prevent two simultaneous log() calls from mix-
ing up their messages. C and D are not correct because if one method remains unsynchro-
nized, it can run while the other is executing, which could result in reading the contents 
while one of the messages is incomplete, or worse. (You don't want to call getString() on 
the StringBuffer as it's resizing its internal character array.)  (Objective 4.3)
 9. Given:
public static synchronized void main(String[] args) throws 
InterruptedException {
    Thread t = new Thread();
    t.start();
    System.out.print("X");
    t.wait(10000);
    System.out.print("Y");
}
  What is the result of this code? A. It prints X and exits
  B. It prints X and never exits
  C. It prints XY and exits almost immeditately
Self T est Answers 777
778 Chapter 9:  Threads
  D. It prints XY with a 10-second delay between X and Y
  E. It prints XY with a 10000-second delay between X and Y
  F. The code does not compile
  G.

--- Chunk #1597 ---
An exception is thrown at runtime
Answer:
   ✓   G is correct. The code does not acquire a lock on t before calling t.wait(), so it throws an 
IllegalMonitorStateException. The method is synchronized, but it's not synchronized 
on t so the exception will be thrown. If the wait were placed inside a synchronized(t) 
block, then the answer would have been D.     A, B, C, D, E, and F are incorrect based the logic described above.

--- Chunk #1598 ---
(Objective 4.2)
 10. Given:
class MyThread extends Thread {
   MyThread() {
     System.out.print(" MyThread");
   }
   public void run() { System.out.print(" bar"); }
   public void run(String s) { System.out.print(" baz"); }
}
public class TestThreads {
  public static void main (String [] args) {
    Thread t = new MyThread() {
      public void run() { System.out.print(" foo"); }
    };
    t.start();
} }
  What is the result? A. foo 
  B. MyThread foo
  C. MyThread bar
  D. foo bar
  E. foo bar baz
  F. bar foo
  G. Compilation fails
  H. An exception is thrown at runtime
Answer:
   ✓   B is correct. The first line of main we're constructing an instance of an anonymous inner 
class extending from MyThread. So the MyThread constructor runs and prints MyThread. Next, main() invokes start() on the new thread instance, which causes the overridden 
run() method (the run() method in the anonymous inner class) to be invoked.     A, C, D, E, F, G, and H are incorrect based on the logic described above. (Objective 4.1)
 11. Given:
public class ThreadDemo {
    synchronized void a() { actBusy(); }
    static synchronized void b() { actBusy(); }
    static void actBusy() {
        try { Thread.sleep(1000); } 
        catch (InterruptedException e) {}
    }
    public static void main(String[] args) {
        final ThreadDemo x = new ThreadDemo();
        final ThreadDemo y = new ThreadDemo();
        Runnable runnable = new Runnable() {
            public void run() {
                int option = (int) (Math.random() * 4);
                switch (option) {
                    case 0: x.a(); break;
                    case 1: x.b(); break;
                    case 2: y.a(); break;
                    case 3: y.b(); break;
            }  }
        };
        Thread thread1 = new Thread(runnable);
        Thread thread2 = new Thread(runnable);
        thread1.start();
        thread2.start();
}   }
  Which of the following pairs of method invocations could NEVER be executing at the same time? (Choose all that apply.)
  A. x.a() in thread1, and x.a() in thread2
  B. x.a() in thread1, and x.b() in thread2
  C. x.a() in thread1, and y.a() in thread2
Self T est Answers 779
780 Chapter 9:  Threads
  D. x.a() in thread1, and y.b() in thread2
  E. x.b() in thread1, and x.a() in thread2
  F. x.b() in thread1, and x.b() in thread2
  G. x.b() in thread1, and y.a() in thread2
  H. x.b() in thread1, and y.b() in thread2
Answer:
   ✓   A, F,  and H. A is a right answer because when synchronized instance methods are called
 on the same instance, they block each other. F and H can't happen because synchronized
 static methods in the same class block each other, regardless of which instance was used
 to call the methods. (An instance is not required to call static methods; only the class.)
      C could happen because synchronized instance methods called on different instances 
do not block each other. B, D, E, and G could all happen because instance methods and 
static methods lock on different objects, and do not block each other. (Objective 4.3)
 12. Given: 
public class TwoThreads {
    static Thread laurel, hardy;
    public static void main(String[] args) {
        laurel = new Thread() {
            public void run() {
                System.out.println("A");
                try {
                    hardy.sleep(1000);
                } catch (Exception e) {
                    System.out.println("B");
                }
                System.out.println("C");
            }
        };
        hardy = new Thread() {
            public void run() {
                System.out.println("D");
                try {
                    laurel.wait();
                } catch (Exception e) {
                    System.out.println("E");
                }
                System.out.println("F");
            }
        };
        laurel.start();
        hardy.start();
    }
}
  Which letters will eventually appear somewhere in the output? (Choose all that apply.)
  A.

--- Chunk #1599 ---
A
  B. B
  C. C
  D. D
  E. E
  F. F
  G. The answer cannot be reliably determined
  H. The code does not compile
Answer:
   ✓   A, C, D, E, and F are correct. This may look like laurel and hardy are battling to cause 
the other to sleep() or wait()—but that's not the case. Since sleep() is a static 
method, it affects the current thread, which is laurel (even though the method is invoked 
using a reference to hardy). That's misleading but perfectly legal, and the Thread laurel 
is able to sleep with no exception, printing A and C (after at least a 1-second delay). Mean-
while hardy tries to call laurel.wait()—but hardy has not synchronized on laurel, 
so calling laurel.wait() immediately causes an IllegalMonitorStateException, and 
so hardy prints D, E, and F. Although the order of the output is somewhat indeterminate 
(we have no way of knowing whether A is printed before D, for example) it is guaranteed 
that A, C, D, E, and F will all be printed in some order, eventually—so G is incorrect.     B, G, and H are incorrect based on the above. (Objective 4.4)
 13.

--- Chunk #1600 ---
Given: 
 3. public class Starter implements Runnable {
 4. void go(long id) { 
 5. System.out.println(id); 
 6. }
 7. public static void main(String[] args) {
 8. System.out.print(Thread.currentThread().getId() + " ");
 9. // insert code here
Self T est Answers 781
782 Chapter 9:  Threads
10. }
11. public void run() { go(Thread.currentThread().getId()); }
12. }
  And given the following five fragments:
I. new Starter().run();  
II. new Starter().start();  
III. new Thread(new Starter());    
IV. new Thread(new Starter()).run();  
V. new Thread(new Starter()).start();
  When the five fragments are inserted, one at a time at line 9, which are true? (Choose all that apply.)
  A. All five will compile
  B. Only one might produce the output 4 4
  C. Only one might produce the output 4 2
  D. Exactly two might produce the output 4 4
  E. Exactly two might produce the output 4 2
  F. Exactly three might produce the output 4 4
  G. Exactly three might produce the output 4 2
Answer:
   ✓   C and D are correct. Fragment I doesn't start a new thread. Fragment II doesn't compile. Fragment III creates a new thread but doesn't start it. Fragment IV creates a new thread 
and invokes run() directly, but it doesn’t start the new thread. Fragment V creates and 
starts a new thread.     A, B, E, F, and G are incorrect based on the above. (Objective 4.1)
 14.

--- Chunk #1601 ---
Given: 
 3. public class Leader implements Runnable {
 4. public static void main(String[] args) {
 5. Thread t = new Thread(new Leader());
 6. t.start();
 7. System.out.print("m1 ");
 8. t.join();
 9. System.out.print("m2 ");
10. }
11. public void run() {
12. System.out.print("r1 ");
13. System.out.print("r2 ");
14. }
15. }
  Which are true? (Choose all that apply.)
  A. Compilation fails
  B. The output could be r1 r2 m1 m2
  C. The output could be m1 m2 r1 r2
  D. The output could be m1 r1 r2 m2
  E. The output could be m1 r1 m2 r2
  F. An exception is thrown at runtime
Answer:
   ✓   A is correct. The join() must be placed in a try/catch block. If it were, answers B and 
D would be correct. The join() causes the main thread to pause and join the end of the 
other thread, meaning "m2" must come last.     B, C, D, E, and F are incorrect based on the above. (Objective 4.2)
 15. Given: 
 3. class Dudes {
 4. static long flag = 0;
 5. // insert code here
 6. if(flag == 0) flag = id;
 7. for(int x = 1; x < 3; x++) {
 8. if(flag == id) System.out.print("yo ");
 9. else System.out.print("dude ");
10. }
11.

--- Chunk #1602 ---
}
12.

--- Chunk #1603 ---
}
13. public class DudesChat implements Runnable {
14. static Dudes d;
15. public static void main(String[] args) {
16. new DudesChat().go();
17. }
18. void go() {
19. d = new Dudes();
Self T est Answers 783
784 Chapter 9:  Threads
20. new Thread(new DudesChat()).start();
21. new Thread(new DudesChat()).start();
22. }
23. public void run() {
24. d.chat(Thread.currentThread().getId());
25. }
26. }
  And given these two fragments:
I. synchronized void chat(long id) {
II. void chat(long id) {
  When fragment I or fragment II is inserted at line 5, which are true? (Choose all that apply.)
  A. An exception is thrown at runtime
  B. With fragment I, compilation fails
  C. With fragment II, compilation fails
  D. With fragment I, the output could be yo dude dude yo
  E. With fragment I, the output could be dude dude yo yo
  F. With fragment II, the output could be yo dude dude yo
Answer:
   ✓   F is correct. With fragment I, the chat method is synchronized, so the two threads can't 
swap back and forth. With either fragment, the first output must be yo.     A, B, C, D, and E are incorrect based on the above. (Objective 4.3)
 16. Given: 
 3. class Chicks {
 4. synchronized void yack(long id) {
 5. for(int x = 1; x < 3; x++) {
 6. System.out.print(id + " ");
 7. Thread.yield();
 8. }
 9.

--- Chunk #1604 ---
}
10.

--- Chunk #1605 ---
}
11. public class ChicksYack implements Runnable {
12. Chicks c;
13. public static void main(String[] args) {
14. new ChicksYack().go();
15. }
16. void go() {
17. c = new Chicks();
18. new Thread(new ChicksYack()).start();
19. new Thread(new ChicksYack()).start();
20. }
21. public void run() {
22. c.yack(Thread.currentThread().getId());
23. }
24.

--- Chunk #1606 ---
}
  Which are true?

--- Chunk #1607 ---
(Choose all that apply.)
  A. Compilation fails
  B. The output could be 4 4 2 3
  C. The output could be 4 4 2 2
  D. The output could be 4 4 4 2
  E. The output could be 2 2 4 4
  F. An exception is thrown at runtime
Answer:
   ✓   F is correct. When run() is invoked, it is with a new instance of ChicksYack and c has 
not been assigned to an object. If c were static, then because yack is synchronized, answers 
C and E would have been correct.     A, B, C, D, and E are incorrect based on the above. (Objective 4.3)
 17.

--- Chunk #1608 ---
Given: 
 3. public class Chess implements Runnable {
 4. public void run() {
 5. move(Thread.currentThread().getId());
 6. }
 7.

--- Chunk #1609 ---
// insert code here
 8. System.out.print(id + " ");   
 9. System.out.print(id + " ");
10. }
11. public static void main(String[] args) {
12. Chess ch = new Chess();
13. new Thread(ch).start();
14. new Thread(new Chess()).start();
15. }
16. }
Self T est Answers 785
786 Chapter 9:  Threads
  And given these two fragments:
I. synchronized void move(long id) { 
II. void move(long id) {
  When either fragment I or fragment II is inserted at line 7, which are true? (Choose all that apply.)
  A. Compilation fails
  B. With fragment I, an exception is thrown
  C. With fragment I, the output could be 4 2 4 2
  D. With fragment I, the output could be 4 4 2 3
  E. With fragment II, the output could be 2 4 2 4
Answer:
   ✓   C and E are correct. E should be obvious. C is correct because even though move() is 
synchronized, it's being invoked on two different objects.     A, B, and D are incorrect based on the above. (Objective 4.3)
EXERCISE ANSWERS
Exercise 9-1:   Creating a Thread and Putting It to Sleep
The final code should look something like this:
class TheCount extends Thread {
   public void run() {
      for(int i = 1;i<=100;++i) {
         System.out.print(i + "  ");
         if(i % 10 == 0)  System.out.println("Hahaha");
         try { Thread.sleep(1000); } 
         catch(InterruptedException e) {}
      }
   }
   public static void main(String [] args) {
      new TheCount().start();
   }
}
Exercise 9-2:   Synchronizing a Block of Code
Your code might look something like this when completed:
class InSync extends Thread {
  StringBuffer letter;     
  public InSync(StringBuffer letter) { this.letter = letter; }     
  public void run() {
    synchronized(letter) {      // #1
      for(int i = 1;i<=100;++i) System.out.print(letter);
      System.out.println();
      char temp = letter.charAt(0);
      ++temp;         // Increment the letter in StringBuffer:
      letter.setCharAt(0, temp);
    }     // #2
  }
  public static void main(String [] args) {
    StringBuffer sb = new StringBuffer("A");
    new InSync(sb).start();  new InSync(sb).start();
    new InSync(sb).start();
  } 
}
Just for fun, try removing lines 1 and 2 then run the program again. It will be 
unsynchronized —watch what happens.

--- Chunk #1610 ---
Exercise Answers 787
			

10
Development
CERTIFICATION OBJECTIVES
 
Use Packages and Imports
 Determine Runtime Behavior 
       for Classes and Command-Lines
 Use Classes in JAR Files
       

 Use Classpaths to
        Compile Code ✓   T wo-Minute Drill
          Q&A Self T est
 
	
790 Chapter 10:   Development
Y
ou want to keep your classes organized. Y ou need to have powerful ways for your classes 
to find each other. Y ou want to make sure that when you're looking for a particular class 
you get the one you want, and not another class that happens to have the same name. In 
this chapter we'll explore some of the advanced capabilities of the java and javac commands. We'll 
revisit the use of packages in Java, and how to search for classes that live in packages. CERTIFICATION OBJECTIVES
Using the javac and java Commands 
(Exam Objectives 7.1, 7.2, and 7.5)
7.1 Given a code example and a scenario, write code that uses the appropriate access 
modifiers, package declarations, and import statements to interact with (through access or 
inheritance) the code in the example. 7.2 Given an example of a class and a command-line, determine the expected runtime 
behavior. 7.5 Given the fully-qualified name of a class that is deployed inside and/or outside a JAR 
file, construct the appropriate directory structure for that class. Given a code example and a 
classpath, determine whether the classpath will allow the code to compile successfully. So far in this book, we've probably talked about invoking the javac and java 
commands about 1000 times; now we're going to take a closer look. Compiling with javac
The javac command is used to invoke Java's compiler. In Chapter 5 we talked 
about the assertion mechanism and when you might use the -source option when 
compiling a file. There are many other options you can specify when running javac, 
options to generate debugging information or compiler warnings for example. For 
the exam, you'll need to understand the -classpath and -d options, which we'll 
cover in the next few pages. Here's the structural overview for javac:
javac [options] [source files]
There are additional command-line options called @argfiles, but you won't 
need to study them for the exam. Both the [options] and the [source files] 
are optional parts of the command, and both allow multiple entries. The following 
are both legal javac commands:
javac -help
javac -classpath com:. -g Foo.java Bar.java
The first invocation doesn't compile any files, but prints a summary of valid 
options. The second invocation passes the compiler two options (-classpath, 
which itself has an argument of com:. and -g), and passes the compiler two .java 
files to compile (Foo.java and Bar.java). Whenever you specify multiple options 
and/or files they should be separated by spaces. Compiling with -d    
By default, the compiler puts a .class file in the same directory as the .java source 
file. This is fine for very small projects, but once you're working on a project of any 
size at all, you'll want to keep your .java files separated from your .class files. (This helps with version control, testing, deployment...) The -d option lets you tell 
the compiler in which directory to put the .class file(s) it generates (d is for 
destination). Let's say you have the following directory structure:
myProject
       |
       |--source
       |      |
       |      |-- MyClass.java
       |
       |-- classes
              |
              |--
The following command, issued from the myProject directory, will compile 
MyClass.java and put the resulting MyClass.class file into the classes 
directory. (Note: This assumes that MyClass does not have a package statement; 
we'll talk about packages in a minute.)
cd myProject
javac -d classes source/MyClass.java
Compiling with javac (Exam Objective 7.2) 791
This command also demonstrates selecting a .java file from a subdirectory of the 
directory from which the command was invoked. Now let's take a quick look at how 
packages work in relationship to the -d option. Suppose we have the following .java file in the following directory structure:
package com.wickedlysmart;
public class MyClass { }
myProject
       |
       |--source
       |      |
       |      |--com
       |           |
       |           |--wickedlysmart
       |                       |
       |                       |--MyClass.java
       |
       |--classes
       |      |
       |      |--com
       |           |
       |           |--wickedlysmart
       |                       |
       |                       |-- (MyClass.class goes here)
If you were in the source directory, you would compile MyClass.java and put 
the resulting MyClass.class file into the classes/com/wickedlysmart directory 
by invoking the following command:
javac -d ../classes com/wickedlysmart/MyClass.java
This command could be read: "To set the destination directory, cd back to 
the myProject directory then cd into the classes directory, which will be your 
destination. Then compile the file named MyClass.java. Finally, put the resulting 
MyClass.class file into the directory structure that matches its package, in this 
case, classes/com/wickedlysmart." Because MyClass.java is in a package, 
the compiler knew to put the resulting .class file into the 
classes/com/wickedlysmart directory. 792 Chapter 10:   Development
Somewhat amazingly, the javac command can sometimes help you out by 
building directories it needs! Suppose we have the following:
package com.wickedlysmart;
public class MyClass { }
myProject
       |
       |--source
       |      |
       |      |--com
       |           |
       |           |--wickedlysmart
       |                       |
       |                       |--MyClass.java
       |
       |--classes
       |      |
And the following command (the same as last time):
javac -d ../classes com/wickedlysmart/MyClass.java
In this case, the compiler will build two directories called com and
com/wickedlysmart in order to put the resulting MyClass.class file into the 
correct package directory (com/wickedlysmart/) which it builds within the 
existing .../classes directory. The last thing about -d that you'll need to know for the exam is that if the 
destination directory you specify doesn't exist, you'll get a compiler error. If, in the 
previous example, the classes directory did NOT exist, the compiler would say 
something like:
java:5: error while writing MyClass: classes/MyClass.class (No 
such file or directory)
Launching Applications with java
The java command is used to invoke the Java virtual machine. In Chapter 5 we 
talked about the assertion mechanism and when you might use flags such as -ea or 
-da when launching an application. There are many other options you can specify 
Launching Applications with java (Exam Objective 7.2) 793
when running the java command, but for the exam, you'll need to understand 
the -classpath (and its twin -cp) and -D options, which we'll cover in the next 
few pages. In addition, it's important to understand the structure of this command. Here's the overview:
java [options] class [args]
The [options] and [args] parts of the java command are optional, and they 
can both have multiple values. You must specify exactly one class file to execute, and 
the java command assumes you're talking about a .class file, so you don't specify 
the .class extension on the command line. Here's an example:
java -DmyProp=myValue MyClass x 1
Sparing the details for later, this command can be read as "Create a system 
property called myProp and set its value to myValue. Then launch the file named 
MyClass.class and send it two String arguments whose values are x and 1."  
Let's look at system properties and command-line arguments more closely. Using System Properties    
Java has a class called java.util.Properties that can be used to access a 
system's persistent information such as the current versions of  the operating system, 
the Java compiler, and the Java virtual machine. In addition to providing such 
default information, you can also add and retrieve your own properties. Take a look 
at the following:
import java.util.*;
public class TestProps {
  public static void main(String[] args) {
    Properties p = System.getProperties();
    p.setProperty("myProp", "myValue");
    p.list(System.out);
  }
}
If this file is compiled and invoked as follows:
java -DcmdProp=cmdVal TestProps
You'll get something like this:
794 Chapter 10:   Development
... os.name=Mac OS X
myProp=myValue
... java.specification.vendor=Sun Microsystems Inc. user.language=en
java.version=1.6.0_05
... cmdProp=cmdVal
... where the .

--- Chunk #1611 ---
.

--- Chunk #1612 ---
. represent lots of other name=value pairs. (The name and value are 
sometimes called the key and the property.) T wo name=value properties were added 
to the system's properties: myProp=myValue was added via the setProperty 
method, and cmdProp=cmdVal was added via the -D option at the command line. When using the -D option, if your value contains white space the entire value 
should be placed in quotes like this:
java -DcmdProp="cmdVal take 2" TestProps
Just in case you missed it, when you use -D, the name=value pair must follow 
immediately, no spaces allowed. The getProperty() method is used to retrieve a single property. It can be 
invoked with a single argument (a String that represents the name (or key)), or it 
can be invoked with two arguments, (a String that represents the name (or key), 
and a default String value to be used as the property if the property does not already 
exist). In both cases, getProperty() returns the property as a String. Handling Command-Line Arguments    
Let's return to an example of launching an application and passing in arguments 
from the command line. If we have the following code:
public class CmdArgs {
  public static void main(String[] args) {
    int x = 0;
    for(String s : args)
      System.out.println(x++ + " element = " + s);
  }
}
Launching Applications with java (Exam Objective 7.2) 795
796 Chapter 10:   Development
compiled and then invoked as follows
java CmdArgs x 1
the output will be
0 element = x
1 element = 1
Like all arrays, args index is zero based. Arguments on the command line 
directly follow the class name. The first argument is assigned to args[0], the second 
argument is assigned to args[1], and so on. Finally, there is some flexibility in the declaration of the main() method that 
is used to start a Java application. The order of main()'s modifiers can be altered 
a little, the String array doesn't have to be named args, and as of Java 5 it can be 
declared using var-args syntax. The following are all legal declarations for main():
static public void main(String[] args)
public static void main(String... x)
static public void main(String bang_a_gong[])
Searching for Other Classes
In most cases, when we use the java and javac commands, we want these 
commands to search for other classes that will be necessary to complete the 
operation. The most obvious case is when classes we create use classes that Sun 
provides with J2SE (now sometimes called Java SE), for instance when we use classes 
in java.lang or java.util. The next common case is when we want to compile a 
file or run a class that uses other classes that have been created outside of what Sun 
provides, for instance our own previously created classes. Remember that for any 
given class, the java virtual machine will need to find exactly the same supporting 
classes that the javac compiler needed to find at compilation time. In other words, 
if javac needed access to java.util.HashMap then the java command will need 
to find java.util.HashMap as well. Both java and javac use the same basic search algorithm:
1. They both have the same list of places (directories) they search, to look 
for classes. 2. They both search through this list of directories in the same order. 3. As soon as they find the class they're looking for, they stop searching for that 
class. In the case that their search lists contain two or more files with the 
same name, the first file found will be the file that is used. 4. The first place they look is in the directories that contain the classes that 
come standard with J2SE. 5. The second place they look is in the directories defined by classpaths. 6. Classpaths should be thought of as "class search paths." They are lists of 
directories in which classes might be found. 7. There are two places where classpaths can be declared:
A classpath can be declared as an operating system environment variable. The classpath declared here is used by default, whenever java or javac are 
invoked. A classpath can be declared as a command-line option for either java or 
javac. Classpaths declared as command-line options override the classpath declared 
as an environment variable, but they persist only for the length of the invocation. Declaring and Using Classpaths    
Classpaths consist of a variable number of directory locations, separated by 
delimiters. For Unix-based operating systems, forward slashes are used to 
construct directory locations, and the separator is the colon (:). For example:
-classpath /com/foo/acct:/com/foo
specifies two directories in which classes can be found: /com/foo/acct and 
/com/foo. In both cases, these directories are absolutely tied to the root of the file 
system, which is specified by the leading forward slash. It's important to remember 
that when you specify a subdirectory, you're NOT specifying the directories above it. For instance, in the preceding example the directory /com will NOT be searched. Searching for Other Classes (Exam Objective 7.5) 797
798 Chapter 10:   Development
A very common situation occurs in which java or javac complains that it can't 
find a class file, and yet you can see that the file is IN the current directory! When 
searching for class files, the java and javac commands don't search the current 
directory by default. You must tell them to search there. The way to tell java or 
javac to search in the current directory is to add a dot (.) to the classpath:
-classpath /com/foo/acct:/com/foo:. This classpath is identical to the previous one EXCEPT that the dot (.) at the end 
of the declaration instructs java or javac to also search for class files in the current 
directory. (Remember, we're talking about class files—when you're telling javac 
which .java file to compile, javac looks in the current directory by default.)
It's also important to remember that classpaths are searched from left to right. Therefore in a situation where classes with duplicate names are located in several 
different directories in the following classpaths, different results will occur:
-classpath /com:/foo:. is not the same as
-classpath .:/foo:/com
Finally, the java command allows you to abbreviate -classpath with -cp. The 
Java documentation is inconsistent about whether the javac command allows the 
-cp abbreviation. On most machines it does, but there are no guarantees. Most of the path-related questions on the exam will use Unix conventions. If you are a Windows user, your directories will be declared using backslashes (\) and the 
separator character you use will be a semicolon (;). But again, you will NOT need any 
shell-speciﬁ  c knowledge for the exam. Packages and Searching
When you start to put classes into packages, and then start to use classpaths to find 
these classes, things can get tricky. The exam creators knew this, and they tried 
to create an especially devilish set of package/classpath questions with which to 
confound you. Let's start off by reviewing packages. In the following code:
package com.foo;
public class MyClass { public void hi() { } }
We're saying that MyClass is a member of the com.foo package. This means that 
the fully qualified name of the class is now com.foo.MyClass. Once a class is in 
a package, the package part of its fully qualified name is atomic—it can never be 
divided. You can't split it up on the command line, and you can't split it up in an 
import statement. Now let's see how we can use com.foo.MyClass in another class:
package com.foo;
public class MyClass { public void hi() { } }
And in another file:
import com.foo.MyClass;   // either import will work
import com.foo.*;
public class Another {
  void go() {
    MyClass m1 = new MyClass();                  // alias name
    com.foo.MyClass m2 = new com.foo.MyClass();  // full name
    m1.hi();
    m2.hi();
  }
}
It's easy to get confused when you use import statements. The preceding code 
is perfectly legal. The import statement is like an alias for the class's fully qualified 
name. You define the fully qualified name for the class with an import statement (or 
with a wildcard in an import statement of the package). Once you've defined the 
fully qualified name, you can use the "alias" in your code—but the alias is referring 
back to the fully qualified name. Searching for Other Classes (Exam Objective 7.5) 799
800 Chapter 10:   Development
Now that we've reviewed packages, let's take a look at how they work in 
conjunction with classpaths and command lines. First we'll start off with the idea 
that when you're searching for a class using its fully qualified name, that fully 
qualified name relates closely to a specific directory structure. For instance, relative 
to your current directory, the class whose source code is
package com.foo;
public class MyClass { public void hi() { } }
would have to be located here:
com/foo/MyClass.class
In order to find a class in a package, you have to have a directory in your classpath 
that has the package's leftmost entry (the package's "root") as a subdirectory. This is an important concept, so let's look at another example:
import com.wickedlysmart.Utils;
class TestClass {
  void doStuff() {
    Utils u = new Utils();                      // simple name
    u.doX("arg1", "arg2");
    com.wickedlysmart.Date d = 
                new com.wickedlysmart.Date();   // full name
    d.getMonth("Oct");
  }
}
In this case we're using two classes from the package com.wickedlysmart. For 
the sake of discussion we imported the fully qualified name for the Utils class, 
and we didn't for the Date class. The only difference is that because we listed 
Utils in an import statement, we didn't have to type its fully qualified name 
inside the class. In both cases the package is com.wickedlysmart. When it's time 
to compile or run TestClass, the classpath will have to include a directory with 
the following attributes:
■ A subdirectory named com (we'll call this the "package root" directory)
■ A subdirectory in com named wickedlysmart
■ T wo files in wickedlysmart named Utils.class and Date.class
Finally, the directory that has all of these attributes has to be accessible (via a 
classpath) in one of two ways:
 1. The path to the directory must be absolute, in other words, from the root 
     (the  file system root, not the package root). or
 2. The path to the directory has to be correct relative to the current directory. Relative and Absolute Paths    
A classpath is a collection of one or more paths. Each path in a classpath is either 
an absolute path or a relative path. An absolute path in Unix begins with a forward 
slash (/) (on Windows it would be something like c:\). The leading slash indicates 
that this path is starting from the root directory of the system. Because it's starting 
from the root, it doesn't matter what the current directory is—a directory's absolute 
path is always the same. A relative path is one that does NOT start with a slash. Here's 
an example of a full directory structure, and a classpath:
/ (root)
     |
     |--dirA
          |
          |-- dirB
                |
                |--dirC
-cp dirB:dirB/dirC
In this example, dirB and dirB/dirC are relative paths (they don't start with a 
slash /). Both of these relative paths are meaningful only when the current directory 
is dirA. Pop Quiz! If the current directory is dirA, and you're searching for class 
files, and you use the classpath described above, which directories will be searched? dirA? dirB? dirC? Too easy? How about the same question if the current directory is the root (/)? When the current directory is dirA, then dirB and dirC will be searched, but not 
Searching for Other Classes (Exam Objective 7.5) 801
802 Chapter 10:   Development
dirA (remember, we didn't specify the current directory by adding a dot (.) to the 
classpath). When the current directory is root, since dirB is not a direct subdirectory 
of root, no directories will be searched. Okay, how about if the current directory 
is dirB? Again, no directories will be searched! This is because dirB doesn't have 
a subdirectory named dirB. In other words, Java will look in dirB for a directory 
named dirB (which it won't find), without realizing that it's already in dirB. Let's use the same directory structure and a different classpath:
/ (root)
     |
     |--dirA
          |
          |-- dirB
                |
                |--dirC
-cp /dirB:/dirA/dirB/dirC
In this case, what directories will be searched if the current directory is dirA? How about if the current directory is root? How about if the current directory is 
dirB? In this case, both paths in the classpath are absolute. It doesn't matter what 
the current directory is; since absolute paths are specified the search results will 
always be the same. Specifically, only dirC will be searched, regardless of the current 
directory. The first path (/dirB) is invalid since dirB is not a direct subdirectory of 
root, so dirB will never be searched. And, one more time, for emphasis, since dot (.) 
is not in the classpath, the current directory will only be searched if it happens to be 
described elsewhere in the classpath (in this case, dirC). CERTIFICATION OBJECTIVE
JAR Files (Objective 7.5)
7.5 Given the fully-qualified name of a class that is deployed inside and/or outside a JAR 
file, construct the appropriate directory structure for that class. Given a code example and 
a classpath, determine whether the classpath will allow the code to compile successfully. JAR Files and Searching
Once you've built and tested your application, you might want to bundle it up so 
that it's easy to distribute and easy for other people to install. One mechanism that 
Java provides for these purposes is a JAR file. JAR stands for Java Archive. JAR files 
are used to compress data (similar to ZIP files) and to archive data. Here's an application with classes in different packages:
test
   |--UseStuff.java
   |--ws
       |--(create MyJar.jar here) 
       |--myApp
             |--utils
             |      |--Dates.class       (package myApp.utils;)
             |--engine
                    |--rete.class        (package myApp.engine;)
                    |--minmax.class         "          "
You can create a single JAR file that contains all of the files in myApp, and also 
maintains myApp's directory structure. Once this JAR file is created, it can be moved 
from place to place, and from machine to machine, and all of the classes in the JAR 
file can be accessed, via classpaths, by java and javac, without ever unJARing the 
JAR file. Although you won't need to know how to make JAR files for the exam, 
let's make the current directory ws, and then make a JAR file called MyJar.jar:
cd ws
jar -cf MyJar.jar myApp
The jar command will create a JAR file called MyJar.jar and it will contain the 
myApp directory and myApp's entire subdirectory tree and files. You can look at the 
contents of the JAR file with the next command (this isn't on the exam either):
jar -tf MyJar.jar
(which produces something like)
META-INF/
META-INF/MANIFEST.MF
myApp/
myApp/.DS_Store
myApp/utils/
JAR Files and Searching (Exam Objective 7.5) 803
804 Chapter 10:   Development
myApp/utils/Dates.class
myApp/engine/
myApp/engine/rete.class
myApp/engine/minmax.class
Back to exam stuff. Finding a JAR file using a classpath is similar to finding a 
package file in a classpath. The difference is that when you specify a path for a JAR 
file, you must include the name of the JAR file at the end of the path. Let's say you want 
to compile UseStuff.java in the test directory, and UseStuff.java needs access 
to a class contained in myApp.jar. To compile  UseStuff.java say
cd test
javac -classpath ws/myApp.jar UseStuff.java
Compare the use of the JAR file to using a class in a package. If UseStuff.java 
needed to use classes in the myApp.utils package, and the class was not in a JAR, 
you would say
cd test
javac -classpath ws UseStuff.java
Remember when using a classpath, the last directory in the path must be the 
super-directory of the root directory for the package. (In the preceding example, 
myApp is the root directory of the package myApp.utils.) Notice that myApp can be 
the root directory for more than one package (myApp.utils and myApp.engine), 
and the java and javac commands can find what they need across multiple peer 
packages like this. So, if ws is on the classpath and ws is the super-directory of myApp, 
then classes in both the myApp.utils and myApp.engine packages will be found. Here are some rules concerning the structure of JAR ﬁ les:
■ The jar command creates the META-INF directory automatically. ■ The jar command creates the MANIFEST.MF ﬁ le automatically. ■ The jar command won’t place any of your ﬁ  les in META-INF/. ■ As you can see above, the exact tree structure is represented. ■ java and javac will use the JAR like a normal directory tree. Using  .../jre/lib/ext  with JAR files
When you install Java, you end up with a huge directory tree of Java-related 
stuff, including the JAR files that contain the classes that come standard with 
J2SE. As we discussed earlier, java and javac have a list of places that they 
access when searching for class files. Buried deep inside of your Java directory 
tree is a subdirectory tree named jre/lib/ext. If you put JAR files into the ext 
subdirectory, java and javac can find them, and use the class files they contain. You don't have to mention these subdirectories in a classpath statement—searching 
this directory is a function that's built right into Java. Sun recommends, however, 
that you use this feature only for your own internal testing and development, and 
not for software that you intend to distribute. When you use an import statement you are declaring only one package. When you say import java.util.*; you are saying "Use the short name for all of the 
classes in the java.util package."  You’re NOT getting the java.util.jar classes or 
java.util.regex packages! Those packages are totally independent of each other; the 
only thing they share is the same "root" directory, but they are not the same packages. As a corollary, you can’t say import java.*; in the hopes of importing multiple 
packages—just remember, an import statement can import only a single package. It’s possible to create environment variables that provide an alias for long 
classpaths. The classpath for some of the JAR ﬁ  les in J2SE can be quite long, and so it’s 
common for such an alias to be used when deﬁ  ning a classpath. If you see something like 
JAVA_HOME or $JAVA_HOME in an exam question it just means "That part of the absolute 
classpath up to the directories we’re specifying explicitly."  You can assume that the 
JAVA_HOME literal means this, and is pre-pended to the partial classpath you see. JAR Files and Searching (Exam Objective 7.5) 805
806 Chapter 10:   Development
CERTIFICATION OBJECTIVE
Using Static Imports (Exam Objective 7.1)
7.1 Given a code example and a scenario, write code that uses the appropriate access 
modifiers, package declarations, and import statements to interact with (through access or 
inheritance) the code in the example. Note: In Chapter 1 we covered most of what's defined in this objective, but we saved 
static imports for this chapter. Static Imports
We've been using import statements throughout the book. Ultimately, the only 
value import statements have is that they save typing and they can make your code 
easier to read. In Java 5, the import statement was enhanced to provide even greater 
keystroke-reduction capabilities…although some would argue that this comes at the 
expense of readability. This new feature is known as static imports. Static imports can 
be used when you want to use a class's static members. (You can use this feature on 
classes in the API and on your own classes.) Here's a "before and after" example:  
Before static imports:
public class TestStatic {
  public static void main(String[] args) {
    System.out.println(Integer.MAX_VALUE);
    System.out.println(Integer.toHexString(42));
  }
}
After static imports:
import static java.lang.System.out;             // 1
import static java.lang.Integer.*;              // 2 
public class TestStaticImport {
  public static void main(String[] args)  {
    out.println(MAX_VALUE);                     // 3
    out.println(toHexString(42));               // 4
  }
}
Both classes produce the same output:
2147483647
2a
Let's look at what's happening in the code that's using the static import feature:
1. Even though the feature is commonly called "static import" the syntax MUST 
be import static followed by the fully qualified name of the static member 
you want to import, or a wildcard. In this case we're doing a static import on the 
System class out object. 2. In this case we might want to use several of the static members of the 
java.lang.Integer class. This static import statement uses the wildcard to say, 
"I want to do static imports of ALL the static members in this class."
3. Now we're finally seeing the benefit of the static import feature! We didn't have to 
type the System in System.out.println! Wow! Second, we didn't have to type 
the Integer in Integer.MAX_VALUE. So in this line of code we were able to use 
a shortcut for a static method AND a constant. 4. Finally, we do one more shortcut, this time for a method in the Integer class. We've been a little sarcastic about this feature, but we're not the only ones. We're 
not convinced that saving a few keystrokes is worth possibly making the code a little 
harder to read, but enough developers requested it that it was added to the language. Here are a couple of rules for using static imports:
■ You must say import static; you can't say static import. ■ Watch out for ambiguously named static members. For instance, if you do 
a static import for both the Integer class and the Long class, referring to 
MAX_VALUE will cause a compiler error, since both Integer and Long have 
a MAX_VALUE constant, and Java won't know which MAX_VALUE you're refer-
ring to. ■ You can do a static import on static object references, constants (remember 
they're static and final), and static methods. Static Imports (Exam Objective 7.1) 807
808 Chapter 10:   Development
CERTIFICATION SUMMARY
We started by exploring the javac command more deeply. The -d option allows you 
to put class files generated by compilation into whatever directory you want to. The 
-d option lets you specify the destination of newly created class files. Next we talked about some of the options available through the java application 
launcher. We discussed the ordering of the arguments java can take, including 
[options] class [args]. We learned how to query and update system properties 
in code and at the command line using the -D option. The next topic was handling command-line arguments. The key concepts are that 
these arguments are put into a String array, and that the first argument goes into 
array element 0, the second argument into array element 1, and so on. We turned to the important topic of how java and javac search for other 
class files when they need them, and how they use the same algorithm to find 
these classes. There are search locations predefined by Sun, and additional search 
locations, called classpaths that are user defined. The syntax for Unix classpaths is 
different than the syntax for Windows classpaths, and the exam will tend to use 
Unix syntax. The topic of packages came next. Remember that once you put a class into a 
package, its name is atomic—in other words, it can't be split up. There is a tight 
relationship between a class's fully qualified package name and the directory 
structure in which the class resides. JAR files were discussed next. JAR files are used to compress and archive data. They can be used to archive entire directory tree structures into a single JAR file. JAR files can be searched by java and javac. We finished the chapter by discussing a new Java 5 feature, static imports. This is 
a convenience-only feature that reduces keying long names for static members in 
the classes you use in your programs. TWO-MINUTE DRILL
Here are the key points from this chapter. Using javac and java (Objective 7.2)
❑ Use -d to change the destination of a class file when it's first generated by the 
javac command. ❑ The -d option can build package-dependent destination classes on-the-fly if 
the root package directory already exists. ❑ Use the -D option in conjunction with the java command when you want to 
set a system property. ❑ System properties consist of name=value pairs that must be appended directly 
behind the -D, for example, java -Dmyproperty=myvalue. ❑ Command-line arguments are always treated as Strings. ❑ The java command-line argument 1 is put into array element 0, argument 2 
is put into element 1, and so on. Searching with java and javac (Objective 7.5) 
❑ Both java and javac use the same algorithms to search for classes. ❑ Searching begins in the locations that contain the classes that come standard 
with J2SE. ❑ Users can define secondary search locations using classpaths. ❑ Default classpaths can be defined by using OS environment variables. ❑ A classpath can be declared at the command line, and it overrides the default 
classpath. ❑ A single classpath can define many different search locations. ❑ In Unix classpaths, forward slashes ( /) are used to separate the directories 
that make up a path. In Windows, backslashes (\) are used. ✓
T wo-Minute Drill 809
810 Chapter 10:   Development
❑ In Unix, colons (:) are used to separate the paths within a classpath. In Win-
dows, semicolons (;) are used. ❑ In a classpath, to specify the current directory as a search location, use a dot (.)
❑ In a classpath, once a class is found, searching stops, so the order of locations 
to search is important. Packages and Searching (Objective 7.5)
❑ When a class is put into a package, its fully qualified name must be used. ❑ An import statement provides an alias to a class's fully qualified name. ❑ In order for a class to be located, its fully qualified name must have a tight 
relationship with the directory structure in which it resides. ❑ A classpath can contain both relative and absolute paths. ❑ An absolute path starts with a / or a \. ❑ Only the final directory in a given path will be searched. JAR Files (Objective 7.5)
❑ An entire directory tree structure can be archived in a single JAR file. ❑ JAR files can be searched by java and javac. ❑ When you include a JAR file in a classpath, you must include not only the 
directory in which the JAR file is located, but the name of the JAR file too. ❑ For testing purposes, you can put JAR files into .../jre/lib/ext, which is 
somewhere inside the Java directory tree on your machine. Static Imports (Objective 7.1)
❑ You must start a static import statement like this: import static
❑ You can use static imports to create shortcuts for static members (static 
variables, constants, and methods) of any class. SELF TEST
 1.

--- Chunk #1613 ---
Given:
1. // insert code here
2. class StatTest {
3. public static void main(String[] args) {
4. System.out.println(Integer.MAX_VALUE);
5. }
6. }
  Which, inserted independently at line 1, compiles? (Choose all that apply.)
  A. import static java.lang; 
  B. import static java.lang.Integer; 
  C. import static java.lang.Integer.*; 
  D. import static java.lang.Integer.*_VALUE;
  E. import static java.lang.Integer.MAX_VALUE; 
  F. None of the above statements are valid import syntax
 2. Given:
import static java.lang.System.*;
class _ {
  static public void main(String... __A_V_) {
    String $ = "";
    for(int x=0; ++x < __A_V_.length; )
      $ += __A_V_[x];
    out.println($);
  }
}
  And the command line:
java _ - A . What is the result?

--- Chunk #1614 ---
A. -A
  B. A. C.

--- Chunk #1615 ---
-A. Self T est 811
812 Chapter 10:   Development
  D. _A.

--- Chunk #1616 ---
E. _-A. F. Compilation fails
  G. An exception is thrown at runtime
 3. Given the default classpath:
/foo
  And this directory structure:
foo
  |
  test 
     |
     xcom
        |--A.class
        |--B.java
  And these two files:
package xcom;
public class A { }
package xcom;
public class B extends A { }
  Which allows B.java to compile? (Choose all that apply.)
  A. Set the current directory to xcom then invoke
    javac B.java
  B. Set the current directory to xcom then invoke
    javac -classpath . B.java
  C. Set the current directory to test then invoke
    javac -classpath . xcom/B.java
  D. Set the current directory to test then invoke
    javac -classpath xcom B.java
  E. Set the current directory to test then invoke
    javac -classpath xcom:. B.java
 4. Given two files:
a=b.java
c_d.class
  Are in the current directory, which command-line invocation(s) could complete without error? (Choose all that apply.)
  A. java -Da=b c_d
  B. java -D a=b c_d
  C. javac -Da=b c_d
  D. javac -D a=b c_d
 5. If three versions of MyClass.class exist on a file system:
Version 1 is in /foo/bar
Version 2 is in /foo/bar/baz
Version 3 is in /foo/bar/baz/bing
  And the system's classpath includes
/foo/bar/baz
  And this command line is invoked from /foo
java -classpath /foo/bar/baz/bing:/foo/bar MyClass
  Which version will be used by java? A. /foo/MyClass.class
  B. /foo/bar/MyClass.class
  C. /foo/bar/baz/MyClass.class
  D. /foo/bar/baz/bing/MyClass.class
  E. The result is not predictable
Self T est 813
814 Chapter 10:   Development
 6.

--- Chunk #1617 ---
Given two files:
 1. package pkgA;
 2. public class Foo {
 3. int a = 5;
 4. protected int b = 6;
 5. }
 1. package pkgB;
 2. import pkgA.*;
 3. public class Fiz extends Foo {
 4. public static void main(String[] args) {
 5. Foo f = new Foo();
 6. System.out.print("  " + f.a);
 7. System.out.print(" " + f.b);
 8. System.out.print(" " + new Fiz().a);
 9. System.out.println(" " + new Fiz().b);
10. }
11.

--- Chunk #1618 ---
}
  What is the result? (Choose all that apply.)
  A. 5 6 5 6
  B. 5 6 followed by an exception
  C. Compilation fails with an error on line 6
  D. Compilation fails with an error on line 7
  E. Compilation fails with an error on line 8
  F. Compilation fails with an error on line 9
 7. Given:
 3. import java.util.*;
 4. public class Antique {
 5. public static void main(String[] args) {
 6. List<String> myList = new ArrayList<String>();
 7. assert (args.length > 0);
 8. System.out.println("still static");
 9. }
10. }
  Which sets of commands ( javac followed by java) will compile and run without exception or 
error? (Choose all that apply.)
  A. javac Antique.java
java Antique
  B. javac Antique.java
java -ea Antique
  C. javac -source 6 Antique.java
java Antique           
  D. javac -source 1.4 Antique.java
java Antique
  E. javac -source 1.6 Antique.java
java -ea Antique
 8. Given:
 3. import java.util.*; 
 4. public class Values {
 5. public static void main(String[] args) {
 6. Properties p = System.getProperties();
 7. p.setProperty("myProp", "myValue");
 8. System.out.print(p.getProperty("cmdProp") + " ");
 9. System.out.print(p.getProperty("myProp") + " ");
10. System.out.print(p.getProperty("noProp") + " ");
11. p.setProperty("cmdProp", "newValue");
12. System.out.println(p.getProperty("cmdProp"));
13. }
14. }
  And given the command line invocation:
java -DcmdProp=cmdValue Values
  What is the result? A. null myValue null null
  B. cmdValue null null cmdValue
  C. cmdValue null null newValue
  D. cmdValue myValue null cmdValue
  E. cmdValue myValue null newValue
  F. An exception is thrown at runtime
Self T est 815
816 Chapter 10:   Development
 9. Given the following directory structure:
x-|
  |- FindBaz.class
  |
  |- test-| 
          |- Baz.class
          |              
          |- myApp-|
                   |- Baz.class
  And given the contents of the related .java files:
 1. public class FindBaz {
 2. public static void main(String[] args) { new Baz(); }
 3. }
  In the test directory:
 1. public class Baz {
 2. static { System.out.println("test/Baz"); }
 3. }
  In the myApp directory:
 1. public class Baz {
 2. static { System.out.println("myApp/Baz"); }
 3. }
  If the current directory is x, which invocations will produce the output  "test/Baz"? (Choose all that apply.)
  A. java FindBaz 
  B. java -classpath test FindBaz 
  C. java -classpath .:test FindBaz 
  D. java -classpath .:test/myApp FindBaz
  E. java -classpath test:test/myApp FindBaz
  F. java -classpath test:test/myApp:. FindBaz
  G. java -classpath test/myApp:test:. FindBaz
 10. Given the following directory structure:
test-| 
     |- Test.java
     |           
     |- myApp-|
              |- Foo.java
              |
              |- myAppSub-|
                          |- Bar.java
  If the current directory is test, and you create a .jar file by invoking this,
jar -cf MyJar.jar myApp
  then which path names will find a file in the .jar file? (Choose all that apply.)
  A. Foo.java
  B. Test.java
  C. myApp/Foo.java
  D. myApp/Bar.java
  E. META-INF/Foo.java
  F. META-INF/myApp/Foo.java
  G. myApp/myAppSub/Bar.java 
 11. Given the following directory structure:
test-| 
     |- GetJar.java
     |
     |- myApp-|
              |-Foo.java
  And given the contents of GetJar.java and Foo.java:
 3. public class GetJar {
 4. public static void main(String[] args) {
 5. System.out.println(myApp.Foo.d);
 6. }
 7. }
Self T est 817
818 Chapter 10:   Development
 3.

--- Chunk #1619 ---
package myApp;
 4. public class Foo { public static int d = 8; }
  If the current directory is "test", and myApp/Foo.class is placed in a JAR file called MyJar.jar 
located in test, which set(s) of commands will compile GetJar.java and produce the output 8? (Choose all that apply.)
  A. javac -classpath MyJar.jar GetJar.java 
java GetJar
  B. javac MyJar.jar GetJar.java 
java GetJar
  C. javac -classpath MyJar.jar GetJar.java 
java -classpath MyJar.jar GetJar
  D. javac MyJar.jar GetJar.java 
java -classpath MyJar.jar GetJar 
 12. Given the following directory structure:
x-|
  |- GoDeep.class
  |
  |- test-| 
          |- MyJar.jar
          |  
          |- myApp-|
                   |-Foo.java
                   |-Foo.class
  And given the contents of GoDeep.java and Foo.java:
 3. public class GoDeep {
 4. public static void main(String[] args) {
 5. System.out.println(myApp.Foo.d);
 6. }
 7.

--- Chunk #1620 ---
}
 3.

--- Chunk #1621 ---
package myApp;
 4. public class Foo { public static int d = 8; }
  And MyJar.jar contains the following entry:
myApp/Foo.class
  If the current directory is x, which commands will successfully execute GoDeep.class and 
produce the output 8? (Choose all that apply.)
  A. java GoDeep
  B. java -classpath . GoDeep
  C. java -classpath test/MyJar.jar GoDeep
  D. java GoDeep -classpath test/MyJar.jar
  E. java GoDeep -classpath test/MyJar.jar:. F. java -classpath .:test/MyJar.jar GoDeep 
  G. java -classpath test/MyJar.jar:. GoDeep
Self T est 819
SELF TEST ANSWERS
 1. Given:
1. // insert code here
2. class StatTest {
3. public static void main(String[] args) {
4. System.out.println(Integer.MAX_VALUE);
5. }
6. }
  Which, inserted independently at line 1, compiles? (Choose all that apply.)
  A. import static java.lang; 
  B. import static java.lang.Integer; 
  C. import static java.lang.Integer.*; 
  D. import static java.lang.Integer.*_VALUE;
  E. import static java.lang.Integer.MAX_VALUE; 
  F. None of the above statements are valid import syntax
Answer:
   ✓   C and E are correct syntax for static imports. Line 4 isn't making use of static imports, 
so the code will also compile with none of the imports.    A, B, D, and F are incorrect based on the above. (Objective 7.1)
 2. Given:
import static java.lang.System.*;
class _ {
  static public void main(String... __A_V_) {
    String $ = "";
    for(int x=0; ++x < __A_V_.length; )
      $ += __A_V_[x];
    out.println($);
  }
}
820 Chapter 10:   Development
  And the command line:
java _ - A . What is the result?

--- Chunk #1622 ---
A. -A
  B. A. C. -A. D. _A. E. _-A. F. Compilation fails
  G. An exception is thrown at runtime
Answer:
   ✓   B is correct. This question is using valid (but inappropriate and weird) identifiers, static 
imports, var-args in main(), and pre-incrementing logic.     A, C, D, E, F, and G are incorrect based on the above. (Objective 7.2)
 3. Given the default classpath:
/foo
  And this directory structure:
foo
  |
  test 
     |
     xcom
        |--A.class
        |--B.java
  And these two files:
package xcom;
public class A { }
package xcom;
public class B extends A { }
Self T est Answers 821
822 Chapter 10:   Development
  Which allows B.java to compile? (Choose all that apply.)
  A. Set the current directory to xcom then invoke
    javac B.java
  B. Set the current directory to xcom then invoke
    javac -classpath . B.java
  C. Set the current directory to test then invoke
    javac -classpath . xcom/B.java
  D. Set the current directory to test then invoke
    javac -classpath xcom B.java
  E. Set the current directory to test then invoke
    javac -classpath xcom:. B.java
Answer:
   ✓  C is correct. In order for B.java to compile, the compiler first needs to be able to find 
B.java. Once it's found B.java it needs to find A.class. Because A.class is in the 
xcom package the compiler won't find A.class if it's invoked from the xcom directory. Remember that the -classpath isn't looking for B.java, it's looking for whatever classes 
B.java needs (in this case A.class).     A, B, and D are incorrect based on the above. E is incorrect because the compiler can't 
find B.java. (Objective 7.2)
 4. Given two files:
a=b.java
c_d.class
  Are in the current directory, which command-line invocation(s) could complete without error? (Choose all that apply.)
  A. java -Da=b c_d
  B. java -D a=b c_d
  C. javac -Da=b c_d
  D. javac -D a=b c_d
Answer:
   ✓   A is correct. The -D flag is NOT a compiler flag, and the name=value pair that is 
associated with the -D must follow the -D with no spaces.     B, C, and D are incorrect based on the above.

--- Chunk #1623 ---
(Objective 7.2)
 5. If three versions of MyClass.class exist on a file system:
Version 1 is in /foo/bar
Version 2 is in /foo/bar/baz
Version 3 is in /foo/bar/baz/bing
  And the system's classpath includes
/foo/bar/baz
  And this command line is invoked from /foo
java -classpath /foo/bar/baz/bing:/foo/bar MyClass
  Which version will be used by java? A. /foo/MyClass.class
  B. /foo/bar/MyClass.class
  C. /foo/bar/baz/MyClass.class
  D. /foo/bar/baz/bing/MyClass.class
  E. The result is not predictable. Answer:
      D is correct. A -classpath included with a java invocation overrides a system classpath. When java is using any classpath, it reads the classpath from left to right, and uses the 
first match it finds.     A, B, C, and E are incorrect based on the above. (Objective 7.5)
Self T est Answers 823
824 Chapter 10:   Development
 6. Given two files:
 1. package pkgA;
 2. public class Foo {
 3. int a = 5;
 4. protected int b = 6;
 5. }
 1. package pkgB;
 2. import pkgA.*;
 3. public class Fiz extends Foo {
 4. public static void main(String[] args) {
 5. Foo f = new Foo();
 6. System.out.print("  " + f.a);
 7. System.out.print(" " + f.b);
 8. System.out.print(" " + new Fiz().a);
 9. System.out.println(" " + new Fiz().b);
10. }
11.

--- Chunk #1624 ---
}
  What is the result? (Choose all that apply.)
  A. 5 6 5 6
  B. 5 6 followed by an exception
  C. Compilation fails with an error on line 6
  D. Compilation fails with an error on line 7
  E. Compilation fails with an error on line 8
  F. Compilation fails with an error on line 9
Answer:
   ✓   C, D, and E are correct. Variable a (default access) cannot be accessed from outside the 
package. Since variable b is protected, it can be accessed only through inheritance.     A, B, and F are incorrect based on the above. (Objectives 1.1, 7.1)
 7. Given:
 3. import java.util.*;
 4. public class Antique {
 5. public static void main(String[] args) {
 6. List<String> myList = new ArrayList<String>();
 7. assert (args.length > 0);
 8. System.out.println("still static");
 9. }
10. }
  Which sets of commands ( javac followed by java) will compile and run without exception or 
error? (Choose all that apply.)
  A. javac Antique.java
java Antique
  B. javac Antique.java
java -ea Antique
  C. javac -source 6 Antique.java
java Antique           
  D. javac -source 1.4 Antique.java
java Antique
  E. javac -source 1.6 Antique.java
java -ea Antique
Answer:
   ✓   A and C are correct. If assertions (which were first available in Java 1.4) are enabled, an 
AssertionError will be thrown at line 7.     D is incorrect because the code uses generics, and generics weren't introduced until Java 5. B and E are incorrect based on the above. (Objective 7.2)
 8. Given:
 3. import java.util.*; 
 4. public class Values {
 5. public static void main(String[] args) {
 6. Properties p = System.getProperties();
 7. p.setProperty("myProp", "myValue");
 8. System.out.print(p.getProperty("cmdProp") + " ");
 9. System.out.print(p.getProperty("myProp") + " ");
10. System.out.print(p.getProperty("noProp") + " ");
11. p.setProperty("cmdProp", "newValue");
12. System.out.println(p.getProperty("cmdProp"));
13. }
14. }
Self T est Answers 825
826 Chapter 10:   Development
  And given the command line invocation:
java -DcmdProp=cmdValue Values
  What is the result? A. null myValue null null
  B. cmdValue null null cmdValue
  C. cmdValue null null newValue
  D. cmdValue myValue null cmdValue
  E. cmdValue myValue null newValue
  F. An exception is thrown at runtime
Answer:
   ✓   E is correct. System properties can be set at the command line, as indicated correctly in 
the example. System properties can also be set and overridden programmatically.     A, B, C, D, and F are incorrect based on the above.

--- Chunk #1625 ---
(Objective 7.2)
 9. Given the following directory structure:
x-|
  |- FindBaz.class
  |
  |- test-| 
          |- Baz.class
          |              
          |- myApp-|
                   |- Baz.class
  And given the contents of the related .java files:
 1. public class FindBaz {
 2. public static void main(String[] args) { new Baz(); }
 3. }
  In the test directory:
 1. public class Baz {
 2. static { System.out.println("test/Baz"); }
 3. }
  In the myApp directory:
 1. public class Baz {
 2. static { System.out.println("myApp/Baz"); }
 3. }
  If the current directory is x, which invocations will produce the output  "test/Baz"? (Choose 
all that apply.)
  A. java FindBaz 
  B. java -classpath test FindBaz 
  C. java -classpath .:test FindBaz 
  D. java -classpath .:test/myApp FindBaz
  E. java -classpath test:test/myApp FindBaz
  F. java -classpath test:test/myApp:. FindBaz
  G. java -classpath test/myApp:test:. FindBaz
Answer:
   ✓   C and F are correct. The java command must find both FindBaz and the version of 
Baz located in the test directory. The "." finds FindBaz, and "test" must come before 
"test/myApp" or java will find the other version of Baz. Remember the real exam will 
default to using the Unix path separator.     A, B, D, E, and G are incorrect based on the above. (Objective 7.2)
 10. Given the following directory structure:
test-| 
     |- Test.java
     |           
     |- myApp-|
              |- Foo.java
              |
              |- myAppSub-|
                          |- Bar.java
  If the current directory is test, and you create a .jar file by invoking this,
jar -cf MyJar.jar myApp
Self T est Answers 827
828 Chapter 10:   Development
  then which path names will find a file in the .jar file? (Choose all that apply.)
  A. Foo.java
  B. Test.java
  C. myApp/Foo.java
  D. myApp/Bar.java
  E. META-INF/Foo.java
  F. META-INF/myApp/Foo.java
  G. myApp/myAppSub/Bar.java 
Answer:
   ✓   C and G are correct. The files in a .jar file will exist within the same exact directory tree 
structure in which they existed when the .jar was created. Although a .jar file will contain 
a META-INF directory, none of your files will be in it. Finally, if any files exist in the 
directory from which the jar command was invoked, they won’t be included in the 
.jar file by default.    A, B, D, E, and F are incorrect based on the above. (Objective 7.5)
 11. Given the following directory structure:
test-| 
     |- GetJar.java
     |
     |- myApp-|
              |-Foo.java
  And given the contents of GetJar.java and Foo.java:
 3. public class GetJar {
 4. public static void main(String[] args) {
 5. System.out.println(myApp.Foo.d);
 6. }
 7.

--- Chunk #1626 ---
}
 3. package myApp;
 4. public class Foo { public static int d = 8; }
  If the current directory is "test", and myApp/Foo.class is placed in a JAR file called MyJar.jar 
located in test, which set(s) of commands will compile GetJar.java and produce the output 8? (Choose all that apply.)
  A. javac -classpath MyJar.jar GetJar.java 
java GetJar
  B. javac MyJar.jar GetJar.java 
java GetJar
  C. javac -classpath MyJar.jar GetJar.java 
java -classpath MyJar.jar GetJar
  D. javac MyJar.jar GetJar.java 
java -classpath MyJar.jar GetJar 
Answer:
   ✓   A is correct. Given the current directory and where the necessary files are located, these 
are the correct command line statements.     B and D are wrong because javac MyJar.jar GetJar.java is incorrect syntax. C is wrong 
because the -classpath MyJar.java in the java invocation does not include the test directory. (Objective 7.5)
 12. Given the following directory structure:
x-|
  |- GoDeep.class
  |
  |- test-| 
          |- MyJar.jar
          |  
          |- myApp-|
                   |-Foo.java
                   |-Foo.class
  And given the contents of GoDeep.java and Foo.java:
 3. public class GoDeep {
 4. public static void main(String[] args) {
 5. System.out.println(myApp.Foo.d);
 6. }
 7.

--- Chunk #1627 ---
}
 3.

--- Chunk #1628 ---
package myApp;
 4. public class Foo { public static int d = 8; }
Self T est Answers 829
830 Chapter 10:   Development
  And MyJar.jar contains the following entry:
myApp/Foo.class
  If the current directory is x, which commands will successfully execute GoDeep.class and 
produce the output 8? (Choose all that apply.)
  A. java GoDeep
  B. java -classpath . GoDeep
  C. java -classpath test/MyJar.jar GoDeep
  D. java GoDeep -classpath test/MyJar.jar
  E. java GoDeep -classpath test/MyJar.jar:. F. java -classpath .:test/MyJar.jar GoDeep 
  G. java -classpath test/MyJar.jar:. GoDeep
Answer:
   ✓   F and G are correct. The java command must find both GoDeep and Foo, and the 
-classpath option must come before the class name. Note, the current directory 
(.), in the classpath can be searched first or last.     A, B, C, D, and E are incorrect based on the above. (Objective 7.5)
A
About the CD
 
	
832 Appendix A: About the CD
T
he CD-ROM included with this book comes complete with MasterExam and the 
electronic version of the book. The software is easy to install on any Windows 98/
NT/2000/XP/Vista computer and must be installed to access the MasterExam feature. Y ou may, however, browse the electronic book directly from the CD without installation. T o register for a second bonus MasterExam, simply click the Bonus Material link on the Main Page 
and follow the directions to the free online registration. System Requirements
Software requires Windows 98 or higher and Internet Explorer 5.0 or above and 
20 MB of hard disk space for full installation. The Electronic book requires Adobe 
Acrobat Reader. Installing and Running MasterExam
If your computer CD-ROM drive is configured to auto run, the CD will 
automatically start up upon inserting the disk. From the opening screen you 
may install MasterExam by pressing the MasterExam buttons. This will begin 
the installation process and create a program group named “LearnKey.” To run 
MasterExam, choose Start | Programs | LearnKey. If the auto run feature did not 
launch your CD, browse to the CD and click RunInstall. MasterExam
MasterExam provides you with a simulation of the actual exam. The number of 
questions, types of questions, and the time allowed are intended to be an accurate 
representation of the exam environment. You have the option to take an open-book 
exam, including hints, references, and answers; a closed-book exam; or the timed 
MasterExam simulation. When you launch MasterExam, a digital clock display will appear in the upper-
left corner of your screen. The clock will continue to count down to zero unless 
you choose to end the exam before the time expires. To register for a second bonus 
MasterExam, simply click the Bonus Material link on the Main Page and follow the 
directions to the free online registration. Removing Installation(s) 833
Electronic Book
The entire contents of the Study Guide are provided in PDF format. Adobe’s 
Acrobat Reader has been included on the CD. Help
A help file is provided through the Help button on the main page in the lower-
left corner. Individual help features are also available through MasterExam and 
LearnKey’s Online Training. Removing Installation(s)
MasterExam is installed on your hard drive. For best results for removal of programs 
use the Start | Programs | LearnKey | Uninstall options to remove MasterExam. If you want to remove the Real Player, use the Add/Remove Programs icon from 
your Control Panel. You may also remove the LearnKey training program from this 
location. T echnical Support
For questions regarding the technical content of the electronic book, or MasterExam, 
please visit www.osborne.com or e-mail customer.service@mcgraw-hill.com. For 
customers outside the 50 United States, e-mail international_cs@mcgraw-hill.com. LearnKey T echnical Support
For technical problems with the software (installation, operation, removing 
installations), and for questions regarding any LearnKey Online Training content, 
please visit www.learnkey.com or e-mail techsupport@learnkey.com. 			

-- (decrement) operator, 302–303
- (subtraction) operator, 306
! (boolean invert) logical operator, 
309–310
!= (not equal to) operator, 292
% (remainder) operator, 299
& (non-short-circuit AND) operator, 
288, 308
&& (short-circuit AND) operator, 
306, 308, 548
* (multiplication) operator, 308
* quantifier, 495
. (dot) metacharacter, 497
. (dot operator), 25, 27
.java files, 791–792
/ (division) operator, 306
: (colons), 354
; (semicolons), 17, 41, 344–345, 675
? quantifier, 495
@argfiles command-line options, 791
\ (backslashes), 798
^ (exclusive-OR [XOR]) logical 
operator, 288, 309–310, 553
^ (regex carat) operator, 494
{} (curly braces), 329, 332
| (non-short-circuit OR) operator, 
288, 308
|| (short-circuit OR) operator, 
306, 308
+ (addition) operator, 288, 299, 307
+ quantifier, 495
++ (increment) operator, 302–303
+= (compound additive operator), 301
<? extends Animal> syntax, 618
<? super ...> syntax, 619
<> (angle brackets), 600
<?> wildcard, 620
<E> placeholder, 622
<Integer> type, 602
<JButton> type, 608
<Object> type, 600
<X> type declaration, 629
= (assignment) operators
assigning one primitive variable 
to another, 198
compound, 197, 289–290
floating-point numbers, 196
literals too large for variable, 
196–197
overview, 190–191, 288–289
primitive casting, 193–195
primitive variables, 191–193
reference variable, 198–200
variable scope, 200–202
== (equals) operator, 245–246, 
292–294, 544
A
absolute paths, 801–802
abstract classes, 16–19, 20
abstract keyword, 15
abstract methods, 41–45
access control
class access, 13
default access, 13–14, 32–34, 
36–38
defined, 12
local variables, 38–39
modifiers, 24–26
private members, 29–32
protected members, 32–36
public access, 14–15, 26–29
access modifiers
declaring class members
default, 32–34, 36–38
local variables and, 38–39
overview, 24–26
private, 29–32
protected, 32–36
public, 26–29
defined, 12
method-local inner class, 682
add( ) method, 581, 620
addAll( ) method, 601, 603
addAnimals( ) method, 616–617
addition (+) operator, 288, 299, 307
addJob( ) method, 754–755
AND operators
& non-short-circuit, 288, 308
&& short-circuit, 306, 308, 548
angle brackets (<>), 600
animate( ) method, 102
anonymous arrays, 228–230
anonymous inner classes
argument-defined, 678–680
overview, 673–678
anotherObject object, 749
append( ) method, 440
applications, launching with java 
command, 793–796
appropriate use of assertions, 392–394
arg_index format string element, 507
args index, 796
arguments. See also var-args
anonymous inner classes defined 
by, 678–680
command-line, 393, 795–796
constructor, 238, 628
defined, 46
final, 41
just-in-time array, 229–230
using assertions to validate, 
392–393
arithmetic operators
decrement, 302–303
increment, 302–303
overview, 298
remainder, 299
string concatenation, 299–301
ArrayIndexOutOfBoundsException 
subclass, 224, 368, 382
INDEX
 
	
836 SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
ArrayList class
basics, 567–568
Collection Interface Concrete 
Implementation, 565
List interface implementation, 562
mixing generic and non-generic 
collections, 601–607
of Strings, 596
arrays
constructing
anonymous, 228–230
multidimensional, 223
on one line, 226–228
one-dimensional, 221–222
overview, 220–221
declarations, 55–57, 219–220, 
226–228
enhanced for loop for, 350–352
initialization blocks, 234–237
initializing
and constructing anonymous, 
228–230
declaring, and constructing on 
one line, 226–228
elements in loop, 225–226
legal element assignments, 230
multidimensional, 233–234
of object references, 231–232
one-dimensional, 232–233
overview, 224–225
primitive, 230–231
reference assignments for one-
dimensional, 232–234
instance variables, 206
length attribute, 437
as objects, 297
primitive, 230–231
returning values, 128
shortcut syntax, 226–228
use of brackets, 56
Arrays class
asList ( ) method, 579
collections, 576
converting to Lists, 579
key methods, 593
searching, 576–578
sort( ) method, 576
asList ( ) method, 579
assert statements, 386–389, 394
AssertionError subtype, 375, 381–382, 
385, 393
assertions
appropriate use of, 392–394
disabling
at runtime, 390
selective, 390–391
enabling
compiling assertion-aware 
code, 388–389
identifiers versus keywords, 
387–388
at runtime, 389
selective, 390–391
expression rules, 385–387
overview, 328, 383–385
assignment (=) operators
assigning one primitive variable 
to another, 198
compound, 197, 289–290
floating-point numbers, 196
literals too large for variable, 
196–197
overview, 190–191, 288–289
primitive casting, 193–195
primitive variables, 191–193
reference variable, 198–200
variable scope, 200–202
assignments. See also arrays; garbage 
collection; wrappers
assignment operators
assigning one primitive 
variable to another, 198
floating-point numbers, 196
literals too large for variable, 
196–197
overview, 190–191
primitive casting, 193–195
primitive variables, 191–193
reference variable, 198–200
variable scope, 200–202
autoboxing
equals( ) method, 245–246
equals operator, 245–246
overview, 244–245
use of, 246–247
heap, 184–185
literal values for primitive types
boolean, 189
character, 189–190
floating-point, 188–189
integer, 186–188
overview, 186
string, 190
local variables
array references, 210
assigning one reference 
variable to another, 210–213
object references, 209–210
overview, 207
primitives, 207–209
overloading
with boxing and var-args, 
249–250
in combination with var-args, 
253–254
overview, 247–249
when combining widening 
and boxing, 251–253
widening reference variables, 
250–251
passing variables into methods
object reference variables, 
213–214
overview, 213
pass-by-value semantics, 
214–215
primitive variables, 215–218
stack, 184–185
uninitialized variables
array, 206
object reference, 203–206
overview, 203
primitive, 203–204
atomic operations, 733–735
autoboxing
with collections, 568
equals( ) method, 245–246
equals operator, 245–246
overloading
with var-args and, 249–250
when combining widening 
and, 252–253
overview, 244–245
in switch statements, 337
use of, 246–247
automatic variables, 207. See also 
local variables
Index 837
B
backed collections
key methods, 593–595
overview, 589–591
using PriorityQueue class, 591–592
backslashes (\), 798
bar( ) method, 215
Bar object, 199, 679
behavior, 2. See also methods
binarySearch( ) method, 576
bitwise operators, 305
block variables, 201
blocked threads, 719–720
boolean add(element) interface 
method, 594
boolean containsKey(object key) 
interface method, 594
boolean contains(object) interface 
method, 594
boolean containsValue(object value) 
interface method, 594
boolean createNewFile( ) method, 446
boolean equals (Object obj) method, 543
boolean exists( ) method, 446
boolean hasNext( ) method, 580
boolean invert (!) logical operator, 
309–310
Boolean wrapper, 239
booleans
arguments in backed collections, 
590–591
assigning versus testing, 334
literals, 189
for loops, 346–347
and relational operators, 290–291
boxing
equals( ) method, 245–246
equals operator, 245–246
overloading
with var-args and, 249–250
when combining widening 
and, 252–253
overview, 244–245
in switch statements, 337
use of, 246–247
brackets, array, 56
branching, if-else, 329–332
break statements
labeled, 354–356
in switch blocks, 338–340
switch statements, 335
unlabeled, 353–354
use of, 352–353
BufferedReader class, 443
BufferedWriter class, 444
byte variables, 192
C
Calculator class, 754
Calendar class, 477–479
call stack
constructors on, 133
overloaded constructors on, 141
propagating uncaught exceptions, 
362–363
unwinding, 367
camelCase format, 7–8
can’t-be-overridden restriction, 40
carat (^) operator, 494
case constants
default, 341–342
evaluation of, 338
legal expressions for, 335–338
casting
primitive, 193–195
reference variables, 116–119
catch clauses, 357–359, 362
catch keyword, 357–359
ceiling( ) method, 587
ceilingKey( ) method, 587
chained methods, 442
chaining
combining I/O classes, 449–452
constructors, 132–133
changeNum( ) method, 470
changeSize( ) method, 110
character literals, 189–190
characters, Unicode, 51, 189, 426–427
charAt( ) method, 435
ChatClient class, 663–664
checked exceptions, 373–375
checkup( ) method, 608
class files, 791–794, 805
class literals, 738
ClassCastException class, 382, 547
classes. See also dates; exceptions; 
individual classes by name; inner 
classes; member declarations
cohesion, 3, 151–154
collections, 557–561
combining, 449–452
declaration
abstract classes, 16–19
class access, 13
default access, 13–14
final classes, 15–16
modifiers, 12–13, 15
overview, 10–11
public access, 13–15
source file rules, 11–12
defined, 2
File, 443, 445–447
finding other, 3–4
generic, 623–627
interfaces
implementing, 122
relationship with, 20
naming standards, 7
searching for
classpaths, 797–798
overview, 796–797
packages, 799–801
relative and absolute paths, 
801–802
thread-safe, 742–744
wrapper, 237–238
classes directory, 791–793
-classpath option, javac command, 
790–791, 794, 798
classpaths, 797–798, 808
close( ) method, 448–449
cmdProp=cmdVal property, 795
cohesion, 3, 151–154
Collection classes, 56
Collection interface, 557–559
collections. See also generics; 
hashCode( ) method
ArrayList basics, 567–568
autoboxing with, 568
backed
key methods, 593–595
overview, 589–591
using PriorityQueue class, 
591–592
classes, 557–561
converting arrays to Lists to 
arrays, 579
interfaces
List, 561–562
Map, 563–564
overview, 557–561
838 SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
collections. See also generics; 
hashCode( ) method (Cont.)
Queue, 564–566
Set, 562–563
legacy code, 597–600
Lists, 580–581
Maps, 583–586
mixing generic and non-generic, 
601–607
overriding Object methods
equals( ), 544–549
overview, 542
toString( ), 542–544
overview, 556–557
searching
arrays and, 576–578
TreeSets and TreeMaps, 
586–588
Sets, 581–583
sorting
Arrays class, 576
Comparable interface, 571–573
Comparator interface, 574–575
overview, 569–571
Collections class, 593
Collections Framework, 556
Collections.sort( ) method, 571, 
573–574, 576
Collections.synchronizedList( ) 
method, 743–744
colons (:), 354
combining I/O classes, 449–452
command-line arguments, 393, 795–796
commands
jar, 803–804
java command, 793–796
javac
assertion-aware code, 388–389
compiling with, 790–793
constructor code generated 
by, 137
failures, 350
JAR files, 804
warnings, 603
searching for other classes with
classpaths, 797–798
overview, 796–797
packages, 799–801
relative and absolute paths, 
801–802
Comparable interface, 561, 566, 
571–573
Comparator interface, 561, 574–575, 592
compare( ) method, 574
compareTo( ) method, 571–574
compiler
assertion-aware code, 388–389
constructor code generated by, 137
failures, 350
JAR files, 804
javac command, 790–793
searching for other classes
classpaths, 797–798
overview, 796–797
packages, 799–801
relative and absolute paths, 
801–802
warnings, 603
compound additive operator (+=), 301
compound assignment operators, 197, 
289–290
concat( ) method, 435–436
concatenation operator, string, 
299–301
concrete classes, 42–44
conditional expressions, 346–347
conditional operators, 304–305
consistency of equals( ) method, 549
constant pool, String, 434
constant specific class bodies, 63, 65
constants
case
default, 341–342
evaluation of, 338
legal expressions for, 335–338
declaring interface, 22–23
enums, 63
MAX_VALUE, 807
values, 23
constructing arrays, 220–223
constructor arguments, 238, 628
constructors
chaining, 132–133
code causing to run, 222
compiler-generated, 137
declarations
in enums, 63–65
overview, 47–48
default, 135–139
overloaded, 139–145
overview, 130–132
rules for, 133–134
super, 136–139
wrapper, 239
continue statements
labeled, 354–356
overview, 352–353
unlabeled, 353–354
contracts
equals( ) method, 549
hashCode( ) method, 554–556
conversion format string element, 508
conversion utilities, wrapper
parseXxx( ) methods, 241
toString( ) method, 242
toXxxString( ) method, 
242–243
valueOf( ) method, 241
xxxValue( ) methods, 240–241
copying reference variables, 213
correct use of assertions, 392–394
coupling, 151–153
covariant returns, 127–128
-cp abbreviation, java command, 798
CreateAnArrayList class, 628
curly braces ({}), 329, 332
currencies, 473–474, 482–487
-d option, javac command, 790–793
-D option, system properties, 
794–795
D
daemon threads, 704
DataInputStream class, 473
DataOutputStream class, 473
Date class, 476–477
DateFormat class, 480–481, 484
dates
Calendar class, 477–479
Date class, 476–477
DateFormat class, 480–481
Locale class, 482–485
orchestrating classes related to, 
474–475
overview, 473–474
dead thread state, 716, 720
deadlocks, thread, 745–746
“Deadly Diamond of Death” 
scenario, 100
Index 839
decimal literals, 186
decision statements
if
if-else branching, 329–332
legal expressions for, 332–334
overview, 328
switch
break statement in, 335, 
338–340
default case, 341–342
fall-through in, 338–340
legal expressions for, 335–338
overview, 328, 334–335
declaration
access modifiers
default, 32–34, 36–38
local variables and, 38–39
overview, 24–26
private, 29–32
protected, 32–36
public, 26–29
array, 219–220, 226–228
class
abstract, 16–19
access, 13
default access, 13–14
final, 15–16
modifiers, 12–13, 15
overview, 10–11
public access, 13–15
source file rules, 11–12
classpath, 797–798
constructor, 47–48
enum
constructors, methods, and 
variables in, 63–65
overview, 60–63
exception, 371–376
generics
classes, 623–627
methods, 627–630
overview, 622–623
interface
constants, 22–23
overview, 19–22
for loop, 346, 351
nonaccess modifiers
abstract methods, 41–45
final arguments, 41
final methods, 40
methods with var-args, 
46–47
native methods, 46
overview, 39
strictfp methods, 46
synchronized methods, 45
var-arg rule, 47
variable
array, 55–57
in enums, 63–65
final, 57–58
generics and polymorphism, 608
instance, 51–53
local, 53–55
overview, 49
primitive, 49–51
reference, 51
static, 59–60
transient, 59
volatile, 59
declared return types, 129
decoupling reference variables, 258
decrement (--) operator, 302–303
default access classes, 13–14
default access control type, 24
default constructors, 135–139
default hashcode method, 552
default keyword, 341–343
default members, 32–34, 36–38
default primitive and reference type 
values, 203
default priority, thread, 725
defining threads, 705–706
delete( ) method, 440–441
delimiters, 502
descending order, 588
development
compiling with javac command, 
790–793
Java Archive files, 802–805
launching applications with java 
command, 793–796
overview, 789–790
searching for other classes
classpaths, 797–798
overview, 796–797
packages, 799–801
relative and absolute paths, 
801–802
static imports, 806–807
direct subdirectories, 802
directories
classpaths, 797–798
javac command, 791–793
META-INF , 804
myApp, 803
relative and absolute paths, 
801–802
root, 804
source, 792
working with files and, 452–457
disabling assertions
at runtime, 390
selective, 390–391
division (/) operator, 306
do loops, 344–345
doInsert( ) method, 620
doStuff( ) method, 114, 215, 670, 679
dot (.) metacharacter, 497
dot operator (.), 25, 27
downcasting, 117–118
E
early loop termination, 348
else if statement, 330–331
else statement, 329–332
enabling assertions
compiling assertion-aware code, 
388–389
identifiers versus keywords, 
387–388
javac, 388
at runtime, 389
selective, 390–391
encapsulation, 86–89
enclosing class, 682
engines, regex, 488
enhanced for loops, 350–352
entry points, 338
enums
declaring constructors, methods, 
and variables in, 63–65
equality operators for, 294–295
maps, 584
overview, 60–63
EOFException subclass, 370, 373
equal (=) sign, 191
equal to (==) operator, 245–246, 
292–294, 544
840 SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
equality operators
for enums, 294–295
overview, 292
for primitives, 292–293
for reference variables, 293–294
equals (==) operator, 245–246, 
292–294, 544
equals( ) method
collections, 562–563
hashCode( ), 548–549
hashcodes, 586
inheritance, 91
maps, 583
overriding, 544–549
wrappers, 245–246
equalsIgnoreCase( ) method, 435–436
equals(java.lang.Object) method, 554
equals(Object) method, 554
Error class, 366–368, 373–375
error detection and handling. See exceptions
errors, scoping, 201–202
escape codes, 190, 498
events, 9
Exception class, 366–368, 374
ExceptionInInitializerError, 382
exceptions
catch keyword, 357–359
checked, 373–375
declaration and public interface, 
371–376
defined, 357, 365–366
finally block, 359–362
hierarchy of, 366–369
JVM thrown, 379–380
matching, 369–371
overview, 328, 356–357
programmatic
defined, 379
list of, 382
programmatically thrown, 380–381
propagating uncaught, 362–365
rethrowing same, 376–378
try keyword, 357–359
unchecked, 373, 375
exclusive-OR (XOR) logical operator, 
288, 309–310, 553
execution, threads of, 702, 709, 757
existingDir subdirectory, 454
explicit casts, 193, 197
expressions
assertions, 385–387
for case constant, 335–338
conditional, 346–347
for if statements, 332–334
iteration, 347–348
for statement, 351
for switch statements, 335–338
extends keyword
generic methods, 618
interfaces, 122–124
java.lang.Thread, 705–706
F
fall-through in switch blocks, 338–340
FIFO (first-in, first-out), 564
File class, 443, 445–447
file navigation
combining I/O classes, 449–452
creating files using class File, 
445–447
directories, 452–457
FileWriter and FileReader classes, 
447–449
overview, 443–445
FileNotFoundException subclass, 
370–371
FileReader class, 443, 447–449
FileWriter class, 444, 447–449
final arguments, 41
final classes, 15–16
final keyword, 15, 40
final methods, 40, 103
final variables, 57–58, 303, 336
final void notify( ) method, 543
final void notifyAll( ) method, 543
final void wait( ) method, 543
finalize( ) method, 263, 542
finally clause, 359–362
find( ) method, 499
first-in, first-out (FIFO), 564
flags, 507
floating points, 15, 46, 188–189
floor( ) method, 587
floorKey( ) method, 587
flow control
assertions
enabling, 387–391
expression rules, 385–387
overview, 383–385
using appropriately, 392–394
exceptions
catch keyword, 357–359
declaration of, 371–376
defined, 365–366
finally block, 359–362
hierarchy of, 366–369
JVM thrown, 379–380
matching, 369–371
overview, 356–357
programmatically thrown, 
380–381
propagating uncaught, 362–365
public interface and, 371–376
rethrowing same, 376–378
try keyword, 357–359
if statements
if-else branching, 329–334
legal expressions for, 332–334
overview, 328
loops
break statement, 352–353
continue statement, 352–353
do, 344–345
for, 345–352
labeled statements, 354–356
unlabeled statements, 353–354
while, 343–344
overview, 327–328
switch statements
break statement in, 338–340
default case, 341–342
fall-through in, 338–340
legal expressions for, 335–338
overview, 328, 334–335
flush( ) method, 448–449
Foo class
argument-defined anonymous 
inner classes, 679–680
compiler-generated constructor 
code, 137
natural order in, 561
overloaded methods, 114
reference variable assignments, 199
shadowing instance variables, 
217–218
for loops
conditional expressions, 346–347
declaration, 346
Index 841
enhanced, 350–352
initialization, 208, 346
issues with, 348–350
iteration expressions, 347–348
legacy collections, 598
overview, 345–346
PriorityQueue class, 592
threads, 714
forced exits, 347–348
forcing garbage collection, 260–262
for-each. See for loops
for-in. See for loops
format( ) method, 506–508
formatting
dates and numbers
Calendar class, 477–479
Date class, 476–477
DateFormat class, 480–481
Locale class, 482–485
NumberFormat class, 485–487
orchestrating classes, 474–475
overview, 473
tokenizing
and delimiters, 502
format( ) method, 506–508
overview, 501–502
printf( ) method, 506–508
Scanner class, 504–506
String.split( ) method, 
502–504
G
garbage collection
code making objects eligible for
finalize( ) method, 263
forcing, 260–262
isolating references, 259–260
nulling references, 257–258
overview, 257
reassigning reference variables, 
258–259
in Java, 255–257
memory management and, 
254–255
generics
declaring
classes, 623–627
methods, 627–630
overview, 622–623
legacy code, 597–600
methods, 609–622
mixing with non-generic 
collections, 601–607
overview, 541–542, 595–597
polymorphism and, 607–609
get( ) method, 581, 584, 586, 599, 606
getDateInstance( ) method, 480–481
getInstance( ) method, 477, 480
getName( ) method, 710–711
getProperty( ) method, 795
getState( ) method, 708
getter methods, 8–9, 88
greedy quantifiers, 495–497
group( ) method, 499
H
HardToRead class, 543
HAS-A relationships, 96–98
hashCode( ) method
equals( ) method, 548–549
HashSet, 562
Maps, 583
overriding
contract, 554–556
implementing, 552–554
overview, 549–552
real-life hashing, 551
HashMap class
Collection interface, 557, 565
collections, 566
hashCode( ) method, 555–556
LinkedHashMap, 564
Map interface implementation, 563
overriding equals( ), 545
use of, 583
HashSet class, 562, 565
Hashtable class, 557, 560, 564–565
headMap( ) method, 590
headSet( ) method, 590
heap, 220–221, 255
hexadecimal literals, 187–188
hierarchy of exceptions, 366–369
high cohesion, 152–153
higher( ) method, 587
higherKey( ) method, 587
higher-level classes, 460
highest-priority threads, 724
I
IDE (Integrated Development 
Environment) tool, 8
identifiers
versus keywords, 387–388
legal, 5–6
Map interface, 563
overview, 2–4
IEEE 754 standard, 15
if statements
if-else branching, 329–332
initialization, 208
legal expressions for, 332–334
overview, 328
illegal overrides, 109, 114
IllegalArgumentException, 
381–382, 393
IllegalMonitorStateException, 
749–750
IllegalStateException, 382
immutability of strings, 426–433
implementation classes, 121–122, 
560, 680
implementers, interface, 677–678
implementing
equals( ) method, 546–549
hashCode( ) method, 552–554
interfaces, 120–125
java.lang.Runnable, 706
implicit casts, 193
import statements, 3–4, 11, 799–800, 
805–806
imports, static, 806–807
increment (++) operator, 302–303
increment expression, 350
indenting, 331–332
indexOf( ) method, 561, 581
IndexOutOfBoundsException, 368
indirect implementations, 296
inheritance
versus dot operator for member 
access, 27
HAS-A relationship, 96–98
IS-A relationship, 94–95
overview, 3, 90–94
and serialization, 468–472
and subclasses, 25–26
initialization blocks, 234–237
842 SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
initializing
arrays
anonymous, 228–230
elements in loop, 225–226
legal element assignments, 230
multidimensional, 233–234
of object references, 231–232
on one line, 226–228
one-dimensional, 232–233
overview, 224–225
primitive, 230–231
reference assignments for 
one-dimensional, 232–234
local variables, 54
for loops, 346
inner classes
anonymous
argument-defined, 678–680
overview, 673–678
coding regular, 664–668
instances, 664, 682
method-local, 670–672
overview, 661–664
referencing inner or outer instance 
from within, 668–670
static nested classes, 680–681
insert( ) method, 441, 602–603
insertion points, 576
instance methods, 102
instance variables
array, 206
defined, 51–53
hashCode( ) method, 552–553
object reference, 203–206
primitive, 203–204
protecting, 31
scope of, 201
uninitialized
array, 206
object reference, 203–206
overview, 203
primitive, 203–204
instanceof operator
compiler error, 297–298
equals( ) method, 547
inheritance, 90
IS-A relationship, 233
overview, 295–298
instances
initialization blocks, 234–235, 237
for java.text and java.util 
classes, 487
static nested classes, 680
instantiating
constructors
chaining, 132–133
default, 135–139
overloaded, 139–145
overview, 130–132
rules for, 133–134
inner classes, 666–668
outer class, 667
static nested classes, 681
threads, 706–708
int hashCode( ) method, 543
int indexOf(object) interface 
method, 594
int size( ) interface method, 594
int variable, 192
Integer class, 242, 807
integer literals
decimal, 186
hexadecimal, 187–188
octal, 187
Integrated Development Environment 
(IDE) tool, 8
interactions, thread
notifyAll( ), 752–757
overview, 746–751
interfaces
as array types, 231
collections
List, 561–562
Map, 563–564
overview, 557–561
Queue, 564–566
Set, 562–563
declaring
constants, 22–23
overview, 19–22
implementers, 677–678
implementing, 120–125
naming standards, 7
overview, 3
relationship with classes, 20
invoking
overloaded methods, 111–113
superclass version of overridden 
methods, 107–108
I/O
class File, 445–447
combining classes, 449–452
FileReader, 447–449
files and directories, 452–457
FileWriter, 447–449
java.io.Console class, 457–459
overview, 443–459
IOException class, 370–371, 373
IS-A relationship, 94–95, 233, 251, 547
isAlive( ) method, 40, 708
isEmpty( ) method, 755
islands of isolation, 259
isolating references, 259–260
iteration
defined, 560
expressions and for loops, 347–348
Iterators, 580, 594
J
JAR (Java Archive) files, 802–805, 808
jar command, 803–804
Java 6 compiler. See javac command
Java Archive (JAR) files, 802–805, 808
Java Code Conventions, 4, 6–8
java command
launching applications with, 
793–796
searching for other classes
classpaths, 797–798
overview, 796–797
packages, 799–801
relative and absolute paths, 
801–802
Java Virtual Machine (JVM)
exceptions, 379–380, 382
thread scheduler, 716
JavaBeans standards, 4, 8–10
javac command
assertion-aware code, 388–389
compiling with, 790–793
constructor code generated by, 137
failures, 350
Index 843
JAR files, 804
searching for other classes
classpaths, 797–798
overview, 796–797
packages, 799–801
relative and absolute paths, 
801–802
warnings, 603
java.io Mini API, 450
java.io.Console class, 457–459
java.lang.Class instances, 737
java.lang.Enum class, 584
java.lang.Object class, 718
java.lang.Runnable interface, 706
java.lang.Thread class, 705–706, 717
java.text class, 487
java.text.DateFormat, 474
java.text.NumberFormat, 474
java.util class, 487, 796
java.util package, 566, 805
java.util.ArrayList class, 567
java.util.Calendar, 474
java.util.Collections class, 558, 569
java.util.Date class, 474
java.util.HashMap class, 796
java.util.jar package, 805
java.util.Locale, 474
java.util.NavigableMap interface, 586
java.util.NavigableSet interface, 586
java.util.Properties class, 794
java.util.regex package, 805
java.utils.Arrays.sort( ) method, 571
JButton class, 608
jobs list, 755–756
join( ) method, 716–717, 726–728
jre/lib/ext subdirectory tree, 805
just-in-time array arguments, 229–230
JVM (Java Virtual Machine)
exceptions, 379–380, 382
thread scheduler, 716
K
keys, 795
keywords
abstract, 15
catch, 357–359
chart, 6
default, 341–343
extends
generic methods, 618
interfaces, 122–124
java.lang.Thread, 705–706
final, 15, 40
versus identifiers, 387–388
new, 222
overview, 3
strictfp, 15, 46
super, 619
throw, 367
try
exceptions, 357–359
with finally block, 359–361
wait( ) method, 750
without catch block, 361
without finally block, 361
L
labeled statements, 354–356
launching applications with java 
command, 793–796
legacy code, 597–602
legal array element assignments, 230
legal expressions
for case constant, 335–338
for if statements, 332–334
for switch statements, 335–338
legal identifiers, 4
legal overloaded methods, 110
legal overridden methods, 109
legal return types
covariant, 127–128
on overloaded methods, 126–127
on overridden methods, 127–128
returning values, 128–130
length attributes, array, 437
length( ) method, 435–436
length variable, 225–226
LinkedHashMap class, 557, 564–566
LinkedHashSet class, 560, 563, 565
LinkedList class, 562, 564–565, 580
List class, 608
List interface
collections, 561–562
in Collections Framework, 557
converting to arrays, 579
generic declarations, 622
key methods, 594–595
use of, 580–581
List<?> syntax, 620
List<Integer> syntax, 621
List<Object> syntax, 620–621
list.add( ) method, 620
listeners, 9
lists, enumerated. See enums
literals
boolean, 189
character, 189–190
floating-point, 188–189
integer
decimal, 186
hexadecimal, 187–188
octal, 187
string, 190, 434
live objects, 257
local arrays, 210
local object references, 209–210
local primitives, 207–209
local variables
access member modifiers and, 
38–39
array references, 210
assigning one reference variable to 
another, 210–213
defined, 53–55
inner classes, 671
object references, 209–210
overview, 207
primitives, 207–209
scope of, 201
uninitialized, 203
Locale class, 482–485
locks, 735–737, 739–740
logical operators
bitwise, 305
boolean invert, 309–310
non-short-circuit, 308–309
short-circuit, 306–308
XOR, 309–310
Long class, 242, 807
loops
break statement, 352–353
continue statement, 352–353
844 SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
loops (Cont.)
do, 344–345
for
conditional expression, 346–347
declaration, 346
enhanced, 350–352
initialization, 346
issues with, 348–350
iteration expression, 347–348
legacy collections, 598
overview, 345–346
PriorityQueue class, 592
threads, 714
initializing elements in, 225–226
labeled statements, 354–356
unlabeled statements, 353–354
wait( ) in, 753–757
while, 343–344
loose coupling, 152
lower( ) method, 587
lowerKey( ) method, 587
lower-level classes, 460
lower-priority threads, 724
M
Machine class, 754
main( ) method, 546, 665, 702, 710, 713
makeArrayList( ) method, 627
makeInner( ) method, 666
makeWithdrawal( ) method, 734
MANIFEST.MF file, 804
Map interface
collections, 563–564
key methods, 594–595
use of, 583–586
MapTest.main( ) method, 585
marker interfaces, 461, 562
Matcher class, 498–501
matching, exception, 369–371
MAX_VALUE constant, 807
meaningfully equivalent instances, 
245–246
Meeks, Jonathan, 97
member classes, 662
member declarations
access modifiers
default members, 32–34, 
36–38
local variables and, 38–39
overview, 24–26
private members, 29–32
protected members, 32–36
public members, 26–29
constructor, 47–48
enum
constructors, methods, and 
variables in, 63–65
overview, 60–63
nonaccess modifiers
abstract methods, 41–45
final arguments, 41
final methods, 40
methods with var-args, 46–47
native methods, 46
overview, 39
strictfp methods, 46
synchronized methods, 45
variable
array, 55–57
final, 57–58
instance, 51–53
local, 53–55
overview, 49
primitive, 49–51
reference, 51
static, 59–60
transient, 59
volatile, 59
visibility and access, 39
member methods, 662
member modifiers applied to inner 
classes, 670
member variables, 662.

--- Chunk #1629 ---
See also 
instance variables
memory
garbage collection, 257
management and garbage 
collection, 254–255
and String class, 433–434
metacharacters
and searches, 490–492
and strings, 497–498
META-INF directory, 804
method-local inner classes, 670–672
methods. See also hashCode( ) method; 
individual methods by name
backed collections, 593–595
chained, 442
comparison of modifiers on, 53
declarations, 41
declaring in enums, 63–65
defined, 2
effects of static on, 150
generic, 609–622, 627–630
in interfaces, 20–21
JavaBean signatures for, 10
naming standards, 7
overriding Object
equals( ), 544–549
toString( ), 542–544
overriding rules, 106–107
passing variables into
object reference, 213–214
overview, 213
pass-by-value semantics, 
214–215
primitive, 215–218
String class, 434–438
StringBuffer, 440–442
StringBuilder, 440–442
synchronizing static, 737–739
thread scheduler, 717–718
with var-args, 46–47
mkdir( ) method, 453
modifiers. See also individual modifiers 
by name
applied to inner classes, 670
class access
default, 13–14
public, 14–15
class nonaccess
abstract, 16–19
final, 15–16
member access
default members, 32–34, 
36–38
local variables and, 38–39
overview, 24–26
private members, 29–32
protected members, 32–36
public members, 26–29
member nonaccess
abstract methods, 41–45
final arguments, 41
final methods, 40
methods with var-args, 46–47
native methods, 46
overview, 39
strictfp methods, 46
synchronized methods, 45
overview, 12–13
variables and methods, 53
Index 845
Moof class, 546
moofValue instance variable, 546–547
multidimensional arrays, 57, 223, 
233–234
multiple inheritance, 100
multiplication (*) operator, 308
multithreading, 702, 713–716
myApp directory, 803
myApp.engine package, 804
myApp.utils package, 804
MyClass class, 738, 791
MyInner class, 666
MyOuter class, 666
MyOuter2 class, 670
N
name variable, 586
names.get(0) method, 743
names.remove(0) method, 744
names.size( ) method, 743–744
naming standards
classes, 7
interfaces, 7
JavaBean listeners, 9
JavaBean properties, 8–9
methods, 7
variables, 7
narrowing, 193
native methods, 46
natural order, 561
NavigableMap interface, 566
NavigableSet interface, 566
navigating
files
combining I/O classes, 
449–452
creating files using class File, 
445–447
directories, 452–457
FileWriter and FileReader 
classes, 447–449
overview, 443–445
methods relating to, 588
TreeSets and TreeMaps, 586–588
nested classes, static, 680–681. See also 
inner classes
new keyword, 222
new threads, 716, 718
next( ) method, 581
nextXxx( ) methods, 505–506
no-arg constructors, 133–134
NoClassDefFoundError exception, 382
nonabstract methods, 17–18
nonaccess class modifiers
abstract classes, 16–19
defined, 12
final classes, 15–16
nonaccess member modifiers
abstract methods, 41–45
final arguments, 41
final methods, 40
methods with variable argument 
lists (var-args), 46–47
native methods, 46
overview, 39
strictfp methods, 46
synchronized methods, 45
non-final local variables, 682
non-generic collections, 597, 601–607
non-serializable elements, 472
non-short-circuit AND (&) operator, 
288, 308
non-short-circuit logical operators, 
308–309
non-short-circuit OR (|) operator, 
288, 308
non-static inner class instantiation 
code, 667
non-static methods, 735, 740–741
non-static synchronized methods, 
739, 741
nonstatic variables, 147–148
non-synchronized methods, 736–737
non-transient variables, 556
non-type safe code, 602–607
NoSuchElementException class, 743
not equal to (!=) operator, 292
notify( ) method, 542, 746, 748, 
752–756
notifyAll( ) method, 542, 746, 752–757
null references, 205, 209, 224, 
257–258, 563–564
NullPointerException class, 224, 247, 
373, 380, 382
NumberFormat class, 484–487
NumberFormatException class, 
381–382
numbers, formatting, 473–487
numeric primitives, 50
O
Object class. See also hashCode( ) 
method
arrays, 579
influencing thread scheduler, 718
overriding methods
equals( ), 544–549
toString( ), 542–544
overview, 542
object get( ) interface methods, 594
object graphs, 461–465
object next( ) method, 580
object orientation
cohesion, 151–154
constructors
chaining, 132–133
default, 135–139
overloaded, 139–145
overview, 130–132
rules for, 133–134
coupling, 151–153
encapsulation, 86–89
implementing interfaces, 120–125
inheritance
HAS-A relationship, 96–98
IS-A relationship, 94–95
overview, 90–94
legal return types
covariant returns, 127–128
on overloaded methods, 
126–127
on overridden methods, 
127–128
returning values, 128–130
overloaded methods
invoking, 111–113
legal, 110
overview, 109–110
polymorphism in, 113–115
overridden methods
examples of legal and 
illegal, 109
invoking superclass version 
of, 107–108
overview, 103–107
polymorphism, 98–102
reference variable casting, 116–119
statics
accessing, 148–151
overview, 145–148
846 SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
object reference instance variables, 
203–206
object reference variables
arrays of, 231–232
assigning null to, 199
passing into methods, 213–214
Object type, 572
Object[] toArray( ) interface 
method, 594
ObjectInputStream method, 460–461
object-oriented design, 97
ObjectOutputStream method, 460–461
objects
arrays as, 297
defined, 2
uneligiblizing for garbage 
collection, 263
wrapper, 239–240
octal literals, 187
offer( ) method, 562, 591–592
one-dimensional arrays, 221–222, 
232–233
operands, 298
operators. See also individual operators 
by name
arithmetic
decrement, 302–303
increment, 302–303
overview, 298
remainder, 299
string concatenation, 299–301
assignment
compound, 197, 289–290
overview, 288–290
conditional, 304–305
instanceof
compiler error, 297–298
overview, 295–297
logical
bitwise, 305
boolean invert, 309–310
non-short-circuit, 308–309
short-circuit, 306–308
XOR, 309–310
precedence, 290
relational
equality operators, 292–295
overview, 290–291
OR operator
non-short-circuit, 288, 308
short-circuit, 306, 308
ordered collections, 560
outer classes
instantiating inner class from 
within, 666–668
overview, 664
referencing from within inner 
classes, 668–670
static members of, 681
OutOfMemoryError subtype, 375
outside outer class instance code, 
666–668
overloaded constructors, 139–145
overloading methods
with boxing and var-args, 249–250
in combination with var-args, 
253–254
invoking, 111–113
legal, 110
legal return types on, 126–127
versus overridden methods, 115
overview, 109–110, 247–249
polymorphism in, 113–115
when combining widening and 
boxing, 251–253
widening reference variables, 
250–251
overridden methods. See also 
hashCode( ) method
invoking superclass version 
of, 107–108
legal and illegal, 109
legal return types on, 127–128
Object
equals( ), 544–549
toString( ), 542–544
versus overloaded methods, 115
overview, 103–107
polymorphism in, 113–115
versus static methods, 151
P
packages, 3, 11–12, 799–801
parameterized type, 598, 626–628
parameters, 46
parentheses, 300
parse( ) method, 481
parseXxx( ) methods, 241
parsing
locating data via pattern matching, 
498–501
overview, 487–488
searches
greedy quantifiers, 495–497
overview, 488–489
predefined dot, 495
simple, 489–490
strings and metacharacters, 
497–498
using metacharacters, 490–492
using quantifiers, 492–495
Part class, 566
pass-by-value semantics, 214–215
passing variables into methods
object reference variables, 213–214
overview, 213
pass-by-value semantics, 214–215
primitive variables, 215–218
Pattern class, 498–501
pattern matching, 498–501
peek( ) method, 562, 591
poll( ) method, 562, 588, 591–592
pollFirst( ) method, 588
pollFirstEntry( ) method, 588
pollFirstXxx( ) method, 591
polling, 588
pollLast( ) method, 588
pollLastEntry( ) method, 588
polymorphism
anonymous inner classes, 675
defined, 92
generics and, 607–610
in overloaded methods, 113–115
in overridden methods, 113–115
overriden methods, 108
overview, 98–102
pool, String constant, 434
populateList( ) method, 570
precedence, 299
precision format string element, 507
predefined dot, 495
preventing thread execution, 
720–721
primitive arrays, 230–231
primitive instance variables, 203–204
primitive literals
boolean, 189
character, 189–190
defined, 186
floating-point, 188–189
integer, 186–188
string, 190
Index 847
primitive return types, 128–129
primitive variables
assignments, 191–193
casting
assigning floating-point num-
bers, 196
assigning literals too large for, 
196–197
assigning one primitive to 
another, 198
overview, 193–195
declaration, 49–51
defined, 49
equality operators for, 292–293
passing into methods, 215–218
ranges, 49–51
printf( ) method, 506–508
PrintWriter class, 444
priorities, thread, 724–728
PriorityQueue class
backed collections, 591–592
Collection interface, 565
methods, 594
overview, 564–566
private access, 32
private constructors, 133
private members, 29–32
private method-local inner class, 672
private methods, 11, 393
private variables, 733
programmatic exceptions
defined, 379
list of, 382
programmatically thrown exceptions, 
380–381
propagating uncaught exceptions, 
362–365
properties, system, 794–795
protected access, 37
protected members, 32–36
protected method-local inner class, 672
public access
classes, 14–15
effects of, 32
public boolean 
equalsIgnoreCase(String s) 
method, 436
public char charAt(int index) 
method, 435
public int length( ) method, 436
public interface, 371–376
public members, 26–29
public methods, 11, 392–393, 672
public modifier, 21
public static String toString( ) 
methods, 593
public static void sort( ) method, 593
public String concat(String s) method, 
435–436
public String replace(char old, char 
new) method, 436
public String substring( ) methods, 
436–437
public String toLowerCase( ) 
method, 437
public String toString( ) method, 438, 
441–442
public String toUpperCase( ) 
method, 438
public String trim( ) method, 438
public StringBuilder delete(int start, int 
end) method, 440–441
public StringBuilder insert(int offset, 
String s) method, 441
public synchronized StringBuffer 
append(String s) method, 440
public synchronized StringBuffer 
reverse( ) method, 441
put(key, value) interface method, 594
Q
quantifiers
greedy, 495–497
and searches, 492–495
Queue interface, 557, 564–566, 
594–595
queues, 562, 591–592, 717
R
race conditions, 733
RandomAccess interface, 562
ranges, primitive variable, 49–51
reachable references, 257
read( ) method, 746
readLine( ) method, 455, 457
readObject( ) method, 465–468
readPassword method, 457
reassigning reference variables, 
258–259
Red-Black tree structure, 563
reference type, 113
reference variables
anonymous inner classes, 674, 676
assignments, 198–200
casting, 116–119
declaring, 51
defined, 49, 191
equality operators for, 293–294
isolating, 259–260
nulling, 257–258
polymorphism, 99
reassigning, 258–259
and string objects, 429
widening, 250–251
references, reachable, 257
referencing instances from within inner 
classes, 668–670
reflexiveness of equals( ) method, 549
regex (regular expressions)
engines, 488
Matcher class, 498–501
overview, 488, 510
Pattern class, 498–501
searches
dot metacharacter, 495
greedy quantifiers, 495–497
overview, 488–489
simple, 489–490
string and metacharacters, 
497–498
using metacharacters, 
490–492
using quantifiers, 492–495
tokenizing, 501–506
regions, 500
regular expressions (regex)
engines, 488
Matcher class, 498–501
overview, 488, 510
Pattern class, 498–501
searches
dot metacharacter, 495
greedy quantifiers, 495–497
overview, 488–489
simple, 489–490
string and metacharacters, 
497–498
using metacharacters, 
490–492
using quantifiers, 492–495
tokenizing, 501–506
848 SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
regular inner classes, 664–668
relational operators
equality
for enums, 294–295
overview, 292
for primitives, 292–293
for reference variables, 293–294
overview, 290–291
relative paths, 801–802
remainder (%) operator, 299
removeFirst( ) method, 743–744
remove(index) interface method, 594
remove(key) interface method, 594
remove(object) interface method, 594
replace( ) method, 435–436
rethrowing exceptions, 376–378
return types, legal
covariant returns, 127–128
on overloaded methods, 126–127
on overridden methods, 127–128
returning values, 128–130
reverse( ) method, 441, 593
roll( ) method, 479
root directory, 804
rules for constructors, 133–134
run( ) method
Thread class
completion, 716
instantiating, 708
leaving running state, 728
making thread, 704–705
order of actions, 714
overview, 710
using wait( ) in loop, 755–757
Runnable interface, 678, 705–709
runnable threads, 716–719, 726
running multiple threads, 713–716
running threads, 719, 733
runtime
disabling assertions at, 390
enabling assertions at, 389
Runtime class, 261
RuntimeException class, 366–368, 
373–374
S
s variable, 200
Scanner class, 501, 504–506
scheduler, thread, 716–718, 728
scope, variable, 200–202, 349
searching
arrays, 576–578
Java Archive files and, 803–805
for other classes, 796–802
classpaths, 797–798
overview, 796–797
packages, 799–801
relative and absolute paths, 
801–802
simple searches, 489–490
TreeSets and TreeMaps, 586–588
using metacharacters, 490–492
using quantifiers, 492–495
seeOuter( ) method, 670
selective enabling and disabling of 
assertions, 390–391
semantics, pass-by-value, 214–215
semicolons (;), 17, 41, 344–345, 675
serial numbers, 566
serialization
and inheritance, 468–472
object graphs, 461–465
ObjectInputStream methods, 
460–461
ObjectOutputStream method, 
460–461
overview, 459–460
readObject method, 465–468
and statics, 472–473
transient variables, 59
writeObject method, 465–468
Set interface
implementations for collections, 
562–563
key methods, 594–595
use of, 581–583
Set keySet( ) interface method, 594
setParseIntegerOnly( ) method, 486
setPriority( ) method, 725
setProperty method, 795
setter methods, 8–9, 88
shadowing variables, 54–55, 201, 
216–218
short-circuit AND (&&) operator, 306, 
308, 548
short-circuit logical operators, 306–308
short-circuit OR (||) operator, 
306, 308
shortcut syntax, array, 226–228
side effects, assertion, 394
signed number types, 49
simple searches, 489–490
size( ) method, 581, 743
sleep( ) method, 717, 721, 723, 727, 757
sleeping threads, 719–724
sort( ) method
ArrayList class, 569
Arrays class, 576, 593
Collections class, 571–572, 574
SortedMap class, 591
SortedSet class, 591
sorting collections
Arrays class, 576
Comparable interface, 571–573
Comparator interface, 574–575
defined, 561
overview, 569–571
source directories, 792
source file declaration rules, 11–12
-source option, javac command, 790
split( ) method, 502–504
spontaneous wakeup, 755
square brackets, 219–220
StackOverflowError subtype, 380, 382
standards, JavaBeans, 4, 8–10
start( ) method
Matcher class, 499
threads, 708–709, 716, 718, 757
starting threads
overview, 709–712
and running multiple, 713–716
thread scheduler, 716–718
statements. See also decision statements
assert, 386–389, 394
break
labeled, 354–356
in switch blocks, 338–340
switch statements, 335
unlabeled, 353–354
use of, 352–353
continue
labeled, 354–356
overview, 352–353
unlabeled, 353–354
else, 329–332
else if, 330–331
import, 3–4, 11, 799–800, 805–806
labeled, 354–356
unlabeled, 353–354
Index 849
states
defined, 2
thread
overview, 718–720
preventing execution, 
720–721
priorities and yield( ), 724–728
sleeping, 721–724
static boolean equals( ) method, 593
static Comparator reverseOrder( ) 
method, 593
static compile( ) method, 499
static imports, 806–807
static initialization blocks, 234–235
static inner classes, 680
static int binarySearch( ) method, 593
static List asList( ) method, 593
static methods
accessing, 148–151
blocked threads, 720
defined, 59–60
inner classes, 667–668
local classes declared in, 672
overview, 145–151
sort( ), 576
synchronizing, 737–741
in Thread class, 756
Thread.sleep( ), 721
static modifier, 45, 59–60, 145, 682
static nested classes, 680–682
static synchronized methods, 739, 741
static Thread.currentThread( ) 
method, 711
static Thread.yield( ) method, 726
static variables
accessing, 148–151
defined, 59–60
overview, 145–151
scope of, 201
and serialization, 472–473
static void reverse( ) method, 593
static void sort( ) method, 593
stop( ) method, 720
Stream classes, 444
strictfp keyword, 15, 46
String class
creating new strings, 434
immutability, 426–433
important methods, 434–438
and memory, 433–434
overriding equals( ), 546
overview, 426
reference variables, 211–213
split( ) method, 502–504
toString( ) method, 543
string concatenation operator, 299–301
String constant pool, 434
StringBuffer class
important methods, 440–442
overview, 438–440
synchronizing code, 738–739
thread-safe, 742
StringBuilder class
important methods, 440–442
overview, 438–440
thread-safe, 742
StringIndexOutOfBoundsException 
subclass, 368
strings
collections, 566
generics, 596
literals, 190, 434
Maps, 584
and metacharacters, 497–498
overview, 426
reference variables, 211–213
String class
creating new, 434
immutability, 426–433
important methods, 434–438
and memory, 433–434
overview, 426
StringBuffer class
important methods, 440–442
overview, 438–440
StringBuilder class
important methods, 440–442
overview, 438–440
synchronizing code, 738
subclasses
and inheritance, 3, 25–26
inner classes, 677
versus interfaces, 122
protected and default members, 
32–34
Thread class, 705
subMap( ) method, 589–590
subSet( ) method, 590
substring( ) method, 435–437
subtraction (-) operator, 306
subXxx( ) method, 591
Sun’s Java Code Conventions, 4
super constructors, 136–139
super keyword, 619
superclasses, 3
suspend( ) method, 720
switch statements
break statement in, 335, 338–340
default case, 341–342
fall-through in, 338–340
legal expressions for, 335–338
overview, 328, 334–335
symmetry of equals( ) method, 549
synchronized methods
in code synchronization, 734–740
defined, 45
thread interaction, 751
Vector, 562
wait( ) in loops, 756
synchronizedList( ) method, 744
synchronizing code
atomic operations, 733–735
deadlock, 745–746
if thread can’t get lock, 739–740
locks, 735–737
overview, 728–733
static methods, 737–739
thread-safe classes, 742–744
when synchronization is needed, 
740–742
syntax
array shortcut, 226–228
generics, 598
system properties, 794–795
System.gc( ) method, 261
System.out.println( ) method, 504, 
542, 630
T
T[ ] toArray(T[ ]) interface method, 594
tailMap( ) method, 590
tailSet( ) method, 590
tailXxx( ) method, 591
target Runnables, 707
ternary operators, 304
test expressions, 347
TestClass class, 800
testIt( ) method, 33
this reference, 29, 668
850 SCJP Sun Certiﬁ  ed Programmer for Java 6 Study Guide
Thread class
extending, 705–706
final methods, 40
influencing thread scheduler, 717
instantiating thread, 706–708
methods, 704–705, 720
one-dimensional arrays, 222
run( ) method completion, 716
starting thread, 709–712
thread scheduler, 716–718, 728
threads
blocked, 719–720
dead, 716, 720
defining, 705–706
of execution, 702, 709, 757
instantiating, 706–708
interaction
notifyAll( ), 752–757
overview, 746–751
making, 704–705
new, 716, 718
overview, 701–704
runnable, 716–719, 726
running, 719, 733
sleeping, 719–724
starting
overview, 709–712
and running multiple, 
713–716
thread scheduler, 716–718
states and transitions
overview, 718–720
preventing execution, 
720–721
priorities, 724–728
sleeping, 721–724
yield( ) method, 726
synchronizing code
atomic operations, 733–735
deadlock, 745–746
if thread can’t get lock, 
739–740
locks, 735–737
overview, 728–733
static methods, 737–739
thread-safe classes, 742–744
when needed, 740–742
waiting, 719–720
thread-safe classes, 742–744
Thread.sleep( ) method, 721
throw keyword, 367
Throwable class, 366–368
thrown exceptions, 357
tight coupling, 152
toArray( ) method, 579, 581
tokenizing
and delimiters, 502
format( ) method, 506–508
overview, 501–502
printf( ) method, 506–508
Scanner class, 504–506
String.split( ) method, 502–504
toLowerCase( ) method, 437
toString( ) method
overriding, 542–544, 570
overriding equals( ), 548
public string, 438
in String class, 435
StringBuffer class, 441–442
wrapper conversion, 242
toUpperCase( ) method, 438
toXxxString( ) method, 242–243
transient method-local inner class, 672
transient modifier, 465
transient variables, 59, 460, 470, 
555–556
transitions, thread
overview, 718–720
preventing execution, 720–721
priorities and yield( ), 724–728
sleeping, 721–724
yield( ), 724–728
transitivity of equals( ) method, 549
TreeMap class
backed collections, 589–590
collections, 557, 565–566
methods, 588, 590
overview, 564
searching, 586–588
subMap( ), 589
TreeSet class
backed collections, 590
Collection interface, 565
methods, 588, 590
overview, 563, 582
searching, 586–588
trim( ) method, 438
try keyword
exceptions, 357–359
with finally block, 359–361
wait( ) method, 750
without catch block, 361
without finally block, 361
t.start( ) method, 713
two-dimensional arrays, 223
type erasure, 604–605
type parameters, 598, 626–628
type safe code, 602–606
U
UML (Unified Modeling Language), 97
unboxing
equals( ) method, 245–246
equals operator, 245–246
overloading
with var-args and, 249–250
when combining widening 
and, 252–253
overview, 244–245
in switch statements, 337
use of, 246–247
uncaught exceptions, propagating, 
362–365
unchecked exceptions, 373, 375
Unicode characters, 51, 189, 426–427
Unified Modeling Language (UML), 97
uninitialized variables
array instance, 206
object reference instance, 203–206
overview, 203
primitive instance, 203–204
unique hashcodes, 585
unique identifiers, 563
unlabeled statements, 353–354
unwinding stack, 367
upcasting, 118
use cases, date and number, 475
V
valueOf( ) methods, 240–241
values, constant, 23
var-args (variable argument lists)
declaration rules for, 47
methods with, 46–47
overloading, 249–250, 253–254
syntax, 796
variable scope, 200–202, 349
Index 851
variables. See also individual variables 
by name
assignment operators
assigning one primitive to 
another, 198
floating-point numbers, 196
literals too large for, 196–197
overview, 190–191
primitive, 191–193
primitive casting, 193–195
reference, 198–200
scope, 200–202
comparison of modifiers on, 53
declarations
arrays, 55–57
in enums, 63–65
final, 57–58
generics and polymorphism, 
608
instance, 51–53
local, 53–55
overview, 49
primitive, 49–51
reference, 51
static, 59–60
transient, 59
volatile, 59
effects of static on, 150
in interfaces, 20–21
local
access member modifiers 
and, 38–39
array references, 210
assigning one reference to 
another, 210–213
defined, 53–55
inner classes, 671
object references, 209–210
overview, 207
primitives, 207–209
scope of, 201
uninitialized, 203
naming standards, 7
passing into methods
object reference variables, 
213–214
overview, 213
pass-by-value semantics, 
214–215
primitive variables, 215–218
uninitialized
array instance, 206
object reference instance, 
203–206
overview, 203
primitive instance, 203–204
Vector class, 562, 564–565
VirtualMachineError subtype, 375
void finalize( ) method, 543
void return types, 129
volatile variables, 59
W
wait( ) method
lock status, 740
in loops, 753–757
overview, 718
thread interaction, 746–752
threads leaving running state, 728
waiting threads, 719–720
wakeup, spontaneous, 755
warnings, compiler, 603
while loops, 343–344, 756
widening
overloading when combining 
boxing and, 251–253
reference variables, 250–251
wrapper classes, 251
width format string element, 507
wrappers
autoboxing
equals( ) method, 245–246
equals operator, 245–246
overview, 244–245
use of, 246–247
classes
overriding equals( ), 546
overview, 237–238
and widening, 251
constructors, 239
conversion methods, 243
conversion utilities
parseXxx( ) methods, 241
toString( ) method, 242
toXxxString( ) method, 
242–243
valueOf( ) method, 241
xxxValue( ) methods, 
240–241
NullPointerException, 247
valueOf( ) methods, 240
wrapping I/O classes, 449–452
writeObject( ) method, 465–468
X
x variable, 200
x2 variable, 200
x3 variable, 200
-Xlint:unchecked flag, 605
XOR (exclusive-OR) logical operator, 
288, 309–310, 553
xxxValue( ) methods, 240–241
Y
y variable, 200
yield( ) method, 724–728
Z
z variable, 200
LICENSE AGREEMENT
THIS PRODUCT (THE “PRODUCT”) CONTAINS PROPRIETARY SOFTWARE, DATA AND INFORMATION (INCLUDING
DOCUMENTATION) OWNED BY THE McGRAW-HILL COMPANIES, INC. (“McGRAW-HILL”) AND ITS LICENSORS.

--- Chunk #1630 ---
YOUR
RIGHT TO USE THE PRODUCT IS GOVERNED BY THE TERMS AND CONDITIONS OF THIS AGREEMENT. LICENSE: Throughout this License Agreement, “you” shall mean either the individual or the entity whose agent opens this package. You
are granted a non-exclusive and non-transferable license to use the Product subject to the following terms:
(i) If you have licensed a single user version of the Product, the Product may only be used on a single computer (i.e., a single CPU). If you
licensed and paid the fee applicable to a local area network or wide area network version of the Product, you are subject to the terms of the
following subparagraph (ii). (ii) If you have licensed a local area network version, you may use the Product on unlimited workstations located in one single building
selected by you that is served by such local area network. If you have licensed a wide area network version, you may use the Product on
unlimited workstations located in multiple buildings on the same site selected by you that is served by such wide area network; provided,
however, that any building will not be considered located in the same site if it is more than five (5) miles away from any building included in
such site. In addition, you may only use a local area or wide area network version of the Product on one single server. If you wish to use the
Product on more than one server, you must obtain written authorization from McGraw-Hill and pay additional fees. (iii) You may make one copy of the Product for back-up purposes only and you must maintain an accurate record as to the location of the
back-up at all times. COPYRIGHT; RESTRICTIONS ON USE AND TRANSFER: All rights (including copyright) in and to the Product are owned by
McGraw-Hill and its licensors. You are the owner of the enclosed disc on which the Product is recorded. You may not use, copy, decompile,
disassemble, reverse engineer, modify, reproduce, create derivative works, transmit, distribute, sublicense, store in a database or retrieval
system of any kind, rent or transfer the Product, or any portion thereof, in any form or by any means (including electronically or otherwise)
except as expressly provided for in this License Agreement. You must reproduce the copyright notices, trademark notices, legends and logos
of McGraw-Hill and its licensors that appear on the Product on the back-up copy of the Product which you are permitted to make hereunder. All rights in the Product not expressly granted herein are reserved by McGraw-Hill and its licensors. TERM: This License Agreement is effective until terminated. It will terminate if you fail to comply with any term or condition of this
License Agreement. Upon termination, you are obligated to return to McGraw-Hill the Product together with all copies thereof and to purge
all copies of the Product included in any and all servers and computer facilities. DISCLAIMER OF WARRANTY: THE PRODUCT AND THE BACK-UP COPY ARE LICENSED “AS IS.” McGRAW-HILL, ITS
LICENSORS AND THE AUTHORS MAKE NO WARRANTIES, EXPRESS OR IMPLIED, AS TO THE RESULTS TO BE OBTAINED
BY ANY PERSON OR ENTITY FROM USE OF THE PRODUCT, ANY INFORMATION OR DATA INCLUDED THEREIN AND/OR
ANY TECHNICAL SUPPORT SERVICES PROVIDED HEREUNDER, IF ANY (“TECHNICAL SUPPORT SERVICES”). McGRAW-HILL, ITS LICENSORS AND THE AUTHORS MAKE NO EXPRESS OR IMPLIED WARRANTIES OF
MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE OR USE WITH RESPECT TO THE PRODUCT. McGRAW-HILL, ITS LICENSORS, AND THE AUTHORS MAKE NO GUARANTEE THAT YOU WILL PASS ANY
CERTIFICATION EXAM WHATSOEVER BY USING THIS PRODUCT. NEITHER McGRAW-HILL, ANY OF ITS LICENSORS NOR
THE AUTHORS WARRANT THAT THE FUNCTIONS CONTAINED IN THE PRODUCT WILL MEET YOUR REQUIREMENTS OR
THAT THE OPERATION OF THE PRODUCT WILL BE UNINTERRUPTED OR ERROR FREE. YOU ASSUME THE ENTIRE RISK
WITH RESPECT TO THE QUALITY AND PERFORMANCE OF THE PRODUCT. LIMITED WARRANTY FOR DISC: To the original licensee only, McGraw-Hill warrants that the enclosed disc on which the Product is
recorded is free from defects in materials and workmanship under normal use and service for a period of ninety (90) days from the date of
purchase. In the event of a defect in the disc covered by the foregoing warranty, McGraw-Hill will replace the disc. LIMITATION OF LIABILITY: NEITHER McGRAW-HILL, ITS LICENSORS NOR THE AUTHORS SHALL BE LIABLE FOR ANY
INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES, SUCH AS BUT NOT LIMITED TO, LOSS OF ANTICIPATED PROFITS
OR BENEFITS, RESULTING FROM THE USE OR INABILITY TO USE THE PRODUCT EVEN IF ANY OF THEM HAS BEEN
ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. THIS LIMITATION OF LIABILITY SHALL APPLY TO ANY CLAIM OR
CAUSE WHATSOEVER WHETHER SUCH CLAIM OR CAUSE ARISES IN CONTRACT, TORT, OR OTHERWISE. Some states do
not allow the exclusion or limitation of indirect, special or consequential damages, so the above limitation may not apply to you. U.S. GOVERNMENT RESTRICTED RIGHTS: Any software included in the Product is provided with restricted rights subject to
subparagraphs (c), (1) and (2) of the Commercial Computer Software-Restricted Rights clause at 48 C.F.R. 52.227-19. The terms of this
Agreement applicable to the use of the data in the Product are those under which the data are generally made available to the general public
by McGraw-Hill. Except as provided herein, no reproduction, use, or disclosure rights are granted with respect to the data included in the
Product and no right to modify or create derivative works from any such data is hereby granted. GENERAL: This License Agreement constitutes the entire agreement between the parties relating to the Product. The terms of any Purchase
Order shall have no effect on the terms of this License Agreement. Failure of McGraw-Hill to insist at any time on strict compliance with
this License Agreement shall not constitute a waiver of any rights under this License Agreement. This License Agreement shall be construed
and governed in accordance with the laws of the State of New York. If any provision of this License Agreement is held to be contrary to law,
that provision will be enforced to the maximum extent permissible and the remaining provisions will remain in full force and effect. 

